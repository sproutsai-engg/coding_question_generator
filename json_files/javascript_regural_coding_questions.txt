Question ID: 1
function twoSum(nums, target) {
    const map = new Map();
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        if (map.has(complement)) {
            return [map.get(complement), i];
        }
        map.set(nums[i], i);
    }
    return [];
}

-----
function twoSum(nums, target) 
    // Your code here
}

************************************
Question ID: 3
function lengthOfLongestSubstring(s) {
    let left = 0, right = 0, maxLength = 0;
    const characters = new Set();

    while (right < s.length) {
        if (!characters.has(s.charAt(right))) {
            characters.add(s.charAt(right));
            maxLength = Math.max(maxLength, right - left + 1);
            right++;
        } else {
            characters.delete(s.charAt(left));
            left++;
        }
    }

    return maxLength;
}

-----
function lengthOfLongestSubstring(s) 
    // Your code here
}

************************************
Question ID: 4
function findMedianSortedArrays(nums1, nums2) {
    if (nums1.length > nums2.length) {
        return findMedianSortedArrays(nums2, nums1);
    }
    
    const x = nums1.length;
    const y = nums2.length;
    let low = 0;
    let high = x;
    
    while (low <= high) {
        const partitionX = Math.floor((low + high) / 2);
        const partitionY = Math.floor((x + y + 1) / 2) - partitionX;
        
        const maxLeftX = (partitionX === 0) ? Number.NEGATIVE_INFINITY : nums1[partitionX - 1];
        const minRightX = (partitionX === x) ? Number.POSITIVE_INFINITY : nums1[partitionX];
        
        const maxLeftY = (partitionY === 0) ? Number.NEGATIVE_INFINITY : nums2[partitionY - 1];
        const minRightY = (partitionY === y) ? Number.POSITIVE_INFINITY : nums2[partitionY];
        
        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {
            if ((x + y) % 2 === 0) {
                return (Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;
            } else {
                return Math.max(maxLeftX, maxLeftY);
            }
        } else if (maxLeftX > minRightY) {
            high = partitionX - 1;
        } else {
            low = partitionX + 1;
        }
    }    
    return 0;
}


-----
function findMedianSortedArrays(nums1, nums2) 
    // Your code here
}


************************************
Question ID: 5
function longestPalindromicSubstring(s) {
  let n = s.length;
  if (n === 0) return "";

  let start = 0, maxLength = 1;

  for (let i = 0; i < n; ++i) {
    let l = i, r = i;

    while (r < n - 1 && s[r] === s[r + 1])
      r++;
    i = r;

    while (l > 0 && r < n - 1 && s[l - 1] === s[r + 1]) {
      l--;
      r++;
    }

    let length = r - l + 1;
    if (length > maxLength) {
      start = l;
      maxLength = length;
    }
  }

  return s.substring(start, start + maxLength);
}

-----
function longestPalindromicSubstring(s) 
    // Your code here
}

************************************
Question ID: 6
function convert(s, numRows) {
    if (numRows === 1 || numRows >= s.length) return s;

    let rows = new Array(numRows).fill("");
    let curRow = 0;
    let goingDown = false;

    for (let c of s) {
        rows[curRow] += c;
        if (curRow === 0 || curRow === numRows - 1) goingDown = !goingDown;
        curRow += goingDown ? 1 : -1;
    }

    return rows.join("");
}

-----
function convert(s, numRows) 
    // Your code here
}

************************************
Question ID: 7
function reverse(x) {
    let sign = x < 0 ? -1 : 1;
    x = Math.abs(x);
    let res = 0;
    while (x !== 0) {
        res = res * 10 + x % 10;
        x = Math.floor(x / 10);
    }
    res *= sign;
    return (res < -(2 ** 31) || res > 2 ** 31 - 1) ? 0 : res;
}

-----
function reverse(x) 
    // Your code here
}

************************************
Question ID: 8
function myAtoi(s) {
    let result = 0, i = 0, sign = 1;
    while (s[i] === ' ') i++;
    if (s[i] === '-' || s[i] === '+') sign = (s[i++] === '+') ? 1 : -1;
    while (!isNaN(s[i]) && s[i] !== ' ') {
        result = result * 10 + parseInt(s[i++], 10);
        if (result * sign > 2147483647) return 2147483647;
        if (result * sign < -2147483648) return -2147483648;
    }
    return result * sign;
}

-----
function myAtoi(s) 
    // Your code here
}

************************************
Question ID: 9
function isPalindrome(x) {
    if (x < 0) return false;
    let original = x, reversed = 0;
    while (x > 0) {
        reversed = reversed * 10 + x % 10;
        x = Math.floor(x / 10);
    }
    return original === reversed;
}


-----
function isPalindrome(x) 
    // Your code here
}


************************************
Question ID: 10
function isMatch(s, p) {
    const m = s.length, n = p.length;
    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(false));
    dp[0][0] = true;

    for (let j = 1; j <= n; j++) {
        if (p[j - 1] === '*' && dp[0][j - 2]) {
            dp[0][j] = true;
        }
    }

    for (let i = 1; i <= m; i++) {
      for (let j = 1; j <= n; j++) {
          if (p[j - 1] === s[i - 1] || p[j - 1] === '.') {
              dp[i][j] = dp[i - 1][j - 1];
          } else if (p[j - 1] === '*') {
              dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] === p[j - 2] || p[j - 2] === '.'));
          }
      }
    }

    return dp[m][n];
}

-----
function isMatch(s, p) 
    // Your code here
}

************************************
Question ID: 11
function maxArea(height) {
    let max_area = 0, left = 0, right = height.length - 1;
    while (left < right) {
        max_area = Math.max(max_area, Math.min(height[left], height[right]) * (right - left));
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }
    return max_area;
}

-----
function maxArea(height) 
    // Your code here
}

************************************
Question ID: 12
function intToRoman(num) {
    const romans = [
        [1000, "M"], [900, "CM"], [500, "D"],
        [400, "CD"], [100, "C"], [90, "XC"],
        [50, "L"], [40, "XL"], [10, "X"], 
        [9, "IX"], [5, "V"], [4, "IV"], [1, "I"]
    ];
    let roman = "";
    for (const [value, symbol] of romans) {
        while (num >= value) {
            roman += symbol;
            num -= value;
        }
    }
    return roman;
}

-----
function intToRoman(num) 
    // Your code here
}

************************************
Question ID: 13
function romanToInt(s) {
    const romanValues = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000};
    let total = 0;
    let prevValue = 0;

    for (let i = 0; i < s.length; i++) {
        let currValue = romanValues[s[i]];
        if (currValue > prevValue)
            total += currValue - (2 * prevValue);
        else
            total += currValue;
        prevValue = currValue;
    }

    return total;
}


-----
function romanToInt(s) 
    // Your code here
}


************************************
Question ID: 14
function longestCommonPrefix(strs) {
    if (strs.length === 0) return "";

    for (let i = 0; i < strs[0].length; ++i) {
        const c = strs[0][i];
        for (let j = 1; j < strs.length; ++j) {
            if (i === strs[j].length || strs[j][i] !== c) {
                return strs[0].substr(0, i);
            }
        }
    }
    return strs[0];
}

-----
function longestCommonPrefix(strs) 
    // Your code here
}

************************************
Question ID: 15
function threeSum(nums) {
    nums.sort((a, b) => a - b);
    const result = [];

    for (let i = 0; i < nums.length - 2; i++) {
        if (i == 0 || nums[i] != nums[i - 1]) {
            let j = i + 1, k = nums.length - 1;
            while (j < k) {
                const sum = nums[i] + nums[j] + nums[k];
                if (sum === 0) {
                    result.push([nums[i], nums[j], nums[k]]);
                    while (j < k && nums[j] === nums[j + 1]) j++;
                    while (j < k && nums[k] === nums[k - 1]) k--;
                    j++;
                    k--;
                } else if (sum < 0) {
                    j++;
                } else {
                    k--;
                }
            }
        }
    }

    return result;
}

-----
function threeSum(nums) 
    // Your code here
}

************************************
Question ID: 16
function threeSumClosest(nums, target) {
    nums.sort((a, b) => a - b);
    let closest = nums[0] + nums[1] + nums[2];
    for (let i = 0; i < nums.length - 2; ++i) {
        let left = i + 1;
        let right = nums.length - 1;
        while (left < right) {
            let sum = nums[i] + nums[left] + nums[right];
            if (sum === target) {
                return sum;
            }
            if (Math.abs(target - sum) < Math.abs(target - closest)) {
                closest = sum;
            }
            if (sum < target) {
                left++;
            } else {
                right--;
            }
        }
    }
    return closest;
}

-----
function threeSumClosest(nums, target) 
    // Your code here
}

************************************
Question ID: 17
function letterCombinations(digits) {
    if (digits.length === 0) return [];
    
    let phone = ["abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"];
    let result = [""];

    for (let i = 0; i < digits.length; i++) {
        let digit = digits[i];
        let temp = [];

        for (let s of result) {
            for (let c of phone[digit - 2]) {
                temp.push(s + c);
            }
        }

        result = temp;
    }

    return result;
}

-----
function letterCombinations(digits) 
    // Your code here
}

************************************
Question ID: 18
function fourSum(nums, target) {
    nums.sort((a, b) => a - b);
    let result = [];
    for (let i = 0; i < nums.length - 3; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) continue;

        for (let j = i + 1; j < nums.length - 2; j++) {
            if (j > i + 1 && nums[j] === nums[j - 1]) continue;

            let left = j + 1;
            let right = nums.length - 1;
            while (left < right) {
                const sum = nums[i] + nums[j] + nums[left] + nums[right];
                if (sum === target) {
                    result.push([nums[i], nums[j], nums[left], nums[right]]);
                    left++;
                    right--;
                    while (left < right && nums[left] === nums[left - 1]) left++;
                    while (left < right && nums[right] === nums[right + 1]) right--;
                } else if (sum < target) {
                    left++;
                } else {
                    right--;
                }
            }
        }
    }
    return result;
}


-----
function fourSum(nums, target) 
    // Your code here
}


************************************
Question ID: 20
function isValid(s) {
    const stack = [];

    for (const c of s) {
        if (c === '(' || c === '{' || c === '[') {
            stack.push(c);
        } else {
            if (!stack.length) return false;
            if (c === ')' && stack[stack.length - 1] !== '(') return false;
            if (c === '}' && stack[stack.length - 1] !== '{') return false;
            if (c === ']' && stack[stack.length - 1] !== '[') return false;
            stack.pop();
        }
    }

    return stack.length === 0;
}

-----
function isValid(s) 
    // Your code here
}

************************************
Question ID: 22
function generateParenthesis(n) {
    function generateParenthesisHelper(open, close, current, result) {
        if (open === 0 && close === 0) {
            result.push(current);
            return;
        }
        if (open > 0) {
            generateParenthesisHelper(open - 1, close + 1, current + '(', result);
        }
        if (close > 0) {
            generateParenthesisHelper(open, close - 1, current + ')', result);
        }
    }

    let result = [];
    generateParenthesisHelper(n, 0, '', result);
    return result;
}


-----
function generateParenthesis(n) 
    // Your code here
}


************************************
Question ID: 24
function swapPairs(head) {
    if (!head || !head.next) return head;

    let second = head.next;
    head.next = swapPairs(second.next);
    second.next = head;

    return second;
}

-----
function swapPairs(head) 
    // Your code here
}

************************************
Question ID: 26
function removeDuplicates(nums) {
    if (nums.length === 0) return 0;
    let i = 0;
    for (let j = 1; j < nums.length; j++) {
        if (nums[j] !== nums[i]) {
            i++;
            nums[i] = nums[j];
        }
    }
    return i + 1;
}


-----
function removeDuplicates(nums) 
    // Your code here
}


************************************
Question ID: 27
function removeElement(nums, val) {
    let i = 0;
    for (let j = 0; j < nums.length; j++) {
        if (nums[j] !== val) {
            nums[i] = nums[j];
            i++;
        }
    }
    return i;
}

-----
function removeElement(nums, val) 
    // Your code here
}

************************************
Question ID: 28
function strStr(haystack, needle) {
    if (needle === '') return 0;

    let index = haystack.indexOf(needle);
    return index;
}

-----
function strStr(haystack, needle) 
    // Your code here
}

************************************
Question ID: 29
function divide(dividend, divisor) {
    if (dividend === -Math.pow(2, 31) && divisor === -1) {
        return Math.pow(2, 31) - 1;
    }

    const sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;

    let dvd = Math.abs(dividend);
    let dvs = Math.abs(divisor);
    let ans = 0;

    while (dvd >= dvs) {
        let temp = dvs;
        let multiple = 1;
        while (dvd >= (temp << 1)) {
            temp <<= 1;
            multiple <<= 1;
        }
        dvd -= temp;
        ans += multiple;
    }

    return ans * sign;
}

-----
function divide(dividend, divisor) 
    // Your code here
}

************************************
Question ID: 30
function findSubstring(s, words) {
    if (!s || !words || words.length === 0) return [];

    const word_count = new Map();
    for (const word of words) {
        word_count.set(word, (word_count.get(word) || 0) + 1);
    }

    const word_length = words[0].length;
    const total_words = words.length;
    const total_length = word_length * total_words;
    const result = [];

    for (let i = 0; i <= s.length - total_length; i++) {
        const temp_word_count = new Map();
        for (let j = 0; j < total_words; j++) {
            const current_word = s.substr(i + j * word_length, word_length);
            if (!word_count.has(current_word)) break;
            temp_word_count.set(current_word, (temp_word_count.get(current_word) || 0) + 1);
            if (temp_word_count.get(current_word) > word_count.get(current_word)) break;
            if (j + 1 === total_words) result.push(i);
        }
    }

    return result;
}

-----
function findSubstring(s, words) 
    // Your code here
}

************************************
Question ID: 31
function nextPermutation(nums) {
    let n = nums.length, k = n - 2, l;
    while(k >= 0 && nums[k] >= nums[k + 1]) k--;

    if(k < 0) {
        nums.sort((a, b) => a - b);
    } else {
        for (l = n - 1; l > k; l--) {
            if (nums[l] > nums[k]) break;
        }
        [nums[k], nums[l]] = [nums[l], nums[k]];
        let tempArr = nums.slice(k + 1).sort((a, b) => a - b);
        nums.splice(k + 1, n - k - 1, ...tempArr);
    }
}

-----
function nextPermutation(nums) 
    // Your code here
}

************************************
Question ID: 32
function longestValidParentheses(s) {
    const n = s.length;
    let result = 0;
    const st = [];

    for (let i = 0; i < n; ++i) {
        if (s[i] === '(') {
            st.push(i);
        } else {
            if (st.length > 0 && s[st[st.length - 1]] === '(') {
                st.pop();
            } else {
                st.push(i);
            }
        }
    }

    if (st.length === 0) {
        result = n;
    } else {
        let right = n, left = 0;
        while (st.length > 0) {
            left = st.pop();
            result = Math.max(result, right - left - 1);
            right = left;
        }
        result = Math.max(result, right);
    }

    return result;
}

-----
function longestValidParentheses(s) 
    // Your code here
}

************************************
Question ID: 33
function search(nums, target) {
    let left = 0, right = nums.length - 1;
    while (left <= right) {
        let mid = left + Math.floor((right - left) / 2);
        if (nums[mid] === target) {
            return mid;
        }
        if (nums[mid] >= nums[left]) {
            if (target >= nums[left] && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            if (target > nums[mid] && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    return -1;
}

-----
function search(nums, target) 
    // Your code here
}

************************************
Question ID: 34
function searchRange(nums, target) {
    let start = -1, end = -1;
    let left = 0, right = nums.length - 1;

    while (left <= right) {
        const mid = left + Math.floor((right - left) / 2);
        if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
            if (nums[mid] === target) {
                start = mid;
            }
        }
    }

    left = 0;
    right = nums.length - 1;

    while (left <= right) {
        const mid = left + Math.floor((right - left) / 2);
        if (nums[mid] > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
            if (nums[mid] === target) {
                end = mid;
            }
        }
    }

    return [start, end];
}

-----
function searchRange(nums, target) 
    // Your code here
}

************************************
Question ID: 35
function searchInsert(nums, target) {
    let left = 0, right = nums.length - 1;
    while (left <= right) {
        let mid = left + Math.floor((right - left) / 2);
        if (nums[mid] === target) return mid;
        if (nums[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return left;
}

-----
function searchInsert(nums, target) 
    // Your code here
}

************************************
Question ID: 36
function isValidSudoku(board) {
    let seen = new Set();
    
    for(let i = 0; i < 9; i++) {
        for(let j = 0; j < 9; j++) {
            let current_val = board[i][j];
            if(current_val !== '.') {
                let row = `${current_val} in row ${i}`;
                let col = `${current_val} in col ${j}`;
                let box = `${current_val} in box ${Math.floor(i/3)}-${Math.floor(j/3)}`;
                
                if(seen.has(row) || seen.has(col) || seen.has(box)) {
                    return false;
                }
                seen.add(row);
                seen.add(col);
                seen.add(box);
            }
        }
    }
    return true;
}


-----
function isValidSudoku(board) 
    // Your code here
}


************************************
Question ID: 37
function isValid(board, row, col, c) {
    for (let i = 0; i < 9; i++) {
        if (board[i][col] === c) return false;
        if (board[row][i] === c) return false;
        if (board[3 * Math.floor(row / 3) + Math.floor(i / 3)][3 * Math.floor(col / 3) + i % 3] === c) return false;
    }
    return true;
}

function solveSudokuHelper(board) {
    for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
            if (board[i][j] === '.') {
                for (let c = 1; c <= 9; c++) {
                    if (isValid(board, i, j, c.toString())) {
                        board[i][j] = c.toString();

                        if (solveSudokuHelper(board)) {
                            return true;
                        }

                        board[i][j] = '.';
                    }
                }
                return false;
            }
        }
    }
    return true;
}

function solveSudoku(board) {
    solveSudokuHelper(board);
}

-----
function isValid(board, row, col, c) 
    // Your code here
}

************************************
Question ID: 38
function countAndSay(n) {
    if (n === 1) return "1";
    let previous = countAndSay(n - 1);
    let result = "";
    let count = 1;
    for (let i = 1; i < previous.length; i++) {
        if (previous[i] === previous[i - 1]) {
            count++;
        } else {
            result += count.toString() + previous[i - 1];
            count = 1;
        }
    }
    result += count.toString() + previous[previous.length - 1];
    return result;
}

-----
function countAndSay(n) 
    // Your code here
}

************************************
Question ID: 39
function combinationSum(candidates, target) {
    function findCombinations(startIndex, remaining) {
        if (remaining === 0) {
            return [[]];
        }
        if (startIndex === candidates.length || remaining < 0) {
            return [];
        }

        let result = [];
        result = result.concat(findCombinations(startIndex + 1, remaining));
        result = result.concat(findCombinations(startIndex, remaining - candidates[startIndex]).map(x => x.concat([candidates[startIndex]])));

        return result;
    }

    return findCombinations(0, target);
}


-----
function combinationSum(candidates, target) 
    // Your code here
}


************************************
Question ID: 40
function combinationSum2(candidates, target) {
    const result = [];
    candidates.sort((a, b) => a - b);
    combine(candidates, target, 0, [], result);
    return result;
}

function combine(candidates, target, start, current, result) {
    if (target === 0) {
        result.push([...current]);
        return;
    }

    for (let i = start; i < candidates.length && target >= candidates[i]; i++) {
        if (i === start || candidates[i] !== candidates[i - 1]) {
            current.push(candidates[i]);
            combine(candidates, target - candidates[i], i + 1, current, result);
            current.pop();
        }
    }
}


-----
function combinationSum2(candidates, target) 
    // Your code here
}


************************************
Question ID: 41
function firstMissingPositive(nums) {
    let n = nums.length;
    for(let i = 0; i < n; i++) {
        while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] !== nums[i]) {
            let temp = nums[i];
            nums[i] = nums[temp - 1];
            nums[temp - 1] = temp;
        }
    }

    for(let i = 0; i < n; i++) {
        if(nums[i] !== i + 1) {
            return i + 1;
        }
    }
    return n + 1;
}

-----
function firstMissingPositive(nums) 
    // Your code here
}

************************************
Question ID: 42
function trap(height) {
    const n = height.length;
    let left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;

    while (left < right) {
        if (height[left] <= height[right]) {
            maxLeft = Math.max(maxLeft, height[left]);
            water += maxLeft - height[left];
            left++;
        } else {
            maxRight = Math.max(maxRight, height[right]);
            water += maxRight - height[right];
            right--;
        }
    }

    return water;
}

-----
function trap(height) 
    // Your code here
}

************************************
Question ID: 43
function multiply(num1, num2) {
    let m = num1.length, n = num2.length;
    let pos = new Array(m + n).fill(0);
    
    for (let i = m - 1; i >= 0; i--) {
        for (let j = n - 1; j >= 0; j--) {
            let mult = (num1[i] - '0') * (num2[j] - '0');
            let p1 = i + j, p2 = i + j + 1;
            let sum = mult + pos[p2];
            pos[p1] += Math.floor(sum / 10);
            pos[p2] = sum % 10;
        }
    }
    
    while (pos.length > 1 && pos[0] == 0)
        pos.shift();
    return pos.join('');
}

-----
function multiply(num1, num2) 
    // Your code here
}

************************************
Question ID: 44
function isMatch(s, p) {
    let m = s.length,
        n = p.length;
    let i = 0,
        j = 0,
        asterisk = -1,
        match = 0;
    while (i < m) {
        if (j < n && (s[i] === p[j] || p[j] === '?')) {
            i++;
            j++;
        } else if (j < n && p[j] === '*') {
            match = i;
            asterisk = j++;
        } else if (asterisk >= 0) {
            i = ++match;
            j = asterisk + 1;
        } else {
            return false;
        }
    }
    while (j < n && p[j] === '*') j++;
    return j === n;
}

-----
function isMatch(s, p) 
    // Your code here
}

************************************
Question ID: 45
function jump(nums) {
    let jumps = 0, currentEnd = 0, currentFarthest = 0;

    for (let i = 0; i < nums.length - 1; i++) {
        currentFarthest = Math.max(currentFarthest, i + nums[i]);
        if (i === currentEnd) {
            jumps++;
            currentEnd = currentFarthest;
        }
    }
    return jumps;
}

-----
function jump(nums) 
    // Your code here
}

************************************
Question ID: 46
function permute(nums) {
  const results = [];
  helper(nums, 0, results);
  return results;
}

function helper(nums, index, results) {
  if (index === nums.length - 1) {
    results.push(nums.slice());
    return;
  }

  for (let i = index; i < nums.length; i++) {
    [nums[index], nums[i]] = [nums[i], nums[index]];
    helper(nums, index + 1, results);
    [nums[index], nums[i]] = [nums[i], nums[index]];
  }
}

-----
function permute(nums) 
    // Your code here
}

************************************
Question ID: 47
function permuteUnique(nums) {
    nums.sort((a, b) => a - b);
    const result = [];
    const visited = new Array(nums.length).fill(false);

    function backtrack(tempList) {
        if (tempList.length === nums.length) {
            result.push([...tempList]);
            return;
        }
        for (let i = 0; i < nums.length; i++) {
            if (visited[i] || (i > 0 && nums[i] === nums[i - 1] && !visited[i - 1])) continue;
            visited[i] = true;
            tempList.push(nums[i]);
            backtrack(tempList);
            tempList.pop();
            visited[i] = false;
        }
    }

    backtrack([]);
    return result;
}


-----
function permuteUnique(nums) 
    // Your code here
}


************************************
Question ID: 48
function rotate(matrix) {
    let n = matrix.length;
    for (let i = 0; i < Math.floor(n / 2); i++) {
        for (let j = i; j < n - i - 1; j++) {
            let temp = matrix[i][j];
            matrix[i][j] = matrix[n - j - 1][i];
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
            matrix[j][n - i - 1] = temp;
        }
    }
}

-----
function rotate(matrix) 
    // Your code here
}

************************************
Question ID: 49
function groupAnagrams(strs) {
    const anagramMap = new Map();

    for (const str of strs) {
        const key = str.split('').sort().join('');

        if (!anagramMap.has(key)) {
            anagramMap.set(key, []);
        }
        anagramMap.get(key).push(str);
    }

    return Array.from(anagramMap.values());
}

-----
function groupAnagrams(strs) 
    // Your code here
}

************************************
Question ID: 50
function myPow(x, n) {
    if (n === 0) return 1;
    if (n < 0) {
        x = 1 / x;
        n = -n;
    }
    let result = 1;
    let currentProduct = x;
    for (let i = n; i > 0; i = Math.floor(i / 2)) {
        if (i % 2 === 1) {
            result *= currentProduct;
        }
        currentProduct *= currentProduct;
    }
    return result;
}

-----
function myPow(x, n) 
    // Your code here
}

************************************
Question ID: 51
function solveNQueens(n) {
  function isSafe(board, row, col) {
    for (let i = 0; i < col; i++)
      if (board[row][i] == 'Q') return false;
    for (let i = row, j = col; i >= 0 && j >= 0; i--, j--)
      if (board[i][j] == 'Q') return false;
    for (let i = row, j = col; i < n && j >= 0; i++, j--)
      if (board[i][j] == 'Q') return false;
    return true;
  }

  function solve(result, board, n, col) {
    if (col == n) {
      result.push(board.map(row => row.join('')));
      return;
    }
    for (let row = 0; row < n; row++) {
      if (isSafe(board, row, col)) {
        board[row][col] = 'Q';
        solve(result, board, n, col + 1);
        board[row][col] = '.';
      }
    }
  }

  const result = [];
  const board = Array.from({ length: n }, () => Array(n).fill('.'));
  solve(result, board, n, 0);
  return result;
}

-----
function solveNQueens(n) 
    // Your code here
}

************************************
Question ID: 52
function isSafe(cols, row) {
    let col = cols.length;
    for (let i = 0; i < cols.length; i++) {
        if (cols[i] === row || Math.abs(i - col) === Math.abs(cols[i] - row)) {
            return false;
        }
    }
    return true;
}

function backtrack(n, cols) {
    if (cols.length === n) {
        return 1;
    }

    let count = 0;
    for (let i = 0; i < n; i++) {
        if (isSafe(cols, i)) {
            cols.push(i);
            count += backtrack(n, cols);
            cols.pop();
        }
    }
    return count;
}

function totalNQueens(n) {
    let cols = [];
    return backtrack(n, cols);
}

-----
function isSafe(cols, row) 
    // Your code here
}

************************************
Question ID: 53
function maxSubArray(nums) {
    let max_sum = nums[0];
    let current_sum = max_sum;

    for (let i = 1; i < nums.length; i++) {
        current_sum = Math.max(current_sum + nums[i], nums[i]);
        max_sum = Math.max(max_sum, current_sum);
    }

    return max_sum;
}

-----
function maxSubArray(nums) 
    // Your code here
}

************************************
Question ID: 54
function spiralOrder(matrix) {
    const result = [];
    if (!matrix.length) return result;
    let m = matrix.length, n = matrix[0].length;
    let rowStart = 0, colStart = 0, rowEnd = m - 1, colEnd = n - 1;

    while (rowStart <= rowEnd && colStart <= colEnd) {
        for (let i = colStart; i <= colEnd; i++) {
            result.push(matrix[rowStart][i]);
        }
        rowStart++;
        for (let i = rowStart; i <= rowEnd; i++) {
            result.push(matrix[i][colEnd]);
        }
        colEnd--;
        if (rowStart <= rowEnd) {
            for (let i = colEnd; i >= colStart; i--) {
                result.push(matrix[rowEnd][i]);
            }
        }
        rowEnd--;
        if (colStart <= colEnd) {
            for (let i = rowEnd; i >= rowStart; i--) {
                result.push(matrix[i][colStart]);
            }
        }
        colStart++;
    }
    return result;
}

-----
function spiralOrder(matrix) 
    // Your code here
}

************************************
Question ID: 55
function canJump(nums) {
    let maxReach = 0;
    for (let i = 0; i < nums.length; ++i) {
        if (i > maxReach) return false;
        maxReach = Math.max(maxReach, i + nums[i]);
    }
    return true;
}

-----
function canJump(nums) 
    // Your code here
}

************************************
Question ID: 56
function merge(intervals) {
    if (intervals.length === 0) return [];

    intervals.sort((a, b) => a[0] - b[0]);
    const result = [intervals[0]];

    for (let i = 1; i < intervals.length; i++) {
        if (result[result.length - 1][1] >= intervals[i][0]) {
            result[result.length - 1][1] = Math.max(result[result.length - 1][1], intervals[i][1]);
        } else {
            result.push(intervals[i]);
        }
    }

    return result;
}

-----
function merge(intervals) 
    // Your code here
}

************************************
Question ID: 57
function insert(intervals, newInterval) {
    const result = [];
    let start_pos = 0;

    while (start_pos < intervals.length && intervals[start_pos][1] < newInterval[0]) {
        result.push(intervals[start_pos]);
        start_pos++;
    }

    while (start_pos < intervals.length && intervals[start_pos][0] <= newInterval[1]) {
        newInterval[0] = Math.min(newInterval[0], intervals[start_pos][0]);
        newInterval[1] = Math.max(newInterval[1], intervals[start_pos][1]);
        start_pos++;
    }

    result.push(newInterval);

    while (start_pos < intervals.length) {
        result.push(intervals[start_pos]);
        start_pos++;
    }

    return result;
}

-----
function insert(intervals, newInterval) 
    // Your code here
}

************************************
Question ID: 58
function lengthOfLastWord(s) {
    let length = 0;
    let tail = s.length - 1;
    while (tail >= 0 && s[tail] === ' ') tail--;
    while (tail >= 0 && s[tail] !== ' ') {
        length++;
        tail--;
    }
    return length;
}

-----
function lengthOfLastWord(s) 
    // Your code here
}

************************************
Question ID: 59
function generateMatrix(n) {
    const matrix = Array.from({ length: n }, () => new Array(n).fill(0));
    let value = 1, top = 0, bottom = n - 1, left = 0, right = n - 1;

    while (value <= n * n) {
        for (let i = left; i <= right; i++) {
            matrix[top][i] = value++;
        }

        for (let i = top + 1; i <= bottom; i++) {
            matrix[i][right] = value++;
        }

        if (top < bottom && left < right) {
            for (let i = right - 1; i >= left; i--) {
                matrix[bottom][i] = value++;
            }

            for (let i = bottom - 1; i > top; i--) {
                matrix[i][left] = value++;
            }
        }

        top++, bottom--, left++, right--;
    }

    return matrix;
}

-----
function generateMatrix(n) 
    // Your code here
}

************************************
Question ID: 60
function getPermutation(n, k) {
    const factorials = [1];
    const nums = [...Array(n)].map((_, i) => i + 1);
    let result = '';

    for (let i = 1; i < n; i++) {
        factorials[i] = factorials[i - 1] * i;
    }

    k--;

    for (let i = n; i >= 1; i--) {
        const index = Math.floor(k / factorials[i - 1]);
        k %= factorials[i - 1];
        result += nums[index];
        nums.splice(index, 1);
    }

    return result;
}

-----
function getPermutation(n, k) 
    // Your code here
}

************************************
Question ID: 62
function uniquePaths(m, n) {
    const dp = Array.from({ length: m }, () => Array(n).fill(1));
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}

-----
function uniquePaths(m, n) 
    // Your code here
}

************************************
Question ID: 63
function uniquePathsWithObstacles(grid) {
    const m = grid.length;
    const n = grid[0].length;
    if (grid[0][0] === 1) return 0;

    grid[0][0] = 1;
    for (let i = 1; i < m; ++i) {
        grid[i][0] = (grid[i][0] === 0 && grid[i - 1][0] === 1) ? 1 : 0;
    }
    for (let i = 1; i < n; ++i) {
        grid[0][i] = (grid[0][i] === 0 && grid[0][i - 1] === 1) ? 1 : 0;
    }

    for (let i = 1; i < m; ++i) {
        for (let j = 1; j < n; ++j) {
            if (grid[i][j] === 0) {
                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];
            } else {
                grid[i][j] = 0;
            }
        }
    }

    return grid[m - 1][n - 1];
}

-----
function uniquePathsWithObstacles(grid) 
    // Your code here
}

************************************
Question ID: 64
function minPathSum(grid) {
    let m = grid.length, n = grid[0].length;
        
    for(let i = 1; i < m; i++)
        grid[i][0] += grid[i - 1][0];
        
    for(let i = 1; i < n; i++)
        grid[0][i] += grid[0][i - 1];
        
    for(let i = 1; i < m; i++){
        for(let j = 1; j < n; j++){
            grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
        }
    }
    return grid[m - 1][n - 1];
}

-----
function minPathSum(grid) 
    // Your code here
}

************************************
Question ID: 65
function isNumber(s) {
    const pattern = /^[-+]?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(e[-+]?[0-9]+)?$/;
    return pattern.test(s);
}


-----
function isNumber(s) 
    // Your code here
}


************************************
Question ID: 66
function plusOne(digits) {
    let n = digits.length;

    for(let i = n - 1; i >= 0; i--) {
        if(digits[i] < 9) {
            digits[i]++;
            return digits;
        }
        digits[i] = 0;
    }

    digits.unshift(1);
    return digits;
}


-----
function plusOne(digits) 
    // Your code here
}


************************************
Question ID: 67
function addBinary(a, b) {
    let result = "";
    let i = a.length - 1, j = b.length - 1, carry = 0;
    while (i >= 0 || j >= 0 || carry) {
        if (i >= 0) carry += parseInt(a[i--], 10);
        if (j >= 0) carry += parseInt(b[j--], 10);
        result = (carry % 2) + result;
        carry = Math.floor(carry / 2);
    }
    return result;
}

-----
function addBinary(a, b) 
    // Your code here
}

************************************
Question ID: 68
function fullJustify(words, maxWidth) {
    const result = [];
    let idx = 0;
    while (idx < words.length) {
        let totalChars = words[idx].length;
        let last = idx + 1;
        while (last < words.length) {
            if (totalChars + 1 + words[last].length > maxWidth) break;
            totalChars += 1 + words[last].length;
            last++;
        }
        const gaps = last - idx - 1;
        let line = "";
        if (last === words.length || gaps === 0) {
            for (let i = idx; i < last; i++) {
                line += words[i];
                if (i < last - 1) line += " ";
            }
            while (line.length < maxWidth) line += " ";
        } else {
            const evenSpaces = Math.floor((maxWidth - totalChars) / gaps);
            const extraSpaces = (maxWidth - totalChars) % gaps;
            for (let i = idx; i < last; i++) {
                line += words[i];
                if (i < last - 1) {
                    line += " ".repeat(evenSpaces + (i - idx < extraSpaces ? 1 : 0));
                }
            }
        }
        idx = last;
        result.push(line);
    }
    return result;
}

-----
function fullJustify(words, maxWidth) 
    // Your code here
}

************************************
Question ID: 69
function mySqrt(x) {
    if (x === 0 || x === 1) return x;
    let start = 1, end = x, ans;
    while (start <= end) {
        let mid = Math.floor((start + end) / 2);
        if (mid * mid === x) return mid;
        if (mid * mid < x) {
            start = mid + 1;
            ans = mid;
        } else {
            end = mid - 1;
        }
    }
    return ans;
}


-----
function mySqrt(x) 
    // Your code here
}


************************************
Question ID: 70
function climbStairs(n) {
    if(n <= 2) return n;
    let a = 1, b = 2, c;
    for(let i = 3; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    return c;
}


-----
function climbStairs(n) 
    // Your code here
}


************************************
Question ID: 71
function simplifyPath(path) {
    let stack = [];
    let parts = path.split("/");

    for (let part of parts) {
        if (!part || part === ".") continue;
        if (part === "..") {
            if (stack.length) stack.pop();
        } else {
            stack.push(part);
        }
    }

    return "/" + stack.join("/");
}

-----
function simplifyPath(path) 
    // Your code here
}

************************************
Question ID: 72
function minDistance(word1, word2) {
    const m = word1.length;
    const n = word2.length;
    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
    
    for (let i = 0; i <= m; i++) {
        for (let j = 0; j <= n; j++) {
            if (i === 0) {
                dp[i][j] = j;
            } else if (j === 0) {
                dp[i][j] = i;
            } else if (word1[i - 1] === word2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;
            }
        }
    }
    
    return dp[m][n];
}

-----
function minDistance(word1, word2) 
    // Your code here
}

************************************
Question ID: 73
function setZeroes(matrix) {
    let rows = matrix.length;
    let cols = matrix[0].length;
    let firstRow = false;
    let firstCol = false;
 
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (matrix[i][j] === 0) {
                if (i === 0) firstRow = true;
                if (j === 0) firstCol = true;
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }
    
    for (let i = 1; i < rows; i++) {
        for (let j = 1; j < cols; j++) {
            if (matrix[i][0] === 0 || matrix[0][j] === 0) {
                matrix[i][j] = 0;
            }
        }
    }
    
    if (firstRow) {
        for (let j = 0; j < cols; j++) 
            matrix[0][j] = 0;
    }
    
    if (firstCol) {
        for (let i = 0; i < rows; i++)
            matrix[i][0] = 0;
    }
}

-----
function setZeroes(matrix) 
    // Your code here
}

************************************
Question ID: 74
function searchMatrix(matrix, target) {
    const m = matrix.length;
    const n = matrix[0].length;
    let l = 0, r = m * n - 1;

    while (l <= r) {
        const mid = l+ Math.floor((r - l) / 2);
        const midVal = matrix[Math.floor(mid / n)][mid % n];

        if (midVal === target) {
            return true;
        } else if (midVal < target) {
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }

    return false;
}

-----
function searchMatrix(matrix, target) 
    // Your code here
}

************************************
Question ID: 75
function sortColors(nums) {
    let red = 0, white = 0, blue = nums.length - 1;
    while (white <= blue) {
        if (nums[white] === 0) {
            [nums[red], nums[white]] = [nums[white], nums[red]];
            red++;
            white++;
        } else if (nums[white] === 1) {
            white++;
        } else {
            [nums[white], nums[blue]] = [nums[blue], nums[white]];
            blue--;
        }
    }
}

-----
function sortColors(nums) 
    // Your code here
}

************************************
Question ID: 76
function minWindow(s, t) {
    const need = new Map();
    const window = new Map();

    for (const c of t) {
        need.set(c, (need.get(c) || 0) + 1);
    }
    
    let left = 0, right = 0;
    let valid = 0;
    let start = 0, length = Infinity;

    while (right < s.length) {
        const c = s[right];
        right++;
        if (need.has(c)) {
            window.set(c, (window.get(c) || 0) + 1);
            if (window.get(c) <= need.get(c)) valid++;
        }

        while (valid === t.length) {
            if (right - left < length) {
                start = left;
                length = right - left;
            }

            const d = s[left];
            left++;
            if (need.has(d)) {
                if (window.get(d) <= need.get(d)) valid--;
                window.set(d, window.get(d) - 1);
            }
        }
    }
    return length === Infinity ? "" : s.substring(start, start + length);
}


-----
function minWindow(s, t) 
    // Your code here
}


************************************
Question ID: 77
function combine(n, k) {
    const result = [];
    backtrack(n, k, 1, [], result);
    return result;
}

function backtrack(n, k, start, current, result) {
    if (current.length === k) {
        result.push([...current]);
        return;
    }

    for (let i = start; i <= n; i++) {
        current.push(i);
        backtrack(n, k, i + 1, current, result);
        current.pop();
    }
}

-----
function combine(n, k) 
    // Your code here
}

************************************
Question ID: 78
function subsets(nums) {
    let result = [];
    let n = nums.length;
    let num_subsets = 1 << n;

    for (let i = 0; i < num_subsets; ++i) {
        let subset = [];
        for (let j = 0; j < n; ++j) {
            if (i & (1 << j)) {
                subset.push(nums[j]);
            }
        }
        result.push(subset);
    }
    return result;
}

-----
function subsets(nums) 
    // Your code here
}

************************************
Question ID: 79
function exist(board, word) {
    const m = board.length;
    const n = board[0].length;

    function dfs(i, j, k) {
        if (i < 0 || i === m || j < 0 || j === n || board[i][j] !== word[k])
            return false;
        if (k === word.length - 1)
            return true;
        
        const temp = board[i][j];
        board[i][j] = '/';
        const res = dfs(i + 1, j, k +1) || dfs(i - 1, j, k + 1) || dfs(i, j + 1, k + 1) || dfs(i, j - 1, k + 1);
        board[i][j] = temp;
        return res;
    }

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (dfs(i, j, 0))
                return true;
        }
    }
    return false;
}


-----
function exist(board, word) 
    // Your code here
}


************************************
Question ID: 80
function removeDuplicates(nums) {
    let i = 0;
    for (let num of nums) {
        if (i < 2 || num > nums[i - 2]) {
            nums[i++] = num;
        }
    }
    return i;
}

-----
function removeDuplicates(nums) 
    // Your code here
}

************************************
Question ID: 81
function search(nums, target) {
    let left = 0, right = nums.length - 1;
    while (left <= right) {
        const mid = left + Math.floor((right - left) / 2);
        if (nums[mid] === target) return true;

        if (nums[mid] === nums[left]) {
            left++;
        } else if (nums[mid] > nums[left]) {
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    return false;
}

-----
function search(nums, target) 
    // Your code here
}

************************************
Question ID: 84
function largestRectangleArea(heights) {
    let stack = [];
    let max_area = 0;
    heights.push(0);
    for (let i = 0; i < heights.length; i++) {
        while (stack.length > 0 && heights[stack[stack.length - 1]] > heights[i]) {
            let height = heights[stack.pop()];
            let width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;
            max_area = Math.max(max_area, height * width);
        }
        stack.push(i);
    }
    return max_area;
}

-----
function largestRectangleArea(heights) 
    // Your code here
}

************************************
Question ID: 85
function maximalRectangle(matrix) {
    if (!matrix.length) return 0;

    let m = matrix.length;
    let n = matrix[0].length;
    let height = Array(n + 1).fill(0);
    let maxArea = 0;

    for (let i = 0; i < m; i++) {
        let s = [];
        for (let j = 0; j <= n; j++) {
            if (j < n) {
                height[j] = matrix[i][j] === '1' ? height[j] + 1 : 0;
            }
            while (s.length && height[j] < height[s[s.length - 1]]) {
                let h = height[s.pop()];
                let w = !s.length ? j : j - s[s.length - 1] - 1;
                maxArea = Math.max(maxArea, h * w);
            }
            s.push(j);
        }
    }

    return maxArea;
}


-----
function maximalRectangle(matrix) 
    // Your code here
}


************************************
Question ID: 87
function isScramble(s1, s2) {
    if (s1 === s2) return true;
    if (s1.length !== s2.length || sorted(s1) !== sorted(s2)) return false;

    for (let i = 1; i < s1.length; i++) {
        if ((isScramble(s1.slice(0, i), s2.slice(0, i)) && isScramble(s1.slice(i), s2.slice(i))) || 
            (isScramble(s1.slice(0, i), s2.slice(s2.length - i)) && isScramble(s1.slice(i), s2.slice(0, s2.length - i))))
            return true;
    }
    return false;
}

function sorted(s) {
    return s.split('').sort().join('');
}

-----
function isScramble(s1, s2) 
    // Your code here
}

************************************
Question ID: 88
function merge(nums1, m, nums2, n) {
    let i = m - 1, j = n - 1, k = m + n - 1;
    while (i >= 0 && j >= 0) {
        if (nums1[i] > nums2[j])
            nums1[k--] = nums1[i--];
        else
            nums1[k--] = nums2[j--];
    }
    while (j >= 0) {
        nums1[k--] = nums2[j--];
    }
}

-----
function merge(nums1, m, nums2, n) 
    // Your code here
}

************************************
Question ID: 89
function grayCode(n) {
    const result = [];
    for (let i = 0; i < (1 << n); i++) {
        result.push(i ^ (i >> 1));
    }
    return result;
}

-----
function grayCode(n) 
    // Your code here
}

************************************
Question ID: 90
function subsetsWithDup(nums) {
  const result = new Set();
  nums.sort((a, b) => a - b);
  backtrack(nums, 0, [], result);
  return Array.from(result).map(item => Array.from(item));
}

function backtrack(nums, index, subset, result) {
  result.add(JSON.stringify(subset));
  for (let i = index; i < nums.length; i++) {
    subset.push(nums[i]);
    backtrack(nums, i + 1, subset, result);
    subset.pop();
  }
}

-----
function subsetsWithDup(nums) 
    // Your code here
}

************************************
Question ID: 91
var numDecodings = function(s) {
    const n = s.length;
    const dp = new Array(n + 1).fill(0);
    dp[0] = 1;
    dp[1] = s[0] !== '0' ? 1 : 0;

    for (let i = 2; i <= n; i++) {
        const oneDigit = parseInt(s.slice(i - 1, i), 10);
        const twoDigits = parseInt(s.slice(i - 2, i), 10);

        if (oneDigit >= 1)
            dp[i] += dp[i - 1];
        if (twoDigits >= 10 && twoDigits <= 26)
            dp[i] += dp[i - 2];
    }
    return dp[n];
};


-----
var numDecodings = function(s) 
    // Your code here
};


************************************
Question ID: 92
function reverseBetween(head, left, right) {
    if (!head || left === right) return head;
    const dummy = new ListNode(0);
    dummy.next = head;
    let pre = dummy;
    for (let i = 1; i < left; ++i) pre = pre.next;
    let cur = pre.next;
    for (let i = left; i < right; ++i) {
        const t = cur.next;
        cur.next = t.next;
        t.next = pre.next;
        pre.next = t;
    }
    return dummy.next;
}

-----
function reverseBetween(head, left, right) 
    // Your code here
}

************************************
Question ID: 93
function restoreIpAddresses(s) {
    const result = [];
    dfs(s, 0, "", result, 0);
    return result;
}

function dfs(s, start, ip, result, part) {
    if (part === 4 && start === s.length) {
        result.push(ip.slice(0, -1));
        return;
    }
    if (part === 4 || start >= s.length) return;

    let num = 0;
    for (let i = start; i < s.length; i++) {
        num = num * 10 + parseInt(s[i]);
        if (num > 255) break;
        dfs(s, i + 1, ip + s[i] + ".", result, part + 1);
        if (num === 0) break;
    }
}


-----
function restoreIpAddresses(s) 
    // Your code here
}


************************************
Question ID: 96
function numTrees(n) {
    let dp = new Array(n + 1).fill(0);
    dp[0] = 1;
    dp[1] = 1;
    for (let i = 2; i <= n; i++) {
        for (let j = 0; j < i; j++) {
            dp[i] += dp[j] * dp[i - j - 1];
        }
    }
    return dp[n];
}

-----
function numTrees(n) 
    // Your code here
}

************************************
Question ID: 97
function isInterleave(s1, s2, s3) {
    let m = s1.length, n = s2.length;
    if (m + n !== s3.length) return false;

    let dp = new Array(m + 1).fill(null).map(() => new Array(n + 1).fill(false));
    dp[0][0] = true;
    for (let i = 1; i <= m; i++)
        dp[i][0] = dp[i - 1][0] && s1[i - 1] === s3[i - 1];
    for (let j = 1; j <= n; j++)
        dp[0][j] = dp[0][j - 1] && s2[j - 1] === s3[j - 1];

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            dp[i][j] = (dp[i - 1][j] && s1[i - 1] === s3[i + j - 1]) ||
                       (dp[i][j - 1] && s2[j - 1] === s3[i + j - 1]);
        }
    }

    return dp[m][n];
}

-----
function isInterleave(s1, s2, s3) 
    // Your code here
}

************************************
Question ID: 99
function inorder(node, nodes) {
    if (!node) return;
    inorder(node.left, nodes);
    if (nodes[1] && nodes[1].val > node.val) {
        if (!nodes[0]) nodes[0] = nodes[1];
        nodes[2] = node;
    }
    nodes[1] = node;
    inorder(node.right, nodes);
}

function recoverTree(root) {
    const nodes = [null, null, null];
    inorder(root, nodes);
    const temp = nodes[0].val;
    nodes[0].val = nodes[2].val;
    nodes[2].val = temp;
}

-----
function inorder(node, nodes) 
    // Your code here
}

************************************
Question ID: 101
function isSymmetric(root) {
    return checkSymmetry(root, root);
}

function checkSymmetry(node1, node2) {
    if (!node1 && !node2) return true;
    if (!node1 || !node2) return false;
    return (node1.val === node2.val) && checkSymmetry(node1.right, node2.left) && checkSymmetry(node1.left, node2.right);
}

-----
function isSymmetric(root) 
    // Your code here
}

************************************
Question ID: 104
function maxDepth(root) {
    if (root === null) {
        return 0;
    }
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}

-----
function maxDepth(root) 
    // Your code here
}

************************************
Question ID: 107
class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

function levelOrderBottom(root) {
    const result = [];
    if (!root) return result;

    const queue = [root];

    while (queue.length > 0) {
        const level = [];
        const size = queue.length;

        for (let i = 0; i < size; i++) {
            const current = queue.shift();
            level.push(current.val);

            if (current.left) queue.push(current.left);
            if (current.right) queue.push(current.right);
        }
        result.unshift(level);
    }

    return result;
}

-----
class TreeNode 
    // Your code here
}

************************************
Question ID: 111
function minDepth(root) {
    if (!root) return 0;
    let left = minDepth(root.left);
    let right = minDepth(root.right);
    return (left === 0 || right === 0) ? left + right + 1 : Math.min(left, right) + 1;
}

-----
function minDepth(root) 
    // Your code here
}

************************************
Question ID: 114
function flatten(root) {
    if (!root) return;
    flatten(root.left);
    flatten(root.right);
    if (root.left) {
        let temp = root.right;
        root.right = root.left;
        root.left = null;
        while (root.right) root = root.right;
        root.right = temp;
    }
}

-----
function flatten(root) 
    // Your code here
}

************************************
Question ID: 115
function numDistinct(s, t) {
    const m = s.length, n = t.length;
    const dp = Array.from({length: m + 1}, () => Array(n + 1).fill(0));

    for (let i = 0; i <= m; i++) {
        dp[i][0] = 1;
    }

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (s[i - 1] === t[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }

    return dp[m][n];
}

-----
function numDistinct(s, t) 
    // Your code here
}

************************************
Question ID: 116
function connect(root) {
    if (root === null || root.left === null) return root;
    root.left.next = root.right;
    if (root.next !== null) {
        root.right.next = root.next.left;
    }
    connect(root.left);
    connect(root.right);
    return root;
}


-----
function connect(root) 
    // Your code here
}


************************************
Question ID: 118
function generate(numRows) {
    const pascalsTriangle = [];
    for (let i = 0; i < numRows; i++) {
        const row = [1];
        for (let j = 1; j < i; j++) {
            row.push(pascalsTriangle[i - 1][j - 1] + pascalsTriangle[i - 1][j]);
        }
        if (i > 0) row.push(1);
        pascalsTriangle.push(row);
    }
    return pascalsTriangle;
}

-----
function generate(numRows) 
    // Your code here
}

************************************
Question ID: 119
function getRow(rowIndex) {
    const row = new Array(rowIndex + 1).fill(1);
    for (let i = 1; i <= rowIndex; i++) {
        for (let j = i - 1; j > 0; j--) {
            row[j] += row[j - 1];
        }
    }
    return row;
}

-----
function getRow(rowIndex) 
    // Your code here
}

************************************
Question ID: 120
function minimumTotal(triangle) {
    for (let row = triangle.length - 2; row >= 0; row--) {
        for (let col = 0; col < triangle[row].length; col++) {
            triangle[row][col] += Math.min(triangle[row + 1][col], triangle[row + 1][col + 1]);
        }
    }
    return triangle[0][0];
}

-----
function minimumTotal(triangle) 
    // Your code here
}

************************************
Question ID: 121
function maxProfit(prices) {
    let minPrice = Number.MAX_VALUE;
    let maxProfit = 0;
    for (const price of prices) {
        minPrice = Math.min(minPrice, price);
        maxProfit = Math.max(maxProfit, price - minPrice);
    }
    return maxProfit;
}

-----
function maxProfit(prices) 
    // Your code here
}

************************************
Question ID: 122
function maxProfit(prices) {
    let max_profit = 0;
    for (let i = 1; i < prices.length; i++) {
        if (prices[i] > prices[i - 1]) {
            max_profit += prices[i] - prices[i - 1];
        }
    }
    return max_profit;
}

-----
function maxProfit(prices) 
    // Your code here
}

************************************
Question ID: 123
function maxProfit(prices) {
    let buy1 = Infinity, buy2 = Infinity;
    let profit1 = 0, profit2 = 0;

    for (let price of prices) {
        buy1 = Math.min(buy1, price);
        profit1 = Math.max(profit1, price - buy1);
        buy2 = Math.min(buy2, price - profit1);
        profit2 = Math.max(profit2, price - buy2);
    }

    return profit2;
}

-----
function maxProfit(prices) 
    // Your code here
}

************************************
Question ID: 125
function isPalindrome(s) {
    const cleaned = s.toLowerCase().replace(/[^a-z0-9]/g, '');
    let left = 0, right = cleaned.length - 1;
    while (left < right) {
        if (cleaned[left++] !== cleaned[right--]) return false;
    }
    return true;
}

-----
function isPalindrome(s) 
    // Your code here
}

************************************
Question ID: 126
function findLadders(beginWord, endWord, wordList) {
    const dict = new Set(wordList);
    if (!dict.has(endWord)) {
        return [];
    }

    const adjacent = new Map();
    const distance = new Map();
    const queue = [beginWord];
    distance.set(beginWord, 0);
    
    function neighbors(word) {
        const result = [];
        for (let i = 0; i < word.length; i++) {
            for (let j = 'a'.charCodeAt(0); j <= 'z'.charCodeAt(0); j++) {
                const next = word.slice(0, i) + String.fromCharCode(j) + word.slice(i + 1);
                if (next !== word) {
                    result.push(next);
                }
            }
        }
        return result;
    }
    
    while (queue.length > 0) {
        const current = queue.shift();
        if (current === endWord) {
            break;
        }
        for (const neighbor of neighbors(current)) {
            if (!dict.has(neighbor)) {
                continue;
            }
            if (!distance.has(neighbor)) {
                distance.set(neighbor, distance.get(current) + 1);
                queue.push(neighbor);
            }
            if (distance.get(neighbor) === distance.get(current) + 1) {
                if (!adjacent.has(current)) {
                    adjacent.set(current, []);
                }
                adjacent.get(current).push(neighbor);
            }
        }
    }

    const result = [];
    const path = [beginWord];

    function backtrack(word) {
        if (word === endWord) {
            result.push([...path]);
            return;
        }
        for (const next of (adjacent.get(word) || [])) {
            path.push(next);
            backtrack(next);
            path.pop();
        }
    }
    
    backtrack(beginWord);
    return result;
}


-----
function findLadders(beginWord, endWord, wordList) 
    // Your code here
}


************************************
Question ID: 127
function ladderLength(beginWord, endWord, wordList) {
    const wordSet = new Set(wordList);
    if (!wordSet.has(endWord)) return 0;

    const q = [beginWord];
    let steps = 1;

    while (q.length > 0) {
        const size = q.length;
        const currentLevel = new Set();

        for (let i = 0; i < size; ++i) {
            const currentWord = q.shift();
            if (currentWord === endWord) return steps;

            const wordChars = currentWord.split('');
            for (let j = 0; j < wordChars.length; ++j) {
                const originalChar = wordChars[j];
                for (let k = 0; k < 26; ++k) {
                    wordChars[j] = String.fromCharCode('a'.charCodeAt(0) + k);
                    const newWord = wordChars.join('');
                    if (wordSet.has(newWord)) {
                        q.push(newWord);
                        currentLevel.add(newWord);
                    }
                }
                wordChars[j] = originalChar;
            }
        }
        steps++;
        for (const word of currentLevel) {
            wordSet.delete(word);
        }
    }
    return 0;
}

-----
function ladderLength(beginWord, endWord, wordList) 
    // Your code here
}

************************************
Question ID: 128
function longestConsecutive(nums) {
    const elements = new Set(nums);
    let longestSeq = 0;

    for (const num of nums) {
        if (!elements.has(num - 1)) {
            let currentNum = num;
            let currentSeq = 1;

            while (elements.has(currentNum + 1)) {
                currentNum++;
                currentSeq++;
            }

            longestSeq = Math.max(longestSeq, currentSeq);
        }
    }

    return longestSeq;
}


-----
function longestConsecutive(nums) 
    // Your code here
}


************************************
Question ID: 129
function sumNumbers(root, cur = 0) {
    if (!root) return 0;
    cur = cur * 10 + root.val;
    if (!root.left && !root.right) return cur;
    return sumNumbers(root.left, cur) + sumNumbers(root.right, cur);
}


-----
function sumNumbers(root, cur = 0) 
    // Your code here
}


************************************
Question ID: 131
function isPalindrome(s, start, end) {
    while (start < end) {
        if (s[start++] !== s[end--]) return false;
    }
    return true;
}

function dfs(s, start, results, current) {
    if (start === s.length) {
        results.push([...current]);
        return;
    }
    
    for (let end = start; end < s.length; end++) {
        if (isPalindrome(s, start, end)) {
            current.push(s.slice(start, end + 1));
            dfs(s, end + 1, results, current);
            current.pop();
        }
    }
}

function partition(s) {
    let results = [];
    dfs(s, 0, results, []);
    return results;
}

-----
function isPalindrome(s, start, end) 
    // Your code here
}

************************************
Question ID: 132
function minCut(s) {
    const n = s.length;
    const dp = Array.from({ length: n + 1 }, (_, i) => i - 1);
    const isPalindrome = Array.from({ length: n }, () => Array(n).fill(false));
    
    for (let j = 1; j < n; j++) {
        for (let i = j; i >= 0; i--) {
            if (s[i] === s[j] && (j - i < 2 || isPalindrome[i + 1][j - 1])) {
                isPalindrome[i][j] = true;
                dp[j + 1] = Math.min(dp[j + 1], dp[i] + 1);
            }
        }
    }
    
    return dp[n];
}

-----
function minCut(s) 
    // Your code here
}

************************************
Question ID: 134
function canCompleteCircuit(gas, cost) {
    let totalGas = 0, totalCost = 0, start = 0, gasTank = 0;
    for (let i = 0; i < gas.length; i++) {
        totalGas += gas[i];
        totalCost += cost[i];
        gasTank += gas[i] - cost[i];
        if (gasTank < 0) {
            start = i + 1;
            gasTank = 0;
        }
    }
    return (totalGas < totalCost) ? -1 : start;
}

-----
function canCompleteCircuit(gas, cost) 
    // Your code here
}

************************************
Question ID: 135
function minCandies(ratings) {
    const n = ratings.length;
    const candies = Array(n).fill(1);

    for (let i = 1; i < n; i++) {
        if (ratings[i] > ratings[i - 1]) candies[i] = candies[i - 1] + 1;
    }
    for (let i = n - 2; i >= 0; i--) {
        if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], candies[i + 1] + 1);
    }

    return candies.reduce((a, b) => a + b, 0);
}

-----
function minCandies(ratings) 
    // Your code here
}

************************************
Question ID: 136
function singleNumber(nums) {
    let result = 0;
    for (let num of nums) {
        result ^= num;
    }
    return result;
}

-----
function singleNumber(nums) 
    // Your code here
}

************************************
Question ID: 137
function singleNumber(nums) {
    let ones = 0, twos = 0;
    for (let n of nums) {
        ones = (ones ^ n) & ~twos;
        twos = (twos ^ n) & ~ones;
    }
    return ones;
}

-----
function singleNumber(nums) 
    // Your code here
}

************************************
Question ID: 139
function wordBreak(s, wordDict) {
    const dict = new Set(wordDict);
    const dp = Array(s.length + 1).fill(false);
    dp[0] = true;
    for (let i = 1; i <= s.length; i++) {
        for (let j = 0; j < i; j++) {
            if (dp[j] && dict.has(s.slice(j, i))) {
                dp[i] = true;
                break;
            }
        }
    }
    return dp[s.length];
}


-----
function wordBreak(s, wordDict) 
    // Your code here
}


************************************
Question ID: 140
function wordBreak(s, wordDict) {
    const dict = new Set(wordDict);
    const memo = {};

    function helper(s, dict, memo) {
        if (s in memo) {
            return memo[s];
        }
        
        const res = [];
        if (dict.has(s)) {
            res.push(s);
        }
        
        for (let i = 1; i < s.length; ++i) {
            const prefix = s.slice(0, i);
            if (!dict.has(prefix)) continue;
            const suffix = s.slice(i);
            const temp = helper(suffix, dict, memo);
            for (const t of temp) {
                res.push(prefix + " " + t);
            }
        }

        memo[s] = res;
        return res;
    }

    return helper(s, dict, memo);
}

-----
function wordBreak(s, wordDict) 
    // Your code here
}

************************************
Question ID: 141
function hasCycle(head) {
    let slow = head, fast = head;
    while (fast !== null && fast.next !== null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow === fast) {
            return true;
        }
    }
    return false;
}

-----
function hasCycle(head) 
    // Your code here
}

************************************
Question ID: 146
class LRUCache {
    constructor(capacity) {
        this.capacity = capacity;
        this.cache = new Map();
    }

    get(key) {
        if (!this.cache.has(key)) {
            return -1;
        }
        const value = this.cache.get(key);
        this.cache.delete(key);
        this.cache.set(key, value);
        return value;
    }

    put(key, value) {
        if (this.cache.has(key)) {
            this.cache.delete(key);
        } else if (this.cache.size >= this.capacity) {
            this.cache.delete(this.cache.keys().next().value);
        }
        this.cache.set(key, value);
    }
}


-----
class LRUCache 
    // Your code here
}


************************************
Question ID: 149
function maxPoints(points) {
    const n = points.length;
    if (n <= 2) return n;

    let maxCount = 0;

    for (let i = 0; i < n; i++) {
        const slopeMap = new Map();
        let duplicates = 0, localMax = 0;

        for (let j = i + 1; j < n; j++) {
            let deltaX = points[j][0] - points[i][0];
            let deltaY = points[j][1] - points[i][1];

            if (deltaX === 0 && deltaY === 0) {
                duplicates++;
                continue;
            }

            const gcdVal = gcd(deltaX, deltaY);
            deltaX /= gcdVal;
            deltaY /= gcdVal;

            const key = `${deltaX}_${deltaY}`;
            slopeMap.set(key, (slopeMap.get(key) || 0) + 1);
            localMax = Math.max(localMax, slopeMap.get(key));
        }
        maxCount = Math.max(maxCount, localMax + duplicates + 1);
    }

    return maxCount;
}

function gcd(a, b) {
    if (b === 0) return a;
    return gcd(b, a % b);
}


-----
function maxPoints(points) 
    // Your code here
}


************************************
Question ID: 150
function evalRPN(tokens) {
    const stack = [];
    for (const token of tokens) {
        if (token === "+" || token === "-" || token === "*" || token === "/") {
            const b = stack.pop();
            const a = stack.pop();
            if (token === "+") stack.push(a + b);
            else if (token === "-") stack.push(a - b);
            else if (token === "*") stack.push(a * b);
            else stack.push(Math.trunc(a / b));
        } else {
            stack.push(parseInt(token));
        }
    }
    return stack.pop();
}

-----
function evalRPN(tokens) 
    // Your code here
}

************************************
Question ID: 151
function reverseWords(s) {
    return s.trim().split(/\s+/).reverse().join(' ');
}

-----
function reverseWords(s) 
    // Your code here
}

************************************
Question ID: 152
function maxProduct(nums) {
    let max_so_far = nums[0];
    let min_so_far = nums[0];
    let result = nums[0];
    
    for (let i = 1; i < nums.length; i++) {
        if (nums[i] < 0) {
            [max_so_far, min_so_far] = [min_so_far, max_so_far];
        }
        
        max_so_far = Math.max(nums[i], max_so_far * nums[i]);
        min_so_far = Math.min(nums[i], min_so_far * nums[i]);
        result = Math.max(result, max_so_far);
    }
    return result;
}


-----
function maxProduct(nums) 
    // Your code here
}


************************************
Question ID: 153
function findMin(nums) {
    let left = 0, right = nums.length - 1;

    while (left < right) {
        let mid = left + Math.floor((right - left) / 2);
        if (nums[mid] > nums[right]) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return nums[left];
}

-----
function findMin(nums) 
    // Your code here
}

************************************
Question ID: 154
function findMin(nums) {
    let low = 0, high = nums.length - 1;
    
    while (low < high) {
        let mid = low + Math.floor((high - low) / 2);
        if (nums[mid] > nums[high]) {
            low = mid + 1;
        } else if (nums[mid] < nums[high]) {
            high = mid;
        } else {
            high--;
        }
    }
    return nums[low];
}

-----
function findMin(nums) 
    // Your code here
}

************************************
Question ID: 157
function read4(buf4) {
    // Implemented elsewhere
}

function read(buf, n) {
    let totalRead = 0;
    const buf4 = new Array(4);

    while (totalRead < n) {
        const read4Count = read4(buf4);
        for(let i = 0; i < read4Count && totalRead < n; ++i) {
            buf[totalRead++] = buf4[i];
        }
        if (read4Count < 4) break;
    }

    return totalRead;
}

-----
function read4(buf4) 
    // Your code here
}

************************************
Question ID: 159
function lengthOfLongestSubstringTwoDistinct(s) {
    let l = 0, r = 0, max_len = 0, cur_len = 0;
    const char_count = new Map();

    while (r < s.length) {
        char_count.set(s[r], (char_count.get(s[r]) || 0) + 1);
        if (char_count.size <= 2) {
            cur_len++;
        } else {
            while (char_count.size > 2 && l <= r) {
                char_count.set(s[l], char_count.get(s[l]) - 1);
                if (char_count.get(s[l]) === 0) {
                    char_count.delete(s[l]);
                }
                l++;
                cur_len--;
            }
            cur_len++;
        }
        max_len = Math.max(max_len, cur_len);
        r++;
    }
    return max_len;
}

-----
function lengthOfLongestSubstringTwoDistinct(s) 
    // Your code here
}

************************************
Question ID: 161
function isOneEditDistance(s, t) {
    let m = s.length, n = t.length;
    if (m > n) {
        return isOneEditDistance(t, s);
    }
    if (n - m > 1) {
        return false;
    }
    for (let i = 0; i < m; ++i) {
        if (s[i] !== t[i]) {
            if (m < n) {
                return s.slice(i) === t.slice(i + 1);
            } else {
                return s.slice(i + 1) === t.slice(i + 1);
            }
        }
    }
    return m + 1 === n;
}


-----
function isOneEditDistance(s, t) 
    // Your code here
}


************************************
Question ID: 162
function findPeakElement(nums) {
    let left = 0, right = nums.length - 1;
    while (left < right) {
        let mid = left + Math.floor((right - left) / 2);
        if (nums[mid] < nums[mid + 1]) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}

-----
function findPeakElement(nums) 
    // Your code here
}

************************************
Question ID: 163
function findMissingRanges(nums, lower, upper) {
    let result = [];
    let prev = lower - 1;

    for (let i = 0; i <= nums.length; ++i) {
        let cur = (i === nums.length) ? upper + 1 : nums[i];
        if (cur - prev >= 2) {
            result.push((prev + 1) + (cur - prev === 2 ? "" : "->") + (cur - 1));
        }
        prev = cur;
    }

    return result;
}

-----
function findMissingRanges(nums, lower, upper) 
    // Your code here
}

************************************
Question ID: 164
function maximumGap(nums) {
    if (nums.length < 2) return 0;

    let min_val = Math.min(...nums);
    let max_val = Math.max(...nums);
    let len = nums.length;
    let bucket_size = Math.max(1, Math.floor((max_val - min_val) / (len - 1)));
    let bucket_num = Math.floor((max_val - min_val) / bucket_size) + 1;
    let buckets = Array.from({ length: bucket_num }, () => [Infinity, -Infinity]);

    for (let num of nums) {
        let idx = Math.floor((num - min_val) / bucket_size);
        buckets[idx][0] = Math.min(buckets[idx][0], num);
        buckets[idx][1] = Math.max(buckets[idx][1], num);
    }

    let max_gap = 0, prev_max = min_val;
    for (let bucket of buckets) {
        if (bucket[0] === Infinity) continue;
        max_gap = Math.max(max_gap, bucket[0] - prev_max);
        prev_max = bucket[1];
    }
    return max_gap;
}

-----
function maximumGap(nums) 
    // Your code here
}

************************************
Question ID: 165
function compareVersion(version1, version2) {
    const v1 = version1.split('.');
    const v2 = version2.split('.');
    
    while (v1.length > 0 || v2.length > 0) {
        const num1 = v1.length > 0 ? parseInt(v1.shift()) : 0;
        const num2 = v2.length > 0 ? parseInt(v2.shift()) : 0;
        
        if (num1 < num2) return -1;
        if (num1 > num2) return 1;
    }
    return 0;
}


-----
function compareVersion(version1, version2) 
    // Your code here
}


************************************
Question ID: 166
function fractionToDecimal(numerator, denominator) {
    if (numerator === 0) return "0";
    let res = "";
    if ((numerator > 0) ^ (denominator > 0)) res += '-';
    let num = Math.abs(numerator), den = Math.abs(denominator);
    res += Math.floor(num / den);
    num %= den;
    if (num === 0) return res;
    res += '.';
    let map = new Map();
    while (num) {
        if (map.has(num)) {
            res = res.slice(0, map.get(num)) + "(" + res.slice(map.get(num)) + ")";
            break;
        }
        map.set(num, res.length);
        num *= 10;
        res += Math.floor(num / den);
        num %= den;
    }
    return res;
}


-----
function fractionToDecimal(numerator, denominator) 
    // Your code here
}


************************************
Question ID: 167
function twoSum(numbers, target) {
    let left = 0, right = numbers.length - 1;
    while (left < right) {
        let current_sum = numbers[left] + numbers[right];
        if (current_sum === target) {
            return [left + 1, right + 1];
        } else if (current_sum < target) {
            left++;
        } else {
            right--;
        }
    }
    return [];
}

-----
function twoSum(numbers, target) 
    // Your code here
}

************************************
Question ID: 168
function convertToTitle(columnNumber) {
    let result = "";
    while (columnNumber) {
        columnNumber--;
        result = String.fromCharCode(columnNumber % 26 + 'A'.charCodeAt(0)) + result;
        columnNumber = Math.floor(columnNumber / 26);
    }
    return result;
}


-----
function convertToTitle(columnNumber) 
    // Your code here
}


************************************
Question ID: 169
function majorityElement(nums) {
    let count = 0;
    let candidate = null;

    for (const num of nums) {
        if (count === 0) {
            candidate = num;
        }
        count += (num === candidate) ? 1 : -1;
    }

    return candidate;
}

-----
function majorityElement(nums) 
    // Your code here
}

************************************
Question ID: 171
function titleToNumber(columnTitle) {
    let result = 0;
    for (let c of columnTitle) {
        result = result * 26 + (c.charCodeAt(0) - 'A'.charCodeAt(0) + 1);
    }
    return result;
}

-----
function titleToNumber(columnTitle) 
    // Your code here
}

************************************
Question ID: 172
function trailingZeroes(n) {
    let count = 0;
    while (n > 0) {
        n = Math.floor(n / 5);
        count += n;
    }
    return count;
}


-----
function trailingZeroes(n) 
    // Your code here
}


************************************
Question ID: 174
function calculateMinimumHP(dungeon) {
    const m = dungeon.length, n = dungeon[0].length;
    const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));

    for (let i = m - 1; i >= 0; i--) {
        for (let j = n - 1; j >= 0; j--) {
            if (i === m - 1 && j === n - 1)
                dp[i][j] = Math.min(0, dungeon[i][j]);
            else if (i === m - 1)
                dp[i][j] = Math.min(0, dp[i][j + 1] + dungeon[i][j]);
            else if (j === n - 1)
                dp[i][j] = Math.min(0, dp[i + 1][j] + dungeon[i][j]);
            else
                dp[i][j] = Math.min(0, Math.max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);
        }
    }

    return Math.abs(dp[0][0]) + 1;
}

-----
function calculateMinimumHP(dungeon) 
    // Your code here
}

************************************
Question ID: 179
function largestNumber(nums) {
    const numsAsStrings = nums.map(String);
    numsAsStrings.sort((a, b) => (b + a).localeCompare(a + b));
    return numsAsStrings[0] === '0' ? '0' : numsAsStrings.join('');
}

-----
function largestNumber(nums) 
    // Your code here
}

************************************
Question ID: 186
function reverseWords(s) {
    function reverse(s, start, end) {
        while (start < end) {
            [s[start], s[end]] = [s[end], s[start]];
            start++;
            end--;
        }
    }

    reverse(s, 0, s.length - 1);
    let start = 0;
    for (let i = 0; i <= s.length; i++) {
        if (i === s.length || s[i] === ' ') {
            reverse(s, start, i - 1);
            start = i + 1;
        }
    }
}

-----
function reverseWords(s) 
    // Your code here
}

************************************
Question ID: 187
function findRepeatedDnaSequences(s) {
    const dnaCounter = new Map();
    const result = [];

    for (let i = 0; i <= s.length - 10; i++) {
        const sequence = s.slice(i, i + 10);
        dnaCounter.set(sequence, (dnaCounter.get(sequence) || 0) + 1);
        if (dnaCounter.get(sequence) === 2) {
            result.push(sequence);
        }
    }

    return result;
}

-----
function findRepeatedDnaSequences(s) 
    // Your code here
}

************************************
Question ID: 188
function maxProfit(k, prices) {
    let n = prices.length;
    if (k > n / 2) {
        let maxProfit = 0;
        for (let i = 1; i < n; ++i)
            maxProfit += Math.max(prices[i] - prices[i - 1], 0);
        return maxProfit;  
    }

    let dp = new Array(k + 1).fill(null).map(() => new Array(n).fill(0));
    for (let i = 1; i <= k; ++i) {
        let maxDiff = -prices[0];
        for (let j = 1; j < n; ++j) {
            dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);
            maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);
        }
    }
    return dp[k][n - 1];
}

-----
function maxProfit(k, prices) 
    // Your code here
}

************************************
Question ID: 189
function rotate(nums, k) {
    const n = nums.length;
    k %= n;
    reverse(nums, 0, n - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, n - 1);
}

function reverse(nums, start, end) {
    while (start < end) {
        [nums[start], nums[end]] = [nums[end], nums[start]];
        start++;
        end--;
    }
}

-----
function rotate(nums, k) 
    // Your code here
}

************************************
Question ID: 190
function reverseBits(n) {
    let res = 0;
    for (let i = 0; i < 32; ++i) {
        res <<= 1;
        res |= n & 1;
        n >>= 1;
    }
    return res >>> 0;
}

-----
function reverseBits(n) 
    // Your code here
}

************************************
Question ID: 191
function hammingWeight(n) {
    let count = 0;
    while (n != 0) {
        count += n & 1;
        n >>>= 1;
    }
    return count;
}

-----
function hammingWeight(n) 
    // Your code here
}

************************************
Question ID: 194
function transpose(content) {
    let data = content.map(line => line.split(" "));
    let result = new Array(data[0].length).fill("");
    for (let i = 0; i < data[0].length; i++) {
        for (let j = 0; j < data.length; j++) {
            result[i] += (j > 0 ? " " : "") + data[j][i];
        }
    }

    return result;
}


-----
function transpose(content) 
    // Your code here
}


************************************
Question ID: 198
function rob(nums) {
    let prev1 = 0, prev2 = 0;
    for (let num of nums) {
        let temp = prev1;
        prev1 = Math.max(prev2 + num, prev1);
        prev2 = temp;
    }
    return prev1;
}

-----
function rob(nums) 
    // Your code here
}

************************************
Question ID: 200
function dfs(grid, i, j) {
    if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0')
        return;

    grid[i][j] = '0';
    dfs(grid, i + 1, j);
    dfs(grid, i - 1, j);
    dfs(grid, i, j + 1);
    dfs(grid, i, j - 1);
}

function numIslands(grid) {
    let count = 0;
    for(let i = 0; i < grid.length; i++) {
        for(let j = 0; j < grid[0].length; j++) {
            if(grid[i][j] === '1') {
                count++;
                dfs(grid, i, j);
            }
        }
    }
    return count;
}

-----
function dfs(grid, i, j) 
    // Your code here
}

************************************
Question ID: 201
function rangeBitwiseAnd(left, right) {
    let shift = 0;
    while (left != right) {
        left >>= 1;
        right >>= 1;
        shift++;
    }
    return left << shift;
}

-----
function rangeBitwiseAnd(left, right) 
    // Your code here
}

************************************
Question ID: 202
function getNext(n) {
    let sum = 0;
    while (n > 0) {
        let digit = n % 10;
        sum += digit * digit;
        n = Math.floor(n / 10);
    }
    return sum;
}

function isHappy(n) {
    let slow = n, fast = getNext(n);
    while (fast !== 1 && slow !== fast) {
        slow = getNext(slow);
        fast = getNext(getNext(fast));
    }
    return fast === 1;
}

-----
function getNext(n) 
    // Your code here
}

************************************
Question ID: 204
function countPrimes(n) {
    if (n <= 2) return 0;
    const isPrime = Array(n).fill(true);
    isPrime[0] = isPrime[1] = false;
    for (let i = 2; i * i < n; i++) {
        if (isPrime[i]) {
            for (let j = i * i; j < n; j += i) {
                isPrime[j] = false;
            }
        }
    }
    return isPrime.filter(prime => prime).length;
}

-----
function countPrimes(n) 
    // Your code here
}

************************************
Question ID: 205
function isIsomorphic(s, t) {
    let map1 = new Map();
    let map2 = new Map();
    for (let i = 0; i < s.length; i++) {
        let sChar = s[i];
        let tChar = t[i];

        if (!map1.has(sChar)) {
            map1.set(sChar, tChar);
        }
        if (!map2.has(tChar)) {
            map2.set(tChar, sChar);
        }

        if (map1.get(sChar) !== tChar || map2.get(tChar) !== sChar) {
            return false;
        }
    }
    return true;
}

-----
function isIsomorphic(s, t) 
    // Your code here
}

************************************
Question ID: 207
function canFinish(numCourses, prerequisites) {
    let adj = Array.from(Array(numCourses), () => []);
    let inDegree = Array(numCourses).fill(0);
    
    for (let [a, b] of prerequisites) {
        adj[b].push(a);
        inDegree[a]++;
    }
    
    let q = [];
    for (let i = 0; i < numCourses; i++) {
        if (inDegree[i] === 0) q.push(i);
    }
    
    while (q.length) {
        const currCourse = q.shift();
        numCourses--;
        
        for (let nextCourse of adj[currCourse]) {
            inDegree[nextCourse]--;
            if (inDegree[nextCourse] === 0) q.push(nextCourse);
        }
    }
    
    return numCourses === 0;
}


-----
function canFinish(numCourses, prerequisites) 
    // Your code here
}


************************************
Question ID: 209
function minSubArrayLen(target, nums) {
    let left = 0, cur_sum = 0, min_len = Number.MAX_VALUE;
    for (let right = 0; right < nums.length; right++) {
        cur_sum += nums[right];
        while (cur_sum >= target) {
            min_len = Math.min(min_len, right - left + 1);
            cur_sum -= nums[left++];
        }
    }
    return min_len === Number.MAX_VALUE ? 0 : min_len;
}


-----
function minSubArrayLen(target, nums) 
    // Your code here
}


************************************
Question ID: 210
function findOrder(numCourses, prerequisites) {
    const inDegree = new Array(numCourses).fill(0);
    const adjList = Array.from({ length: numCourses }, () => []);
    
    for (const p of prerequisites) {
        adjList[p[1]].push(p[0]);
        inDegree[p[0]]++;
    }
    
    const q = [];
    for (let i = 0; i < numCourses; i++) {
        if (inDegree[i] === 0) {
            q.push(i);
        }
    }
    
    const order = [];
    
    while (q.length) {
        const curr = q.shift();
        order.push(curr);
        for (const next of adjList[curr]) {
            if (--inDegree[next] === 0) {
                q.push(next);
            }
        }
    }
    
    return (order.length === numCourses) ? order : [];
}


-----
function findOrder(numCourses, prerequisites) 
    // Your code here
}


************************************
Question ID: 212
function findWords(board, words) {
    function dfs(board, word, index, i, j, visited) {
        if (index === word.length) {
            return true;
        }
        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j] || board[i][j] !== word.charAt(index)) {
            return false;
        }
        visited[i][j] = true;
        const found = dfs(board, word, index + 1, i - 1, j, visited) ||
                      dfs(board, word, index + 1, i + 1, j, visited) ||
                      dfs(board, word, index + 1, i, j - 1, visited) ||
                      dfs(board, word, index + 1, i, j + 1, visited);
        visited[i][j] = false;
        return found;
    }

    const res = [];
    for (const word of words) {
        let found = false;
        for (let i = 0; i < board.length && !found; i++) {
            for (let j = 0; j < board[0].length && !found; j++) {
                if (dfs(board, word, 0, i, j, Array.from({ length: board.length }, () => Array(board[0].length).fill(false)))) {
                    found = true;
                }
            }
        }
        if (found) {
            res.push(word);
        }
    }
    return res;
}


-----
function findWords(board, words) 
    // Your code here
}


************************************
Question ID: 213
function rob(nums) {
    if (nums.length === 1) return nums[0];
    let prev = 0, curr = 0;
    for (let i = 0; i < nums.length - 1; i++) {
        let temp = Math.max(curr, prev + nums[i]);
        prev = curr;
        curr = temp;
    }
    let res = curr;
    prev = 0;
    curr = 0;
    for (let i = 1; i < nums.length; i++) {
        let temp = Math.max(curr, prev + nums[i]);
        prev = curr;
        curr = temp;
    }
    return Math.max(res, curr);
}

-----
function rob(nums) 
    // Your code here
}

************************************
Question ID: 214
function shortestPalindrome(s) {
    let n = s.length;
    let rev_s = s.split('').reverse().join('');
    
    for (let i = 0; i < n; ++i) {
        if (s.slice(0, n - i) === rev_s.slice(i))
            return rev_s.slice(0, i) + s;
    }
    return "";
}


-----
function shortestPalindrome(s) 
    // Your code here
}


************************************
Question ID: 215
function findKthLargest(nums, k) {
    nums.sort((a, b) => b - a);
    return nums[k - 1];
}


-----
function findKthLargest(nums, k) 
    // Your code here
}


************************************
Question ID: 216
function combinationSum3(k, n) {
  function helper(k, n, current, currentComb, result) {
    if (k === 0 && n === 0) {
      result.push([...currentComb]);
    } else if (k > 0 && n > 0) {
      for (let i = current + 1; i <= 9; i++) {
        currentComb.push(i);
        helper(k - 1, n - i, i, currentComb, result);
        currentComb.pop();
      }
    }
  }

  const result = [];
  helper(k, n, 0, [], result);
  return result;
}


-----
function combinationSum3(k, n) 
    // Your code here
}


************************************
Question ID: 217
function containsDuplicate(nums) {
    const set = new Set();
    for (const num of nums) {
        if (set.has(num)) {
            return true;
        }
        set.add(num);
    }
    return false;
}


-----
function containsDuplicate(nums) 
    // Your code here
}


************************************
Question ID: 218
function getSkyline(buildings) {
    const points = [];
    for (const [l, r, h] of buildings) {
        points.push([l, -h]);
        points.push([r, h]);
    }
    points.sort((a, b) => a[0] - b[0]);
    const heights = new SortedSet([0]);
    let prev = 0;
    const skyline = [];
    for (const [x, h] of points) {
        if (h < 0) {
            heights.add(-h);
        } else {
            heights.delete(h);
        }
        const cur = heights.last();
        if (cur !== prev) {
            skyline.push([x, cur]);
            prev = cur;
        }
    }
    return skyline;
}

-----
function getSkyline(buildings) 
    // Your code here
}

************************************
Question ID: 219
function containsNearbyDuplicate(nums, k) {
    const valueIndexMap = new Map();
    for (let i = 0; i < nums.length; i++) {
        if (valueIndexMap.has(nums[i]) && i - valueIndexMap.get(nums[i]) <= k) {
            return true;
        }
        valueIndexMap.set(nums[i], i);
    }
    return false;
}

-----
function containsNearbyDuplicate(nums, k) 
    // Your code here
}

************************************
Question ID: 220
function containsNearbyAlmostDuplicate(nums, k, t) {
    let window = new Set();
    for (let i = 0; i < nums.length; i++) {
        if (i > k) {
            window.delete(nums[i - k - 1]);
        }
        for (const num of window) {
            if (Math.abs(num - nums[i]) <= t) {
                return true;
            }
        }
        window.add(nums[i]);
    }
    return false;
}

-----
function containsNearbyAlmostDuplicate(nums, k, t) 
    // Your code here
}

************************************
Question ID: 221
function maximalSquare(matrix) {
    const m = matrix.length;
    const n = matrix[0].length;
    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
    let maxSize = 0;

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (matrix[i - 1][j - 1] === '1') {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;
                maxSize = Math.max(maxSize, dp[i][j]);
            }
        }
    }

    return maxSize * maxSize;
}

-----
function maximalSquare(matrix) 
    // Your code here
}

************************************
Question ID: 223
function totalArea(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
    const area1 = (ax2 - ax1) * (ay2 - ay1);
    const area2 = (bx2 - bx1) * (by2 - by1);

    const overlapWidth = Math.min(ax2, bx2) - Math.max(ax1, bx1);
    const overlapHeight = Math.min(ay2, by2) - Math.max(ay1, by1);

    const overlapArea = Math.max(overlapWidth, 0) * Math.max(overlapHeight, 0);

    return area1 + area2 - overlapArea;
}


-----
function totalArea(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) 
    // Your code here
}


************************************
Question ID: 224
function calculate(s) {
    let result = 0, sign = 1, num = 0;
    let st = [];
    for (let c of s) {
        if (/\d/.test(c)) {
            num = num * 10 + (c - '0');
        } else {
            result += sign * num;
            num = 0;
            if (c === '+') {
                sign = 1;
            } else if (c === '-') {
                sign = -1;
            } else if (c === '(') {
                st.push(result);
                st.push(sign);
                result = 0;
                sign = 1;
            } else if (c === ')') {
                let prev_sign = st.pop();
                let prev_result = st.pop();
                result = prev_result + prev_sign * result;
            }
        }
    }
    result += sign * num;
    return result;
}

-----
function calculate(s) 
    // Your code here
}

************************************
Question ID: 225
class MyStack {
    constructor() {
        this.q1 = [];
        this.q2 = [];
    }

    push(x) {
        this.q2.push(x);
        while (this.q1.length > 0) {
            this.q2.push(this.q1.shift());
        }
        [this.q1, this.q2] = [this.q2, this.q1];
    }

    pop() {
        return this.q1.shift();
    }

    top() {
        return this.q1[0];
    }

    empty() {
        return this.q1.length === 0;
    }
}

-----
class MyStack 
    // Your code here
}

************************************
Question ID: 227
function calculate(s) {
    let result = 0, num = 0, sign = 1;
    const stack = [];

    for (const c of s) {
        if ('0' <= c && c <= '9') {
            num = num * 10 + parseInt(c);
        } else if (c === '+') {
            result += sign * num;
            num = 0;
            sign = 1;
        } else if (c === '-') {
            result += sign * num;
            num = 0;
            sign = -1;
        } else if (c === '(') {
            stack.push(result);
            stack.push(sign);
            result = 0;
            sign = 1;
        } else if (c === ')') {
            result += sign * num;
            num = 0;
            result *= stack.pop();
            result += stack.pop();
        }
    }
    if (num) result += sign * num;
    return result;
}

-----
function calculate(s) 
    // Your code here
}

************************************
Question ID: 228
function findRanges(nums) {
    const result = [];
    const n = nums.length;
    if (n === 0) return result;

    let start = nums[0];
    for (let i = 1; i < n; i++) {
        if (nums[i] > nums[i - 1] + 1) {
            if (start === nums[i - 1])
                result.push(`${start}`);
            else
                result.push(`${start}->${nums[i - 1]}`);
            start = nums[i];
        }
    }

    if (start === nums[n - 1])
        result.push(`${start}`);
    else
        result.push(`${start}->${nums[n - 1]}`);

    return result;
}

-----
function findRanges(nums) 
    // Your code here
}

************************************
Question ID: 229
function majorityElement(nums) {
    const n = nums.length;
    const count = {};
    const result = [];

    for (const num of nums) {
        if (count.hasOwnProperty(num)) {
            count[num]++;
        } else {
            count[num] = 1;
        }
        if (count[num] > n / 3 && !result.includes(num)) {
            result.push(num);
        }
    }
    return result;
}

-----
function majorityElement(nums) 
    // Your code here
}

************************************
Question ID: 231
function isPowerOfTwo(n) {
    if (n <= 0) {
        return false;
    }
    return (n & (n - 1)) == 0;
}

-----
function isPowerOfTwo(n) 
    // Your code here
}

************************************
Question ID: 233
function countDigitOne(n) {
    let count = 0;
    for(let i = 1; i <= n; i *= 10){
        let divider = i * 10;
        count += Math.floor(n / divider) * i + Math.min(Math.max(n % divider - i + 1, 0), i);
    }
    return count;
}

-----
function countDigitOne(n) 
    // Your code here
}

************************************
Question ID: 237
function deleteNode(node) {
    const nextNode = node.next;
    node.val = nextNode.val;
    node.next = nextNode.next;
}

-----
function deleteNode(node) 
    // Your code here
}

************************************
Question ID: 238
function productExceptSelf(nums) {
    const n = nums.length;
    const answer = new Array(n).fill(1);
    
    let left = 1;
    for (let i = 0; i < n; i++) {
        answer[i] *= left;
        left *= nums[i];
    }
    
    let right = 1;
    for (let i = n - 1; i >= 0; i--) {
        answer[i] *= right;
        right *= nums[i];
    }
    
    return answer;
}

-----
function productExceptSelf(nums) 
    // Your code here
}

************************************
Question ID: 239
function maxSlidingWindow(nums, k) {
  let result = [];
  let dq = [];

  for (let i = 0; i < nums.length; i++) {
    while (dq.length && dq[0] < i - k + 1) {
      dq.shift();
    }

    while (dq.length && nums[dq[dq.length - 1]] < nums[i]) {
      dq.pop();
    }

    dq.push(i);

    if (i >= k - 1) {
      result.push(nums[dq[0]]);
    }
  }

  return result;
}


-----
function maxSlidingWindow(nums, k) 
    // Your code here
}


************************************
Question ID: 240
function searchMatrix(matrix, target) {
    let row = matrix.length - 1, col = 0;
    while(row >= 0 && col < matrix[0].length) {
        if(matrix[row][col] > target) {
            row--;
        } else if(matrix[row][col] < target) {
            col++;
        } else {
            return true;
        }
    }
    return false;
}


-----
function searchMatrix(matrix, target) 
    // Your code here
}


************************************
Question ID: 241
function diffWaysToCompute(input) {
    const result = [];
    for (let i = 0; i < input.length; i++) {
        const c = input[i];
        if (c === '+' || c === '-' || c === '*') {
            const left = diffWaysToCompute(input.slice(0, i));
            const right = diffWaysToCompute(input.slice(i + 1));
            for (const l of left) {
                for (const r of right) {
                    if (c === '+') result.push(l + r);
                    else if (c === '-') result.push(l - r);
                    else if (c === '*') result.push(l * r);
                }
            }
        }
    }
    if (result.length === 0) result.push(parseInt(input));
    return result;
}

-----
function diffWaysToCompute(input) 
    // Your code here
}

************************************
Question ID: 242
function isAnagram(s, t) {
    if (s.length !== t.length)
        return false;

    const counts = {};
    for (let c of s)
        counts[c] = (counts[c] || 0) + 1;

    for (let c of t) {
        if (counts[c] === 0 || !counts[c])
            return false;
        counts[c]--;
    }

    return true;
}


-----
function isAnagram(s, t) 
    // Your code here
}


************************************
Question ID: 243
function shortestDistance(wordsDict, word1, word2) {
    let idx1 = -1, idx2 = -1, minDistance = Number.MAX_VALUE;
    for (let i = 0; i < wordsDict.length; i++) {
        if (wordsDict[i] === word1) idx1 = i;
        if (wordsDict[i] === word2) idx2 = i;
        if (idx1 !== -1 && idx2 !== -1)
            minDistance = Math.min(minDistance, Math.abs(idx1 - idx2));
    }
    return minDistance;
}

-----
function shortestDistance(wordsDict, word1, word2) 
    // Your code here
}

************************************
Question ID: 245
function shortestDistance(wordsDict, word1, word2) {
    let index1 = -1, index2 = -1, minDistance = Infinity;
    for (let i = 0; i < wordsDict.length; ++i) {
        if (wordsDict[i] === word1) { index1 = i; }
        if (wordsDict[i] === word2) { index2 = i; }
        if (index1 !== -1 && index2 !== -1) {
            minDistance = Math.min(minDistance, Math.abs(index1 - index2));
        }
    }
    return minDistance;
}

-----
function shortestDistance(wordsDict, word1, word2) 
    // Your code here
}

************************************
Question ID: 246
function isStrobogrammatic(num) {
    const lookup = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'};
    let left = 0, right = num.length - 1;
    while(left <= right) {
        if(!(num[left] in lookup) || lookup[num[left]] !== num[right]) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}

-----
function isStrobogrammatic(num) 
    // Your code here
}

************************************
Question ID: 247
function findStrobogrammatic(n) {
    return helper(n, n);
}

function helper(n, m) {
    if (n === 0) return [""];
    if (n === 1) return ["0", "1", "8"];
    
    const list = helper(n - 2, m);
    const res = [];

    for (let i = 0; i < list.length; i++) {
        const s = list[i];

        if (n !== m) res.push("0" + s + "0");

        res.push("1" + s + "1");
        res.push("6" + s + "9");
        res.push("8" + s + "8");
        res.push("9" + s + "6");
    }

    return res;
}

-----
function findStrobogrammatic(n) 
    // Your code here
}

************************************
Question ID: 248
function strobogrammaticInRange(low, high) {
    let count = 0;
    for (let len = low.length; len <= high.length; ++len) {
        const num = helper(len, len);
        count += (num >= low && num <= high) ? 1 : 0;
    }
    return count;
}

function helper(m, n) {
    if (m === 0) return "";
    if (m === 1) return "0 1 8";
    if (n === 0) return "11 69 88 96";
    let res = "";
    for (const a of helper(m - 2, n).split(" ")) {
        if (m !== n) res += a + "0" + a + " ";
        res += a + "1" + a + " ";
        res += a + "6" + a + " ";
        res += a + "8" + a + " ";
        res += a + "9" + a + " ";
    }
    return res;
}


-----
function strobogrammaticInRange(low, high) 
    // Your code here
}


************************************
Question ID: 249
function groupStrings(strings) {
    const map = new Map();

    for (const s of strings) {
        let key = '';
        for (const c of s) {
            key += `${(c.charCodeAt(0) - s.charCodeAt(0) + 26) % 26},`;
        }
        if (!map.has(key)) {
            map.set(key, []);
        }
        map.get(key).push(s);
    }

    return Array.from(map.values());
}

-----
function groupStrings(strings) 
    // Your code here
}

************************************
Question ID: 252
function canAttendMeetings(intervals) {
    intervals.sort((a, b) => a[0] - b[0]);
    
    for (let i = 1; i < intervals.length; ++i) {
        if (intervals[i][0] < intervals[i - 1][1])
            return false;
    }
    
    return true;
}

-----
function canAttendMeetings(intervals) 
    // Your code here
}

************************************
Question ID: 253
function minMeetingRooms(intervals) {
    if (intervals.length === 0) return 0;

    intervals.sort((a, b) => a[0] - b[0]);
    const minHeap = [intervals[0][1]];

    for (let i = 1; i < intervals.length; i++) {
        if (intervals[i][0] >= minHeap[0]) {
            minHeap.shift();
        }
        minHeap.push(intervals[i][1]);
        minHeap.sort((a, b) => a - b);
    }

    return minHeap.length;
}

-----
function minMeetingRooms(intervals) 
    // Your code here
}

************************************
Question ID: 254
function getFactors(n) {
    const result = [];
    const helper = (n, start, path) => {
        if (n === 1) {
            if (path.length > 1) {
                result.push([...path]);
            }
            return;
        }

        for (let i = start; i <= n; i++) {
            if (n % i === 0) {
                path.push(i);
                helper(n / i, i, path);
                path.pop();
            }
        }
    };

    helper(n, 2, []);
    return result;
}

-----
function getFactors(n) 
    // Your code here
}

************************************
Question ID: 255
var isValidPreorder = function(preorder) {
    let stack = [];
    let lowerBound = Number.MIN_SAFE_INTEGER;
    for (let num of preorder) {
        if (num < lowerBound) return false;
        while (stack.length > 0 && num > stack[stack.length - 1]) {
            lowerBound = stack.pop();
        }
        stack.push(num);
    }
    return true;
};

-----
var isValidPreorder = function(preorder) 
    // Your code here
};

************************************
Question ID: 256
function minCost(costs) {
    if (costs.length === 0) return 0;
    for (let i = 1; i < costs.length; i++) {
        costs[i][0] += Math.min(costs[i - 1][1], costs[i - 1][2]);
        costs[i][1] += Math.min(costs[i - 1][0], costs[i - 1][2]);
        costs[i][2] += Math.min(costs[i - 1][0], costs[i - 1][1]);
    }
    return Math.min(costs[costs.length - 1][0], costs[costs.length - 1][1], costs[costs.length - 1][2]);
}

-----
function minCost(costs) 
    // Your code here
}

************************************
Question ID: 258
function addDigits(num) {
    return 1 + (num - 1) % 9;
}

-----
function addDigits(num) 
    // Your code here
}

************************************
Question ID: 259
function threeSumSmaller(nums, target) {
    let count = 0;
    nums.sort((a, b) => a - b);
    for (let i = 0; i < nums.length; ++i) {
        let j = i + 1, k = nums.length - 1;
        while (j < k) {
            if (nums[i] + nums[j] + nums[k] < target) {
                count += k - j;
                ++j;
            } else {
                --k;
            }
        }
    }
    return count;
}

-----
function threeSumSmaller(nums, target) 
    // Your code here
}

************************************
Question ID: 260
function singleNumber(nums) {
    let xor_all = 0;
    for (const num of nums) {
        xor_all ^= num;
    }

    const bit = xor_all & -xor_all;
    let n1 = 0;
    let n2 = 0;
    for (const num of nums) {
        if (num & bit) {
            n1 ^= num;
        } else {
            n2 ^= num;
        }
    }

    return [n1, n2];
}

-----
function singleNumber(nums) 
    // Your code here
}

************************************
Question ID: 261
function isTree(n, edges) {
    const neighbors = Array.from({length: n}, () => []);
    for (const edge of edges) {
        neighbors[edge[0]].push(edge[1]);
        neighbors[edge[1]].push(edge[0]);
    }
    const visited = Array(n).fill(false);
    if(hasCycle(neighbors, visited, -1, 0)) return false;
    for (const visit of visited)
        if (!visit) return false;
    return true;
}

function hasCycle(neighbors, visited, parent, node) {
    visited[node] = true;
    for (const neighbour of neighbors[node])
        if ((neighbour !== parent && visited[neighbour]) || (!visited[neighbour] && hasCycle(neighbors, visited, node, neighbour))) return true;
    return false;
}

-----
function isTree(n, edges) 
    // Your code here
}

************************************
Question ID: 263
function isUgly(n) {
    if (n <= 0) return false;
    while (n % 2 === 0) n /= 2;
    while (n % 3 === 0) n /= 3;
    while (n % 5 === 0) n /= 5;
    return n === 1;
}

-----
function isUgly(n) 
    // Your code here
}

************************************
Question ID: 264
function nthUglyNumber(n) {
    let uglyNumbers = new Array(n);
    uglyNumbers[0] = 1;
    let i2 = 0, i3 = 0, i5 = 0;

    for (let i = 1; i < n; i++) {
        uglyNumbers[i] = Math.min(Math.min(uglyNumbers[i2] * 2, uglyNumbers[i3] * 3), uglyNumbers[i5] * 5);
        if (uglyNumbers[i] === uglyNumbers[i2] * 2) i2++;
        if (uglyNumbers[i] === uglyNumbers[i3] * 3) i3++;
        if (uglyNumbers[i] === uglyNumbers[i5] * 5) i5++;
    }

    return uglyNumbers[n - 1];
}


-----
function nthUglyNumber(n) 
    // Your code here
}


************************************
Question ID: 265
function minCost(costs) {
    if (!costs || costs.length === 0) return 0;

    const n = costs.length;
    const k = costs[0].length;

    for (let i = 1; i < n; i++) {
        for (let j = 0; j < k; j++) {
            let minCost = Number.MAX_VALUE;
            for (let l = 0; l < k; l++) {
                if (l === j) continue;
                minCost = Math.min(minCost, costs[i - 1][l]);
            }
            costs[i][j] += minCost;
        }
    }
    return Math.min(...costs[n - 1]);
}


-----
function minCost(costs) 
    // Your code here
}


************************************
Question ID: 266
function canPermutePalindrome(s) {
    const count = {}
    for (const c of s) {
        if (c in count) {
            count[c]++;
        } else {
            count[c] = 1;
        }
    }
    let odd_count = 0;
    for (const value of Object.values(count)) {
        if (value % 2) {
            odd_count++;
        }
    }
    return odd_count <= 1;
}


-----
function canPermutePalindrome(s) 
    // Your code here
}


************************************
Question ID: 267
function generatePalindromes(s) {
    let result = [];
    let charCount = new Map();
    for (const c of s) {
        charCount.set(c, (charCount.get(c) || 0) + 1);
    }

    let midChar = "";
    let halfChars = [];
    let numOdds = 0;
    charCount.forEach((count, char) => {
        if (count % 2 === 1) {
            numOdds++;
            midChar = char;
        }
        for (let i = 0; i < Math.floor(count / 2); i++) {
            halfChars.push(char);
        }

        if (numOdds > 1) {
            return [];
        }
    });

    function btPerm(idx, current) {
        if (idx === halfChars.length) {
            const firstHalf = current.join('');
            result.push(firstHalf + midChar + firstHalf.split('').reverse().join(''));
            return;
        }

        for (let i = 0; i < halfChars.length; i++) {
            if (i > 0 && halfChars[i] === halfChars[i - 1]) {
                continue;
            }
            const char = halfChars.splice(i, 1)[0];
            current.push(char);
            btPerm(idx + 1, current);
            current.pop();
            halfChars.splice(i, 0, char);
        }
    }

    halfChars.sort();
    btPerm(0, []);

    return result;
}

-----
function generatePalindromes(s) 
    // Your code here
}

************************************
Question ID: 268
function missingNumber(nums) {
    const n = nums.length;
    const expectedSum = (n * (n + 1)) / 2;
    const actualSum = nums.reduce((acc, num) => acc + num, 0);
    return expectedSum - actualSum;
}

-----
function missingNumber(nums) 
    // Your code here
}

************************************
Question ID: 269
function alienOrder(words) {
    const graph = new Map();
    const inDegree = new Map();
    
    for (const word of words)
        for (const c of word)
            inDegree.set(c, 0);
    
    for (let i = 0; i < words.length - 1; i++) {
        const word1 = words[i], word2 = words[i + 1];
        
        let found = false;
        for (let j = 0; j < Math.min(word1.length, word2.length); j++) {
            const c1 = word1[j], c2 = word2[j];
            if (c1 !== c2) {
                if (!graph.has(c1)) graph.set(c1, new Set());
                if (!graph.get(c1).has(c2)) {
                    graph.get(c1).add(c2);
                    inDegree.set(c2, inDegree.get(c2) + 1);
                }
                found = true;
                break;
            }
        }
        
        if (!found && word1.length > word2.length)
            return "";
    }

    const q = [];
    for (const [c, deg] of inDegree.entries())
        if (deg === 0)
            q.push(c);
    
    let result = "";
    while (q.length) {
        const c = q.shift();
        result += c;
        
        if (graph.has(c)) {
            for (const neigh of graph.get(c)) {
                inDegree.set(neigh, inDegree.get(neigh) - 1);
                if (inDegree.get(neigh) === 0)
                    q.push(neigh);
            }
        }
    }
    
    if (result.length < inDegree.size)
        return "";
    
    return result;
}

-----
function alienOrder(words) 
    // Your code here
}

************************************
Question ID: 271
function encode(strs) {
    let encodedString = "";
    for (const s of strs) {
        encodedString += s.length + "#" + s;
    }
    return encodedString;
}

function decode(s) {
    let strs = [];
    let i = 0;
    while (i < s.length) {
        const delimiterPos = s.indexOf('#', i);
        const length = parseInt(s.slice(i, delimiterPos));
        strs.push(s.slice(delimiterPos + 1, delimiterPos + 1 + length));
        i = delimiterPos + 1 + length;
    }
    return strs;
}


-----
function encode(strs) 
    // Your code here
}


************************************
Question ID: 272
class TreeNode {
    constructor(val, left=null, right=null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

function closestKValues(root, target, k) {
    const values = [];
    const maxHeap = [];

    function inorderTraversal(node) {
        if (!node) return;
        inorderTraversal(node.left);
        maxHeap.push({diff: Math.abs(node.val - target), val: node.val});
        maxHeap.sort((a, b) => b.diff - a.diff);
        if (maxHeap.length > k) maxHeap.pop();
        inorderTraversal(node.right);
    }

    inorderTraversal(root);
    for (let item of maxHeap) {
        values.push(item.val);
    }
    return values;
}

-----
class TreeNode 
    // Your code here
}

************************************
Question ID: 274
function hIndex(citations) {
    citations.sort((a, b) => b - a);
    let h = 0;
    for (let i = 0; i < citations.length; i++) {
        if (citations[i] >= i + 1) {
            h = i + 1;
        } else {
            break;
        }
    }
    return h;
}

-----
function hIndex(citations) 
    // Your code here
}

************************************
Question ID: 275
function hIndex(citations) {
    const n = citations.length;
    let left = 0, right = n - 1;

    while (left <= right) {
        const mid = left + Math.floor((right - left) / 2);
        if (citations[mid] === n - mid) {
            return n - mid;
        } else if (citations[mid] < n - mid) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return n - left;
}

-----
function hIndex(citations) 
    // Your code here
}

************************************
Question ID: 276
function numWays(n, k) {
    if (n === 0) return 0;
    if (n === 1) return k;

    let same = k;
    let different = k * (k - 1);
    for (let i = 2; i < n; ++i) {
        const temp = different;
        different = (same + different) * (k - 1);
        same = temp;
    }
    return same + different;
}


-----
function numWays(n, k) 
    // Your code here
}


************************************
Question ID: 277
function knows(a, b) {
    // Implementation not shown
}

function findCelebrity(n) {
    let candidate = 0;
    for (let i = 1; i < n; i++) {
        if (knows(candidate, i)) {
            candidate = i;
        }
    }

    for (let i = 0; i < n; i++) {
        if (i !== candidate && (knows(candidate, i) || !knows(i, candidate))) {
            return -1;
        }
    }
    return candidate;
}

-----
function knows(a, b) 
    // Your code here
}

************************************
Question ID: 278
function firstBadVersion(n) {
    let left = 1;
    let right = n;
    while (left < right) {
        let mid = Math.floor(left + (right - left) / 2);
        if (isBadVersion(mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}


-----
function firstBadVersion(n) 
    // Your code here
}


************************************
Question ID: 279
function numSquares(n) {
    const dp = new Array(n + 1).fill(Infinity);
    dp[0] = 0;

    for (let i = 1; i <= n; i++) {
        for (let j = 1; j * j <= i; j++) {
            dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
        }
    }

    return dp[n];
}

-----
function numSquares(n) 
    // Your code here
}

************************************
Question ID: 280
function wiggleSort(nums) {
    for (let i = 1; i < nums.length; i++) {
        if (i % 2 === 0 && nums[i] > nums[i-1] || i % 2 === 1 && nums[i] < nums[i-1]) {
            [nums[i], nums[i-1]] = [nums[i-1], nums[i]];
        }
    }
}

-----
function wiggleSort(nums) 
    // Your code here
}

************************************
Question ID: 282
var addOperators = function(num, target) {
    const res = [];
    const helper = (num, target, pos, currVal, prevVal, currExpr) => {
        if (pos === num.length) {
            if (currVal === target) {
                res.push(currExpr);
            }
            return;
        }

        for (let i = pos; i < num.length; ++i) {
            if (i !== pos && num[pos] === '0') break;

            const val = parseInt(num.substring(pos, i + 1));
            if (pos === 0) {
                helper(num, target, i + 1, val, val, currExpr + num.substring(pos, i + 1));
            } else {
                helper(num, target, i + 1, currVal + val, val, currExpr + "+" + num.substring(pos, i + 1));
                helper(num, target, i + 1, currVal - val, -val, currExpr + "-" + num.substring(pos, i + 1));
                helper(num, target, i + 1, currVal - prevVal + prevVal * val, prevVal * val, currExpr + "*" + num.substring(pos, i + 1));
            }
        }
    }

    helper(num, target, 0, 0, 0, "");
    return res;
}


-----
var addOperators = function(num, target) 
    // Your code here
}


************************************
Question ID: 283
function moveZeroes(nums) {
    let index = 0;
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] !== 0) {
            nums[index++] = nums[i];
        }
    }
    for (let i = index; i < nums.length; i++) {
        nums[i] = 0;
    }
}

-----
function moveZeroes(nums) 
    // Your code here
}

************************************
Question ID: 286
function wallsAndGates(rooms) {
    const m = rooms.length;
    const n = rooms[0].length;
    const q = [];
    const INF = 2147483647;
    
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (rooms[i][j] === 0) {
                q.push([i, j]);
            }
        }
    }

    const directions = [
        [0, 1],
        [0, -1],
        [1, 0],
        [-1, 0]
    ];

    while (q.length) {
        const [i, j] = q.shift();

        directions.forEach(([di, dj]) => {
            const ni = i + di;
            const nj = j + dj;

            if (ni >= 0 && ni < m && nj >= 0 && nj < n && rooms[ni][nj] === INF) {
                rooms[ni][nj] = rooms[i][j] + 1;
                q.push([ni, nj]);
            }
        });
    }
}

-----
function wallsAndGates(rooms) 
    // Your code here
}

************************************
Question ID: 287
function findDuplicate(nums) {
    let slow = nums[0];
    let fast = nums[0];

    do {
        slow = nums[slow];
        fast = nums[nums[fast]];
    } while (slow !== fast);

    slow = nums[0];

    while (slow !== fast) {
        slow = nums[slow];
        fast = nums[fast];
    }

    return slow;
}


-----
function findDuplicate(nums) 
    // Your code here
}


************************************
Question ID: 289
function gameOfLife(board) {
    let m = board.length;
    let n = board[0].length;
    let result = new Array(m).fill(0).map(() => new Array(n).fill(0));
    let dirs = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            let liveNeighbors = 0;

            for (let dir of dirs) {
                let newRow = i + dir[0];
                let newCol = j + dir[1];

                if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && board[newRow][newCol] === 1) {
                    liveNeighbors++;
                }
            }

            if (board[i][j] === 1 && (liveNeighbors === 2 || liveNeighbors === 3)) {
                result[i][j] = 1;
            } else if (board[i][j] === 0 && liveNeighbors === 3) {
                result[i][j] = 1;
            }
        }
    }

    return result;
}

-----
function gameOfLife(board) 
    // Your code here
}

************************************
Question ID: 290
function wordPattern(pattern, s) {
    const words = s.split(' ');
    if (pattern.length !== words.length) return false;

    const charMap = new Map();
    const wordMap = new Map();

    for (let i = 0; i < pattern.length; i++) {
        const c = pattern[i];
        const word = words[i];
        if (!charMap.has(c) && !wordMap.has(word)) {
            charMap.set(c, word);
            wordMap.set(word, c);
        } else {
            if (charMap.get(c) !== word || wordMap.get(word) !== c) return false;
        }
    }

    return true;
}


-----
function wordPattern(pattern, s) 
    // Your code here
}


************************************
Question ID: 291
var wordPatternMatch = function(pattern, s) {
    const patternMap = new Map();
    const words = new Set();
    return backtrack(pattern, 0, s, 0, patternMap, words);
    
    function backtrack(pattern, pIndex, s, sIndex, patternMap, words) {
        if (pIndex == pattern.length && sIndex == s.length) return true;
        if (pIndex == pattern.length || sIndex == s.length) return false;

        let p = pattern[pIndex];
        if (patternMap.has(p)) {
            let word = patternMap.get(p);
            if (s.slice(sIndex, sIndex + word.length) !== word) return false;
            return backtrack(pattern, pIndex + 1, s, sIndex + word.length, patternMap, words);
        } else {
            for (let length = 1; length <= s.length - sIndex; length++) {
                let word = s.substr(sIndex, length);
                if (words.has(word)) continue;
                patternMap.set(p, word);
                words.add(word);
                if (backtrack(pattern, pIndex + 1, s, sIndex + length, patternMap, words)) return true;
                patternMap.delete(p);
                words.delete(word);
            }
        }
        return false;
    }
};

-----
var wordPatternMatch = function(pattern, s) 
    // Your code here
};

************************************
Question ID: 292
function canWinNim(n) {
    return n % 4 !== 0;
}

-----
function canWinNim(n) 
    // Your code here
}

************************************
Question ID: 293
function generatePossibleNextMoves(currentState) {
    const result = [];
    for (let i = 1; i < currentState.length; i++) {
        if (currentState[i] === '+' && currentState[i - 1] === '+') {
            result.push(currentState.slice(0, i - 1) + '--' + currentState.slice(i + 1));
        }
    }
    return result;
}

-----
function generatePossibleNextMoves(currentState) 
    // Your code here
}

************************************
Question ID: 294
function canWin(currentState) {
    for (let i = 0; i < currentState.length - 1; ++i) {
        if (currentState[i] === '+' && currentState[i + 1] === '+') {
            let temp = currentState.slice(0, i) + "--" + currentState.slice(i + 2);
            if (!canWin(temp)) return true;
        }
    }
    return false;
}

-----
function canWin(currentState) 
    // Your code here
}

************************************
Question ID: 295
class MedianFinder {
    constructor() {
        this.left = new MaxPriorityQueue();
        this.right = new MinPriorityQueue();
    }
    
    addNum(num) {
        if (this.left.isEmpty() || num <= this.left.peek().element) {
            this.left.enqueue(num);
        } else {
            this.right.enqueue(num);
        }
        
        if (this.left.size() < this.right.size()) {
            this.left.enqueue(this.right.dequeue().element);
        } else if (this.left.size() > this.right.size() + 1) {
            this.right.enqueue(this.left.dequeue().element);
        }
    }
    
    findMedian() {
        if (this.left.size() === this.right.size()) {
            return (this.left.peek().element + this.right.peek().element) / 2.0;
        } else {
            return this.left.peek().element;
        }
    }
}


-----
class MedianFinder 
    // Your code here
}


************************************
Question ID: 296
var minTotalDistance = function(grid) {
    let m = grid.length, n = grid[0].length;
    let rows = [], cols = [];
    for (let i = 0; i < m; ++i) {
        for (let j = 0; j < n; ++j) {
            if (grid[i][j] === 1) {
                rows.push(i);
                cols.push(j);
            }
        }
    }
    cols.sort((a, b) => a - b);
    let row_median = rows[Math.floor(rows.length / 2)], col_median = cols[Math.floor(cols.length / 2)];
    let distance = rows.reduce((acc, i) => acc + Math.abs(i - row_median), 0) + cols.reduce((acc, j) => acc + Math.abs(j - col_median), 0);
    return distance;
};

-----
var minTotalDistance = function(grid) 
    // Your code here
};

************************************
Question ID: 299
function getHint(secret, guess) {
    let bulls = 0, cows = 0;
    let secretCount = Array(10).fill(0);
    let guessCount = Array(10).fill(0);

    for (let i = 0; i < secret.length; i++) {
        if (secret[i] === guess[i]) {
            bulls++;
        } else {
            secretCount[parseInt(secret[i])]++;
            guessCount[parseInt(guess[i])]++;
        }
    }

    for (let i = 0; i < 10; i++) {
        cows += Math.min(secretCount[i], guessCount[i]);
    }

    return `${bulls}A${cows}B`;
}


-----
function getHint(secret, guess) 
    // Your code here
}


************************************
Question ID: 300
function lengthOfLIS(nums) {
    const dp = new Array(nums.length).fill(1);
    let max_length = 1;
    for (let i = 1; i < nums.length; i++) {
        for (let j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
        max_length = Math.max(max_length, dp[i]);
    }
    return max_length;
}

-----
function lengthOfLIS(nums) 
    // Your code here
}

************************************
Question ID: 301
class Solution {
    removeInvalidParentheses(s) {
        let visited = new Set();
        let queue = [s];
        let result = [];
        let found = false;

        while (queue.length > 0) {
            let cur = queue.shift();

            if (this.isValid(cur)) {
                found = true;
                result.push(cur);
            }

            if (found) continue;

            for (let i = 0; i < cur.length; i++) {
                if (cur[i] === '(' || cur[i] === ')') {
                    let next = cur.slice(0, i) + cur.slice(i + 1);
                    if (!visited.has(next)) {
                        visited.add(next);
                        queue.push(next);
                    }
                }
            }
        }
        return result;
    }

    isValid(s) {
        let count = 0;
        for (let c of s) {
            if (c === '(') count++;
            if (c === ')') count--;
            if (count < 0) return false;
        }
        return count === 0;
    }
}


-----
class Solution 
    // Your code here
}


************************************
Question ID: 302
function minArea(image, x, y) {
    let top = x, bottom = x, left = y, right = y;
    for (let i = 0; i < image.length; ++i) {
        for (let j = 0; j < image[i].length; ++j) {
            if (image[i][j] === '1') {
                top = Math.min(top, i);
                bottom = Math.max(bottom, i);
                left = Math.min(left, j);
                right = Math.max(right, j);
            }
        }
    }
    return (bottom - top + 1) * (right - left + 1);
}

-----
function minArea(image, x, y) 
    // Your code here
}

************************************
Question ID: 305
function numIslands2(m, n, positions) {
    const roots = new Array(m * n).fill(-1);
    const dirs = [[0, 1], [1, 0], [-1, 0], [0, -1]];
    let islandCount = 0;
    const result = [];

    const index = (x, y) => x * n + y;
    
    function find(x) {
        if (roots[x] !== x) roots[x] = find(roots[x]);
        return roots[x];
    }

    for (const [i, j] of positions) {
        const idx = index(i, j);
        if (roots[idx] !== -1) {
            result.push(islandCount);
            continue;
        }
        islandCount++;
        roots[idx] = idx;
        for (const [dx, dy] of dirs) {
            const ni = i + dx, nj = j + dy;
            const neighbor = index(ni, nj);
            if (ni >= 0 && ni < m && nj >= 0 && nj < n && roots[neighbor] !== -1) {
                const root_neighbor = find(neighbor);
                if (idx !== root_neighbor) {
                    roots[root_neighbor] = idx;
                    islandCount--;
                }
            }
        }
        result.push(islandCount);
    }
    return result;
}


-----
function numIslands2(m, n, positions) 
    // Your code here
}


************************************
Question ID: 306
function isAdditiveNumber(num) {
    for (let i = 1; i <= num.length / 2; i++) {
        for (let j = 1; j <= (num.length - i) / 2; j++) {
            if (check(num.slice(0, i), num.slice(i, i + j), num.slice(i + j))) {
                return true;
            }
        }
    }
    return false;
}

function check(num1, num2, remaining) {
    if ((num1.length > 1 && num1[0] === '0') || (num2.length > 1 && num2[0] === '0')) {
        return false;
    }
    let sum = add(num1, num2);
    if (remaining === sum) {
        return true;
    }
    if (!remaining.startsWith(sum)) {
        return false;
    }
    return check(num2, sum, remaining.slice(sum.length));
}

function add(num1, num2) {
    let carry = 0;
    let result = '';
    for (let i = num1.length - 1, j = num2.length - 1;
         i >= 0 || j >= 0 || carry > 0; i--, j--) {
        let n1 = i >= 0 ? Number(num1[i]) : 0;
        let n2 = j >= 0 ? Number(num2[j]) : 0;
        let sum = n1 + n2 + carry;
        carry = Math.floor(sum / 10);
        result = (sum % 10).toString() + result;
    }
    return result;
}

-----
function isAdditiveNumber(num) 
    // Your code here
}

************************************
Question ID: 309
function maxProfit(prices) {
    let profit = 0;
    for (let i = 1; i < prices.length; i++) {
        profit += Math.max(prices[i] - prices[i - 1], 0);
    }
    return profit;
}

-----
function maxProfit(prices) 
    // Your code here
}

************************************
Question ID: 310
function findMinHeightTrees(n, edges) {
  if (n === 1) return [0];

  const adjList = Array.from({ length: n }, () => []);
  const degrees = new Array(n).fill(0);

  for (const [a, b] of edges) {
    adjList[a].push(b);
    adjList[b].push(a);
    degrees[a]++;
    degrees[b]++;
  }

  const queue = [];
  for (let i = 0; i < n; i++) {
    if (degrees[i] === 1) queue.push(i);
  }

  while (n > 2) {
    const leavesSize = queue.length;
    n -= leavesSize;
    for (let i = 0; i < leavesSize; i++) {
      const leaf = queue.shift();
      for (const neighbor of adjList[leaf]) {
        if (--degrees[neighbor] === 1) queue.push(neighbor);
      }
    }
  }

  return queue;
}

-----
function findMinHeightTrees(n, edges) 
    // Your code here
}

************************************
Question ID: 311
function multiply(mat1, mat2) {
    const m = mat1.length;
    const k = mat1[0].length;
    const n = mat2[0].length;
    const result = Array.from({ length: m }, () => Array.from({ length: n }, () => 0));
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < k; j++) {
            if (mat1[i][j] !== 0) {
                for (let l = 0; l < n; l++) {
                    result[i][l] += mat1[i][j] * mat2[j][l];
                }
            }
        }
    }
    return result;
}

-----
function multiply(mat1, mat2) 
    // Your code here
}

************************************
Question ID: 312
function maxCoins(nums) {
    nums.unshift(1);
    nums.push(1);
    const n = nums.length;

    const dp = [];
    for (let i = 0; i < n; i++) {
        dp.push(new Array(n).fill(0));
    }

    for (let len = 1; len <= n - 2; len++) {
        for (let left = 1; left <= n - len - 1; left++) {
            const right = left + len - 1;
            for (let i = left; i <= right; i++) {
                dp[left][right] = Math.max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);
            }
        }
    }

    return dp[1][n - 2];
}

-----
function maxCoins(nums) 
    // Your code here
}

************************************
Question ID: 313
function nthSuperUglyNumber(n, primes) {
    let ugly = new Array(n);
    ugly[0] = 1;
    let indices = new Array(primes.length).fill(0);

    for (let i = 1; i < n; i++) {
        let minVal = Number.MAX_SAFE_INTEGER;

        for (let j = 0; j < primes.length; j++)
            minVal = Math.min(minVal, ugly[indices[j]] * primes[j]);

        ugly[i] = minVal;

        for (let j = 0; j < primes.length; j++)
            if (ugly[i] == ugly[indices[j]] * primes[j])
                indices[j]++;
    }

    return ugly[n - 1];
}

-----
function nthSuperUglyNumber(n, primes) 
    // Your code here
}

************************************
Question ID: 314
class TreeNode {
    constructor(val, left, right) {
        this.val = (val===undefined ? 0 : val)
        this.left = (left===undefined ? null : left)
        this.right = (right===undefined ? null : right)
    }
}

var verticalOrder = function(root) {
    if (!root) return [];
    
    const columnTable = new Map();
    const q = [[root, 0]];

    while (q.length) {
        const [curNode, column] = q.shift();

        if (curNode) {
            if (!columnTable.has(column)) columnTable.set(column, []);
            columnTable.get(column).push(curNode.val);
            q.push([curNode.left, column - 1]);
            q.push([curNode.right, column + 1]);
        }
    }

    return Array.from(columnTable.entries()).sort((a, b) => a[0] - b[0]).map(entry => entry[1]);
};

-----
class TreeNode 
    // Your code here
};

************************************
Question ID: 315
function countSmaller(nums) {
    function mergeSort(indices, start, end) {
        if (start >= end) {
            return;
        }

        let mid = start + ((end - start) >> 1);
        mergeSort(indices, start, mid);
        mergeSort(indices, mid + 1, end);

        let i = start, j = mid + 1, k = 0, cnt = 0;
        let temp = [];
        while (i <= mid || j <= end) {
            if (j > end || (i <= mid && nums[indices[i]] <= nums[indices[j]])) {
                cnt += j - mid - 1;
                counts[indices[i]] = cnt;
                temp[k++] = indices[i++];
            } else {
                temp[k++] = indices[j++];
            }
        }

        for (let i = 0; i < k; i++) {
            indices[start + i] = temp[i];
        }
    }
    
    let counts = Array(nums.length).fill(0);
    let indices = Array.from({length: nums.length}, (_, i) => i);
    mergeSort(indices, 0, nums.length - 1);
    return counts;
}

-----
function countSmaller(nums) 
    // Your code here
}

************************************
Question ID: 316
function removeDuplicateLetters(s) {
    let count = new Array(256).fill(0);
    let visited = new Array(256).fill(false);
    let st = [];
    
    for (let ch of s) {
        count[ch.charCodeAt(0)]++;
    }
    
    for (let ch of s) {
        count[ch.charCodeAt(0)]--;
        if (visited[ch.charCodeAt(0)]) continue;
        while (st.length > 0 && ch < st[st.length - 1] && count[st[st.length - 1].charCodeAt(0)] > 0) {
            visited[st.pop().charCodeAt(0)] = false;
        }
        st.push(ch);
        visited[ch.charCodeAt(0)] = true;
    }

    return st.join("");
}

-----
function removeDuplicateLetters(s) 
    // Your code here
}

************************************
Question ID: 317
function shortestDistance(grid) {
    let m = grid.length;
    let n = grid[0].length;
    
    let total_count = Array.from({length: m}, () => Array(n).fill(0));
    let dist_sum = Array.from({length: m}, () => Array(n).fill(0));
    let house_count = 0;
    
    let dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];
    
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (grid[i][j] === 1) {
                house_count++;
                let q = [{x: i, y: j}];
                let visited = Array.from({length: m}, () => Array(n).fill(false));
                let level = 1;
                while (q.length) {
                    let sz = q.length;
                    for (let q_i = 0; q_i < sz; q_i++) {
                        let { x, y } = q.shift();
                        dirs.forEach(([dx, dy]) => {
                            let x_new = x + dx;
                            let y_new = y + dy;
                            if (x_new >= 0 && x_new < m && y_new >= 0 && y_new < n && !visited[x_new][y_new] && grid[x_new][y_new] === 0) {
                                visited[x_new][y_new] = true;
                                q.push({ x: x_new, y: y_new });
                                dist_sum[x_new][y_new] += level;
                                total_count[x_new][y_new]++;
                            }
                        });
                    }
                    level++;
                }
            }
        }
    }
                                         
    let min_dist = Infinity;
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (total_count[i][j] === house_count) {
                min_dist = Math.min(min_dist, dist_sum[i][j]);
            }
        }
    }
    
    return min_dist === Infinity ? -1 : min_dist;
}


-----
function shortestDistance(grid) 
    // Your code here
}


************************************
Question ID: 318
function maxProduct(words) {
    const n = words.length;
    const mask = new Array(n).fill(0);
    for (let i = 0; i < n; i++) {
        for (const c of words[i]) {
            mask[i] |= (1 << (c.charCodeAt(0) - 'a'.charCodeAt(0)));
        }
    }

    let maxProduct = 0;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            if ((mask[i] & mask[j]) === 0) {
                maxProduct = Math.max(maxProduct, words[i].length * words[j].length);
            }
        }
    }

    return maxProduct;
}


-----
function maxProduct(words) 
    // Your code here
}


************************************
Question ID: 319
function bulbSwitch(n) {
    return Math.floor(Math.sqrt(n));
}

-----
function bulbSwitch(n) 
    // Your code here
}

************************************
Question ID: 320
function generateAbbreviations(word) {
    if (word === '') {
        return ['']
    }
    const res = []
    for (let i = 0; i < word.length + 1; i++) {
        for (const item of generateAbbreviations(word.slice(i + 1))) {
            if (i === 0 || !item || isNaN(item[0])) {
                res.push(word.slice(0, i + 1) + item)
            }
            if (item && !isNaN(item[0])) {
                res.push(word.slice(0, i) + '1' + item)
            }
        }
    }
    return res
}

-----
function generateAbbreviations(word) 
    // Your code here
}

************************************
Question ID: 321

```python
def maxNumber(nums1, nums2, k):
    def maxArray(nums, k):
        ans = []
        for i, num in enumerate(nums):
            while len(ans) + len(nums) - i > k and ans and ans[-1] < num:
                ans.pop()
            if len(ans) < k:
                ans.append(num)
        return ans

    def merge(nums1, nums2):
        return [max(nums1, nums2).pop(0) for _ in nums1 + nums2]

    return max(merge(maxArray(nums1, i), maxArray(nums2, k - i))
               for i in range(k + 1)
               if i <= len(nums1) and k - i <= len(nums2))
```


-----

```python
def maxNumber(nums1, nums2, k):
    def maxArray(nums, k):
        ans = []
        for i, num in enumerate(nums):
            while len(ans) + len(nums) - i > k and ans and ans[-1] < num:
                ans.pop()
            if len(ans) < k:
                ans.append(num)
        return ans

    def merge(nums1, nums2):
        return [max(nums1, nums2).pop(0) for _ in nums1 + nums2]

    return max(merge(maxArray(nums1, i), maxArray(nums2, k - i))
               for i in range(k + 1)
               if i <= len(nums1) and k - i <= len(nums2))
```

    // Your code here


************************************
Question ID: 322
function coinChange(coins, amount) {
    const dp = new Array(amount + 1).fill(amount + 1);
    dp[0] = 0;

    for (const coin of coins) {
        for (let i = coin; i <= amount; i++) {
            dp[i] = Math.min(dp[i], dp[i - coin] + 1);
        }
    }

    return dp[amount] <= amount ? dp[amount] : -1;
}

-----
function coinChange(coins, amount) 
    // Your code here
}

************************************
Question ID: 323
function countComponents(n, edges) {
    const adjList = new Array(n).fill(0).map(() => []);
    for (const edge of edges) {
        adjList[edge[0]].push(edge[1]);
        adjList[edge[1]].push(edge[0]);
    }

    const visited = new Array(n).fill(false);
    let connectedComponents = 0;

    function dfs(node) {
        visited[node] = true;
        for (const neighbor of adjList[node]) {
            if (!visited[neighbor]) {
                dfs(neighbor);
            }
        }
    }

    for (let i = 0; i < n; i++) {
        if (!visited[i]) {
            dfs(i);
            connectedComponents++;
        }
    }
    return connectedComponents;
}


-----
function countComponents(n, edges) 
    // Your code here
}


************************************
Question ID: 324
function wiggleSort(nums) {
    nums.sort((a, b) => a - b);
    for (let i = 1; i < nums.length - 1; i += 2) {
        [nums[i], nums[i + 1]] = [nums[i + 1], nums[i]];
    }
}


-----
function wiggleSort(nums) 
    // Your code here
}


************************************
Question ID: 325
function maxSubArrayLen(nums, k) {
    let sumIndex = new Map();
    let maxLength = 0, sum = 0;
    for (let i = 0; i < nums.length; i++) {
        sum += nums[i];
        if (sum === k) maxLength = i + 1;
        if (sumIndex.has(sum - k)) maxLength = Math.max(maxLength, i - sumIndex.get(sum - k));
        if (!sumIndex.has(sum)) sumIndex.set(sum, i);
    }
    return maxLength;
}


-----
function maxSubArrayLen(nums, k) 
    // Your code here
}


************************************
Question ID: 326
function isPowerOfThree(n) {
    if (n < 1) {
        return false;
    }
    
    while (n % 3 === 0) {
        n /= 3;
    }
    
    return n === 1;
}

-----
function isPowerOfThree(n) 
    // Your code here
}

************************************
Question ID: 327
function countRangeSum(nums, lower, upper) {
    let sums = new Array(nums.length + 1).fill(0);
    for (let i = 0; i < nums.length; ++i)
        sums[i + 1] = sums[i] + nums[i];

    function mergeSort(start, end) {
        if (start === end)
            return 0;
        let mid = start + Math.floor((end - start) / 2);
        let count = mergeSort(start, mid) + mergeSort(mid + 1, end);

        let j = mid + 1, k = mid + 1;
        for (let i = start; i <= mid; ++i) {
            while (j <= end && sums[j] - sums[i] < lower) ++j;
            while (k <= end && sums[k] - sums[i] <= upper) ++k;
            count += k - j;
        }

        let sortedPart = sums.slice(start, end + 1).sort((a, b) => a - b);
        for (let i = start; i <= end; ++i) {
            sums[i] = sortedPart[i - start];
        }

        return count;
    };

    return mergeSort(0, nums.length);
}


-----
function countRangeSum(nums, lower, upper) 
    // Your code here
}


************************************
Question ID: 329
const dx = [0, 0, 1, -1];
const dy = [1, -1, 0, 0];

function dfs(matrix, memo, i, j) {
    if (memo[i][j] !== 0) return memo[i][j];
    
    let max_len = 0;
    for (let k = 0; k < 4; ++k) {
        const ni = i + dx[k], nj = j + dy[k];
        if (ni >= 0 && ni < matrix.length && nj >= 0 && nj < matrix[0].length && matrix[ni][nj] > matrix[i][j]) {
            max_len = Math.max(max_len, dfs(matrix, memo, ni, nj));
        }
    }
    
    memo[i][j] = max_len + 1;
    return memo[i][j];
}

function longestIncreasingPath(matrix) {
    const m = matrix.length, n = matrix[0].length;
    
    const memo = Array.from({length: m}, () => Array.from({length: n}, () => 0));
    
    let ans = 0;
    for (let i = 0; i < m; ++i) {
        for (let j = 0; j < n; ++j) {
            ans = Math.max(ans, dfs(matrix, memo, i, j));
        }
    }
    
    return ans;
}


-----
const dx = [0, 0, 1, -1];
const dy = [1, -1, 0, 0];

function dfs(matrix, memo, i, j) 
    // Your code here
}


************************************
Question ID: 330
function minPatches(nums, n) {
    let maxSum = 0;
    let patches = 0;
    let i = 0;

    while (maxSum < n) {
        if (i < nums.length && nums[i] <= maxSum + 1) {
            maxSum += nums[i];
            i++;
        } else {
            maxSum += maxSum + 1;
            patches++;
        }
    }
    return patches;
}


-----
function minPatches(nums, n) 
    // Your code here
}


************************************
Question ID: 331
function isValidSerialization(preorder) {
    const nodes = preorder.split(',');
    let node_count = 1;

    for (let node of nodes) {
        node_count--;

        if (node_count < 0) return false;
        if (node !== '#') node_count += 2;
    }

    return node_count === 0;
}

-----
function isValidSerialization(preorder) 
    // Your code here
}

************************************
Question ID: 332
function findItinerary(tickets) {
    const flights = {};
    const itinerary = [];

    for (const ticket of tickets) {
        if (!flights[ticket[0]]) {
            flights[ticket[0]] = [];
        }
        flights[ticket[0]].push(ticket[1]);
        flights[ticket[0]].sort((a, b) => b.localeCompare(a));
    }

    function dfs(airport) {
        while (flights[airport] && flights[airport].length > 0) {
            dfs(flights[airport].pop());
        }
        itinerary.push(airport);
    }

    dfs("JFK");
    
    return itinerary.reverse();
}

-----
function findItinerary(tickets) 
    // Your code here
}

************************************
Question ID: 334
function findTriplets(nums) {
    let first = Number.MAX_VALUE;
    let second = Number.MAX_VALUE;

    for (let num of nums) {
        if (num <= first) {
            first = num;
        } else if (num <= second) {
            second = num;
        } else {
            return true;
        }
    }
    return false;
}

-----
function findTriplets(nums) 
    // Your code here
}

************************************
Question ID: 335
function isPathCrossing(distance) {
    let visited = new Set(["0,0"]);
    let x = 0, y = 0;
    const dx = [0, -1, 0, 1];
    const dy = [1, 0, -1, 0];
    
    for (let i = 0; i < distance.length; i++) {
        let direction = i % 4;
        for (let j = 0; j < distance[i]; j++) {
            x += dx[direction];
            y += dy[direction];
            let point = `${x},${y}`; 
            if (visited.has(point)) {
                return true;
            }
            visited.add(point);
        }
    }
    return false;
}


-----
function isPathCrossing(distance) 
    // Your code here
}


************************************
Question ID: 336
function palindromePairs(words) {
    function isPalindrome(s) {
        return s === s.split('').reverse().join('');
    }

    const result = [];
    for (let i = 0; i < words.length; i++) {
        for (let j = 0; j < words.length; j++) {
            if (i === j) continue;
            const concat = words[i] + words[j];
            if (isPalindrome(concat)) {
                result.push([i, j]);
            }
        }
    }

    return result;
}

-----
function palindromePairs(words) 
    // Your code here
}

************************************
Question ID: 337
var rob = function(root) {
    const [withNode, withoutNode] = robHelper(root);
    return Math.max(withNode, withoutNode);
};

function robHelper(node) {
    if (!node) return [0, 0];

    const [leftWithNode, leftWithoutNode] = robHelper(node.left);
    const [rightWithNode, rightWithoutNode] = robHelper(node.right);

    const withNode = node.val + leftWithoutNode + rightWithoutNode;
    const withoutNode = Math.max(leftWithNode, leftWithoutNode) + Math.max(rightWithNode, rightWithoutNode);
    return [withNode, withoutNode];
}

-----
var rob = function(root) 
    // Your code here
}

************************************
Question ID: 338
function countBits(n) {
    const ans = new Array(n + 1).fill(0);
    for (let i = 1; i <= n; ++i) {
        ans[i] = ans[i & (i - 1)] + 1;
    }
    return ans;
}

-----
function countBits(n) 
    // Your code here
}

************************************
Question ID: 339
function depthSum(nestedList) {
    return depthSumHelper(nestedList, 1);
}

function depthSumHelper(nestedList, depth) {
    let sum = 0;
    for (let element of nestedList) {
        if (typeof element === "number") {
            sum += element * depth;
        } else {
            sum += depthSumHelper(element, depth + 1);
        }
    }
    return sum;
}


-----
function depthSum(nestedList) 
    // Your code here
}


************************************
Question ID: 340
function lengthOfLongestSubstringKDistinct(s, k) {
    const charCount = new Map();
    let left = 0;
    let maxLength = 0;

    for (let right = 0; right < s.length; ++right) {
        charCount.set(s[right], (charCount.get(s[right]) || 0) + 1);

        while (charCount.size > k) {
            charCount.set(s[left], charCount.get(s[left]) - 1);
            if (charCount.get(s[left]) === 0) {
                charCount.delete(s[left]);
            }
            left++;
        }

        maxLength = Math.max(maxLength, right - left + 1);
    }
    return maxLength;
}

-----
function lengthOfLongestSubstringKDistinct(s, k) 
    // Your code here
}

************************************
Question ID: 342
function isPowerOfFour(n) {
    if (n <= 0) return false;
    while (n % 4 === 0) {
        n = Math.floor(n / 4);
    }
    return n === 1;
}

-----
function isPowerOfFour(n) 
    // Your code here
}

************************************
Question ID: 343
function integerBreak(n) {
    if (n <= 3) return n - 1;
    let product = 1;
    while (n > 4) {
        product *= 3;
        n -= 3;
    }
    return product * n;
}

-----
function integerBreak(n) 
    // Your code here
}

************************************
Question ID: 344
function reverseString(s) {
    let left = 0, right = s.length - 1;
    while (left < right) {
        [s[left], s[right]] = [s[right], s[left]];
        left++;
        right--;
    }
}

-----
function reverseString(s) 
    // Your code here
}

************************************
Question ID: 345
function reverseVowels(s) {
    const vowels = new Set('aeiouAEIOU');
    let chars = Array.from(s);
    let i = 0, j = s.length - 1;
    while (i < j) {
        if (!vowels.has(chars[i])) {
            i++;
        } else if (!vowels.has(chars[j])) {
            j--;
        } else {
            [chars[i], chars[j]] = [chars[j], chars[i]];
            i++;
            j--;
        }
    }
    return chars.join('');
}

-----
function reverseVowels(s) 
    // Your code here
}

************************************
Question ID: 346
class MovingAverage {
    constructor(size) {
        this.queue = [];
        this.maxSize = size;
        this.sum = 0;
    }

    next(val) {
        if (this.queue.length === this.maxSize) {
            this.sum -= this.queue.shift();
        }
        this.queue.push(val);
        this.sum += val;
        return this.sum / this.queue.length;
    }
}

-----
class MovingAverage 
    // Your code here
}

************************************
Question ID: 347
function kMostFrequent(nums, k) {
  const frequency = new Map();
  for (const num of nums) {
    frequency.set(num, (frequency.get(num) || 0) + 1);
  }

  const minHeap = [];

  for (const [num, freq] of frequency) {
    minHeap.push([freq, num]);
    if (minHeap.length > k) {
      minHeap.sort((a, b) => a[0] - b[0]).shift();
    }
  }

  return minHeap.map(entry => entry[1]);
}


-----
function kMostFrequent(nums, k) 
    // Your code here
}


************************************
Question ID: 349
function intersection(nums1, nums2) {
    const set1 = new Set(nums1);
    const resultSet = new Set();

    for (const num of nums2) {
        if (set1.has(num)) {
            resultSet.add(num);
        }
    }

    return Array.from(resultSet);
}


-----
function intersection(nums1, nums2) 
    // Your code here
}


************************************
Question ID: 350
function intersect(nums1, nums2) {
    const countMap = {};
    const result = [];
    
    for (const num of nums1) {
        countMap[num] = (countMap[num] || 0) + 1;
    }
    
    for (const num of nums2) {
        if (countMap[num] > 0) {
            result.push(num);
            countMap[num]--;
        }
    }

    return result;
}


-----
function intersect(nums1, nums2) 
    // Your code here
}


************************************
Question ID: 351
var numberOfPatterns = function(m, n) {
    const jumps = Array.from({length: 10}, () => Array(10).fill(0));
    jumps[1][3] = jumps[3][1] = 2;
    jumps[1][7] = jumps[7][1] = 4;
    jumps[3][9] = jumps[9][3] = 6;
    jumps[7][9] = jumps[9][7] = 8;
    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5;

    const visited = Array(10).fill(false);

    let cnt = 0;
    for (let i = m; i <= n; ++i) {
        cnt += dfs(jumps, visited, 1, i - 1) * 4; // 1, 3, 7, 9
        cnt += dfs(jumps, visited, 2, i - 1) * 4; // 2, 4, 6, 8
        cnt += dfs(jumps, visited, 5, i - 1);     // 5
    }

    return cnt;
};

function dfs(jumps, visited, curr, remaining) {
    if (remaining < 0) return 0;
    if (remaining === 0) return 1;

    visited[curr] = true;
    let cnt = 0;
    for (let next = 1; next <= 9; ++next) {
        if (!visited[next] && (jumps[curr][next] === 0 || visited[jumps[curr][next]])) {
            cnt += dfs(jumps, visited, next, remaining - 1);
        }
    }
    visited[curr] = false;

    return cnt;
}


-----
var numberOfPatterns = function(m, n) 
    // Your code here
}


************************************
Question ID: 352
class SummaryRanges {
    constructor() {
        this.intervals = new Map();
    }

    addNum(val) {
        if (!this.intervals.size || [...this.intervals.keys()][0] > val + 1) {
            this.intervals.set(val, val);
        } else {
            let keys = [...this.intervals.keys()];
            let index = keys.findIndex(key => key > val);

            if (index > 0 && keys[index - 1] <= val && val <= this.intervals.get(keys[index - 1])) {
                return;
            } else if (index !== -1 && val + 1 === keys[index]) {
                this.intervals.set(val, this.intervals.get(keys[index]));
                this.intervals.delete(keys[index]);
            } else {
                this.intervals.set(val, val);
            }
        }
    }

    getIntervals() {
        return [...this.intervals.entries()].map(([start, end]) => [start, end]);
    }
}


-----
class SummaryRanges 
    // Your code here
}


************************************
Question ID: 353
class SnakeGame {
    constructor(width, height, food) {
        this.width = width;
        this.height = height;
        this.food = food;
        this.pos = 0;
        this.score = 0;
        this.snake = [[0, 0]];
        this.occupied = new Set(['0_0']);
        this.dx = {'U': -1, 'D': 1, 'L': 0, 'R': 0};
        this.dy = {'U': 0, 'D': 0, 'L': -1, 'R': 1};
    }

    move(direction) {
        let newX = this.snake[this.snake.length - 1][0] + this.dx[direction];
        let newY = this.snake[this.snake.length - 1][1] + this.dy[direction];

        if (newX < 0 || newX >= this.height || newY < 0 || newY >= this.width) {
            return -1;
        }

        let newHead = [newX, newY];
        let tail = this.snake.shift();

        if (this.pos < this.food.length && this.food[this.pos][0] === newX && this.food[this.pos][1] === newY) {
            this.score++;
            this.pos++;
        } else {
            this.occupied.delete(tail[0] + '_' + tail[1]);
        }

        if (this.occupied.has(newX + '_' + newY)) {
            return -1;
        }

        this.snake.push(newHead);
        this.occupied.add(newX + '_' + newY);
        return this.score;
    }
}

-----
class SnakeGame 
    // Your code here
}

************************************
Question ID: 354
function maxEnvelopes(envelopes) {
    envelopes.sort((a, b) => a[0] === b[0] ? b[1] - a[1] : a[0] - b[0]);
    const dp = [];

    for (const envelope of envelopes) {
        const idx = lowerBound(dp, envelope[1]);
        if (idx === dp.length) {
            dp.push(envelope[1]);
        } else {
            dp[idx] = envelope[1];
        }
    }

    return dp.length;

    function lowerBound(arr, target) {
        let low = 0, high = arr.length;
        while (low < high) {
            const mid = Math.floor((low + high) / 2);
            if (arr[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }
}

-----
function maxEnvelopes(envelopes) 
    // Your code here
}

************************************
Question ID: 355
class Twitter {
    constructor() {
        this.tweets = {};
        this.following = {};
        this.timeStamp = 0;
    }

    postTweet(userId, tweetId) {
        if (!this.tweets[userId]) {
            this.tweets[userId] = [];
        }
        this.tweets[userId].push({ time: this.timeStamp++, tweetId });
    }

    getNewsFeed(userId) {
        let feed = this.tweets[userId] ? [...this.tweets[userId]] : [];
        if (this.following[userId]) {
            for (const user of this.following[userId]) {
                if (this.tweets[user]) {
                    feed.push(...this.tweets[user]);
                }
            }
        }

        feed.sort((a, b) => b.time - a.time);

        return feed.slice(0, 10).map(tweet => tweet.tweetId);
    }

    follow(followerId, followeeId) {
        if (followerId !== followeeId) {
            if (!this.following[followerId]) {
                this.following[followerId] = new Set();
            }
            this.following[followerId].add(followeeId);
        }
    }

    unfollow(followerId, followeeId) {
        if (this.following[followerId]) {
            this.following[followerId].delete(followeeId);
        }
    }
}


-----
class Twitter 
    // Your code here
}


************************************
Question ID: 356
function isReflected(points) {
    let minX = Infinity;
    let maxX = -Infinity;
    const pointSet = new Set();

    for (const point of points) {
        minX = Math.min(minX, point[0]);
        maxX = Math.max(maxX, point[0]);
        pointSet.add(point[0] + "," + point[1]);
    }

    const sum = minX + maxX;
    for (const point of points) {
        if (!pointSet.has((sum - point[0]) + "," + point[1])) {
            return false;
        }
    }

    return true;
}

-----
function isReflected(points) 
    // Your code here
}

************************************
Question ID: 357
function countNumbersWithUniqueDigits(n) {
    if (n === 0) return 1;

    let total = 10;
    let uniqueDigits = 9;
    let currentAvailableDigits = 9;

    while (n-- > 1 && currentAvailableDigits > 0) {
        uniqueDigits *= currentAvailableDigits;
        total += uniqueDigits;
        currentAvailableDigits--;
    }

    return total;
}


-----
function countNumbersWithUniqueDigits(n) 
    // Your code here
}


************************************
Question ID: 358
function rearrangeString(s, k) {
  if (k === 0) return s;

  const freqMap = new Map();
  for (const c of s) {
    freqMap.set(c, (freqMap.get(c) || 0) + 1);
  }

  const maxHeap = Array.from(freqMap.entries()).sort((a, b) => b[1] - a[1]);

  let result = '';
  while (maxHeap.length) {
    const temp = [];

    for (let i = 0; i < k && maxHeap.length > 0; i++) {
      const curr = maxHeap.shift();

      result += curr[0];
      if (curr[1] - 1 > 0) {
        temp.push([curr[0], curr[1] - 1]);
      }
    }

    maxHeap.unshift(...temp.sort((a, b) => b[1] - a[1]));

    if (!maxHeap.length) break;
    if (result.length < s.length) {
      result += " ".repeat(k - temp.length);
    }
  }

  if (result.length < s.length) return "";
  return result;
}


-----
function rearrangeString(s, k) 
    // Your code here
}


************************************
Question ID: 360
function sortTransformedArray(nums, a, b, c) {
    let result = new Array(nums.length);
    let i = 0, j = nums.length - 1;
    let index = (a >= 0) ? nums.length - 1 : 0;
    
    while (i <= j) {
        let left = nums[i] * nums[i] * a + nums[i] * b + c;
        let right = nums[j] * nums[j] * a + nums[j] * b + c;
        
        if (a >= 0) {
            if (left >= right) {
                result[index--] = left;
                i++;
            } else {
                result[index--] = right;
                j--;
            }
        } else {
            if (left <= right) {
                result[index++] = left;
                i++;
            } else {
                result[index++] = right;
                j--;
            }
        }
    }
    return result;
}


-----
function sortTransformedArray(nums, a, b, c) 
    // Your code here
}


************************************
Question ID: 361
function maxKilledEnemies(grid) {
    if (!grid.length) return 0;
    let m = grid.length, n = grid[0].length, result = 0, rowhits;
    let colhits = new Array(n).fill(0);
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (j === 0 || grid[i][j - 1] === 'W') {
                rowhits = 0;
                for (let k = j; k < n && grid[i][k] !== 'W'; k++)
                    rowhits += grid[i][k] === 'E' ? 1 : 0;
            }
            if (i === 0 || grid[i - 1][j] === 'W') {
                colhits[j] = 0;
                for (let k = i; k < m && grid[k][j] !== 'W'; k++)
                    colhits[j] += grid[k][j] === 'E' ? 1 : 0;
            }
            if (grid[i][j] === '0') result = Math.max(result, rowhits + colhits[j]);
        }
    }
    return result;
}

-----
function maxKilledEnemies(grid) 
    // Your code here
}

************************************
Question ID: 362
class HitCounter {
  constructor() {
    this.queue = [];
  }

  hit(timestamp) {
    this.queue.push(timestamp);
  }

  getHits(timestamp) {
    while (this.queue.length > 0 && this.queue[0] <= timestamp - 300) {
      this.queue.shift();
    }
    return this.queue.length;
  }
}

-----
class HitCounter 
    // Your code here
}

************************************
Question ID: 363
function maxSumSubmatrix(matrix, k) {
    const rows = matrix.length;
    const cols = matrix[0].length;
    let maxSum = -Infinity;

    function lowerBound(arr, target) {
        let l = 0;
        let r = arr.length;
        while (l < r) {
            const mid = Math.floor((l + r) / 2);
            if (arr[mid] >= target) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }

    for (let l = 0; l < cols; ++l) {
        const sums = Array(rows).fill(0);
        for (let r = l; r < cols; ++r) {
            for (let i = 0; i < rows; ++i) {
                sums[i] += matrix[i][r];
            }

            const sortedSums = [0];
            let currSum = 0;
            for (const sum of sums) {
                currSum += sum;
                const it = lowerBound(sortedSums, currSum - k);
                if (it < sortedSums.length)
                    maxSum = Math.max(maxSum, currSum - sortedSums[it]);
                const insertPosition = lowerBound(sortedSums, currSum);
                sortedSums.splice(insertPosition, 0, currSum);
            }
        }
    }

    return maxSum;
}


-----
function maxSumSubmatrix(matrix, k) 
    // Your code here
}


************************************
Question ID: 364
function depthSumInverse(nestedList) {
    function maxDepthHelper(nestedList) {
        let depth = 1;
        for (let nested of nestedList) {
            if (Array.isArray(nested)) {
                depth = Math.max(depth, 1 + maxDepthHelper(nested));
            }
        }
        return depth;
    }
    function sumHelper(nestedList, depth) {
        let sum = 0;
        for (let nested of nestedList) {
            if (typeof nested === "number") {
                sum += depth * nested;
            } else {
                sum += sumHelper(nested, depth - 1);
            }
        }
        return sum;
    }
    let maxDepth = maxDepthHelper(nestedList);
    return sumHelper(nestedList, maxDepth);
}

-----
function depthSumInverse(nestedList) 
    // Your code here
}

************************************
Question ID: 365
function canMeasureWater(jug1Capacity, jug2Capacity, targetCapacity) {
    if (targetCapacity > jug1Capacity + jug2Capacity) return false;
    if (jug1Capacity == targetCapacity || jug2Capacity == targetCapacity 
        || jug1Capacity + jug2Capacity == targetCapacity) return true;
    return targetCapacity % gcd(jug1Capacity, jug2Capacity) === 0;
}

function gcd(a, b) {
    while (b) {
        let tmp = a % b;
        a = b;
        b = tmp;
    }
    return a;
}

-----
function canMeasureWater(jug1Capacity, jug2Capacity, targetCapacity) 
    // Your code here
}

************************************
Question ID: 367
function isPerfectSquare(num) {
    if (num < 2) return true;
    let left = 2, right = Math.floor(num / 2), mid, square;
    while (left <= right) {
        mid = left + Math.floor((right - left) / 2);
        square = mid * mid;
        if (square === num) return true;
        if (square > num) right = mid - 1;
        else left = mid + 1;
    }
    return false;
}

-----
function isPerfectSquare(num) 
    // Your code here
}

************************************
Question ID: 368
function largestDivisibleSubset(nums) {
    nums.sort((a, b) => a - b);
    const n = nums.length;
    const count = new Array(n).fill(1);
    const prev = new Array(n).fill(-1);
    let max_idx = 0;

    for (let i = 1; i < n; i++) {
        for (let j = 0; j < i; j++) {
            if (nums[i] % nums[j] === 0 && count[i] < count[j] + 1) {
                count[i] = count[j] + 1;
                prev[i] = j;
            }
        }
        if (count[max_idx] < count[i]) {
            max_idx = i;
        }
    }

    const res = [];
    for (let i = max_idx; i >= 0; i = prev[i]) {
        res.push(nums[i]);
    }

    return res;
}

-----
function largestDivisibleSubset(nums) 
    // Your code here
}

************************************
Question ID: 370
function getUpdatedArray(length, updates) {
    const arr = new Array(length).fill(0);

    for (const [start, end, inc] of updates) {
        arr[start] += inc;
        if (end + 1 < length) {
            arr[end + 1] -= inc;
        }
    }

    for (let i = 1; i < length; i++) {
        arr[i] += arr[i - 1];
    }

    return arr;
}

-----
function getUpdatedArray(length, updates) 
    // Your code here
}

************************************
Question ID: 371
function add(a, b) {
    while (b) {
        let carry = a & b;
        a = a ^ b;
        b = carry << 1;
    }
    return a;
}

-----
function add(a, b) 
    // Your code here
}

************************************
Question ID: 372
function powmod(a, b) {
    if (b === 0) return 1;
    const res = powmod(a, Math.floor(b / 2));
    return b % 2 ? res * res % 1337 * a % 1337 : res * res % 1337;
}

function superPow(a, b) {
    let n = 0;
    for (const bi of b) n = (n * 10 + bi) % 1140;
    return powmod(a % 1337, n + 1140);
}

-----
function powmod(a, b) 
    // Your code here
}

************************************
Question ID: 373
function kSmallestPairs(nums1, nums2, k) {
    const minHeap = new PriorityQueue(k, (a, b) => a[0] + a[1] - (b[0] + b[1]));
    const result = [];

    if (nums1.length === 0 || nums2.length === 0 || k === 0) {
        return result;
    }

    for (let i = 0; i < nums1.length && i < k; i++) {
        minHeap.offer([nums1[i], nums2[0], 0]);
    }

    while (k-- > 0 && !minHeap.isEmpty()) {
        const curr = minHeap.poll();
        result.push([curr[0], curr[1]]);
        if (curr[2] === nums2.length - 1) {
            continue;
        }
        minHeap.offer([curr[0], nums2[curr[2] + 1], curr[2] + 1]);
    }

    return result;
}

-----
function kSmallestPairs(nums1, nums2, k) 
    // Your code here
}

************************************
Question ID: 374
function guessNumber(n) {
    let low = 1, high = n;
    while (low <= high) {
        let mid = Math.floor(low + (high - low) / 2);
        let result = guess(mid);
        if (result === 0) {
            return mid;
        } else if (result < 0) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return -1;
}

-----
function guessNumber(n) 
    // Your code here
}

************************************
Question ID: 375
function getMoneyAmount(n) {
    const dp = Array.from(Array(n + 1), () => Array(n + 1).fill(0));
    for (let i = n - 1; i >= 1; i--) {
        for (let j = i + 1; j <= n; j++) {
            let min_cost = Infinity;
            for (let k = i; k < j; k++) {
                const cost = k + Math.max(dp[i][k - 1], dp[k + 1][j]);
                min_cost = Math.min(min_cost, cost);
            }
            dp[i][j] = min_cost;
        }
    }
    return dp[1][n];
}

-----
function getMoneyAmount(n) 
    // Your code here
}

************************************
Question ID: 376
function wiggleMaxLength(nums) {
    let len = nums.length;
    if (len < 2) return len;

    let up = 1, down = 1;
    for (let i = 1; i < len; ++i) {
        if (nums[i] > nums[i - 1])
            up = down + 1;
        else if (nums[i] < nums[i - 1])
            down = up + 1;
    }
    return Math.max(up, down);
}

-----
function wiggleMaxLength(nums) 
    // Your code here
}

************************************
Question ID: 377
function combinationSum(nums, target) {
    let dp = new Array(target + 1).fill(0);
    dp[0] = 1;

    for(let num of nums) {
        for(let i = num; i <= target; i++) {
            dp[i] += dp[i - num];
        }
    }

    return dp[target];
}


-----
function combinationSum(nums, target) 
    // Your code here
}


************************************
Question ID: 378
function kthSmallest(matrix, k) {
    const n = matrix.length;
    const minHeap = [];

    for (let i = 0; i < n; i++) {
        minHeap.push({ value: matrix[i][0], row: i, col: 0 });
    }

    minHeap.sort((a, b) => a.value - b.value);

    while (--k) {
        const { value, row, col } = minHeap.shift();

        if (col + 1 < n) {
            const newVal = { value: matrix[row][col + 1], row: row, col: col + 1 };
            insertSorted(minHeap, newVal, (a, b) => a.value - b.value);
        }
    }

    return minHeap[0].value;
}

function insertSorted(arr, item, comparator) {
    const insertIndex = arr.findIndex((el) => comparator(el, item) > 0);

    if (insertIndex === -1) {
        arr.push(item);
    } else {
        arr.splice(insertIndex, 0, item);
    }
}


-----
function kthSmallest(matrix, k) 
    // Your code here
}


************************************
Question ID: 379
class PhoneDirectory {
    constructor(maxNumbers) {
        this.available = new Array(maxNumbers).fill(true);
        this.released = [];
    }
    
    get() {
        if (this.released.length > 0) {
            let number = this.released.shift();
            this.available[number] = false;
            return number;
        }
        for (let i = 0; i < this.available.length; i++) {
            if (this.available[i]) {
                this.available[i] = false;
                return i;
            }
        }
        return -1;
    }
    
    check(number) {
        return this.available[number];
    }
    
    release(number) {
        if (!this.available[number]) {
            this.available[number] = true;
            this.released.push(number);
        }
    }
}


-----
class PhoneDirectory 
    // Your code here
}


************************************
Question ID: 380
class RandomizedSet {
    constructor() {
        this.indexMap = new Map();
        this.nums = [];
    }

    insert(val) {
        if (this.indexMap.has(val)) return false;

        this.indexMap.set(val, this.nums.length);
        this.nums.push(val);
        return true;
    }

    remove(val) {
        if (!this.indexMap.has(val)) return false;

        const last = this.nums[this.nums.length - 1];
        this.indexMap.set(last, this.indexMap.get(val));
        this.nums[this.indexMap.get(val)] = last;

        this.nums.pop();
        this.indexMap.delete(val);
        return true;
    }

    getRandom() {
        return this.nums[Math.floor(Math.random() * this.nums.length)];
    }
}

-----
class RandomizedSet 
    // Your code here
}

************************************
Question ID: 381
class RandomizedCollection {
    constructor() {
        this.indices = new Map();
        this.nums = [];
    }

    insert(val) {
        this.nums.push(val);
        if (!this.indices.has(val)) this.indices.set(val, new Set());
        this.indices.get(val).add(this.nums.length - 1);
        return this.indices.get(val).size === 1;
    }

    remove(val) {
        if (!this.indices.has(val) || this.indices.get(val).size === 0) return false;
        const idx = this.indices.get(val).values().next().value;
        this.indices.get(val).delete(idx);

        if (idx < this.nums.length - 1) {
            const last = this.nums[this.nums.length - 1];
            this.nums[idx] = last;
            this.indices.get(last).delete(this.nums.length - 1);
            this.indices.get(last).add(idx);
        }
        this.nums.pop();
        return true;
    }

    getRandom() {
        const index = Math.floor(Math.random() * this.nums.length);
        return this.nums[index];
    }
}


-----
class RandomizedCollection 
    // Your code here
}


************************************
Question ID: 382
class ListNode {
    constructor(val, next = null) {
        this.val = val;
        this.next = next;
    }
}

class Solution {
    constructor(head) {
        this.head = head;
    }

    getRandom() {
        let current = this.head;
        let result = current.val;
        for (let i = 1; current !== null; i++) {
            if (Math.floor(Math.random() * i) === 0) {
                result = current.val;
            }
            current = current.next;
        }
        return result;
    }
}

-----
class ListNode 
    // Your code here
}

************************************
Question ID: 383
function canConstruct(ransomNote, magazine) {
    let letterCount = new Map();
    
    for (const c of magazine) {
        letterCount.set(c, (letterCount.get(c) || 0) + 1);
    }
    
    for (const c of ransomNote) {
        if (!letterCount.has(c) || letterCount.get(c) === 0) {
            return false;
        }
        letterCount.set(c, letterCount.get(c) - 1);
    }

    return true;
}

-----
function canConstruct(ransomNote, magazine) 
    // Your code here
}

************************************
Question ID: 384
class Solution {
    constructor(nums) {
        this.original = nums;
    }
    
    reset() {
        return this.original;
    }
    
    shuffle() {
        let shuffled = [...this.original];
        for (let i = shuffled.length - 1; i > 0; i--) {
            let j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
    }
}


-----
class Solution 
    // Your code here
}


************************************
Question ID: 386
function lexicographicalOrderHelper(current, n, result) {
    if (current > n) return;

    result.push(current);
    for (let i = 0; i <= 9; ++i) {
        lexicographicalOrderHelper(current * 10 + i, n, result);
    }
}

function lexicalOrder(n) {
    let result = [];
    for (let i = 1; i <= 9; ++i) {
        lexicographicalOrderHelper(i, n, result);
    }
    return result;
}

-----
function lexicographicalOrderHelper(current, n, result) 
    // Your code here
}

************************************
Question ID: 387
function firstUniqChar(s) {
    let charCount = {};
    for (let c of s)
        charCount[c] = (charCount[c] || 0) + 1;
    for (let i = 0; i < s.length; i++)
        if (charCount[s[i]] === 1)
            return i;
    return -1;
}


-----
function firstUniqChar(s) 
    // Your code here
}


************************************
Question ID: 388
function lengthLongestPath(input) {
    const dirLengthStack = [];
    const lines = input.split('\n');
    let maxFileLength = 0;

    for (const line of lines) {
        const level = (line.match(/\t/g) || []).length;
        const lineText = line.replace(/\t/g, '');

        while (dirLengthStack.length > level)
            dirLengthStack.pop();

        const length = (dirLengthStack.length === 0) ? lineText.length : (dirLengthStack[dirLengthStack.length - 1] + lineText.length + 1);
        dirLengthStack.push(length);

        if (lineText.includes('.')) {
            maxFileLength = Math.max(maxFileLength, length);
        }
    }

    return maxFileLength;
}


-----
function lengthLongestPath(input) 
    // Your code here
}


************************************
Question ID: 389
function findTheDifference(s, t) {
    let sum_s = 0, sum_t = 0;
    for(let c of s) sum_s += c.charCodeAt(0);
    for(let c of t) sum_t += c.charCodeAt(0);
    return String.fromCharCode(sum_t - sum_s);
}

-----
function findTheDifference(s, t) 
    // Your code here
}

************************************
Question ID: 390
function lastRemaining(n) {
    let direction = true;
    let head = 1, remaining = n, step = 1;

    while (remaining > 1) {
        if (direction || remaining % 2 === 1) {
            head += step;
        }
        remaining = Math.floor(remaining / 2);
        step *= 2;
        direction = !direction;
    }

    return head;
}

-----
function lastRemaining(n) 
    // Your code here
}

************************************
Question ID: 391
function isRectangleCover(rectangles) {
    let area = 0;
    let points = new Set();
    let lx = Infinity, ly = Infinity, rx = -Infinity, ry = -Infinity;

    for (let rect of rectangles) {
        lx = Math.min(lx, rect[0]);
        ly = Math.min(ly, rect[1]);
        rx = Math.max(rx, rect[2]);
        ry = Math.max(ry, rect[3]);

        area += (rect[2] - rect[0]) * (rect[3] - rect[1]);

        let p1 = rect[0] + "," + rect[1];
        let p2 = rect[0] + "," + rect[3];
        let p3 = rect[2] + "," + rect[1];
        let p4 = rect[2] + "," + rect[3];

        if (points.has(p1)) points.delete(p1);
        else points.add(p1);
        if (points.has(p2)) points.delete(p2);
        else points.add(p2);
        if (points.has(p3)) points.delete(p3);
        else points.add(p3);
        if (points.has(p4)) points.delete(p4);
        else points.add(p4);
    }

    return points.size === 4 &&
           points.has(lx + "," + ly) && points.has(lx + "," + ry) &&
           points.has(rx + "," + ly) && points.has(rx + "," + ry) &&
           area === (rx - lx) * (ry - ly);
}

-----
function isRectangleCover(rectangles) 
    // Your code here
}

************************************
Question ID: 392
function isSubsequence(s, t) {
    let si = 0, ti = 0;

    while (si < s.length && ti < t.length) {
        if (s[si] === t[ti])
            si++;
        ti++;
    }

    return si === s.length;
}


-----
function isSubsequence(s, t) 
    // Your code here
}


************************************
Question ID: 393
function validUtf8(data) {
    let count = 0;
    for (let byte of data) {
        if (count === 0) {
            if (byte >> 5 === 0b110) count = 1;
            else if (byte >> 4 === 0b1110) count = 2;
            else if (byte >> 3 === 0b11110) count = 3;
            else if (byte >> 7) return false;
        } else {
            if (byte >> 6 !== 0b10) return false;
            count--;
        }
    }
    return count === 0;
}

-----
function validUtf8(data) 
    // Your code here
}

************************************
Question ID: 394
function decodeString(s) {
    const counts = [];
    const results = [];
    let current = "";
    let ptr = 0;

    while (ptr < s.length) {
        if (s[ptr].match(/\d/)) {
            let count = 0;
            while (s[ptr].match(/\d/)) {
                count = count * 10 + parseInt(s[ptr]);
                ptr++;
            }
            counts.push(count);
        } else if (s[ptr] === '[') {
            results.push(current);
            current = "";
            ptr++;
        } else if (s[ptr] === ']') {
            const prev = results.pop();
            const count = counts.pop();
            for (let i = 0; i < count; i++) {
                prev += current;
            }
            current = prev;
            ptr++;
        } else {
            current += s[ptr];
            ptr++;
        }
    }

    return current;
}

-----
function decodeString(s) 
    // Your code here
}

************************************
Question ID: 395
function longestSubstring(s, k) {
    if (!s || k <= 0) return 0;

    const charCount = {};
    for (const ch of s)
        charCount[ch] = (charCount[ch] || 0) + 1;

    for (const key in charCount) {
        if (charCount[key] < k) {
            let res = 0;
            for (const subStr of s.split(key))
                res = Math.max(res, longestSubstring(subStr, k));
            return res;
        }
    }
    return s.length;
}

-----
function longestSubstring(s, k) 
    // Your code here
}

************************************
Question ID: 396
function maxRotateFunction(nums) {
    let n = nums.length;
    let total_sum = nums.reduce((a, b) => a + b, 0);
    let f = nums.reduce((acc, val, i) => acc + i * val, 0);

    let max_f = f;
    for (let i = 1; i < n; i++) {
        f += total_sum - n * nums[n - i];
        max_f = Math.max(max_f, f);
    }

    return max_f;
}


-----
function maxRotateFunction(nums) 
    // Your code here
}


************************************
Question ID: 397
function minOperations(n) {
    let steps = 0;
    while(n > 1) {
        n = (n % 2 === 0) ? n / 2 : n - 1;
        steps++;
    }
    return steps;
}

-----
function minOperations(n) 
    // Your code here
}

************************************
Question ID: 398
class Solution {
    constructor(nums) {
        this.nums = nums;
    }
    
    pick(target) {
        let count = 0, res = 0;
        for (let i = 0; i < this.nums.length; i++) {
            if (this.nums[i] === target) {
                count++;
                if (Math.floor(Math.random() * count) === 0) {
                    res = i;
                }
            }
        }
        return res;
    }
}

-----
class Solution 
    // Your code here
}

************************************
Question ID: 399
function dfs(s1, s2, graph) {
  if (!graph[s1] || !graph[s2]) return -1.0;
  if (s1 === s2) return 1.0;

  for (const [neighbor, weight] of graph[s1]) {
    if (!visited.has(neighbor)) {
      visited.add(neighbor);
      const temp = dfs(neighbor, s2, graph);
      if (temp > 0) return weight * temp;
    }
  }
  return -1.0;
}

function calcEquation(equations, values, queries) {
  const graph = {};
  for (let i = 0; i < equations.length; i++) {
    const [s1, s2] = equations[i];
    const value = values[i];

    if (!graph[s1]) graph[s1] = [];
    if (!graph[s2]) graph[s2] = [];
    graph[s1].push([s2, value]);
    graph[s2].push([s1, 1 / value]);
  }

  const ans = [];
  for (const [s1, s2] of queries) {
    const visited = new Set();
    ans.push(dfs(s1, s2, graph));
  }
  return ans;
}

-----
function dfs(s1, s2, graph) 
    // Your code here
}

************************************
Question ID: 400
function findNthDigit(n) {
    let size = 1;
    let length = 9;
    let start = 1;

    while (n > length * size) {
        n -= length * size;
        size++;
        length *= 10;
        start *= 10;
    }

    start += Math.floor((n - 1) / size);
    const s = start.toString();
    return parseInt(s.charAt((n - 1) % size));
}

-----
function findNthDigit(n) 
    // Your code here
}

************************************
Question ID: 401
function readBinaryWatch(turnedOn) {
    function countBits(n) {
        return n.toString(2).split('1').length - 1;
    }

    const times = [];
    for (let h = 0; h < 12; h++) {
        for (let m = 0; m < 60; m++) {
            if (countBits(h) + countBits(m) === turnedOn) {
                times.push(`${h}:${m.toString().padStart(2, '0')}`);
            }
        }
    }
    return times;
}

-----
function readBinaryWatch(turnedOn) 
    // Your code here
}

************************************
Question ID: 402
function removeKDigits(num, k) {
    let stack = [];
    for (let i = 0; i < num.length; i++) {
        let c = num[i];
        while (k > 0 && stack.length > 0 && stack[stack.length - 1] > c) {
            stack.pop();
            k--;
        }
        stack.push(c);
    }
    while (k > 0) {
        stack.pop();
        k--;
    }
    let result = stack.join('').replace(/^0+/, '');
    return result || '0';
}

-----
function removeKDigits(num, k) 
    // Your code here
}

************************************
Question ID: 403
function canCross(stones) {
    const dp = new Map();
    stones.forEach(stone => dp.set(stone, new Set()));
    dp.get(0).add(0);

    for (const stone of stones) {
        for (const k of dp.get(stone)) {
            for (const jump of [k - 1, k, k + 1]) {
                if (jump > 0 && dp.has(stone + jump))
                    dp.get(stone + jump).add(jump);
            }
        }
    }
    return dp.get(stones[stones.length - 1]).size > 0;
}


-----
function canCross(stones) 
    // Your code here
}


************************************
Question ID: 405
function toHex(num) {
  if (num === 0) return '0';
  const hexDigits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
  let hex = '';
  let n = num >>> 0;
  while (n) {
    hex = hexDigits[n & 0xf] + hex;
    n >>>= 4;
  }
  return hex;
}

-----
function toHex(num) 
    // Your code here
}

************************************
Question ID: 406
function reconstructQueue(people) {
    people.sort((a, b) => {
        return a[0] !== b[0] ? b[0] - a[0] : a[1] - b[1];
    });

    const result = [];
    for (const p of people) {
        result.splice(p[1], 0, p);
    }
    return result;
}


-----
function reconstructQueue(people) 
    // Your code here
}


************************************
Question ID: 407
function trapRainWater(heightMap) {
    const m = heightMap.length;
    const n = heightMap[0].length;
    const pq = [];
    const visited = Array.from({ length: m }, () => Array(n).fill(false));

    const comparator = (a, b) => a[0] - b[0];

    for (let i = 0; i < m; i++) {
        pq.push([heightMap[i][0], i, 0], [heightMap[i][n - 1], i, n - 1]);
        visited[i][0] = visited[i][n - 1] = true;
    }

    for (let i = 1; i < n - 1; i++) {
        pq.push([heightMap[0][i], 0, i], [heightMap[m - 1][i], m - 1, i]);
        visited[0][i] = visited[m - 1][i] = true;
    }

    pq.sort(comparator);

    let water = 0;
    let maxHeight = 0;
    const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];

    while (pq.length) {
        const [h, r, c] = pq.shift();
        maxHeight = Math.max(maxHeight, h);
        for (const [dx, dy] of dirs) {
            const x = r + dx;
            const y = c + dy;
            if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) continue;
            if (heightMap[x][y] < maxHeight) water += maxHeight - heightMap[x][y];
            pq.push([heightMap[x][y], x, y]);
            pq.sort(comparator);
            visited[x][y] = true;
        }
    }

    return water;
}

-----
function trapRainWater(heightMap) 
    // Your code here
}

************************************
Question ID: 408
function validWordAbbreviation(word, abbr) {
    let i = 0, j = 0;
    while (i < word.length && j < abbr.length) {
        if (!isNaN(abbr[j])) {
            if (abbr[j] === '0') return false; // leading zero
            let num = 0;
            while (j < abbr.length && !isNaN(abbr[j])) {
                num = num * 10 + parseInt(abbr[j]);
                j++;
            }
            i += num;
        } else {
            if (word[i] !== abbr[j]) return false;
            i++; j++;
        }
    }
    return i === word.length && j === abbr.length;
}

-----
function validWordAbbreviation(word, abbr) 
    // Your code here
}

************************************
Question ID: 409
function longestPalindrome(s) {
    let charCount = new Array(128).fill(0);
    let result = 0;
    for (let c of s)
        charCount[c.charCodeAt(0)]++;
    for (let count of charCount) {
        result += Math.floor(count / 2) * 2;
        if (result % 2 === 0 && count % 2 === 1)
            result++;
    }
    return result;
}

-----
function longestPalindrome(s) 
    // Your code here
}

************************************
Question ID: 410
function splitArray(nums, m) {
    let left = 0, right = 0;
    for (let num of nums) {
        left = Math.max(left, num);
        right += num;
    }

    while (left < right) {
        let mid = Math.floor((left + right) / 2);
        let count = 1;
        let curSum = 0;
        for (let num of nums) {
            curSum += num;
            if (curSum > mid) {
                curSum = num;
                count++;
            }
        }

        if (count > m) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return left;
}

-----
function splitArray(nums, m) 
    // Your code here
}

************************************
Question ID: 411
function abbreviate(s, k, i) {
    if (i === s.length) {
        return (k > 0) ? String(k) : "";
    }
    if (k === 0) {
        return s.slice(i) + (i + 1 < s.length ? abbreviate(s, 1, i + 1) : "");
    }
    return String(k) + s[i] + (i + 1 < s.length ? abbreviate(s, 1, i + 1) : "");
}

function isAbbreviation(target, word) {
    let i = 0, j = 0;
    while (i < target.length && j < word.length) {
        if (target[i] === word[j]) {
            i++; j++;
        } else if (target[i] >= '0' && target[i] <= '9') {
            let k = 0;
            while (i < target.length && target[i] >= '0' && target[i] <= '9') {
                k = k * 10 + parseInt(target[i++]);
            }
            j += k;
        } else {
            return false;
        }
    }
    return (i === target.length && j === word.length);
}

function minAbbreviation(target, dictionary) {
    let ans = target;
    for (let k = 0; k <= target.length; k++) {
        for (let i = 0; i <= target.length - k; i++) {
            let current = abbreviate(target, k, i);
            if (current.length < ans.length) {
                let valid = true;
                for (const word of dictionary) {
                    if (isAbbreviation(current, word)) {
                        valid = false;
                        break;
                    }
                }
                if (valid) {
                    ans = current;
                }
            }
        }
    }
    return ans;
}


-----
function abbreviate(s, k, i) 
    // Your code here
}


************************************
Question ID: 412
function fizzBuzz(n) {
    let result = [];
    for (let i = 1; i <= n; i++) {
        if (i % 15 === 0) result.push("FizzBuzz");
        else if (i % 3 === 0) result.push("Fizz");
        else if (i % 5 === 0) result.push("Buzz");
        else result.push(String(i));
    }
    return result;
}

-----
function fizzBuzz(n) 
    // Your code here
}

************************************
Question ID: 413
function numberOfArithmeticSlices(nums) {
    let n = nums.length, count = 0, cur = 0;
    for (let i = 2; i < n; ++i) {
        if (nums[i] - nums[i - 1] === nums[i - 1] - nums[i - 2]) {
            cur++;
            count += cur;
        } else {
            cur = 0;
        }
    }
    return count;
}

-----
function numberOfArithmeticSlices(nums) 
    // Your code here
}

************************************
Question ID: 414
function thirdMax(nums) {
    const top3 = new Set();
    for (const num of nums) {
        top3.add(num);
        if (top3.size > 3) {
            top3.delete(Math.min(...top3));
        }
    }
    return top3.size === 3 ? Math.min(...top3) : Math.max(...top3);
}

-----
function thirdMax(nums) 
    // Your code here
}

************************************
Question ID: 415
function addStrings(num1, num2) {
    let i = num1.length - 1, j = num2.length - 1, carry = 0;
    let result = [];

    while (i >= 0 || j >= 0 || carry) {
        let sum = carry;

        if (i >= 0) {
            sum += parseInt(num1[i]);
            --i;
        }
        if (j >= 0) {
            sum += parseInt(num2[j]);
            --j;
        }

        carry = Math.floor(sum / 10);
        result.push(sum % 10);
    }

    return result.reverse().join('');
}


-----
function addStrings(num1, num2) 
    // Your code here
}


************************************
Question ID: 416
function canPartition(nums) {
    const sum = nums.reduce((a, b) => a + b);
    if (sum % 2 !== 0) return false;

    const target = sum / 2;
    const dp = new Array(target + 1).fill(false);
    dp[0] = true;

    for (const num of nums) {
        for (let i = target; i >= num; i--) {
            dp[i] = dp[i] || dp[i - num];
        }
    }
    return dp[target];
}


-----
function canPartition(nums) 
    // Your code here
}


************************************
Question ID: 417
function pacificAtlantic(heights) {
    function dfs(r, c, prevHeight, visited) {
        if (r < 0 || r >= heights.length || c < 0 || c >= heights[0].length) return;
        if (heights[r][c] >= prevHeight && !visited[r][c]) {
            visited[r][c] = true;
            dfs(r - 1, c, heights[r][c], visited);
            dfs(r + 1, c, heights[r][c], visited);
            dfs(r, c - 1, heights[r][c], visited);
            dfs(r, c + 1, heights[r][c], visited);
        }
    }

    const m = heights.length;
    const n = heights[0].length;
    const pacific = Array.from(Array(m), () => new Array(n).fill(false));
    const atlantic = Array.from(Array(m), () => new Array(n).fill(false));

    for (let r = 0; r < m; ++r) {
        dfs(r, 0, -1, pacific);
        dfs(r, n - 1, -1, atlantic);
    }
    for (let c = 0; c < n; ++c) {
        dfs(0, c, -1, pacific);
        dfs(m - 1, c, -1, atlantic);
    }
    const result = [];
    for (let r = 0; r < m; ++r) {
        for (let c = 0; c < n; ++c) {
            if (pacific[r][c] && atlantic[r][c]) {
                result.push([r, c]);
            }
        }
    }
    return result;
}


-----
function pacificAtlantic(heights) 
    // Your code here
}


************************************
Question ID: 418
function wordsTyping(sentence, rows, cols) {
    let totalChars = sentence.reduce((acc, word) => acc + word.length + 1, 0);

    let result = 0;
    let index = 0;
    for (let r = 0; r < rows; ++r) {
        let remainingCols = cols;
        while (true) {
            let wordLen = sentence[index].length;
            if (remainingCols >= wordLen) {
                remainingCols -= wordLen + 1;
                index = (index + 1) % sentence.length;
                if (index === 0) result++;
            } else {
                break;
            }
        }
    }

    return result;
}

-----
function wordsTyping(sentence, rows, cols) 
    // Your code here
}

************************************
Question ID: 419
function countBattleships(board) {
    let count = 0;
    for (let i = 0; i < board.length; i++) {
        for (let j = 0; j < board[i].length; j++) {
            if (board[i][j] === 'X' &&
                (i === 0 || board[i - 1][j] === '.') &&
                (j === 0 || board[i][j - 1] === '.')) {
                count++;
            }
        }
    }
    return count;
}

-----
function countBattleships(board) 
    // Your code here
}

************************************
Question ID: 420
function strongPassword(password) {
    let missingLower = 1, missingUpper = 1, missingDigit = 1;
    let total = password.length;
    for (const c of password) {
        if (c.match(/[a-z]/)) missingLower = 0;
        if (c.match(/[A-Z]/)) missingUpper = 0;
        if (c.match(/[0-9]/)) missingDigit = 0;
    }
    let missing = missingLower + missingUpper + missingDigit;
    if (total < 6) return Math.max(missing, 6 - total);
    if (total > 20) return missing + total - 20;
    return missing;
}

-----
function strongPassword(password) 
    // Your code here
}

************************************
Question ID: 421
function findMaximumXOR(nums) {
    let max_xor = 0, mask = 0;
    
    for (let i = 31; i >= 0; i--) {
        mask |= (1 << i);
        let prefixes = new Set();
        
        for (let num of nums) {
            prefixes.add(num & mask);
        }
        
        let possible_max = max_xor | (1 << i);

        for (let prefix of prefixes) {
            if (prefixes.has(prefix ^ possible_max)) {
                max_xor = possible_max;
                break;
            }
        }
    }
    
    return max_xor;
}

-----
function findMaximumXOR(nums) 
    // Your code here
}

************************************
Question ID: 422
function validWordSquare(words) {
    for (let i = 0; i < words.length; i++) {
        for (let j = 0; j < words[i].length; j++) {
            if (j >= words.length || i >= words[j].length || words[i][j] !== words[j][i]) {
                return false;
            }
        }
    }
    return true;
}


-----
function validWordSquare(words) 
    // Your code here
}


************************************
Question ID: 423
function findDigitsInAscendingOrder(s) {
    const count = new Array(10).fill(0);
    for (const c of s) {
        if (c === 'z') count[0]++;
        if (c === 'w') count[2]++;
        if (c === 'u') count[4]++;
        if (c === 'x') count[6]++;
        if (c === 'g') count[8]++;
        if (c === 'o') count[1]++;
        if (c === 'h') count[3]++;
        if (c === 'f') count[5]++;
        if (c === 's') count[7]++;
        if (c === 'i') count[9]++;
    }
    count[1] -= (count[0] + count[2] + count[4]);
    count[3] -= count[8];
    count[5] -= count[4];
    count[7] -= count[6];
    count[9] -= (count[5] + count[6] + count[8]);
    
    let res = "";
    for (let i = 0; i < 10; i++) {
        res += String(i).repeat(count[i]);
    }
    return res;
}


-----
function findDigitsInAscendingOrder(s) 
    // Your code here
}


************************************
Question ID: 424
function characterReplacement(s, k) {
    let n = s.length;
    let left = 0, right = 0, maxFreq = 0, result = 0;
    let freq = new Array(26).fill(0);

    for (right = 0; right < n; right++) {
        freq[s.charCodeAt(right) - 'A'.charCodeAt(0)]++;
        maxFreq = Math.max(maxFreq, freq[s.charCodeAt(right) - 'A'.charCodeAt(0)]);

        if (right - left + 1 - maxFreq > k) {
            freq[s.charCodeAt(left) - 'A'.charCodeAt(0)]--;
            left++;
        }

        result = Math.max(result, right - left + 1);
    }
    
    return result;
}


-----
function characterReplacement(s, k) 
    // Your code here
}


************************************
Question ID: 425
function wordSquares(words) {
    const buildPrefixMap = words => {
        const prefixMap = new Map();
        for (const word of words) {
            for (let i = 0; i <= word.length; i++) {
                const prefix = word.slice(0, i);
                if (!prefixMap.has(prefix)) {
                    prefixMap.set(prefix, []);
                }
                prefixMap.get(prefix).push(word);
            }
        }
        return prefixMap;
    };

    const search = (row, square, prefixMap, res) => {
        if (row === square.length) {
            res.push(square.slice());
            return;
        }
        const prefix = square.slice(0, row).map((word, i) => word[row]).join('');
        for (const word of prefixMap.get(prefix) || []) {
            square[row] = word;
            search(row + 1, square, prefixMap, res);
        }
    };

    const prefixMap = buildPrefixMap(words);
    const res = [];
    for (const word of words) {
        search(1, [word], prefixMap, res);
    }
    return res;
}

-----
function wordSquares(words) 
    // Your code here
}

************************************
Question ID: 433
function minMutation(start, end, bank) {
    const q = [start];
    const visited = new Set([start]);
    let depth = 0;

    while (q.length) {
        const levelSize = q.length;
        for (let i = 0; i < levelSize; i++) {
            const current = q.shift();
            if (current === end) return depth;

            for (const gene of bank) {
                if (!visited.has(gene)) {
                    let diff = 0;
                    for (let j = 0; j < 8; j++) {
                        if (current[j] !== gene[j]) diff++;
                        if (diff > 1) break;
                    }

                    if (diff === 1) {
                        q.push(gene);
                        visited.add(gene);
                    }
                }
            }
        }
        depth++;
    }
    return -1;
}


-----
function minMutation(start, end, bank) 
    // Your code here
}


************************************
Question ID: 434
function countSegments(s) {
    if (!s || s.trim().length === 0) {
        return 0;
    }
    const segments = s.trim().split(/\s+/);
    return segments.length;
}

-----
function countSegments(s) 
    // Your code here
}

************************************
Question ID: 435
function eraseOverlapIntervals(intervals) {
    if (intervals.length === 0) return 0;

    intervals.sort((a, b) => a[1] - b[1]);

    let count = 0;
    let prev_end = intervals[0][1];

    for (let i = 1; i < intervals.length; i++) {
        if (intervals[i][0] < prev_end) {
            count++;
        } else {
            prev_end = intervals[i][1];
        }
    }

    return count;
}

-----
function eraseOverlapIntervals(intervals) 
    // Your code here
}

************************************
Question ID: 436
function findRightInterval(intervals) {
    const starts = new Map();
    const res = [];

    intervals.forEach((interval, index) => {
        starts.set(interval[0], index);
    });

    for (const interval of intervals) {
        const rightKeys = [...starts.keys()].filter(x => x >= interval[1]);
        const right = Math.min(...rightKeys);
        res.push(right === Infinity ? -1 : starts.get(right));
    }

    return res;
}

-----
function findRightInterval(intervals) 
    // Your code here
}

************************************
Question ID: 437
function pathSumHelper(node, targetSum, currentSum) {
    if (node === null) {
        return 0;
    }

    currentSum += node.val;
    let totalPaths = (currentSum === targetSum) ? 1 : 0;
    totalPaths += pathSumHelper(node.left, targetSum, currentSum);
    totalPaths += pathSumHelper(node.right, targetSum, currentSum);
    return totalPaths;
}

function pathSum(root, targetSum) {
    if (root === null) {
        return 0;
    }

    return pathSumHelper(root, targetSum, 0) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum);
}


-----
function pathSumHelper(node, targetSum, currentSum) 
    // Your code here
}


************************************
Question ID: 438
function findAnagrams(s, p) {
    if (s.length < p.length) return [];

    const s_count = new Array(26).fill(0);
    const p_count = new Array(26).fill(0);
    for (const c of p) p_count[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;

    const result = [];
    for (let i = 0; i < s.length; i++) {
        s_count[s.charCodeAt(i) - 'a'.charCodeAt(0)]++;
        if (i >= p.length) s_count[s.charCodeAt(i - p.length) - 'a'.charCodeAt(0)]--;
        if (s_count.join(',') === p_count.join(',')) result.push(i - p.length + 1);
    }

    return result;
}

-----
function findAnagrams(s, p) 
    // Your code here
}

************************************
Question ID: 439
function parseTernary(expression) {
    const stack = [];
    for (let i = expression.length - 1; i >= 0; i--) {
        const c = expression[i];
        if (stack.length && stack[stack.length - 1] === '?') {
            stack.pop(); // Pop '?'
            const first = stack.pop();
            stack.pop(); // Pop ':'
            const second = stack.pop();
            stack.push(c === 'T' ? first : second);
        } else {
            stack.push(c);
        }
    }
    return stack[stack.length - 1];
}


-----
function parseTernary(expression) 
    // Your code here
}


************************************
Question ID: 440
function findKthNumber(n, k) {
    const nums = [];
    for (let i = 1; i <= n; i++) {
        nums.push(i);
    }
    nums.sort((a, b) => String(a).localeCompare(String(b)));
    return nums[k - 1];
}


-----
function findKthNumber(n, k) 
    // Your code here
}


************************************
Question ID: 441
function arrangeCoins(n) {
    let k = 0;
    while (n > k) {
        k++;
        n -= k;
    }
    return k;
}

-----
function arrangeCoins(n) 
    // Your code here
}

************************************
Question ID: 442
function findDuplicates(nums) {
    let duplicates = [];
    for (let i = 0; i < nums.length; i++) {
        let index = Math.abs(nums[i]) - 1;
        if (nums[index] < 0) {
            duplicates.push(Math.abs(nums[i]));
        } else {
            nums[index] *= -1;
        }
    }
    return duplicates;
}

-----
function findDuplicates(nums) 
    // Your code here
}

************************************
Question ID: 443
function compress(chars) {
    let index = 0, count;
    for(let i = 0; i < chars.length; i += count) {
        count = 1;
        while(i + count < chars.length && chars[i] === chars[i + count]) {
            count++;
        }
        chars[index++] = chars[i];
        if(count > 1) {
            for(let c of count.toString()) {
                chars[index++] = c;
            }
        }
    }
    return index;
}

-----
function compress(chars) 
    // Your code here
}

************************************
Question ID: 444
function isShortestAndUniqueSupersequence(nums, sequences) {
    const pos = new Map();
    for (let i = 0; i < nums.length; i++) {
        pos.set(nums[i], i);
    }

    for (const seq of sequences) {
        if (pos.get(seq[0]) > pos.get(seq[seq.length - 1])) {
            return false;
        }
    }
    return true;
}

-----
function isShortestAndUniqueSupersequence(nums, sequences) 
    // Your code here
}

************************************
Question ID: 446
function numberOfArithmeticSlices(nums) {
    let res = 0;
    const n = nums.length;
    const dp = new Array(n).fill(0).map(() => new Map());

    for (let i = 0; i < n; ++i) {
        for (let j = 0; j < i; ++j) {
            const diff = nums[i] - nums[j];
            if (diff <= Number.MIN_SAFE_INTEGER || diff > Number.MAX_SAFE_INTEGER) continue;

            if (!dp[i].has(diff)) {
                dp[i].set(diff, 0);
            }

            dp[i].set(diff, dp[i].get(diff) + 1);

            if (dp[j].has(diff)) {
                res += dp[j].get(diff);
                dp[i].set(diff, dp[i].get(diff) + dp[j].get(diff));
            }
        }
    }
    return res;
}


-----
function numberOfArithmeticSlices(nums) 
    // Your code here
}


************************************
Question ID: 447
function numberOfBoomerangs(points) {
    let count = 0;

    for (let i of points) {
        let group_count = new Map();
        for (let j of points) {
            let dx = i[0] - j[0], dy = i[1] - j[1];
            let dist = dx * dx + dy * dy;
            group_count.set(dist, (group_count.get(dist) || 0) + 1);
        }

        for (let g of group_count.values()) {
            count += g * (g - 1);
        }
    }

    return count;
}

-----
function numberOfBoomerangs(points) 
    // Your code here
}

************************************
Question ID: 448
function findDisappearedNumbers(nums) {
    const result = [];

    for (let i = 0; i < nums.length; i++) {
        const index = Math.abs(nums[i]) - 1;
        nums[index] = -Math.abs(nums[index]);
    }

    for (let i = 0; i < nums.length; i++) {
        if (nums[i] > 0) {
            result.push(i + 1);
        }
    }

    return result;
}

-----
function findDisappearedNumbers(nums) 
    // Your code here
}

************************************
Question ID: 451
function sortByFrequency(s) {
    const freq = {};
    const chars = [...s];
    
    for (const c of s)
        freq[c] = (freq[c] || 0) + 1;
        
    chars.sort((a, b) => freq[b] - freq[a]);
    
    return chars.join('');
}

-----
function sortByFrequency(s) 
    // Your code here
}

************************************
Question ID: 452
function findMinArrowShots(points) {
    if (points.length === 0) return 0;
    points.sort((a, b) => a[1] - b[1]);

    let arrows = 1;
    let end = points[0][1];

    for (let i = 1; i < points.length; i++) {
        if (points[i][0] > end) {
            arrows++;
            end = points[i][1];
        }
    }

    return arrows;
}

-----
function findMinArrowShots(points) 
    // Your code here
}

************************************
Question ID: 453
function minMoves(nums) {
    let min_element = Math.min(...nums);
    let moves = nums.reduce((acc, num) => acc + (num - min_element), 0);
    return moves;
}


-----
function minMoves(nums) 
    // Your code here
}


************************************
Question ID: 454
function fourSumCount(nums1, nums2, nums3, nums4) {
    const hashMap = new Map();
    let count = 0;

    for (const i of nums1) {
        for (const j of nums2) {
            hashMap.set(i + j, (hashMap.get(i + j) || 0) + 1);
        }
    }

    for (const k of nums3) {
        for (const l of nums4) {
            count += hashMap.get(-(k + l)) || 0;
        }
    }

    return count;
}

-----
function fourSumCount(nums1, nums2, nums3, nums4) 
    // Your code here
}

************************************
Question ID: 455
function findContentChildren(g, s) {
    g.sort((a, b) => a - b);
    s.sort((a, b) => a - b);
    let i = 0, j = 0;

    while (i < g.length && j < s.length) {
        if (s[j] >= g[i]) {
            i++;
        }

        j++;
    }

    return i;
}


-----
function findContentChildren(g, s) 
    // Your code here
}


************************************
Question ID: 456
function find132pattern(nums) {
    const stack = [];
    let third = Number.MIN_SAFE_INTEGER;
    for (let i = nums.length - 1; i >= 0; --i) {
        if (nums[i] < third) {
            return true;
        }
        while (stack.length && stack[stack.length - 1] < nums[i]) {
            third = stack.pop();
        }
        stack.push(nums[i]);
    }
    return false;
}

-----
function find132pattern(nums) 
    // Your code here
}

************************************
Question ID: 457
function circularArrayLoop(nums) {
  const N = nums.length;
  for (let i = 0; i < N; i++) {
    let slow = i, fast = i;
    do {
      slow = getNextIndex(slow, nums);
      fast = getNextIndex(getNextIndex(fast, nums), nums);
    } while (slow !== fast && nums[slow] * nums[fast] > 0);

    if (slow !== fast) continue;
    let cycle = false;
    let start = slow;
    do {
      cycle |= getNextIndex(start, nums) === start;
      start = getNextIndex(start, nums);
    } while (start !== slow);
    if (!cycle) return true;
  }
  return false;
}

function getNextIndex(idx, nums) {
    const N = nums.length;
    return ((idx + nums[idx]) % N + N) % N;
}


-----
function circularArrayLoop(nums) 
    // Your code here
}


************************************
Question ID: 458
function poorPigs(buckets, minutesToDie, minutesToTest) {
    let pigs = 0;
    while (Math.pow(Math.floor(minutesToTest / minutesToDie) + 1, pigs) < buckets) {
        pigs++;
    }
    return pigs;
}


-----
function poorPigs(buckets, minutesToDie, minutesToTest) 
    // Your code here
}


************************************
Question ID: 459
function canConstruct(s) {
    const n = s.length;
    for (let i = Math.floor(n / 2); i > 0; --i) {
        if (n % i === 0) {
            const substr = s.substring(0, i);
            let flag = true;
            for (let j = i; j < n; j += i) {
                if (s.substring(j, j + i) !== substr) {
                    flag = false;
                    break;
                }
            }

            if (flag) return true;
        }
    }
    return false;
}


-----
function canConstruct(s) 
    // Your code here
}


************************************
Question ID: 461
function hammingDistance(x, y) {
    let dist = 0;
    let xorResult = x ^ y;
    while (xorResult != 0) {
        dist += xorResult & 1;
        xorResult >>= 1;
    }
    return dist;
}

-----
function hammingDistance(x, y) 
    // Your code here
}

************************************
Question ID: 462
function minMoves2(nums) {
    nums.sort((a, b) => a - b);
    const mid = nums[Math.floor(nums.length / 2)];
    let moves = 0;
    for (const num of nums) {
        moves += Math.abs(num - mid);
    }
    return moves;
}

-----
function minMoves2(nums) 
    // Your code here
}

************************************
Question ID: 463
function islandPerimeter(grid) {
    let perimeter = 0;
    for (let row = 0; row < grid.length; row++) {
        for (let col = 0; col < grid[row].length; col++) {
            if (grid[row][col] === 1) {
                perimeter += 4;
                if (row > 0 && grid[row - 1][col] === 1) perimeter -= 2;
                if (col > 0 && grid[row][col - 1] === 1) perimeter -= 2;
            }
        }
    }
    return perimeter;
}

-----
function islandPerimeter(grid) 
    // Your code here
}

************************************
Question ID: 464
var canIWin = function(maxChoosableInteger, desiredTotal) {
    if (maxChoosableInteger >= desiredTotal) return true;
    if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) return false;

    const memo = new Map();

    function canWin(state) {
        if (memo.has(state)) return memo.get(state);

        for (let i = 1; i <= maxChoosableInteger; i++) {
            let bitCheck = 1 << i;
            if ((state & bitCheck) === 0) {
                if (!canWin(state | bitCheck)) {
                    memo.set(state, true);
                    return true;
                }
            }
        }

        memo.set(state, false);
        return false;
    }

    return canWin(0);
}


-----
var canIWin = function(maxChoosableInteger, desiredTotal) 
    // Your code here
}


************************************
Question ID: 465
function minTransfers(transactions) {
    const balances = new Map();
    for (const transaction of transactions) {
        balances.set(transaction[0], (balances.get(transaction[0]) || 0) - transaction[2]);
        balances.set(transaction[1], (balances.get(transaction[1]) || 0) + transaction[2]);
    }

    const debts = [];
    for (const balance of balances.values()) {
        if (balance !== 0) {
            debts.push(balance);
        }
    }
    return dfs(debts, 0);
}

function dfs(debts, start) {
    while (start < debts.length && debts[start] === 0) {
        start++;
    }
    if (start === debts.length) {
        return 0;
    }
    let result = Infinity;
    for (let i = start + 1; i < debts.length; ++i) {
        if ((debts[start] > 0) !== (debts[i] > 0)) {
            debts[i] += debts[start];
            result = Math.min(result, 1 + dfs(debts, start + 1));
            debts[i] -= debts[start];
        }
    }
    return result;
}


-----
function minTransfers(transactions) 
    // Your code here
}


************************************
Question ID: 466
function getMaxRepetitions(s1, n1, s2, n2) {
    let count1 = 0, count2 = 0, i = 0, j = 0;
    while (count1 < n1) {
        if (s1.charAt(i) === s2.charAt(j)) {
            j++;
            if (j === s2.length) {
                j = 0;
                count2++;
            }
        }
        i++;
        if (i === s1.length) {
            i = 0;
            count1++;
        }
    }
    return Math.floor(count2 / n2);
}


-----
function getMaxRepetitions(s1, n1, s2, n2) 
    // Your code here
}


************************************
Question ID: 467
function findSubstringInWraproundString(p) {
    const cnt = new Array(26).fill(0);
    let length = 0;

    for (let i = 0; i < p.length; i++) {
        if (i > 0 && (p.charCodeAt(i) === p.charCodeAt(i - 1) + 1 || p.charCodeAt(i - 1) - p.charCodeAt(i) === 25)) {
            length++;
        } else {
            length = 1;
        }
        cnt[p.charCodeAt(i) - 'a'.charCodeAt(0)] = Math.max(cnt[p.charCodeAt(i) - 'a'.charCodeAt(0)], length);
    }

    return cnt.reduce((a, b) => a + b, 0);
}


-----
function findSubstringInWraproundString(p) 
    // Your code here
}


************************************
Question ID: 468
function validateIP(queryIP) {
    const ipv4_parts = queryIP.split('.');
    const ipv6_parts = queryIP.split(':');

    if (ipv4_parts.length == 4) {
        if (isValidIPv4(ipv4_parts)) return "IPv4";
    } else if (ipv6_parts.length == 8) {
        if (isValidIPv6(ipv6_parts)) return "IPv6";
    }

    return "Neither";
}

function isValidIPv4(parts) {
    for (let part of parts) {
        if (!part || part.length > 3 || (part.length > 1 && part[0] == '0')) return false;

        let num = 0;
        for (let ch of part) {
            if (!/[0-9]/.test(ch)) return false;
            num = num * 10 + parseInt(ch);
        }

        if (num < 0 || num > 255) return false;
    }

    return true;
}

function isValidIPv6(parts) {
    for (let part of parts) {
        if (!part || part.length > 4) return false;

        for (let ch of part) {
            if (!/[0-9a-fA-F]/.test(ch)) return false;
        }
    }

    return true;
}

-----
function validateIP(queryIP) 
    // Your code here
}

************************************
Question ID: 469
function isConvex(points) {
    const n = points.length;
    let pre = 0, cur = 0;

    for (let i = 0; i < n; ++i) {
        const x1 = points[(i + 1) % n][0] - points[i][0];
        const y1 = points[(i + 1) % n][1] - points[i][1];
        const x2 = points[(i + 2) % n][0] - points[(i + 1) % n][0];
        const y2 = points[(i + 2) % n][1] - points[(i + 1) % n][1];
        cur = x1 * y2 - x2 * y1;

        if (cur === 0)
            continue;
        if (cur * pre < 0)
            return false;
        pre = cur;
    }

    return true;
}

-----
function isConvex(points) 
    // Your code here
}

************************************
Question ID: 470
function rand7() ; // Provided API

function rand10() {
    let result;
    do {
        result = (rand7() - 1) * 7 + rand7();
    } while (result > 40);
    return result % 10 + 1;
}

-----
function rand7() ; // Provided API

function rand10() 
    // Your code here
}

************************************
Question ID: 471
function encode(s) {
    const n = s.length;
    for (let i = Math.floor(n / 2); i > 0; i--) {
        if (n % i === 0) {
            const reps = n / i;
            const sub = s.slice(0, i);
            let composed = "";
            for (let j = 0; j < reps; j++) {
                composed += sub;
            }
            if (s === composed) {
                return `${reps}[${sub}]`;
            }
        }
    }
    return s;
}

-----
function encode(s) 
    // Your code here
}

************************************
Question ID: 472
function isConcatenated(word, wordDict) {
    const n = word.length;
    const dp = Array(n + 1).fill(false);
    dp[0] = true;

    for (let i = 1; i <= n; ++i) {
        for (let j = 0; j < i; ++j) {
            if (dp[j] && wordDict.has(word.substring(j, i))) {
                dp[i] = true;
                break;
            }
        }
    }
    return dp[n];
}

function findAllConcatenatedWords(words) {
    const wordDict = new Set(words);
    const result = [];

    for (const word of words) {
        if (isConcatenated(word, wordDict)) {
            result.push(word);
        }
    }

    return result;
}

-----
function isConcatenated(word, wordDict) 
    // Your code here
}

************************************
Question ID: 473
function makesquare(matchsticks) {
    if (matchsticks.length < 4) return false;
    const total = matchsticks.reduce((a, b) => a + b, 0);
    if (total % 4 !== 0) return false;
    const target = total / 4;
    matchsticks.sort((a, b) => b - a);
    const sums = [0, 0, 0, 0];
    return dfs(matchsticks, sums, target, 0);
}

function dfs(matchsticks, sums, target, index) {
    if (index === matchsticks.length) {
        return sums[0] === target && sums[1] === target && sums[2] === target;
    }
    for (let i = 0; i < 4; i++) {
        if (sums[i] + matchsticks[index] <= target) {
            sums[i] += matchsticks[index];
            if (dfs(matchsticks, sums, target, index + 1)) return true;
            sums[i] -= matchsticks[index];
        }
    }
    return false;
}


-----
function makesquare(matchsticks) 
    // Your code here
}


************************************
Question ID: 474
function findMaxForm(strs, m, n) {
    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
    
    for (const str of strs) {
        const ones = str.split('').filter(ch => ch === '1').length;
        const zeros = str.length - ones;
        
        for (let i = m; i >= zeros; --i) {
            for (let j = n; j >= ones; --j) {
                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);
            }
        }
    }
    return dp[m][n];
}

-----
function findMaxForm(strs, m, n) 
    // Your code here
}

************************************
Question ID: 475
function findRadius(houses, heaters) {
    houses.sort((a, b) => a - b);
    heaters.sort((a, b) => a - b);
    let result = 0;
    let i = 0;

    for (const house of houses) {
        while (i < heaters.length - 1 &&
               Math.abs(heaters[i + 1] - house) <= Math.abs(heaters[i] - house)) {
            i++;
        }
        result = Math.max(result, Math.abs(heaters[i] - house));
    }
    return result;
}

-----
function findRadius(houses, heaters) 
    // Your code here
}

************************************
Question ID: 476
function findComplement(num) {
    let bitLength = 0;
    let mask = num;
    while (mask > 0) {
        mask >>= 1;
        bitLength++;
    }
    const allOnes = (1 << bitLength) - 1;

    return num ^ allOnes;
}

-----
function findComplement(num) 
    // Your code here
}

************************************
Question ID: 477
function totalHammingDistance(nums) {
    let totalDistance = 0, n = nums.length;
    
    for (let i = 0; i < 32; ++i) {
        let bitCount = 0;
        for (let num of nums) {
            bitCount += (num >> i) & 1;
        }
        totalDistance += bitCount * (n - bitCount);
    }
    
    return totalDistance;
}

-----
function totalHammingDistance(nums) 
    // Your code here
}

************************************
Question ID: 478
class Solution {
    constructor(radius, x_center, y_center) {
        this.radius = radius;
        this.x_center = x_center;
        this.y_center = y_center;
    }

    randPoint() {
        const r = Math.sqrt(Math.random()) * this.radius;
        const theta = Math.random() * 2 * Math.PI;
        return [this.x_center + r * Math.cos(theta), this.y_center + r * Math.sin(theta)];
    }
}

-----
class Solution 
    // Your code here
}

************************************
Question ID: 479
function largestPalindrome(n) {
    if (n === 1) return 9; // Handle 1-digit numbers
    let upper_limit = Math.pow(10, n) - 1;
    let lower_limit = Math.floor(upper_limit / 10);
    for (let i = upper_limit; i > lower_limit; i--) {
        let temp = i;
        let reverse = 0;
        while (temp !== 0) {
            reverse = reverse * 10 + temp % 10;
            temp = Math.floor(temp / 10);
        }
        let palindrome = i * Math.pow(10, n) + reverse;
        for (let j = upper_limit; j > lower_limit; j--) {
            let product = Math.floor(palindrome / j);
            if (palindrome % j === 0 && product <= upper_limit) {
                return palindrome % 1337;
            }
        }
    }
    return -1;
}


-----
function largestPalindrome(n) 
    // Your code here
}


************************************
Question ID: 480
function medianSlidingWindow(nums, k) {
    const window = new SortedSet();
    const medians = [];

    for (let i = 0; i < k; i++) {
        window.add(nums[i]);
    }

    for (let i = k; i <= nums.length; i++) {
        const mid1 = window.at(Math.floor((k - 1) / 2));
        const mid2 = window.at(Math.floor(k / 2));

        medians.push((mid1 + mid2) / 2);

        if (i < nums.length) {
            window.delete(nums[i - k]);
            window.add(nums[i]);
        }
    }

    return medians;
}


-----
function medianSlidingWindow(nums, k) 
    // Your code here
}


************************************
Question ID: 481
function magicalString(n) {
    if (n === 0) return 0;
    if (n <= 3) return 1;

    let magic = [1, 2, 2];
    let countOnes = 1;
    let index = 2;
    let value = 1;

    while (magic.length < n) {
        for (let i = 0; i < magic[index]; i++) {
            magic.push(value);
            if (value === 1 && magic.length <= n) countOnes++;
        }
        value = 3 - value;
        index++;
    }

    return countOnes;
}


-----
function magicalString(n) 
    // Your code here
}


************************************
Question ID: 482
function licenseKeyFormatting(s, k) {
    let result = '';
    let count = 0;
    for (let i = s.length - 1; i >= 0; i--) {
        if (s[i] !== '-') {
            if (count === k) {
                result = '-' + result;
                count = 0;
            }
            result = s[i].toUpperCase() + result;
            count++;
        }
    }
    return result;
}

-----
function licenseKeyFormatting(s, k) 
    // Your code here
}

************************************
Question ID: 483
function smallestGoodBase(n) {
    const num_n = BigInt(n);
    
    for(let m = BigInt(Math.floor(Math.log2(Number(n))) + 1); m >= 1; m--) {
        const k = BigInt(Math.floor(num_n ** (1n / m)));
        let sum = 0n;
        for(let i=0n; i <= m; i++) {
            sum = sum * k + 1n;
        }
        if(sum === num_n) {
            return String(k);
        }
    }
    
    return "-1";
}

-----
function smallestGoodBase(n) 
    // Your code here
}

************************************
Question ID: 484
function findPermutation(s) {
    let perm = new Array(s.length + 1).fill(0);
    let left = 1;
    for(let i = 0; i < s.length; i++) {
        if(s[i] === 'I') {
            perm[i] = left++;
            while(i + 1 < s.length && s[i + 1] === 'D')
                i++;
        }
    }
    perm[s.length] = left++;
    for(let i = s.length - 1; i >= 0; i--)
        if(s[i] === 'D')
            perm[i] = left++;
    return perm;
}

-----
function findPermutation(s) 
    // Your code here
}

************************************
Question ID: 485
function findMaxConsecutiveOnes(nums) {
    let maxConsecutive = 0, currentConsecutive = 0;
    for (let num of nums) {
        currentConsecutive = (num === 1) ? currentConsecutive + 1 : 0;
        maxConsecutive = Math.max(maxConsecutive, currentConsecutive);
    }
    return maxConsecutive;
}

-----
function findMaxConsecutiveOnes(nums) 
    // Your code here
}

************************************
Question ID: 486
function canWin(nums) {
    const n = nums.length;
    const dp = Array.from({ length: n }, () => Array(n).fill(0));
    for (let i = 0; i < n; i++) {
        dp[i][i] = nums[i];
    }
    for (let len = 1; len < n; len++) {
        for (let i = 0; i < n - len; i++) {
            const j = i + len;
            dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);
        }
    }
    return dp[0][n - 1] >= 0;
}


-----
function canWin(nums) 
    // Your code here
}


************************************
Question ID: 487
function findMaxConsecutiveOnes(nums) {
    let maxCount = 0, countZeros = 0, left = 0;
    for (let right = 0; right < nums.length; ++right) {
        if (nums[right] === 0) countZeros++;
        while (countZeros > 1) {
            if (nums[left++] === 0) countZeros--;
        }
        maxCount = Math.max(maxCount, right - left + 1);
    }
    return maxCount;
}

-----
function findMaxConsecutiveOnes(nums) 
    // Your code here
}

************************************
Question ID: 488
function findMinStep(board, hand) {
    function findMinStepHelper(board, memo, hand) {
        if (board.length === 0) return 0;
        if (memo.has(board)) return memo.get(board);

        let result = Infinity;
        let i = 0;
        while (i < board.length) {
            let j = i;
            while (j < board.length && board[i] === board[j]) j++;

            let color = board[i];
            let required = 3 - (j - i);
            if (hand[color] >= required) {
                hand[color] -= required;
                let nextBoard = board.slice(0, i) + board.slice(j);
                let tmp = findMinStepHelper(nextBoard, memo, hand);
                if (tmp !== -1) result = Math.min(result, tmp + required);
                hand[color] += required;
            }
            i = j;
        }

        let res = (result === Infinity) ? -1 : result;
        memo.set(board, res);
        return res;
    }

    let handMap = {};
    for (let c of hand) handMap[c] = (handMap[c] || 0) + 1;

    return findMinStepHelper(board, new Map(), handMap);
}


-----
function findMinStep(board, hand) 
    // Your code here
}


************************************
Question ID: 489
function comb(n, r) {
    if(r > n - r) r = n - r;
    let res = 1;
    for(let i = 1; i <= r; i++) {
        res *= n - r + i;
        res /= i;
    }
    return res;
}

function kthSmallestPath(destination, k) {
    let row = destination[0];
    let col = destination[1];
    let ans = "";

    for(let i = 0; i < row + col; i++) {
        if(row === 0) {
            ans += 'H';
            col--;
        } else if(col === 0) {
            ans += 'V';
            row--;
        } else if(k <= comb(row + col - 1, row - 1)) {
            ans += 'H';
            col--;
        } else {
            ans += 'V';
            k -= comb(row + col - 1, row - 1);
            row--;
        }
    }

    return ans;
}


-----
function comb(n, r) 
    // Your code here
}


************************************
Question ID: 490
function hasPath(maze, start, destination) {
    const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
    const q = [start];
    while (q.length > 0) {
        const [x, y] = q.shift();
        if (x === destination[0] && y === destination[1]) return true;
        for (const [dx, dy] of dirs) {
            let i = x, j = y;
            while (i + dx >= 0 && i + dx < maze.length && j + dy >= 0 && j + dy < maze[0].length && maze[i + dx][j + dy] === 0) {
                i += dx;
                j += dy;
            }
            if (maze[i][j] === 0) {
                maze[i][j] = 1;
                q.push([i, j]);
            }
        }
    }
    return false;
}

-----
function hasPath(maze, start, destination) 
    // Your code here
}

************************************
Question ID: 491
function findSubsequences(nums) {
    const res = new Set();
    dfs(nums, 0, [], res);
    return Array.from(res).map(x => Array.from(x));
}

function dfs(nums, start, path, res) {
    if (path.length >= 2) {
        res.add(path);
    }
    for (let i = start; i < nums.length; i++) {
        if (path.length && path[path.length - 1] > nums[i]) {
            continue;
        }
        dfs(nums, i + 1, [...path, nums[i]], res);
    }
}

-----
function findSubsequences(nums) 
    // Your code here
}

************************************
Question ID: 492
function constructRectangle(area) {
    let width = Math.floor(Math.sqrt(area));
    while(area % width !== 0) {
        width--;
    }
    let length = area / width;
    return [length, width];
}

-----
function constructRectangle(area) 
    // Your code here
}

************************************
Question ID: 493
function reversePairs(nums) {
    function mergeSort(l, r) {
        if (l >= r) {
            return 0;
        }

        const mid = Math.floor((l + r) / 2);
        let count = mergeSort(l, mid) + mergeSort(mid + 1, r);
        let j = mid + 1;
        for (let i = l; i <= mid; i++) {
            while (j <= r && nums[i] > 2 * nums[j]) {
                j++;
            }
            count += j - (mid + 1);
        }

        const merged = nums.slice(l, r + 1).sort((a, b) => a - b);
        nums.splice(l, merged.length, ...merged);

        return count;
    }

    return mergeSort(0, nums.length - 1);
}



-----
function reversePairs(nums) 
    // Your code here
}



************************************
Question ID: 494
function findTargetSumWays(nums, target) {
    let sum = nums.reduce((a, b) => a + b);
    if (sum < target || (sum + target) % 2 !== 0) return 0;
    let target_sum = (sum + target) >> 1;
    let dp = new Array(target_sum + 1).fill(0);
    dp[0] = 1;
    for (const num of nums) {
        for (let j = target_sum; j >= num; j--) {
            dp[j] += dp[j - num];
        }
    }
    return dp[target_sum];
}


-----
function findTargetSumWays(nums, target) 
    // Your code here
}


************************************
Question ID: 495
function findPoisonedDuration(timeSeries, duration) {
    if (timeSeries.length === 0) return 0;
    let total = 0;
    for (let i = 1; i < timeSeries.length; ++i) {
        total += Math.min(timeSeries[i] - timeSeries[i - 1], duration);
    }
    return total + duration;
}

-----
function findPoisonedDuration(timeSeries, duration) 
    // Your code here
}

************************************
Question ID: 496
function nextGreaterElement(nums1, nums2) {
    const nextGreater = new Map();
    const stack = [];

    nums2.forEach(num => {
        while (stack.length && stack[stack.length - 1] < num) {
            nextGreater.set(stack.pop(), num);
        }
        stack.push(num);
    });

    return nums1.map(n => nextGreater.get(n) || -1);
}

-----
function nextGreaterElement(nums1, nums2) 
    // Your code here
}

************************************
Question ID: 497
class Solution {
    constructor(rects) {
        this.rects = rects;
        this.areas = new Array(rects.length);
        this.totalArea = 0;

        for (let i = 0; i < rects.length; i++) {
            const area = (rects[i][2] - rects[i][0] + 1) * (rects[i][3] - rects[i][1] + 1);
            this.areas[i] = area;
            this.totalArea += area;
        }
    }

    pick() {
        let rnd = Math.floor(Math.random() * this.totalArea);
        let idx = 0;

        while (rnd >= this.areas[idx]) {
            rnd -= this.areas[idx];
            idx++;
        }

        const x = this.rects[idx][0] + Math.floor(Math.random() * (this.rects[idx][2] - this.rects[idx][0] + 1));
        const y = this.rects[idx][1] + Math.floor(Math.random() * (this.rects[idx][3] - this.rects[idx][1] + 1));

        return [x, y];
    }
}


-----
class Solution 
    // Your code here
}


************************************
Question ID: 498
function findDiagonalOrder(mat) {
    const m = mat.length;
    const n = mat[0].length;
    const result = new Array(m * n);
    let row = 0, col = 0;
    for (let i = 0; i < m * n; i++) {
        result[i] = mat[row][col];
        if ((row + col) % 2 === 0) {
            if (col === n - 1) {
                row++;
            } else if (row === 0) {
                col++;
            } else {
                row--;
                col++;
            }
        } else {
            if (row === m - 1) {
                col++;
            } else if (col === 0) {
                row++;
            } else {
                row++;
                col--;
            }
        }
    }
    return result;
}

-----
function findDiagonalOrder(mat) 
    // Your code here
}

************************************
Question ID: 499
class Solution {
    findShortestWay(maze, ball, hole) {
        const m = maze.length, n = maze[0].length;
        const dist = Array.from({ length: m }, () => Array(n).fill(Infinity));
        const dirs = ["d", "l", "r", "u"];
        const dirs_vector = [[1, 0], [0, -1], [0, 1], [-1, 0]];
        dist[ball[0]][ball[1]] = 0;
        const pq = [[0, "", ball[0], ball[1]]];

        while (pq.length > 0) {
            pq.sort((a, b) => a[0] - b[0] || a[1].localeCompare(b[1]));
            const [cur_dist, cur_path, x, y] = pq.shift();
            if (x === hole[0] && y === hole[1]) return cur_path;

            for (let k = 0; k < 4; ++k) {
                let dist_move = 0, r = x, c = y;
                while (r >= 0 && r < m && c >= 0 && c < n && maze[r][c] === 0 && (r !== hole[0] || c !== hole[1])) {
                    r += dirs_vector[k][0];
                    c += dirs_vector[k][1];
                    ++dist_move;
                }
                r -= dirs_vector[k][0];
                c -= dirs_vector[k][1];
                --dist_move;

                if (dist[x][y] + dist_move < dist[r][c]) {
                    dist[r][c] = dist[x][y] + dist_move;
                    pq.push([cur_dist + dist_move, cur_path + dirs[k], r, c]);
                }
            }
        }

        return "impossible";
    }
}

-----
class Solution 
    // Your code here
}

************************************
Question ID: 500
function findWords(words) {
    const rows = [
        new Set("qwertyuiopQWERTYUIOP".split('')),
        new Set("asdfghjklASDFGHJKL".split('')),
        new Set("zxcvbnmZXCVBNM".split(''))
    ];
    const res = [];

    for (const word of words) {
        let row = -1;
        for (let i = 0; i < 3; i++) {
            if (rows[i].has(word[0])) {
                row = i;
                break;
            }
        }

        if (word.split('').every(c => rows[row].has(c))) {
            res.push(word);
        }
    }

    return res;
}


-----
function findWords(words) 
    // Your code here
}


************************************
Question ID: 501
function findMode(root) {
    if (!root) return [];
    
    const frequencies = new Map();
    const stack = [];
    let maxFrequency = 0;
    let currentNode = root;
    
    while (currentNode || stack.length) {
        while (currentNode) {
            stack.push(currentNode);
            currentNode = currentNode.left;
        }
        currentNode = stack.pop();
        frequencies.set(currentNode.val, (frequencies.get(currentNode.val) || 0) + 1);
        maxFrequency = Math.max(maxFrequency, frequencies.get(currentNode.val));
        currentNode = currentNode.right;
    }
    
    const modes = [];
    for (const [key, value] of frequencies) {
        if (value === maxFrequency) modes.push(key);
    }
    
    return modes;
}

-----
function findMode(root) 
    // Your code here
}

************************************
Question ID: 502
function findMaximizedCapital(k, w, profits, capital) {
    const project_pool = profits.map((p, i) => [capital[i], p]).sort((a, b) => a[0] - b[0]);
    const profit_pool = new MaxPriorityQueue();
    let index = 0;

    for (let i = 0; i < k; i++) {
        while (index < project_pool.length && project_pool[index][0] <= w) {
            profit_pool.insert(project_pool[index++][1]);
        }

        if (!profit_pool.isEmpty()) {
            w += profit_pool.removeMax();
        } else {
            break;
        }
    }

    return w;
}

class MaxPriorityQueue {
    constructor() {
        this.queue = [];
    }
    
    insert(value) {
        this.queue.push(value);
        this.siftUp(this.queue.length - 1);
    }
    
    removeMax() {
        const maxValue = this.queue[0];
        const lastValue = this.queue.pop();
        
        if (this.queue.length) {
            this.queue[0] = lastValue;
            this.siftDown(0);
        }
        
        return maxValue;
    }
    
    siftUp(index) {
        while (index) {
            const parentIndex = (index - 1) >> 1;
            if (this.queue[parentIndex] >= this.queue[index]) break;
            [this.queue[parentIndex], this.queue[index]] = [this.queue[index], this.queue[parentIndex]];
            index = parentIndex;
        }
    }
    
    siftDown(index) {
        while (true) {
            const leftIndex = (index << 1) + 1;
            const rightIndex = leftIndex + 1;
            let maxIndex = index;
            if (leftIndex < this.queue.length && this.queue[leftIndex] > this.queue[maxIndex]) maxIndex = leftIndex;
            if (rightIndex < this.queue.length && this.queue[rightIndex] > this.queue[maxIndex]) maxIndex = rightIndex;
            if (maxIndex === index) break;
            [this.queue[index], this.queue[maxIndex]] = [this.queue[maxIndex], this.queue[index]];
            index = maxIndex;
        }
    }
    
    isEmpty() {
        return this.queue.length === 0;
    }
}

-----
function findMaximizedCapital(k, w, profits, capital) 
    // Your code here
}

************************************
Question ID: 503
function nextGreaterElements(nums) {
  const result = new Array(nums.length).fill(-1);
  const stack = [];

  for (let i = 0; i < nums.length * 2; i++) {
    const index = i % nums.length;
    while (stack.length > 0 && nums[stack[stack.length - 1]] < nums[index]) {
      result[stack.pop()] = nums[index];
    }
    if (i < nums.length) {
      stack.push(index);
    }
  }
  return result;
}

-----
function nextGreaterElements(nums) 
    // Your code here
}

************************************
Question ID: 504
function convertToBase7(num) {
    if (num === 0) return "0";
    let result = "";
    let negative = num < 0;
    if (negative) num *= -1;
    while (num > 0) {
        result = (num % 7).toString() + result;
        num = Math.floor(num / 7);
    }
    return negative ? "-" + result : result;
}

-----
function convertToBase7(num) 
    // Your code here
}

************************************
Question ID: 505
function shortestDistance(maze, start, destination) {
    const m = maze.length, n = maze[0].length;
    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
    const dist = new Array(m).fill(null).map(() => new Array(n).fill(-1));

    const q = [[start[0], start[1], 0]];
    dist[start[0]][start[1]] = 0;

    while (q.length) {
        const [x, y, d] = q.shift();

        for (const dir of directions) {
            let newX = x + dir[0];
            let newY = y + dir[1];
            let step = 0;

            while (0 <= newX && newX < m && 0 <= newY && newY < n && maze[newX][newY] === 0) {
                newX += dir[0];
                newY += dir[1];
                step++;
            }

            newX -= dir[0];
            newY -= dir[1];

            if (dist[newX][newY] === -1 || dist[x][y] + step < dist[newX][newY]) {
                dist[newX][newY] = dist[x][y] + step;
                q.push([newX, newY, dist[newX][newY]]);
            }
        }
    }

    return dist[destination[0]][destination[1]];
}


-----
function shortestDistance(maze, start, destination) 
    // Your code here
}


************************************
Question ID: 506
function findRelativeRanks(score) {
    const rankSort = [...Array(score.length).keys()].sort((a, b) => score[b] - score[a]);
    const result = new Array(score.length);
    for (let i = 0; i < rankSort.length; ++i) {
        result[rankSort[i]] = i + 1;
    }
    return result;
}


-----
function findRelativeRanks(score) 
    // Your code here
}


************************************
Question ID: 507
function checkPerfectNumber(num) {
    if (num <= 1) return false;
    let sum = 1;
    for (let i = 2; i * i <= num; i++) {
        if (num % i === 0) {
            sum += i;
            if (i * i !== num) sum += num / i;
        }
    }
    return sum === num;
}

-----
function checkPerfectNumber(num) 
    // Your code here
}

************************************
Question ID: 508
function helper(root, counts) {
    if (!root) return 0;
    const sum = root.val + helper(root.left, counts) + helper(root.right, counts);
    counts[sum] = (counts[sum] || 0) + 1;
    return sum;
}

function findFrequentTreeSum(root) {
    const counts = {};
    helper(root, counts);
    const maxCount = Math.max(...Object.values(counts));
    return Object.keys(counts).filter(key => counts[key] === maxCount).map(Number);
}


-----
function helper(root, counts) 
    // Your code here
}


************************************
Question ID: 509
function fib(n) {
    if(n < 2) {
        return n;
    }
    let a = 0, b = 1, c;
    for(let i = 2; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    return b;
}

-----
function fib(n) 
    // Your code here
}

************************************
Question ID: 513
function findBottomLeftValue(root) {
    const result = { maxDepth: 0, value: 0 };
    helper(root, 1, result);
    return result.value;
};

function helper(node, depth, result) {
    if (!node) return;
    if (depth > result.maxDepth) {
        result.maxDepth = depth;
        result.value = node.val;
    }
    helper(node.left, depth+1, result);
    helper(node.right, depth+1, result);
}


-----
function findBottomLeftValue(root) 
    // Your code here
}


************************************
Question ID: 514
function findRotateSteps(ring, key) {
    const n = ring.length, m = key.length;
    const dp = Array.from({ length: m + 1 }, () => new Array(n).fill(0));

    for (let i = m - 1; i >= 0; --i) {
        for (let j = 0; j < n; ++j) {
            dp[i][j] = Infinity;
            for (let k = 0; k < n; ++k) {
                if (ring[k] === key[i]) {
                    const diff = Math.abs(j - k);
                    const step = Math.min(diff, n - diff);
                    dp[i][j] = Math.min(dp[i][j], step + dp[i + 1][k]);
                }
            }
        }
    }

    return dp[0][0] + m;
}


-----
function findRotateSteps(ring, key) 
    // Your code here
}


************************************
Question ID: 515
class TreeNode {
    constructor(val, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

function largestValues(root) {
    if (!root) return [];
    const result = [];
    const queue = [root];

    while (queue.length) {
        const size = queue.length;
        let maxVal = Number.MIN_SAFE_INTEGER;
        for (let i = 0; i < size; i++) {
            const node = queue.shift();
            maxVal = Math.max(maxVal, node.val);

            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
        result.push(maxVal);
    }
    return result;
}

-----
class TreeNode 
    // Your code here
}

************************************
Question ID: 516
function longestPalindromeSubseq(s) {
    const n = s.length;
    const dp = Array.from({ length: n }, () => Array(n).fill(0));

    for (let i = n - 1; i >= 0; i--) {
        dp[i][i] = 1;
        for (let j = i + 1; j < n; j++) {
            if (s[i] === s[j]) {
                dp[i][j] = 2 + dp[i + 1][j - 1];
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }

    return dp[0][n - 1];
}

-----
function longestPalindromeSubseq(s) 
    // Your code here
}

************************************
Question ID: 517
function findMinMoves(machines) {
    let n = machines.length;
    let totalDresses = machines.reduce((a, b) => a + b, 0);
    if (totalDresses % n !== 0) return -1;
    let average = totalDresses / n;
    let moves = 0, imbalance = 0;
    
    for (let i = 0; i < n; i++) {
        imbalance += machines[i] - average;
        moves = Math.max(moves, Math.max(Math.abs(imbalance), machines[i] - average));
    }
    
    return moves;
}

-----
function findMinMoves(machines) 
    // Your code here
}

************************************
Question ID: 518
function change(amount, coins) {
    let dp = new Array(amount + 1).fill(0);
    dp[0] = 1;
    for (let coin of coins) {
        for (let i = coin; i <= amount; i++) {
            dp[i] += dp[i - coin];
        }
    }
    return dp[amount];
}

-----
function change(amount, coins) 
    // Your code here
}

************************************
Question ID: 519
class Solution {
    constructor(m, n) {
        this.m = m;
        this.n = n;
        this.total = m * n;
        this.matrix = Array.from({ length: m }, () => new Array(n).fill(0));
    }

    flip() {
        const idx = Math.floor(Math.random() * this.total);
        this.total--;

        for (let i = 0; i < this.m; i++) {
            for (let j = 0; j < this.n; j++) {
                if (this.matrix[i][j] === 0) {
                    if (idx === 0) {
                        this.matrix[i][j] = 1;
                        return [i, j];
                    }
                    idx--;
                }
            }
        }
        return [-1, -1]; // This line should never be reached
    }

    reset() {
        this.total = this.m * this.n;
        for (let i = 0; i < this.m; i++) {
            for (let j = 0; j < this.n; j++) {
                this.matrix[i][j] = 0;
            }
        }
    }
}


-----
class Solution 
    // Your code here
}


************************************
Question ID: 520
function detectCapitalUse(word) {
    let numCapital = 0;
    for (let c of word) {
        if (c === c.toUpperCase()) numCapital++;
    }
    return numCapital === 0 || numCapital === word.length || (numCapital === 1 && word[0] === word[0].toUpperCase());
}


-----
function detectCapitalUse(word) 
    // Your code here
}


************************************
Question ID: 521
function findLUSlength(a, b) {
    if (a === b) {
        return -1;
    }
    return Math.max(a.length, b.length);
}

-----
function findLUSlength(a, b) 
    // Your code here
}

************************************
Question ID: 522
function findLUSlength(strs) {
    let maxLength = -1;
    for(let i = 0; i < strs.length; ++i) {
        let isUncommon = true;
        for(let j = 0; j < strs.length; ++j) {
            if(i != j && strs[j].includes(strs[i])) {
                isUncommon = false;
                break;
            }
        }
        if(isUncommon) {
            maxLength = Math.max(maxLength, strs[i].length);
        }
    }
    return maxLength;
}


-----
function findLUSlength(strs) 
    // Your code here
}


************************************
Question ID: 523
function checkSubarraySum(nums, k) {
    let n = nums.length, sum = 0, mp = new Map();
    mp.set(0, -1);
    for (let i = 0; i < n; i++) {
        sum += nums[i];
        if (k !== 0) sum %= k;
        if (mp.has(sum)) {
            if (i - mp.get(sum) > 1) return true;
        } else {
            mp.set(sum, i);
        }
    }
    return false;
}

-----
function checkSubarraySum(nums, k) 
    // Your code here
}

************************************
Question ID: 524
function findLongestWord(s, dictionary) {
    function isSubsequence(s, word) {
        let i = 0, j = 0;
        while (i < s.length && j < word.length) {
            if (s[i] === word[j]) {
                j++;
            }
            i++;
        }
        return j === word.length;
    }

    dictionary.sort();
    let longest = '';
    for (let word of dictionary) {
        if (isSubsequence(s, word)) {
            if (word.length > longest.length) {
                longest = word;
            }
        }
    }
    return longest;
}


-----
function findLongestWord(s, dictionary) 
    // Your code here
}


************************************
Question ID: 525
function findMaxLength(nums) {
    let counts = new Map();
    counts.set(0, -1);
    let max_len = 0, count = 0;
    for (let i = 0; i < nums.length; i++) {
        count += (nums[i] === 1) ? 1 : -1;
        if (counts.has(count))
            max_len = Math.max(max_len, i - counts.get(count));
        else
            counts.set(count, i);
    }
    return max_len;
}

-----
function findMaxLength(nums) 
    // Your code here
}

************************************
Question ID: 526
function countArrangement(n) {
    let res=0;
    let visited=Array(n+1).fill(false); 
    helper(n,1,visited); 
    return res;

    function helper(n, idx, visited) {
        if (idx > n) {
            ++res;
        }

        for(let i=1; i<=n; i++){
            if (!visited[i] && (idx % i === 0 || i % idx === 0)) { 
                visited[i] = true; 
                helper(n, idx+1, visited); 
                visited[i] = false; 
            }
        }
    }
}

-----
function countArrangement(n) 
    // Your code here
}

************************************
Question ID: 527
function wordsAbbreviation(words) {
    function abbrev(word, k) {
        return k < word.length - 2 ? word.slice(0, k + 1) + (word.length - k - 2) + word.slice(-1) : word;
    }

    const n = words.length;
    const abbr = words.map(word => abbrev(word, 1));
    const prefixLen = new Array(n).fill(1);

    for (let i = 0; i < n; i++) {
        while (abbr.filter(a => a === abbr[i]).length > 1) {
            const groups = {};
            for (let j = i + 1; j < n; j++) {
                if (abbr[i] === abbr[j]) {
                    if (!groups[abbr[j]]) {
                        groups[abbr[j]] = [];
                    }
                    groups[abbr[j]].push(j);
                }
            }
            for (const groupMembers of Object.values(groups)) {
                for (const j of groupMembers) {
                    abbr[j] = abbrev(words[j], prefixLen[j] + 1);
                    prefixLen[j]++;
                }
            }
            abbr[i] = abbrev(words[i], prefixLen[i] + 1);
            prefixLen[i]++;
        }
    }

    return abbr;
}

-----
function wordsAbbreviation(words) 
    // Your code here
}

************************************
Question ID: 529

-----

    // Your code here

************************************
Question ID: 531
function findLonelyPixel(picture) {
    let m = picture.length, n = picture[0].length;
    let row = new Array(m).fill(0), col = new Array(n).fill(0);
    
    for(let i = 0; i < m; ++i) {
        for(let j = 0; j < n; ++j) {
            if(picture[i][j] == 'B') {
                row[i]++;
                col[j]++;
            }
        }
    }
    
    let lonely = 0;
    for(let i = 0; i < m; ++i) {
        for(let j = 0; j < n; ++j) {
            if(picture[i][j] == 'B' && row[i] == 1 && col[j] == 1) {
                lonely++;
            }
        }
    }
    
    return lonely;
}

-----
function findLonelyPixel(picture) 
    // Your code here
}

************************************
Question ID: 532
function findPairs(nums, k) {
    if (k < 0) return 0;
    let starters = new Set();
    let occurrences = new Map();
    for (let num of nums) {
        if (occurrences.has(num + k)) starters.add(num);
        if (occurrences.has(num - k)) starters.add(num - k);
        occurrences.set(num, (occurrences.get(num) || 0) + 1);
    }
    return starters.size;
}

-----
function findPairs(nums, k) 
    // Your code here
}

************************************
Question ID: 533
function findBlackPixel(picture, target) {
    const m = picture.length;
    const n = picture[0].length;
    const rows = new Array(m).fill(0);
    const cols = new Array(n).fill(0);
    const rowCounts = new Map();
    for (let i = 0; i < m; ++i) {
        let row = "";
        for (let j = 0; j < n; ++j) {
            if (picture[i][j] === 'B') {
                rows[i]++;
                cols[j]++;
            }
            row += picture[i][j];
        }
        if (rows[i] === target)
            rowCounts.set(row, (rowCounts.get(row) || 0) + 1);
    }
    let ans = 0;
    for (let [row, count] of rowCounts.entries()) {
        if (count === target) {
            for (let j = 0; j < n; ++j) {
                if (row[j] === 'B' && cols[j] === target)
                    ans += count;
            }
        }
    }
    return ans;
}

-----
function findBlackPixel(picture, target) 
    // Your code here
}

************************************
Question ID: 535
class Solution {
    constructor() {
        this.urlMap = new Map();
        this.alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    }

    encode(longUrl) {
        let key;

        do {
            key = Array.from({ length: 6 }, () => this.alphabet.charAt(Math.floor(Math.random() * this.alphabet.length))).join('');
        } while (this.urlMap.has(key));

        this.urlMap.set(key, longUrl);

        return 'http://tinyurl.com/' + key;
    }

    decode(shortUrl) {
        return this.urlMap.get(shortUrl.substr(-6));
    }
}

-----
class Solution 
    // Your code here
}

************************************
Question ID: 537
function complexNumberMultiply(num1, num2) {
    const [real1, imag1] = num1.slice(0, -1).split('+').map(Number);
    const [real2, imag2] = num2.slice(0, -1).split('+').map(Number);

    const real = real1 * real2 - imag1 * imag2;
    const imag = real1 * imag2 + real2 * imag1;

    return `${real}+${imag}i`;
}

-----
function complexNumberMultiply(num1, num2) 
    // Your code here
}

************************************
Question ID: 539
function findMinDifference(timePoints) {
    timePoints.sort();
    let minDifference = Infinity;

    for (let i = 0; i < timePoints.length; ++i) {
        const [h1, m1] = timePoints[i].split(':').map(Number);
        const [h2, m2] = timePoints[(i + 1) % timePoints.length].split(':').map(Number);
        const curDifference = Math.abs((h1 * 60 + m1) - (h2 * 60 + m2));
        minDifference = Math.min(minDifference, curDifference > 720 ? 1440 - curDifference : curDifference);
    }

    return minDifference;
}

-----
function findMinDifference(timePoints) 
    // Your code here
}

************************************
Question ID: 540
function singleNonDuplicate(nums) {
    let low = 0, high = nums.length - 1;
    while (low < high) {
        let mid = low + Math.floor((high - low) / 2);
        if (mid % 2 === 1)
            mid--;
        if (nums[mid] === nums[mid + 1])
            low = mid + 2;
        else
            high = mid;
    }
    return nums[low];
}

-----
function singleNonDuplicate(nums) 
    // Your code here
}

************************************
Question ID: 541
function reverseStr(s, k) {
    let chars = s.split("");
    for (let i = 0; i < chars.length; i += 2 * k) {
        let left = i;
        let right = Math.min(i + k - 1, chars.length - 1);
        while (left < right) {
            [chars[left++], chars[right--]] = [chars[right], chars[left]];
        }
    }
    return chars.join("");
}

-----
function reverseStr(s, k) 
    // Your code here
}

************************************
Question ID: 542
function updateMatrix(mat) {
    let m = mat.length;
    let n = mat[0].length;
    let distance = Array.from({ length: m }, () => Array.from({ length: n }, () => Infinity));
    let queue = [];

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (mat[i][j] === 0) {
                distance[i][j] = 0;
                queue.push([i, j]);
            }
        }
    }

    let directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];
    while (queue.length) {
        let [x, y] = queue.shift();
        for (const [dx, dy] of directions) {
            let newX = x + dx;
            let newY = y + dy;
            if (newX >= 0 && newY >= 0 && newX < m && newY < n && distance[newX][newY] > distance[x][y] + 1) {
                distance[newX][newY] = distance[x][y] + 1;
                queue.push([newX, newY]);
            }
        }
    }
    return distance;
}


-----
function updateMatrix(mat) 
    // Your code here
}


************************************
Question ID: 544
function findContestMatch(n) {
    let matches = Array.from({length: n}, (_, i) => String(i + 1));
    
    while (n > 1) {
        for (let i = 0; i < (n / 2); i++) {
            matches[i] = "(" + matches[i] + "," + matches[n - 1 - i] + ")";
        }
        n = Math.floor(n / 2);
    }
    
    return matches[0];
}


-----
function findContestMatch(n) 
    // Your code here
}


************************************
Question ID: 546
function removeBoxes(boxes) {
    const dfs = (l, r, k) => {
        if (l > r) return 0;
        if (dp[l][r][k] !== 0) return dp[l][r][k];

        while (r > l && boxes[r] == boxes[r - 1]) {r--; k++;}

        dp[l][r][k] = (k + 1) * (k + 1) + dfs(l, r - 1, 0);

        for (let i = l; i < r; i++) {
            if (boxes[i] == boxes[r]) {
                dp[l][r][k] = Math.max(dp[l][r][k], dfs(l, i, k + 1) + dfs(i + 1, r - 1, 0));
            }
        }

        return dp[l][r][k];
    };

    let dp = Array.from({ length: 100 }, () => Array.from({ length: 100 }, () => Array(100).fill(0)));
    return dfs(0, boxes.length - 1, 0);
}

-----
function removeBoxes(boxes) 
    // Your code here
}

************************************
Question ID: 547
function findCircleNum(isConnected) {
    function dfs(isConnected, visited, i) {
        visited[i] = true;
        for (let j = 0; j < isConnected.length; j++) {
            if (isConnected[i][j] === 1 && !visited[j]) {
                dfs(isConnected, visited, j);
            }
        }
    }

    let provinces = 0;
    const visited = new Array(isConnected.length).fill(false);
    for (let i = 0; i < isConnected.length; i++) {
        if (!visited[i]) {
            dfs(isConnected, visited, i);
            provinces++;
        }
    }
    return provinces;
}

-----
function findCircleNum(isConnected) 
    // Your code here
}

************************************
Question ID: 548
function find_triplet_equal_sum(nums) {
    const n = nums.length;
    const prefix_sum = new Array(n + 1).fill(0);

    for (let i = 0; i < n; ++i) {
        prefix_sum[i + 1] = prefix_sum[i] + nums[i];
    }

    for (let i = 1; i + 2 < n; ++i) {
        for (let j = i + 2; j + 1 < n; ++j) {
            for (let k = j + 2; k < n; ++k) {
                const s1 = prefix_sum[i];
                const s2 = prefix_sum[j] - prefix_sum[i + 1];
                const s3 = prefix_sum[k] - prefix_sum[j + 1];
                const s4 = prefix_sum[n] - prefix_sum[k + 1];
                if (s1 === s2 && s2 === s3 && s3 === s4) {
                    return true;
                }
            }
        }
    }
    return false;
}

-----
function find_triplet_equal_sum(nums) 
    // Your code here
}

************************************
Question ID: 551
function checkRecord(s) {
    let late = 0, absent = 0;
    for (let i = 0; i < s.length; i++) {
        if (s[i] === 'A') {
            absent++;
            late = 0;
        } else if (s[i] === 'L') {
            late++;
        } else {
            late = 0;
        }

        if (absent >= 2 || late >= 3) return false;
    }
    return true;
}

-----
function checkRecord(s) 
    // Your code here
}

************************************
Question ID: 552
function checkRecord(n) {
    let M = 1000000007;
    let dp = Array(6).fill(1);  // [latent state 0, latent state 1, ..., latent state 5]
    while (n--) {
        let next_dp = Array(6).fill(0);
        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M;
        next_dp[1] = dp[0];
        next_dp[2] = dp[1];
        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M;
        next_dp[4] = dp[3];
        next_dp[5] = dp[4];
        dp = next_dp;
    }
    return dp.reduce((sum, val) => (sum + val) % M, 0);
}


-----
function checkRecord(n) 
    // Your code here
}


************************************
Question ID: 553
function optimalDivision(nums) {
    const n = nums.length;
    if (n === 1) return nums[0].toString();
    if (n === 2) return nums[0].toString() + '/' + nums[1].toString();
    let res = nums[0].toString() + '/(';
    for (let i = 1; i < n - 1; ++i) {
        res += nums[i].toString() + '/';
    }
    res += nums[n - 1].toString() + ')';
    return res;
}


-----
function optimalDivision(nums) 
    // Your code here
}


************************************
Question ID: 554
function leastBricks(wall) {
    const edgeCount = new Map();
    let maxCount = 0;

    for (const row of wall) {
        let edgePosition = 0;
        for (let i = 0; i < row.length - 1; ++i) {
            edgePosition += row[i];
            edgeCount.set(edgePosition, (edgeCount.get(edgePosition) || 0) + 1);
            maxCount = Math.max(maxCount, edgeCount.get(edgePosition));
        }
    }

    return wall.length - maxCount;
}


-----
function leastBricks(wall) 
    // Your code here
}


************************************
Question ID: 555
function splitLoopedString(strs) {
    let ans = "", cur = "";
    strs.forEach(s => {
        const rev = s.split('').reverse().join('');
        cur += s > rev ? s : rev;
    });

    for (let i = 0, k = 0; i < strs.length; i++) {
        let rev = strs[i].split('').reverse().join('');
        [strs[i], rev].forEach(xstr => {
            for (let j = 0; j < xstr.length; j++) {
                let t = xstr.slice(j) + cur.slice(k + xstr.length) + cur.slice(0, k) + xstr.slice(0, j);
                ans = ans > t ? ans : t;
            }
        });
        k += strs[i].length;
    }
    return ans;
}

-----
function splitLoopedString(strs) 
    // Your code here
}

************************************
Question ID: 556
function nextGreaterElement(n) {
    const numStr = n.toString();
    let numArr = numStr.split('');
    let i, j;

    for (i = numArr.length - 1; i > 0; i--) {
        if (+numArr[i - 1] < +numArr[i]) break;
    }

    if (i === 0) return -1;

    let x = +numArr[i - 1], smallest = i;
    for (j = i + 1; j < numArr.length; j++) {
        if (+numArr[j] > x && +numArr[j] < +numArr[smallest]) {
            smallest = j;
        }
    }

    [numArr[smallest], numArr[i - 1]] = [numArr[i - 1], numArr[smallest]];

    numArr = [...numArr.slice(0, i), ...numArr.slice(i).sort()];

    const result = parseInt(numArr.join(''), 10);

    return (result <= Math.pow(2, 31) - 1) ? result : -1;
}

-----
function nextGreaterElement(n) 
    // Your code here
}

************************************
Question ID: 557
function reverseWordsInString(s) {
    return s.split(' ').map(word => word.split('').reverse().join('')).join(' ');
}

-----
function reverseWordsInString(s) 
    // Your code here
}

************************************
Question ID: 560
function subarraySum(nums, k) {
    const prefixSumFrequency = {0: 1};
    let prefixSum = 0, result = 0;
    
    for (const num of nums) {
        prefixSum += num;
        result += (prefixSumFrequency[prefixSum - k] || 0);
        prefixSumFrequency[prefixSum] = (prefixSumFrequency[prefixSum] || 0) + 1;
    }
    
    return result;
}

-----
function subarraySum(nums, k) 
    // Your code here
}

************************************
Question ID: 561
function arrayPairSum(nums) {
    nums.sort((a, b) => a - b);
    let sum = 0;
    for (let i = 0; i < nums.length; i += 2) {
        sum += nums[i];
    }
    return sum;
}

-----
function arrayPairSum(nums) 
    // Your code here
}

************************************
Question ID: 562
function longestLine(mat) {
    const rows = mat.length;
    const cols = mat[0].length;
    let max_length = 0;
    const dp = Array.from(Array(rows), () => Array.from(Array(cols), () => Array(4).fill(0)));

    for (let r = 0; r < rows; ++r) {
        for (let c = 0; c < cols; ++c) {
            if (mat[r][c] === 1) {
                dp[r][c][0] = r > 0 ? dp[r - 1][c][0] + 1 : 1;
                dp[r][c][1] = c > 0 ? dp[r][c - 1][1] + 1 : 1;
                dp[r][c][2] = (r > 0 && c > 0) ? dp[r - 1][c - 1][2] + 1 : 1;
                dp[r][c][3] = (r > 0 && c < cols - 1) ? dp[r - 1][c + 1][3] + 1 : 1;
                max_length = Math.max(max_length, Math.max(...dp[r][c]));
            }
        }
    }
    return max_length;
}


-----
function longestLine(mat) 
    // Your code here
}


************************************
Question ID: 563
function findTilt(root) {
    function findTiltUtil(node) {
        if (!node) return [0, 0];
        
        let [leftSum, leftTilt] = findTiltUtil(node.left);
        let [rightSum, rightTilt] = findTiltUtil(node.right);
    
        return [node.val + leftSum + rightSum, Math.abs(leftSum - rightSum) + leftTilt + rightTilt];
    }

    return findTiltUtil(root)[1];
};


-----
function findTilt(root) 
    // Your code here
};


************************************
Question ID: 564
function isPalindrome(str) {
    let left = 0;
    let right = str.length - 1;

    while (left < right) {
        if (str[left] !== str[right]) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}

function closestPalindrome(n) {
    const num = parseInt(n);
    let left = num - 1;
    let right = num + 1;

    while (true) {
        if (isPalindrome(left.toString())) {
            return left;
        }
        if (isPalindrome(right.toString())) {
            return right;
        }
        left--;
        right++;
    }
}

-----
function isPalindrome(str) 
    // Your code here
}

************************************
Question ID: 565
function arrayNesting(nums) {
    let n = nums.length;
    let max_len = 0;
    for (let i = 0; i < n; ++i) {
        if (nums[i] !== -1) {       
            let start = nums[i];
            let count = 0;
            while (nums[start] !== -1) {
                let temp = start;
                start = nums[start];
                count++;
                nums[temp] = -1;
            }
            max_len = Math.max(max_len, count);
        }
    }
    return max_len;
}

-----
function arrayNesting(nums) 
    // Your code here
}

************************************
Question ID: 566
function matrixReshape(mat, r, c) {
    const m = mat.length;
    const n = mat[0].length;
    if (m * n !== r * c) {
        return mat;
    }

    const reshaped = new Array(r).fill(null).map(() => new Array(c));
    for (let i = 0; i < m * n; ++i) {
        reshaped[Math.floor(i / c)][i % c] = mat[Math.floor(i / n)][i % n];
    }

    return reshaped;
}

-----
function matrixReshape(mat, r, c) 
    // Your code here
}

************************************
Question ID: 567
function checkInclusion(s1, s2) {
    if (s1.length > s2.length) return false;
    const s1_map = new Array(26).fill(0);
    const s2_map = new Array(26).fill(0);

    for (let i = 0; i < s1.length; i++) {
        s1_map[s1.charCodeAt(i) - 'a'.charCodeAt(0)]++;
        s2_map[s2.charCodeAt(i) - 'a'.charCodeAt(0)]++;
    }

    for (let i = 0; i < s2.length - s1.length; i++) {
        if (s1_map.every((val, idx) => val === s2_map[idx])) return true;
        s2_map[s2.charCodeAt(i) - 'a'.charCodeAt(0)]--;
        s2_map[s2.charCodeAt(i + s1.length) - 'a'.charCodeAt(0)]++;
    }

    return s1_map.every((val, idx) => val === s2_map[idx]);
}


-----
function checkInclusion(s1, s2) 
    // Your code here
}


************************************
Question ID: 568
function maxVacationDays(flights, days) {
    let n = flights.length;
    let k = days[0].length;
    let memo = new Array(n).fill(null).map(() => new Array(k).fill(-1));

    function dfs(week, city) {
        if (week === k) {
            return 0;
        }
        if (memo[city][week] !== -1) {
            return memo[city][week];
        }

        let maxVacation = days[city][week] + dfs(week + 1, city);

        for (let i = 0; i < n; i++) {
            if (flights[city][i] === 1) {
                maxVacation = Math.max(maxVacation, days[i][week] + dfs(week + 1, i));
            }
        }

        memo[city][week] = maxVacation;
        return maxVacation;
    }

    return dfs(0, 0);
}


-----
function maxVacationDays(flights, days) 
    // Your code here
}


************************************
Question ID: 572

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
        
def isSubtree(root, subRoot):
    if root is None:
        return False
    if is_identical(root, subRoot):
        return True
    return isSubtree(root.left, subRoot) or isSubtree(root.right, subRoot)

def is_identical(n1, n2):
    if n1 is None or n2 is None:
        return n1 == n2
    if n1.val != n2.val:
        return False
    return is_identical(n1.left, n2.left) and is_identical(n1.right, n2.right)
```


-----

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
        
def isSubtree(root, subRoot):
    if root is None:
        return False
    if is_identical(root, subRoot):
        return True
    return isSubtree(root.left, subRoot) or isSubtree(root.right, subRoot)

def is_identical(n1, n2):
    if n1 is None or n2 is None:
        return n1 == n2
    if n1.val != n2.val:
        return False
    return is_identical(n1.left, n2.left) and is_identical(n1.right, n2.right)
```

    // Your code here


************************************
Question ID: 573
function minDistance(height, width, tree, squirrel, nuts) {
    let totalDist = 0;
    let minDiff = Infinity;
    
    for (let nut of nuts) {
        let treeDist = Math.abs(tree[0] - nut[0]) + Math.abs(tree[1] - nut[1]);
        let squirrelDist = Math.abs(squirrel[0] - nut[0]) + Math.abs(squirrel[1] - nut[1]);
        
        totalDist += 2 * treeDist;
        minDiff = Math.min(minDiff, squirrelDist - treeDist);
    }
    
    return totalDist + minDiff;
}


-----
function minDistance(height, width, tree, squirrel, nuts) 
    // Your code here
}


************************************
Question ID: 575
function maxNumberOfCandies(candyType) {
    const uniqueCandies = new Set(candyType);
    return Math.min(uniqueCandies.size, candyType.length / 2);
}


-----
function maxNumberOfCandies(candyType) 
    // Your code here
}


************************************
Question ID: 576
function findPaths(m, n, maxMove, startRow, startColumn) {
    const MOD = 1e9 + 7;
    let dp = new Array(maxMove + 1).fill(0).map(() => new Array(m).fill(0).map(() => new Array(n).fill(0)));
    let moves = [[-1, 0], [1, 0], [0, -1], [0, 1]];

    for (let k = 1; k <= maxMove; k++) {
        for (let i = 0; i < m; i++) {
            for (let j = 0; j < n; j++) {
                for (let move of moves) {
                    let ni = i + move[0], nj = j + move[1];
                    if (ni < 0 || ni >= m || nj < 0 || nj >= n) {
                        dp[k][i][j] = (dp[k][i][j] + 1) % MOD;
                    } else {
                        dp[k][i][j] = (dp[k][i][j] + dp[k - 1][ni][nj]) % MOD;
                    }
                }
            }
        }
    }
    return dp[maxMove][startRow][startColumn];
}

-----
function findPaths(m, n, maxMove, startRow, startColumn) 
    // Your code here
}

************************************
Question ID: 581
function findUnsortedSubarray(nums) {
    const sortedNums = [...nums].sort((a, b) => a - b);
    let start = 0, end = nums.length - 1;
    while (start < nums.length && nums[start] === sortedNums[start]) start++;
    while (end > start && nums[end] === sortedNums[end]) end--;
    return end - start + 1;
}

-----
function findUnsortedSubarray(nums) 
    // Your code here
}

************************************
Question ID: 582
function killProcess(pid, ppid, kill) {
  const children = new Map();
  for (let i = 0; i < pid.length; i++) {
    if (!children.has(ppid[i])) children.set(ppid[i], []);
    children.get(ppid[i]).push(pid[i]);
  }

  const killed = [];
  function dfs(id) {
    killed.push(id);
    const childList = children.get(id) || [];
    for (const child of childList) {
      dfs(child);
    }
  }
  dfs(kill);

  return killed;
}

-----
function killProcess(pid, ppid, kill) 
    // Your code here
}

************************************
Question ID: 583
function minDistance(word1, word2) {
    let m = word1.length, n = word2.length;
    let dp = new Array(m + 1).fill().map(() => new Array(n + 1).fill(0));

    for(let i = 0; i <= m; i++) {
        for(let j = 0; j <= n; j++) {
            if(i === 0 || j === 0)
                dp[i][j] = i + j;
            else if(word1.charAt(i-1) === word2.charAt(j-1))
                dp[i][j] = dp[i-1][j-1];
            else
                dp[i][j] = 1 + Math.min(dp[i-1][j], dp[i][j-1]);
        }
    }

    return dp[m][n];
}

-----
function minDistance(word1, word2) 
    // Your code here
}

************************************
Question ID: 587
function crossProduct(p, q, r) {
    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);
}

function fence(trees) {
    trees.sort((p, q) => p[0] === q[0] ? p[1] - q[1] : p[0] - q[0]);
    const hull = [];
    for (const p of trees) {
        while (hull.length >= 2 && crossProduct(hull[hull.length - 2], hull[hull.length - 1], p) > 0) {
            hull.pop();
        }
        hull.push(p);
    }
    for (let i = trees.length - 1; i >= 0; i--) {
        const p = trees[i];
        while (hull.length >= 2 && crossProduct(hull[hull.length - 2], hull[hull.length - 1], p) > 0) {
            hull.pop();
        }
        hull.push(p);
    }
    return hull;
}

-----
function crossProduct(p, q, r) 
    // Your code here
}

************************************
Question ID: 591
function isValid(code, i) {
    if (!code || i.value >= code.length) return false;
    if (code[i.value] != '<') return false;
    let nameLength = 0;
    for (++i.value; i.value < code.length && nameLength < 9 && /^[A-Z]$/.test(code[i.value]); ++i.value) ++nameLength;
    if (nameLength < 1 || nameLength > 9 || code[i.value++] != '>') return false;

    while (i.value < code.length && code[i.value] != '<') ++i.value;
    if (i.value >= code.length) return false;

    if (code.substring(i.value, i.value + nameLength + 3) != "</" + code.substring(i.value - nameLength - 1, i.value-1) + ">")
        return false;
    i.value += nameLength + 3;
    return true;
}

function validateCodeSnippet(code) {
    let i = {value: 0};
    return isValid(code, i) && i.value == code.length;
}

-----
function isValid(code, i) 
    // Your code here
}

************************************
Question ID: 592
function gcd(a, b) {
    return b === 0 ? a : gcd(b, a % b);
}

function fractionAddition(expression) {
    let A = 0, B = 1;
    let i = 0;
    while (i < expression.length) {
        const sign = expression[i++] === '+' ? 1 : -1;
        let num = 0, den = 0;
        while (i < expression.length && !isNaN(expression[i])) {
            num = num * 10 + parseInt(expression[i++]);
        }
        i++; // skip '/'
        while (i < expression.length && !isNaN(expression[i])) {
            den = den * 10 + parseInt(expression[i++]);
        }
        A = A * den + B * num * sign;
        B *= den;
        const GCD = gcd(Math.abs(A), Math.abs(B));
        A /= GCD;
        B /= GCD;
    }
    return `${A}/${B}`;
}

-----
function gcd(a, b) 
    // Your code here
}

************************************
Question ID: 593
function validSquare(p1, p2, p3, p4) {
    function distSq(p, q) {
        return (p[0] - q[0]) ** 2 + (p[1] - q[1]) ** 2;
    }

    let points = [p1, p2, p3, p4];
    let dists = new Set();

    for (let i = 0; i < 4; i++) {
        for (let j = i + 1; j < 4; j++) {
            dists.add(distSq(points[i], points[j]));
        }
    }

    return dists.size === 2 && !dists.has(0);
}

-----
function validSquare(p1, p2, p3, p4) 
    // Your code here
}

************************************
Question ID: 594
function findLHS(nums) {
    const count = new Map();
    for (const num of nums) {
        count.set(num, (count.get(num) || 0) + 1);
    }

    let longest_sequence = 0;
    for (const key of count.keys()) {
        if (count.has(key + 1)) {
            longest_sequence = Math.max(longest_sequence, count.get(key) + count.get(key + 1));
        }
    }

    return longest_sequence;
}

-----
function findLHS(nums) 
    // Your code here
}

************************************
Question ID: 598
function maxCount(m, n, ops) {
    for (let op of ops) {
        m = Math.min(m, op[0]);
        n = Math.min(n, op[1]);
    }
    return m * n;
}

-----
function maxCount(m, n, ops) 
    // Your code here
}

************************************
Question ID: 599
function findRestaurant(list1, list2) {
    let restaurantMap = new Map();
    for (let i = 0; i < list1.length; i++) {
        restaurantMap.set(list1[i], i);
    }

    let minSum = Infinity;
    let result = [];
    for (let j = 0; j < list2.length; j++) {
        if (restaurantMap.has(list2[j])) {
            let sum = j + restaurantMap.get(list2[j]);
            if (sum < minSum) {
                result = [list2[j]];
                minSum = sum;
            } else if (sum == minSum) {
                result.push(list2[j]);
            }
        }
    }
    return result;
}


-----
function findRestaurant(list1, list2) 
    // Your code here
}


************************************
Question ID: 600
function findIntegers(n) {
    let dp = new Array(32).fill(0).map(() => Array(2).fill(0));
    dp[0][0] = 1;
    dp[0][1] = 1;

    for (let i = 1; i < 32; i++) {
        dp[i][0] = dp[i - 1][0] + dp[i - 1][1];
        dp[i][1] = dp[i - 1][0];
    }

    let ans = 0, prev_bit = 0;
    for (let i = 30; i >= 0; i--) {
        if (n & (1 << i)) {
            ans += dp[i][0];
            if (prev_bit === 1) break;
            prev_bit = 1;
        } else {
            prev_bit = 0;
        }
    }

    return ans + 1;
}


-----
function findIntegers(n) 
    // Your code here
}


************************************
Question ID: 605
function canPlaceFlowers(flowerbed, n) {
    let count = 0;
    for(let i = 0; i < flowerbed.length; i++) {
        if(flowerbed[i] === 0 && (i === 0 || flowerbed[i - 1] === 0) && (i === flowerbed.length - 1 || flowerbed[i + 1] === 0)) {
            flowerbed[i] = 1;
            count++;
        }
        if(count >= n) return true;
    }
    return count >= n;
}


-----
function canPlaceFlowers(flowerbed, n) 
    // Your code here
}


************************************
Question ID: 609
function findDuplicate(paths) {
    const contentMap = new Map();

    for (const path of paths) {
        const parts = path.split(' ');
        const directory = parts[0];
        for (let i = 1; i < parts.length; i++) {
            const start = parts[i].indexOf('(');
            const end = parts[i].indexOf(')');
            const content = parts[i].substring(start + 1, end);
            const filePath = directory + '/' + parts[i].substring(0, start);

            if (!contentMap.has(content)) {
                contentMap.set(content, []);
            }
            contentMap.get(content).push(filePath);
        }
    }
    const result = [];
    for (const filePaths of contentMap.values()) {
        if (filePaths.length > 1) {
            result.push(filePaths);
        }
    }
    return result;
}

-----
function findDuplicate(paths) 
    // Your code here
}

************************************
Question ID: 611
function triangleNumber(nums) {
    nums.sort((a, b) => a - b);
    let count = 0;
    for (let i = 0; i < nums.length; ++i) {
        for (let j = i + 1; j < nums.length; ++j) {
            for (let k = j + 1; k < nums.length; ++k) {
                if (nums[i] + nums[j] > nums[k]) {
                    count++;
                }
                else {
                    break;
                }
            }
        }
    }
    return count;
}

-----
function triangleNumber(nums) 
    // Your code here
}

************************************
Question ID: 616
function addBoldTag(s, words) {
    const n = s.length;
    const marked = new Array(n).fill(false);
    for (const word of words) {
        let pos = s.indexOf(word, 0);
        while (pos !== -1) {
            marked.fill(true, pos, pos + word.length);
            pos = s.indexOf(word, pos + 1);
        }
    }
    let result = "";
    for (let i = 0; i < n; i++) {
        if (marked[i] && (i === 0 || !marked[i - 1])) {
            result += "<b>";
        }
        result += s[i];
        if (marked[i] && (i === n - 1 || !marked[i + 1])) {
            result += "</b>";
        }
    }
    return result;
}

-----
function addBoldTag(s, words) 
    // Your code here
}

************************************
Question ID: 621
function leastInterval(tasks, n) {
    const taskFreq = {};
    tasks.forEach(task => {
        taskFreq[task] = (taskFreq[task] || 0) + 1;
    });

    const frequencies = Object.values(taskFreq).sort((a, b) => b - a);

    const maxF = frequencies[0] - 1;
    let idleSlots = maxF * n;

    for (let i = 1; i < frequencies.length; i++) {
        idleSlots -= Math.min(frequencies[i], maxF);
    }

    return idleSlots > 0 ? idleSlots + tasks.length : tasks.length;
}


-----
function leastInterval(tasks, n) 
    // Your code here
}


************************************
Question ID: 623
function addOneRowHelper(node, val, depth, currentDepth) {
    if (!node) return;
    if (currentDepth === depth - 1) {
        let left = node.left;
        let right = node.right;
        node.left = new TreeNode(val);
        node.left.left = left;
        node.right = new TreeNode(val);
        node.right.right = right;
    } else {
        addOneRowHelper(node.left, val, depth, currentDepth + 1);
        addOneRowHelper(node.right, val, depth, currentDepth + 1);
    }
}

function addOneRow(root, val, depth) {
    if (depth === 1) {
        let newRoot = new TreeNode(val);
        newRoot.left = root;
        return newRoot;
    }
    addOneRowHelper(root, val, depth, 1);
    return root;
}

-----
function addOneRowHelper(node, val, depth, currentDepth) 
    // Your code here
}

************************************
Question ID: 624
var maxDistance = function(arrays) {
    let max_dist = 0;
    let min_val = arrays[0][0];
    let max_val = arrays[0][arrays[0].length - 1];

    for (let i = 1; i < arrays.length; i++) {
        max_dist = Math.max(max_dist, Math.max(
            Math.abs(arrays[i][arrays[i].length - 1] - min_val),
            Math.abs(max_val - arrays[i][0])
        ));
        min_val = Math.min(min_val, arrays[i][0]);
        max_val = Math.max(max_val, arrays[i][arrays[i].length - 1]);
    }
    return max_dist;
};

-----
var maxDistance = function(arrays) 
    // Your code here
};

************************************
Question ID: 625
function smallestFactorization(num) {
    if (num === 1) return 1;
    let result = 0, factor = 1;
    for (let i = 9; i > 1; --i) {
        while (num % i === 0) {
            num /= i;
            result += i * factor;
            factor *= 10;
            if (result > (2**31 - 1)) return 0;
        }
    }
    return num === 1 ? result : 0;
}

-----
function smallestFactorization(num) 
    // Your code here
}

************************************
Question ID: 628
function maximumProduct(nums) {
    nums.sort((a, b) => a - b);
    const n = nums.length;
    return Math.max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3]);
}

-----
function maximumProduct(nums) 
    // Your code here
}

************************************
Question ID: 629
function kInversePairs(n, k) {
    const mod = 1e9 + 7;
    const dp = Array.from({ length: n + 1 }, () => Array(k + 1).fill(0));
    for (let i = 1; i <= n; ++i) {
        dp[i][0] = 1;
        for (let j = 1; j <= k; ++j) {
            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod;
            if (j - i >= 0) {
                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;
            }
        }
    }
    return dp[n][k];
}

-----
function kInversePairs(n, k) 
    // Your code here
}

************************************
Question ID: 630
function scheduleCourse(courses) {
    courses.sort((a, b) => a[1] - b[1]);

    const pq = new PriorityQueue((a, b) => b - a);
    let time = 0;

    for (const course of courses) {
        time += course[0];
        pq.push(course[0]);

        if (time > course[1]) {
            time -= pq.pop();
        }
    }

    return pq.size();
}

class PriorityQueue {
    constructor(comparator) {
        this.data = [];
        this.comparator = comparator;
    }

    push(item) {
        this.data.push(item);
        this.data.sort(this.comparator);
    }

    pop() {
        return this.data.shift();
    }

    size() {
        return this.data.length;
    }
}

-----
function scheduleCourse(courses) 
    // Your code here
}

************************************
Question ID: 632
function smallestRange(nums) {
    const minHeap = [],
          listIndices = Array(nums.length).fill(0);
          
    let maxVal = -Infinity;
    
    for (let i = 0; i < nums.length; i++) {
        minHeap.push([nums[i][0], i]);
        maxVal = Math.max(maxVal, nums[i][0]);
    }
    minHeap.sort(([a], [b]) => a - b);

    let minRange = Infinity,
        start = -1,
        end = -1;
    
    while (minHeap.length === nums.length) {
        const [val, listIdx] = minHeap.shift();
        const range = maxVal - val;
        
        if (range < minRange) {
            minRange = range;
            start = val;
            end = maxVal;
        }

        listIndices[listIdx]++;
        if (listIndices[listIdx] < nums[listIdx].length) {
            const newVal = nums[listIdx][listIndices[listIdx]];
            minHeap.push([newVal, listIdx]);
            minHeap.sort(([a], [b]) => a - b);
            maxVal = Math.max(maxVal, newVal);
        }
    }

    return [start, end];
}

-----
function smallestRange(nums) 
    // Your code here
}

************************************
Question ID: 633
function judgeSquareSum(c) {
    for (let a = 0; a <= Math.sqrt(c); ++a) {
        let b = Math.floor(Math.sqrt(c - a * a));
        if (a * a + b * b === c) {
            return true;
        }
    }
    return false;
}

-----
function judgeSquareSum(c) 
    // Your code here
}

************************************
Question ID: 634
function findDerangement(n) {
    const MOD = 1000000007;
    let dp = new Array(n + 1).fill(0);
    dp[2] = 1;
    for (let i = 3; i <= n; ++i) {
        dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD;
    }
    return dp[n];
}

-----
function findDerangement(n) 
    // Your code here
}

************************************
Question ID: 636
function exclusiveTime(n, logs) {
    const res = new Array(n).fill(0);
    const stack = [];
    let prevTime = 0;

    for (const log of logs) {
        const parts = log.split(':');
        const id = parseInt(parts[0]);
        const type = parts[1];
        const time = parseInt(parts[2]);

        if (type === "start") {
            if (stack.length > 0) {
                res[stack[stack.length - 1]] += time - prevTime;
            }
            stack.push(id);
            prevTime = time;
        } else {
            res[stack.pop()] += time - prevTime + 1;
            prevTime = time + 1;
        }
    }

    return res;
}

-----
function exclusiveTime(n, logs) 
    // Your code here
}

************************************
Question ID: 638
function shoppingOffers(price, special, needs) {
    function helper(index) {
        if (index === special.length) {
            return needs.reduce((sum, curr, i) => sum + curr * price[i], 0);
        }

        let no_offer = helper(index + 1);
        let can_apply_offer = true;
        for (let i = 0; i < needs.length; ++i) {
            needs[i] -= special[index][i];
            if (needs[i] < 0) can_apply_offer = false;
        }

        let with_offer = Infinity;
        if (can_apply_offer) {
            let offer_cost = special[index][needs.length] + helper(index);
            with_offer = Math.min(no_offer, offer_cost);
        }

        for (let i = 0; i < needs.length; ++i) {
            needs[i] += special[index][i];
        }

        return can_apply_offer ? with_offer : no_offer;
    }

    return helper(0);
}


-----
function shoppingOffers(price, special, needs) 
    // Your code here
}


************************************
Question ID: 639
function numDecodings(s) {
    const MOD = 1_000_000_007;
    const n = s.length;
    const dp = new Array(n + 1).fill(0);
    dp[0] = 1;
    dp[1] = s[0] === '*' ? 9 : (s[0] === '0' ? 0 : 1);

    for (let i = 2; i <= n; ++i) {
        let c = s[i - 1];
        let prevC = s[i - 2];

        if (c === '*') {
            dp[i] = 9 * dp[i - 1];
            if (prevC === '1') dp[i] += 9 * dp[i - 2];
            else if (prevC === '2') dp[i] += 6 * dp[i - 2];
            else if (prevC === '*') dp[i] += 15 * dp[i - 2];
        } else {
            dp[i] = (c !== '0') ? dp[i - 1] : 0;
            let num = parseInt(s.slice(i - 2, i));
            if (prevC === '1' || (prevC === '2' && num <= 26)) dp[i] += dp[i - 2];
            else if (prevC === '*') dp[i] += (num <= 26 && num >= 10) ? 2 * dp[i - 2] : dp[i - 2];
        }
        dp[i] %= MOD;
    }
    return dp[n];
}

-----
function numDecodings(s) 
    // Your code here
}

************************************
Question ID: 640
function solveEquation(equation) {
    let coef = 0, val = 0, left = 1, operate = 1;
    let parts = equation.replace(/([+-])/g, ' $1').split('=');
    let leftPart = parts[0].split(' ');
    let rightPart = parts[1].split(' ');

    for (let part of leftPart.concat(rightPart)) {
        if (part === '+') {
            operate = 1;
        } else if (part === '-') {
            operate = -1;
        } else if (part.includes('x')) {
            coef += parseInt(part.replace('x', '') || '1', 10) * operate * left;
        } else {
            val += parseInt(part, 10) * operate * left;
        }
    }

    if (coef === 0) {
        return val === 0 ? "Infinite solutions" : "No solution";
    } else {
        return "x=" + (-val / coef).toString();
    }
}


-----
function solveEquation(equation) 
    // Your code here
}


************************************
Question ID: 642
class TrieNode {
    constructor() {
        this.children = {};
        this.sentence = "";
        this.times = 0;
    }
}

class AutocompleteSystem {
    constructor(sentences, times) {
        this.root = new TrieNode();
        this.current = this.root;
        this.search = "";
        
        for (let i = 0; i < sentences.length; ++i) {
            this.insert(sentences[i], times[i]);
        }
    }
    
    insert(sentence, times) {
        let curr = this.root;
        for (let c of sentence) {
            if (!curr.children[c]) {
                curr.children[c] = new TrieNode();
            }
            curr = curr.children[c];
        }
        curr.sentence = sentence;
        curr.times += times;
    }
    
    input(c) {
        if (c === '#') {
            this.insert(this.search, 1);
            this.search = "";
            this.current = this.root;
            return [];
        }
        
        this.search += c;
        if (!this.current) {
            return [];
        }
        
        if (!this.current.children[c]) {
            this.current = null;
            return [];
        }
        
        this.current = this.current.children[c];
        const heap = [];
        for (let node of Object.values(this.current.children)) {
            if (node.times) {
                heap.push([node]);
            }
        }
        
        heap.sort((a, b) => {
            if (a.times === b.times) {
                return a.sentence.localeCompare(b.sentence);
            }
            return b.times - a.times;
        });
        
        const res = [];
        for (let i = 0; i < 3 && i < heap.length; ++i) {
            res.push(heap[i].sentence);
        }
        return res;
    }
}


-----
class TrieNode 
    // Your code here
}


************************************
Question ID: 643
function findMaxAverage(nums, k) {
    let n = nums.length;
    let sum = 0;
    for (let i = 0; i < k; i++) {
        sum += nums[i];
    }
    let max_avg = sum / k;
    for (let i = k; i < n; i++) {
        sum = sum - nums[i - k] + nums[i];
        max_avg = Math.max(max_avg, sum / k);
    }
    return max_avg;
}

-----
function findMaxAverage(nums, k) 
    // Your code here
}

************************************
Question ID: 644
function findMaxAverage(nums, k) {
    let sum = 0;
    for(let i = 0; i < k; i++) {
        sum += nums[i];
    }

    let max_avg = sum / k;
    
    for(let i = k; i < nums.length; i++) {
        sum += nums[i] - nums[i - k];
        max_avg = Math.max(max_avg, sum / k);
    }
    
    return max_avg;
}

-----
function findMaxAverage(nums, k) 
    // Your code here
}

************************************
Question ID: 645
function findErrorNums(nums) {
    let result = [];
    for (let num of nums) {
        let index = Math.abs(num) - 1;
        if (nums[index] > 0) {
            nums[index] = -nums[index];
        } else {
            result.push(index + 1);
        }
    }
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] > 0) {
            result.push(i + 1);
            break;
        }
    }
    return result;
}

-----
function findErrorNums(nums) 
    // Your code here
}

************************************
Question ID: 646
function findLongestChain(pairs) {
    pairs.sort((a, b) => a[1] - b[1]);

    let max_chain_length = 0, last_right = Number.MIN_SAFE_INTEGER;
    for (const pair of pairs) {
        if (pair[0] > last_right) {
            last_right = pair[1];
            max_chain_length++;
        }
    }

    return max_chain_length;
}


-----
function findLongestChain(pairs) 
    // Your code here
}


************************************
Question ID: 647
function countSubstrings(s) {
    const n = s.length;
    let count = 0;
    for (let center = 0; center < 2 * n - 1; ++center) {
        let left = Math.floor(center / 2);
        let right = left + center % 2;
        while (left >= 0 && right < n && s[left] === s[right]) {
            ++count;
            --left;
            ++right;
        }
    }
    return count;
}

-----
function countSubstrings(s) 
    // Your code here
}

************************************
Question ID: 648
function replaceWords(dict, sentence) {
    const roots = new Set(dict);
    const words = sentence.split(' ');
    const result = [];

    for (const word of words) {
        let prefix = '';
        for (let i = 1; i <= word.length; ++i) {
            prefix = word.substring(0, i);
            if (roots.has(prefix)) {
                break;
            }
        }
        result.push(prefix);
    }

    return result.join(' ');
}

-----
function replaceWords(dict, sentence) 
    // Your code here
}

************************************
Question ID: 649
function predictPartyVictory(senate) {
    let radiant = [];
    let dire = [];
    let n = senate.length;
    
    for (let i = 0; i < n; i++) {
        if (senate[i] === 'R')
            radiant.push(i);
        else
            dire.push(i);
    }

    while (radiant.length > 0 && dire.length > 0) {
        let r = radiant.shift();
        let d = dire.shift();

        if (r < d)
            radiant.push(r + n);
        else
            dire.push(d + n);
    }

    return radiant.length === 0 ? "Dire" : "Radiant";
}


-----
function predictPartyVictory(senate) 
    // Your code here
}


************************************
Question ID: 650
function minSteps(n) {
    let result = 0;
    for (let i = 2; i <= n; i++) {
        while (n % i === 0) {
            result += i;
            n /= i;
        }
    }
    return result;
}

-----
function minSteps(n) 
    // Your code here
}

************************************
Question ID: 651
function maxA(n) {
    let dp = new Array(n + 1);
    for(let i = 1; i <= n; ++i) {
        dp[i] = i;
        for(let j = 1; j <= i - 3; ++j)
            dp[i] = Math.max(dp[i], dp[j] * (i - j - 1));
    }
    return dp[n];
}

-----
function maxA(n) 
    // Your code here
}

************************************
Question ID: 653
function findTarget(root, k) {
    const nodes = new Set();
    return findNode(root, k, nodes);
}

function findNode(root, k, nodes) {
    if (!root) return false;
    if (nodes.has(k - root.val)) return true;
    nodes.add(root.val);
    return findNode(root.left, k, nodes) || findNode(root.right, k, nodes);
}

-----
function findTarget(root, k) 
    // Your code here
}

************************************
Question ID: 655
class TreeNode {
  constructor(val, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

function printTree(root) {
    if (!root) {
        return [[]];
    }

    let depth = 0;
    let q = [root];
    while (q.length) {
        depth++;
        let size = q.length;
        for (let i = 0; i < size; i++) {
            let node = q.shift();
            if (node.left) q.push(node.left);
            if (node.right) q.push(node.right);
        }
    }

    const res = Array.from({length: depth}, () => Array(2 ** depth - 1).fill(""));

    q.push(root);
    let level = 0;
    let step = (1 << (depth - 1));
    while (q.length) {
        let size = q.length;
        let curPos = step - 1;
        for (let i = 0; i < size; i++) {
            let node = q.shift();
            res[level][curPos] = String(node.val);
            curPos += (step << 1);
            if (node.left) q.push(node.left);
            if (node.right) q.push(node.right);
        }
        step >>= 1;
        level++;
    }

    return res;
}


-----
class TreeNode 
    // Your code here
}


************************************
Question ID: 656
function cheapestJump(coins, maxJump) {
    const n = coins.length;
    const dp = new Array(n).fill(Infinity);
    const parent = new Array(n).fill(-1);
    dp[0] = coins[0];
    for (let i = 0; i < n; ++i) {
        if (coins[i] === -1) continue;
        for (let j = 1; j <= maxJump && i + j < n; ++j) {
            const next = i + j;
            const cost = coins[next] + dp[i];
            if (cost < dp[next]) {
                dp[next] = cost;
                parent[next] = i;
            }
        }
    }
    const ans = [];
    if (dp[n - 1] === Infinity) return ans;
    let cur = n - 1;
    while (cur !== -1) {
        ans.push(cur + 1);
        cur = parent[cur];
    }
    ans.reverse();
    return ans;
}

-----
function cheapestJump(coins, maxJump) 
    // Your code here
}

************************************
Question ID: 657
function judgeCircle(moves) {
    let x = 0, y = 0;
    for(let move of moves) {
        if(move === 'U') y++;
        else if(move === 'D') y--;
        else if(move === 'R') x++;
        else if(move === 'L') x--;
    }
    return x === 0 && y === 0;
}

-----
function judgeCircle(moves) 
    // Your code here
}

************************************
Question ID: 658
function findClosestElements(arr, k, x) {
    let left = 0;
    let right = arr.length - k;

    while (left < right) {
        let mid = left + ((right - left) >> 1);
        if (x - arr[mid] > arr[mid + k] - x) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return arr.slice(left, left + k);
}

-----
function findClosestElements(arr, k, x) 
    // Your code here
}

************************************
Question ID: 659
function canSplit(nums) {
    const freq = new Array(20001).fill(0), needed = new Array(20001).fill(0);
    for (let n of nums)
        freq[n]++;
    for (let n of nums) {
        if (!freq[n]) continue;
        if (!needed[n - 1]) {
            if (freq[n + 1] && freq[n + 2]) {
                freq[n]--; freq[n + 1]--; freq[n + 2]--;
                needed[n + 2]++;
            } else return false;
        } else {
            freq[n]--; needed[n - 1]--;
            needed[n]++;
        }
    }
    return true;
}

-----
function canSplit(nums) 
    // Your code here
}

************************************
Question ID: 660
function newInteger(n) {
    let result = 0, base = 1;
    while (n > 0) {
        result += (n % 9) * base;
        n = Math.floor(n / 9);
        base *= 10;
    }
    return result;
}

-----
function newInteger(n) 
    // Your code here
}

************************************
Question ID: 661
function imageSmoother(img) {
    const m = img.length, n = img[0].length;
    const result = new Array(m).fill(0).map(() => new Array(n).fill(0));

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            let count = 0, sum = 0;

            for (let x = i - 1; x <= i + 1; x++) {
                for (let y = j - 1; y <= j + 1; y++) {
                    if (x >= 0 && x < m && y >= 0 && y < n) {
                        sum += img[x][y];
                        count++;
                    }
                }
            }
            result[i][j] = Math.floor(sum / count);
        }
    }

    return result;
}

-----
function imageSmoother(img) 
    // Your code here
}

************************************
Question ID: 662
function widthOfBinaryTree(root) {
    if (!root) return 0;
    let maxWidth = 0;
    const q = [[root, 1]];

    while (q.length) {
        const levelSize = q.length;
        let left = q[0][1];
        let right = left;

        for (let i = 0; i < levelSize; i++) {
            const [node, pos] = q.shift();
            right = pos;

            if (node.left) {
                q.push([node.left, 2 * pos]);
            }
            if (node.right) {
                q.push([node.right, 2 * pos + 1]);
            }
        }
        maxWidth = Math.max(maxWidth, right - left + 1);
    }

    return maxWidth;
}

-----
function widthOfBinaryTree(root) 
    // Your code here
}

************************************
Question ID: 664
function strangePrinter(s) {
    let n = s.length;
    if(n === 0) return 0;
    const dp = Array.from({ length: n }, () => Array(n).fill(0));
    for(let i = 0; i < n; i++) dp[i][i] = 1;
    for(let len = 1; len < n; len++) {
        for(let i = 0; i < n - len; i++) {
            let j = i + len;
            dp[i][j] = dp[i+1][j] + 1;
            for(let k = i + 1; k <= j; k++) {
                if(s.charAt(i) === s.charAt(k)) {
                    dp[i][j] = Math.min(dp[i][j], dp[i+1][k-1] + dp[k][j]);
                }
            }
        }
    }
    return dp[0][n-1];
}

-----
function strangePrinter(s) 
    // Your code here
}

************************************
Question ID: 665
function checkPossibility(nums) {
    let cnt = 0;
    for (let i = 1; i < nums.length; i++) {
        if (nums[i] < nums[i - 1]) {
            cnt++;
            if (i === 1 || nums[i] >= nums[i - 2]) {
                nums[i-1] = nums[i];
            } else {
                nums[i] = nums[i - 1];
            }
            if (cnt > 1) return false;
        }
    }
    return true;
}

-----
function checkPossibility(nums) 
    // Your code here
}

************************************
Question ID: 666
function sum(root, val) {
    if (!root) return 0;
    val = val * 10 + root.val;
    if (!root.left && !root.right) return val;
    return sum(root.left, val) + sum(root.right, val);
}

function pathSum(nums) {
    const root = new TreeNode(nums[0] % 10);
    for (const num of nums) {
        const depth = Math.floor(num / 100);
        const pos = Math.floor(num % 100 / 10);
        const val = num % 10;
        let cur = root;
        for (let d = depth - 2; d >= 0; --d) {
            if ((pos >> d) & 1) {
                if (!cur.right) cur.right = new TreeNode(val);
                cur = cur.right;
            } else {
                if (!cur.left) cur.left = new TreeNode(val);
                cur = cur.left;
            }
        }
    }
    return sum(root, 0);
}

-----
function sum(root, val) 
    // Your code here
}

************************************
Question ID: 667
function constructArray(n, k) {
    let answer = new Array(n);
    for (let i = 0; i < n; i++) {
        if (i % 2 === 0) {
            answer[i] = i / 2 + 1;
        } else {
            answer[i] = n - ((i - 1) / 2);
            k--;
        }
    }
    if (k > 0) {
        for (let i = n - 2; i >= 0 && k > 0; i--) {
            answer[i] = answer[i + 1] - answer[i];
            k--;
        }
    }
    return answer;
}

-----
function constructArray(n, k) 
    // Your code here
}

************************************
Question ID: 668
function findKthNumber(m, n, k) {
    let low = 1, high = m * n;
    while (low < high) {
        let mid = low + Math.floor((high - low) / 2);
        let count = 0;
        for (let i = 1; i <= m; i++) {
            count += Math.min(Math.floor(mid / i), n);
        }
        if (count < k) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    return low;
}

-----
function findKthNumber(m, n, k) 
    // Your code here
}

************************************
Question ID: 670
function maximumSwap(num) {
    let num_str = Array.from(num.toString());
    let last = new Array(10).fill(0);
    
    for (let i = 0; i < num_str.length; i++) {
        last[parseInt(num_str[i])] = i;
    }
    
    for (let i = 0; i < num_str.length; i++) {
        for (let d = 9; d > parseInt(num_str[i]); d--) {
            if (last[d] > i) {
                [num_str[i], num_str[last[d]]] = [num_str[last[d]], num_str[i]];
                return parseInt(num_str.join(''));
            }
        }
    }
    
    return num;
}

-----
function maximumSwap(num) 
    // Your code here
}

************************************
Question ID: 672
function numLightConfiguration(n, presses) {
    let dp = new Array(n + 1).fill(0).map(() => new Array(presses + 1).fill(0));
    dp[0][0] = 1;

    for (let i = 0; i <= n; ++i) {
        for (let j = 1; j <= presses; ++j) {
            dp[i][j] = dp[i][j - 1] * (i + 1) + (i > 0 ? dp[i - 1][j - 1] : 0);
        }
    }

    return dp[n][presses];
}

-----
function numLightConfiguration(n, presses) 
    // Your code here
}

************************************
Question ID: 673
function findNumberOfLIS(nums) {
    const n = nums.length;
    let maxLength = 0, ans = 0;
    const length = new Array(n).fill(1);
    const count = new Array(n).fill(1);

    for (let i = 0; i < n; ++i) {
        for (let j = 0; j < i; ++j) {
            if (nums[i] > nums[j]) {
                if (length[i] === length[j] + 1) {
                    count[i] += count[j];
                } else if (length[i] < length[j] + 1) {
                    length[i] = length[j] + 1;
                    count[i] = count[j];
                }
            }
        }
        if (maxLength === length[i]) {
            ans += count[i];
        } else if (maxLength < length[i]) {
            maxLength = length[i];
            ans = count[i];
        }
    }

    return ans;
}


-----
function findNumberOfLIS(nums) 
    // Your code here
}


************************************
Question ID: 674
function findLengthOfLCIS(nums) {
    if (nums.length === 0) return 0;
    let result = 1, current = 1;
    for (let i = 1; i < nums.length; ++i) {
        current = nums[i] > nums[i - 1] ? current + 1 : 1;
        result = Math.max(result, current);
    }
    return result;
}

-----
function findLengthOfLCIS(nums) 
    // Your code here
}

************************************
Question ID: 675
function cutOffTree(forest) {
    if(!forest || !forest[0]) return 0;
    let m = forest.length, n = forest[0].length;
    let trees = [];
    
    for(let i = 0; i < m; i++)
        for(let j = 0; j < n; j++)
            if(forest[i][j] > 1)
                trees.push([forest[i][j], i, j]);
    
    trees.sort((a, b) => a[0] - b[0]);

    let startX = 0, startY = 0;
    let totalSteps = 0;
    for(let tree of trees){
        let [, x, y] = tree;
        let steps = bfs(forest, startX, startY, x, y);
        if(steps === -1) return -1;
        totalSteps += steps;
        startX = x;
        startY = y;
    }
    
    return totalSteps;
}

function bfs(forest, startX, startY, endX, endY) {
    let m = forest.length, n = forest[0].length;
    let visited = Array.from({ length: m }, () => Array(n).fill(false));
    let q = [[startX, startY, 0]];
    visited[startX][startY] = true;
    let dirs = [-1, 0, 1, 0, -1];
    
    while(q.length !== 0) {
        let [x, y, steps] = q.shift();
        for(let k = 0; k < 4; k++) {
            let newX = x + dirs[k], newY = y + dirs[k+1];
            if(0 <= newX && newX < m && 0 <= newY && newY < n && !visited[newX][newY] && forest[newX][newY] !== 0) {
                if(newX === endX && newY === endY)
                    return steps + 1;
                q.push([newX, newY, steps + 1]);
                visited[newX][newY] = true;
            }
        }
    }
    
    return -1;
}

-----
function cutOffTree(forest) 
    // Your code here
}

************************************
Question ID: 678
function checkValidString(s) {
    let left_balance = 0, right_balance = 0;

    for (let i = 0; i < s.length; i++) {
        left_balance += (s[i] === '(' || s[i] === '*') ? 1 : -1;
        right_balance += (s[s.length - 1 - i] === ')' || s[s.length - 1 - i] === '*') ? 1 : -1;

        if (left_balance < 0 || right_balance < 0)
            return false;
    }

    return true;
}


-----
function checkValidString(s) 
    // Your code here
}


************************************
Question ID: 679
function helper(cards) {
  if (cards.length === 1) {
    return Math.abs(cards[0] - 24) < 1e-6;
  }

  for (let i = 0; i < cards.length; ++i) {
    for (let j = i + 1; j < cards.length; ++j) {
      const a = cards[i], b = cards[j];
      const next = [a + b, a - b, a * b, a / b];

      cards.splice(j, 1);
      cards.splice(i, 1);

      for (const e of next) {
        cards.push(e);
        if (helper(cards)) {
          return true;
        }
        cards.pop();
      }

      cards.splice(i, 0, a);
      cards.splice(j, 0, b);
    }
  }
  return false;
}

function canGet24(cards) {
  return helper(cards);
}


-----
function helper(cards) 
    // Your code here
}


************************************
Question ID: 680
function validPalindrome(s) {
    for (let i = 0, j = s.length - 1; i < j; i++, j--) {
        if (s[i] != s[j]) {
            let temp1 = i + 1, temp2 = j;
            while (temp1 < temp2 && s[temp1] == s[temp2]) { temp1++; temp2--; }
            if (temp1 >= temp2) return true;

            temp1 = i; temp2 = j - 1;
            while (temp1 < temp2 && s[temp1] == s[temp2]) { temp1++; temp2--; }
            if (temp1 >= temp2) return true;
            
            return false;
        }
    }
    return true;
}

-----
function validPalindrome(s) 
    // Your code here
}

************************************
Question ID: 681
function nextClosestTime(time) {
    let digits = time.substring(0, 2) + time.substring(3);
    let next_time = time;
    let elapsed = Infinity;

    for (const a of digits) {
    for (const b of digits) {
    for (const c of digits) {
    for (const d of digits) {
        const candidate_time = `${a}${b}:${c}${d}`;
        const cand_elapsed = (parseInt(candidate_time.substring(0, 2)) * 60 + parseInt(candidate_time.substring(3)) -
                              parseInt(time.substring(0, 2)) * 60 - parseInt(time.substring(3)) + 1440) % 1440;
        if (0 < cand_elapsed && cand_elapsed < elapsed) {
          elapsed = cand_elapsed;
          next_time = candidate_time;
        }
    }}}}

    return next_time;
}

-----
function nextClosestTime(time) 
    // Your code here
}

************************************
Question ID: 682
function calPoints(ops) {
    let record = [];
    for (let op of ops) {
        if (op === '+') {
            record.push(record[record.length - 1] + record[record.length - 2]);
        } else if (op === 'D') {
            record.push(record[record.length - 1] * 2);
        } else if (op === 'C') {
            record.pop();
        } else {
            record.push(parseInt(op));
        }
    }
    return record.reduce((a, b) => a + b, 0);
}


-----
function calPoints(ops) 
    // Your code here
}


************************************
Question ID: 683
function kEmptySlots(bulbs, k) {
    const days = new Array(bulbs.length);
    for (let i = 0; i < bulbs.length; i++) {
        days[bulbs[i] - 1] = i;
    }

    let ans = Number.MAX_SAFE_INTEGER;
    let left = 0;
    let right = k + 1;
    while (right < days.length) {
        let i = left + 1;
        while (i < right) {
            if (days[i] < days[left] || days[i] < days[right]) {
                left = i;
                break;
            }
            i++;
        }
        if (i === right) {
            ans = Math.min(ans, Math.max(days[left], days[right]));
            left++;
            right++;
        }
    }

    return ans === Number.MAX_SAFE_INTEGER ? -1 : ans + 1;
}


-----
function kEmptySlots(bulbs, k) 
    // Your code here
}


************************************
Question ID: 684
function findRedundantConnection(edges) {
    const parent = new Array(edges.length + 1).fill(0).map((_, i) => i);

    function find(x) {
        if (parent[x] !== x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    for (const edge of edges) {
        const root1 = find(edge[0]);
        const root2 = find(edge[1]);
        if (root1 === root2) {
            return edge;
        }
        parent[root1] = root2;
    }

    return [];
}


-----
function findRedundantConnection(edges) 
    // Your code here
}


************************************
Question ID: 685
function findRedundantDirectedConnection(edges) {
    const parent = Array(edges.length + 1).fill(0);
    let candidateA = null, candidateB = null;

    for (const edge of edges) {
        const [u, v] = edge;
        if (parent[v] > 0) {
            candidateA = [parent[v], v];
            candidateB = edge;
        } else {
            parent[v] = u;
        }
    }

    for (let i = 1; i <= edges.length; ++i) {
        let cycle = i, steps = edges.length;
        while (parent[cycle] !== 0 && steps-- > 0) {
            cycle = parent[cycle];
        }
        if (steps === -1) {
            if (candidateA === null) return [parent[i], i];
            else return candidateA;
        }
    }

    return candidateB;
}


-----
function findRedundantDirectedConnection(edges) 
    // Your code here
}


************************************
Question ID: 686
function minRepeatsToSubstring(a, b) {
    let times = Math.floor((b.length + a.length - 1) / a.length);

    for (let i = 0; i < 2; i++) {
        let repeated_a = "";
        for (let j = 0; j < times + i; j++) {
            repeated_a += a;
        }

        if (repeated_a.includes(b)) return times + i;
    }

    return -1;
}

-----
function minRepeatsToSubstring(a, b) 
    // Your code here
}

************************************
Question ID: 687
function longestUnivaluePath(root) {
    let maxLen = 0;

    function findUnivaluePath(node) {
        if (!node) return 0;
        let left = findUnivaluePath(node.left);
        let right = findUnivaluePath(node.right);
        left = (node.left && node.left.val === node.val) ? left + 1 : 0;
        right = (node.right && node.right.val === node.val) ? right + 1 : 0;
        maxLen = Math.max(maxLen, left + right);
        return Math.max(left, right);
    }

    findUnivaluePath(root);
    return maxLen;
}


-----
function longestUnivaluePath(root) 
    // Your code here
}


************************************
Question ID: 688
function knightProbability(n, k, row, column) {
    let memo = new Array(n).fill().map(() => new Array(n).fill().map(() => new Array(k + 1).fill(-1)));
    return helper(n, k, row, column, memo);
}

function helper(n, k, row, column, memo) {
    if (row < 0 || row >= n || column < 0 || column >= n) return 0.0;
    if (k === 0) return 1.0;
    if (memo[row][column][k] >= 0) return memo[row][column][k];
    
    let result = 0.0;
    let moves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
    for (let i = 0; i < 8; ++i)
        result += helper(n, k - 1, row + moves[i][0], column + moves[i][1], memo) / 8;

    memo[row][column][k] = result;
    return result;
}

-----
function knightProbability(n, k, row, column) 
    // Your code here
}

************************************
Question ID: 689
function max_sum_of_three_subarrays(nums, k) {
    const n = nums.length;
    const sums = new Array(n - k + 1);
    const left = new Array(n), right = new Array(n);
    let acc_sum = 0;

    for (let i = 0; i < n; i++) {
        acc_sum += nums[i];
        if (i >= k) {
            acc_sum -= nums[i - k];
        }
        if (i >= k - 1) {
            sums[i - k + 1] = acc_sum;
        }
    }

    left[0] = 0;
    right[n - k] = n - k;

    for (let i = 1; i < n - k + 1; i++) {
        left[i] = sums[i] > sums[left[i - 1]] ? i : left[i - 1];
    }

    for (let i = n - k - 1; i >= 0; i--) {
        right[i] = sums[i] >= sums[right[i + 1]] ? i : right[i + 1];
    }

    let max_sum = 0;
    const ans = [0, 0, 0];

    for (let i = k; i < n - 2 * k + 1; i++) {
        const left_idx = left[i - k], right_idx = right[i + k], total_sum = sums[left_idx] + sums[i] + sums[right_idx];
        if (total_sum > max_sum) {
            max_sum = total_sum;
            ans[0] = left_idx;
            ans[1] = i;
            ans[2] = right_idx;
        }
    }

    return ans;
}

-----
function max_sum_of_three_subarrays(nums, k) 
    // Your code here
}

************************************
Question ID: 691
function minStickers(stickers, target) {
    let targetCount = new Array(26).fill(0);
    let memo = new Map();
    for (let c of target) targetCount[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;

    for (let s of stickers) {
        let stickerCount = new Array(26).fill(0);
        let state = "";
        for (let c of s) {
            if (!targetCount[c.charCodeAt(0) - 'a'.charCodeAt(0)]) continue;
            stickerCount[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;
        }
        for (let i = 0; i < 26; ++i) {
            state += String.fromCharCode('a'.charCodeAt(0) + i).repeat(stickerCount[i]);
        }
        memo.set(state, 1);
    }
    
    return dp(memo, target);
}

function dp(memo, target) {
    if (memo.has(target)) return memo.get(target);
    let counts = new Array(26).fill(0);
    for (let c of target) counts[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;
    let ans = Infinity;
    for (let [key, value] of memo) {
        let ok = true;
        for (let i = 0; i < 26 && ok; ++i)
            ok = counts[i] >= (key.match(new RegExp(String.fromCharCode('a'.charCodeAt(0) + i), 'g')) || []).length;
        if (!ok) continue;
        ans = Math.min(ans, dp(memo, target.substring(key.length)) + value);
    }
    memo.set(target, ans == Infinity ? -1 : ans);
    return memo.get(target);
}

-----
function minStickers(stickers, target) 
    // Your code here
}

************************************
Question ID: 692
function kFrequentWords(words, k) {
    const wordCount = new Map();
    for (const word of words) {
        wordCount.set(word, (wordCount.get(word) || 0) + 1);
    }

    const pq = Array.from(wordCount.entries()).sort((a, b) => {
        if (a[1] === b[1]) {
            return a[0].localeCompare(b[0]);
        }
        return b[1] - a[1];
    });

    const result = [];
    for (let i = 0; i < k; i++) {
        result.push(pq[i][0]);
    }
    return result;
}

-----
function kFrequentWords(words, k) 
    // Your code here
}

************************************
Question ID: 693
function hasAlternatingBits(n) {
    let prevBit = n % 2;
    n = Math.floor(n / 2);
    while (n > 0) {
        let currBit = n % 2;
        if (currBit === prevBit) return false;
        prevBit = currBit;
        n = Math.floor(n / 2);
    }
    return true;
}


-----
function hasAlternatingBits(n) 
    // Your code here
}


************************************
Question ID: 694
function numDistinctIslands(grid) {
    const uniqueIslands = new Set();
    for (let i = 0; i < grid.length; i++) {
        for (let j = 0; j < grid[0].length; j++) {
            if (grid[i][j] === 1) {
                const islandShape = [];
                dfs(grid, i, j, i, j, islandShape);
                islandShape.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
                uniqueIslands.add(JSON.stringify(islandShape));
            }
        }
    }
    return uniqueIslands.size;
}

function dfs(grid, i, j, i0, j0, shape) {
    if (i >= 0 && i < grid.length && j >= 0 && j < grid[0].length && grid[i][j] == 1) {
        grid[i][j] = 2;
        shape.push([i - i0, j - j0]);
        dfs(grid, i - 1, j, i0, j0, shape);
        dfs(grid, i + 1, j, i0, j0, shape);
        dfs(grid, i, j - 1, i0, j0, shape);
        dfs(grid, i, j + 1, i0, j0, shape);
    }
}

-----
function numDistinctIslands(grid) 
    // Your code here
}

************************************
Question ID: 695
var maxAreaOfIsland = function(grid) {
    let maxArea = 0;
    
    function dfs(i, j) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === 0) {
            return 0;
        }
        grid[i][j] = 0;
        return 1 + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1);
    }
    
    for (let i = 0; i < grid.length; i++) {
        for (let j = 0; j < grid[0].length; j++) {
            if (grid[i][j] === 1) {
                maxArea = Math.max(maxArea, dfs(i, j));
            }
        }
    }

    return maxArea;
};


-----
var maxAreaOfIsland = function(grid) 
    // Your code here
};


************************************
Question ID: 696
function countBinarySubstrings(s) {
    let prev = 0, curr = 1, result = 0;
    for (let i = 1; i < s.length; i++) {
        if (s[i] === s[i - 1]) {
            curr++;
        } else {
            result += Math.min(prev, curr);
            prev = curr;
            curr = 1;
        }
    }
    return result + Math.min(prev, curr);
}

-----
function countBinarySubstrings(s) 
    // Your code here
}

************************************
Question ID: 697
function findShortestSubArray(nums) {
    const freq_map = {}, start_map = {};
    let max_freq = 0, min_length = nums.length;

    for (let i = 0; i < nums.length; ++i) {
        if (!start_map.hasOwnProperty(nums[i])) {
            start_map[nums[i]] = i;
        }
        if (!freq_map.hasOwnProperty(nums[i])) {
            freq_map[nums[i]] = 0;
        }
        freq_map[nums[i]]++;

        const freq = freq_map[nums[i]];
        if (freq > max_freq) {
            max_freq = freq;
            min_length = i - start_map[nums[i]] + 1;
        } else if (freq === max_freq) {
            min_length = Math.min(min_length, i - start_map[nums[i]] + 1);
        }
    }

    return min_length;
}

-----
function findShortestSubArray(nums) 
    // Your code here
}

************************************
Question ID: 698
function canPartitionKSubsets(nums, k) {
  let sum = nums.reduce((a, b) => a + b, 0);
  if (sum % k !== 0) return false;
  const target = sum / k;
  const visited = new Array(nums.length).fill(false);
  return dfs(nums, visited, 0, target, 0, k);
}

function dfs(nums, visited, start, target, currSum, k) {
  if (k === 1) return true;
  if (currSum === target) return dfs(nums, visited, 0, target, 0, k - 1);
  for (let i = start; i < nums.length; i++) {
    if (!visited[i] && currSum + nums[i] <= target) {
      visited[i] = true;
      if (dfs(nums, visited, i + 1, target, currSum + nums[i], k)) return true;
      visited[i] = false;
    }
  }
  return false;
}

-----
function canPartitionKSubsets(nums, k) 
    // Your code here
}

************************************
Question ID: 699
function fallingSquares(positions) {
    let ans = [];
    let intervals = [];

    for (let p of positions) {
        let L = p[0];
        let R = p[0] + p[1];
        let h = p[1];
        for (let it of intervals) {
            if (it[1] > L && R > it[1]) {
                h = Math.max(h, p[1] + it[0]);
            }
        }

        let maxHeight = h;
        for (let it of intervals) {
            maxHeight = Math.max(maxHeight, it[0]);
        }

        ans.push(maxHeight);
        intervals.push([h, R]);
    }
    
    return ans;
}

-----
function fallingSquares(positions) 
    // Your code here
}

************************************
Question ID: 702
function search(reader, target) {
    let left = 0, right = 1;
    while (reader.get(right) < target) {
        left = right;
        right <<= 1;
    }

    while (left <= right) {
        let mid = left + ((right - left) >> 1);
        let val = reader.get(mid);
        if (val === target)
            return mid;
        if (val > target)
            right = mid - 1;
        else
            left = mid + 1;
    }
    return -1;
}

-----
function search(reader, target) 
    // Your code here
}

************************************
Question ID: 703
class KthLargest {
    constructor(k, nums) {
        this.k = k;
        this.minHeap = new MinHeap();
        for (let num of nums) {
            this.add(num);
        }
    }
    
    add(val) {
        this.minHeap.offer(val);
        if (this.minHeap.size() > this.k) {
            this.minHeap.poll();
        }
        return this.minHeap.peek();
    }
}

class MinHeap {
    constructor() {
        this.heap = [];
    }

    offer(val) {
        this.heap.push(val);
        this.heap.sort((a, b) => a - b);
    }

    poll() {
        return this.heap.shift();
    }

    peek() {
        return this.heap[0];
    }

    size() {
        return this.heap.length;
    }
}

-----
class KthLargest 
    // Your code here
}

************************************
Question ID: 704
function search(nums, target) {
    let left = 0, right = nums.length - 1;
    while (left <= right) {
        const mid = Math.floor(left + (right - left) / 2);
        if (nums[mid] === target) return mid;
        if (nums[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}


-----
function search(nums, target) 
    // Your code here
}


************************************
Question ID: 709
function toLowerCase(s) {
    let result = '';
    for (let i = 0; i < s.length; i++) {
        let charCode = s.charCodeAt(i);
        if (charCode >= 65 && charCode <= 90) {
            charCode += 32;
        }
        result += String.fromCharCode(charCode);
    }
    return result;
}

-----
function toLowerCase(s) 
    // Your code here
}

************************************
Question ID: 710
class Solution {
    constructor(n, blacklist) {
        blacklist.sort((a, b) => a - b);
        this.mapping = new Map();
        let idx = 0;
        for (let i = 0; i < blacklist.length; ++i) {
            let black = blacklist[i];
            while (idx < black) {
                this.mapping.set(idx++, n - 1);
                n--;
            }
            idx++;
            n--;
        }
        this.last = n;
    }

    pick() {
        const num = Math.floor(Math.random() * this.last);
        return this.mapping.has(num) ? this.mapping.get(num) : num;
    }
}

-----
class Solution 
    // Your code here
}

************************************
Question ID: 712
function minimumDeleteSum(s1, s2) {
    const dp = Array.from({ length: s1.length + 1 }, () => Array(s2.length + 1).fill(0));
    for (let i = 1; i <= s1.length; i++) {
        dp[i][0] = dp[i - 1][0] + s1.charCodeAt(i - 1);
    }
    for (let j = 1; j <= s2.length; j++) {
        dp[0][j] = dp[0][j - 1] + s2.charCodeAt(j - 1);
    }
    for (let i = 1; i <= s1.length; i++) {
        for (let j = 1; j <= s2.length; j++) {
            if (s1.charAt(i - 1) === s2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.min(dp[i - 1][j] + s1.charCodeAt(i - 1), dp[i][j - 1] + s2.charCodeAt(j - 1));
            }
        }
    }
    return dp[s1.length][s2.length];
}

-----
function minimumDeleteSum(s1, s2) 
    // Your code here
}

************************************
Question ID: 713
function numSubarrayProductLessThanK(nums, k) {
    if (k <= 1) return 0;
    let prod = 1, count = 0, left = 0;
    for (let right = 0; right < nums.length; right++) {
        prod *= nums[right];
        while (prod >= k) prod /= nums[left++];
        count += right - left + 1;
    }
    return count;
}

-----
function numSubarrayProductLessThanK(nums, k) 
    // Your code here
}

************************************
Question ID: 714
function maxProfit(prices, fee) {
    let cash = 0, hold = -prices[0];
    for (const price of prices) {
        let temp = cash;
        cash = Math.max(cash, hold + price - fee);
        hold = Math.max(hold, temp - price);
    }
    return cash;
}

-----
function maxProfit(prices, fee) 
    // Your code here
}

************************************
Question ID: 716
class MaxStack {
    constructor() {
        this.mainStack = [];
        this.maxSet = new Set();
    }

    push(x) {
        this.mainStack.push(x);
        this.maxSet.add(x);
    }

    pop() {
        const top = this.mainStack.pop();
        this.maxSet.delete(top);
        return top;
    }

    top() {
        return this.mainStack[this.mainStack.length - 1];
    }

    peekMax() {
        return Math.max(...this.maxSet);
    }

    popMax() {
        const max = Math.max(...this.maxSet);
        this.maxSet.delete(max);

        const tempStack = [];
        while (this.mainStack[this.mainStack.length - 1] !== max) {
            tempStack.push(this.mainStack.pop());
        }
        this.mainStack.pop();
        while (tempStack.length) {
            this.mainStack.push(tempStack.pop());
        }

        return max;
    }
}

-----
class MaxStack 
    // Your code here
}

************************************
Question ID: 717
function isOneBitCharacter(bits) {
    let i;
    for (i = 0; i < bits.length - 1; i++) {
        i += bits[i];
    }
    return i === bits.length - 1;
}

-----
function isOneBitCharacter(bits) 
    // Your code here
}

************************************
Question ID: 718
function findLength(nums1, nums2) {
    const m = nums1.length;
    const n = nums2.length;
    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
    let maxLength = 0;

    for (let i = m - 1; i >= 0; i--) {
        for (let j = n - 1; j >= 0; j--) {
            if (nums1[i] === nums2[j]) {
                dp[i][j] = dp[i + 1][j + 1] + 1;
                maxLength = Math.max(maxLength, dp[i][j]);
            }
        }
    }

    return maxLength;
}

-----
function findLength(nums1, nums2) 
    // Your code here
}

************************************
Question ID: 719
function smallestDistancePair(nums, k) {
    nums.sort((a, b) => a - b);
    let low = 0, high = nums[nums.length - 1] - nums[0];
    
    while (low < high) {
        let mid = Math.floor((low + high) / 2);
        let count = 0, left = 0;

        for (let right = 0; right < nums.length; ++right) {
            while (nums[right] - nums[left] > mid) {
                ++left;
            }
            count += (right - left);
        }

        if (count < k) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    
    return low;
}


-----
function smallestDistancePair(nums, k) 
    // Your code here
}


************************************
Question ID: 720
function longestWord(words) {
    words.sort();
    const builtWords = new Set();
    let result = '';

    for (const word of words) {
        if (word.length === 1 || builtWords.has(word.slice(0, -1))) {
            result = (word.length > result.length) ? word : result;
            builtWords.add(word);
        }
    }

    return result;
}


-----
function longestWord(words) 
    // Your code here
}


************************************
Question ID: 721
var accountsMerge = function(accounts) {
    function dfs(id, visited, mergedEmails) {
        if (visited.has(id)) return;
        visited.add(id);
        for (let j = 1; j < accounts[id].length; j++) {
            const email = accounts[id][j];
            mergedEmails.add(email);
            const nextId = emailToId[email];
            dfs(nextId, visited, mergedEmails);
        }
    }

    const emailToId = {};
    accounts.forEach((account, i) => {
        account.slice(1).forEach(email => {
            emailToId[email] = i;
        });
    });

    const result = [];
    const visited = new Set();
    accounts.forEach((account, i) => {
        if (!visited.has(i)) {
            const mergedEmails = new Set();
            dfs(i, visited, mergedEmails);
            result.push([account[0], ...Array.from(mergedEmails).sort()]);
        }
    });
    return result;
};


-----
var accountsMerge = function(accounts) 
    // Your code here
};


************************************
Question ID: 722
var removeComments = function(source) {
    let result = [];
    let buffer = '';
    let inBlockComment = false;
    
    for (const line of source) {
        for (let i = 0; i < line.length; ++i) {
            if (inBlockComment) {
                if (i < line.length - 1 && line[i] === '*' && line[i + 1] === '/') {
                    inBlockComment = false;
                    ++i;
                }
            } else {
                if (i < line.length - 1 && line[i] === '/' && line[i + 1] === '*') {
                    inBlockComment = true;
                    ++i;
                } else if (i < line.length - 1 && line[i] === '/' && line[i + 1] === '/') {
                    break;
                } else {
                    buffer += line[i];
                }
            }
        }
        if (!inBlockComment && buffer.length) {
            result.push(buffer);
            buffer = '';
        }
    }
    return result;
};


-----
var removeComments = function(source) 
    // Your code here
};


************************************
Question ID: 723
function candyCrush(board) {
    let rows = board.length;
    let cols = board[0].length;
    let toDo = false;
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols - 2; c++) {
            let val = Math.abs(board[r][c]);
            if (val && val === Math.abs(board[r][c + 1]) && val === Math.abs(board[r][c + 2])) {
                board[r][c] = board[r][c + 1] = board[r][c + 2] = -val;
                toDo = true;
            }
        }
    }
    for (let r = 0; r < rows - 2; r++) {
        for (let c = 0; c < cols; c++) {
            let val = Math.abs(board[r][c]);
            if (val && val === Math.abs(board[r + 1][c]) && val === Math.abs(board[r + 2][c])) {
                board[r][c] = board[r + 1][c] = board[r + 2][c] = -val;
                toDo = true;
            }
        }
    }

    for (let c = 0; c < cols; c++) {
        let wr = rows - 1;
        for (let r = rows - 1; r >= 0; r--) {
            if (board[r][c] > 0) {
                board[wr][c] = board[r][c];
                wr--;
            }
        }
        for (let r = wr; r >= 0; r--) {
            board[r][c] = 0;
        }
    }

    return toDo ? candyCrush(board) : board;
}


-----
function candyCrush(board) 
    // Your code here
}


************************************
Question ID: 724
function pivotIndex(nums) {
    const total_sum = nums.reduce((a, b) => a + b, 0);
    let left_sum = 0;
    for (let i = 0; i < nums.length; ++i) {
        if (left_sum === total_sum - left_sum - nums[i])
            return i;
        left_sum += nums[i];
    }
    return -1;
}


-----
function pivotIndex(nums) 
    // Your code here
}


************************************
Question ID: 726
function parse(formula, i) {
    let counts = {};
    while (i[0] < formula.length) {
        if (formula[i[0]] == '(') {
            i[0] += 1;
            let temp = parse(formula, i);
            let count = 0;
            while (i[0] < formula.length && !isNaN(formula[i[0]])) {
                count = count * 10 + parseInt(formula[i[0]]);
                i[0] += 1;
            }
            if (count == 0) count = 1;
            for (let [name, c] of Object.entries(temp)) {
                counts[name] = (counts[name] || 0) + c * count;
            }
        } else if (formula[i[0]] == ')') {
            i[0] += 1;
            return counts;
        } else {
            let name = formula[i[0]];
            i[0] += 1;
            while (i[0] < formula.length && formula[i[0]] >= 'a' && formula[i[0]] <= 'z') {
                name += formula[i[0]];
                i[0] += 1;
            }
            let count = 0;
            while (i[0] < formula.length && !isNaN(formula[i[0]])) {
                count = count * 10 + parseInt(formula[i[0]]);
                i[0] += 1;
            }
            if (count == 0) count = 1;
            counts[name] = (counts[name] || 0) + count;
        }
    }
    return counts;
}

function countOfAtoms(formula) {
    let i = [0];
    let counts = parse(formula, i);
    let ans = [];
    for (let name of Object.keys(counts).sort()) {
        ans.push(name);
        if (counts[name] > 1) ans.push(counts[name]);
    }
    return ans.join('');
}


-----
function parse(formula, i) 
    // Your code here
}


************************************
Question ID: 727
function minWindowSubSequence(s1, s2) {
    const m = s1.length, n = s2.length;
    const dp = Array.from({ length: n + 1 }, () => Array(m + 1).fill(0));

    for (let j = 0; j <= m; ++j) {
        dp[0][j] = j;
    }

    for (let i = 1; i <= n; ++i) {
        for (let j = 1; j <= m; ++j) {
            if (s1[j - 1] === s2[i - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = dp[i][j - 1];
            }
        }
    }
    
    let start = 0, length = m + 1;
    for (let j = 1; j <= m; ++j) {
        if (dp[n][j] !== 0 && j - dp[n][j] < length) {
            start = dp[n][j];
            length = j - start;
        }
    }

    return length === m + 1 ? "" : s1.slice(start, start + length);
}

-----
function minWindowSubSequence(s1, s2) 
    // Your code here
}

************************************
Question ID: 728
function isSelfDividing(num) {
    let n = num;
    while (n) {
        const digit = n % 10;
        if (digit === 0 || num % digit !== 0)
            return false;
        n = Math.floor(n / 10);
    }
    return true;
}

function selfDividingNumbers(left, right) {
    const result = [];
    for (let i = left; i <= right; ++i) {
        if (isSelfDividing(i))
            result.push(i);
    }
    return result;
}

-----
function isSelfDividing(num) 
    // Your code here
}

************************************
Question ID: 729
class MyCalendar {
    constructor() {
        this.calendar = new Map();
    }

    book(start, end) {
        if (this.calendar.size === 0) {
            this.calendar.set(start, end);
            return true;
        }

        let booked = false;
        for (let [s, e] of this.calendar) {
            if (Math.max(s, start) < Math.min(e, end)) {
                booked = true;
                break;
            }
        }

        if (!booked) {
            this.calendar.set(start, end);
            return true;
        }

        return false;
    }
}

-----
class MyCalendar 
    // Your code here
}

************************************
Question ID: 730
function countPalindromicSubsequences(s) {
    const n = s.length;
    const MOD = 1000000007;
    const dp = Array.from({ length: 4 }, () => Array(n + 1).fill(0));

    for (let i = n - 1; i >= 0; i--) {
        for (let j = i + 1; j <= n; j++) {
            const c = s.charCodeAt(i) - 97;
            dp[c][j] = dp[0][j - 1] + dp[1][j - 1] + dp[2][j - 1] + dp[3][j - 1] - dp[c][i] + 2;
            dp[c][j] = (dp[c][j] + MOD) % MOD;
        }
    }

    return (dp[0][n] + dp[1][n] + dp[2][n] + dp[3][n]) % MOD;
}


-----
function countPalindromicSubsequences(s) 
    // Your code here
}


************************************
Question ID: 732
class MyCalendarThree {
    constructor() {
        this.timeline = new Map();
    }

    book(start, end) {
        this.timeline.set(start, (this.timeline.get(start) || 0) + 1);
        this.timeline.set(end, (this.timeline.get(end) || 0) - 1);
        let ongoing = 0, k = 0;
        for (const value of this.timeline.values()) {
            k = Math.max(k, ongoing += value);
        }
        return k;
    }
}


-----
class MyCalendarThree 
    // Your code here
}


************************************
Question ID: 733
function floodFill(image, sr, sc, newColor) {
    let startColor = image[sr][sc];
    function fill(sr, sc) {
        if (sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length || image[sr][sc] !== startColor || image[sr][sc] === newColor) return;
        image[sr][sc] = newColor;
        fill(sr - 1, sc);
        fill(sr + 1, sc);
        fill(sr, sc - 1);
        fill(sr, sc + 1);
    }
    fill(sr, sc);
    return image;
}


-----
function floodFill(image, sr, sc, newColor) 
    // Your code here
}


************************************
Question ID: 734
function areSentencesSimilar(sentence1, sentence2, similarPairs) {
    if (sentence1.length !== sentence2.length) return false;
    const similarityMap = new Map();
    for (const pair of similarPairs) {
        if (!similarityMap.has(pair[0])) similarityMap.set(pair[0], new Set());
        if (!similarityMap.has(pair[1])) similarityMap.set(pair[1], new Set());
        similarityMap.get(pair[0]).add(pair[1]);
        similarityMap.get(pair[1]).add(pair[0]);
    }
    for (let i = 0; i < sentence1.length; ++i) {
        if (sentence1[i] !== sentence2[i] && !similarityMap.get(sentence1[i])?.has(sentence2[i]))
            return false;
    }
    return true;
}


-----
function areSentencesSimilar(sentence1, sentence2, similarPairs) 
    // Your code here
}


************************************
Question ID: 735
function asteroidCollision(asteroids) {
    const s = [];
    for (let i = 0; i < asteroids.length; i++) {
        if (asteroids[i] > 0 || !s.length || s[s.length - 1] < 0) {
            s.push(asteroids[i]);
        } else if (s[s.length - 1] <= -asteroids[i]) {
            if (s[s.length - 1] < -asteroids[i]) i--;
            s.pop();
        }
    }
    return s;
}


-----
function asteroidCollision(asteroids) 
    // Your code here
}


************************************
Question ID: 736
function evaluate(expression) {
    function calculate(s, start, end, variables) {
        if (s[start] === '(') {
            if (s.substr(start + 1, 3) === "add") {
                let first = start + 5;
                let second = first;
                let value1 = calculate(s, first, end, variables);
                second = s.indexOf(' ', second) + 1;
                let value2 = calculate(s, second, end, variables);
                return value1 + value2;
            } else if (s.substr(start + 1, 4) === "mult") {
                let first = start + 6;
                let second = first;
                let value1 = calculate(s, first, end, variables);
                second = s.indexOf(' ', second) + 1;
                let value2 = calculate(s, second, end, variables);
                return value1 * value2;
            } else {
                let inner = new Map(variables);
                let idx = start + 5;
                while (idx < end - 1 && s[idx] !== '(') {
                    let temp = idx;
                    idx = s.indexOf(' ', idx + 1);
                    let varName = s.substring(temp, idx);
                    temp = idx + 1;
                    if (s[temp] === '(') {
                        idx++;
                    } else {
                        idx = s.indexOf(' ', idx + 1);
                    }
                    let result = calculate(s, temp, idx, variables);
                    inner.set(varName, result);
                    variables = inner;
                }
                return calculate(s, end - 1, end, variables);
            }
        } else {
            if (s[start] === '-' || !isNaN(s[start])) {
                let idx = s.indexOf(' ', start);
                end = idx === -1 ? end : idx;
                return parseInt(s.substring(start, end));
            } else {
                let idx = s.indexOf(' ', start);
                end = idx === -1 ? end : idx;
                return variables.get(s.substring(start, end));
            }
        }
    }

    return calculate(expression, 0, expression.length, new Map());
}

-----
function evaluate(expression) 
    // Your code here
}

************************************
Question ID: 737
function areSentencesSimilar(sentence1, sentence2, pairs) {
    if (sentence1.length !== sentence2.length) return false;
    
    const graph = new Map();
    for (const [a, b] of pairs) {
        if (!graph.has(a)) graph.set(a, new Set());
        if (!graph.has(b)) graph.set(b, new Set());
        
        graph.get(a).add(b);
        graph.get(b).add(a);
    }
    
    for (let i = 0; i < sentence1.length; ++i) {
        if (sentence1[i] === sentence2[i]) continue;

        const neighbors = graph.get(sentence1[i]);
        if (!neighbors || !neighbors.has(sentence2[i])) return false;
    }
    
    return true;
}

-----
function areSentencesSimilar(sentence1, sentence2, pairs) 
    // Your code here
}

************************************
Question ID: 738
function monotoneIncreasingDigits(n) {
    let n_str = n.toString();
    let n_len = n_str.length;

    let i = n_len - 1;
    while (i > 0) {
        if (n_str.charAt(i) < n_str.charAt(i - 1)) {
            n_str = n_str.slice(0, i-1) + String.fromCharCode(n_str.charCodeAt(i-1) - 1) + '9'.repeat(n_len - i);
        }
        --i;
    }

    return parseInt(n_str);
}


-----
function monotoneIncreasingDigits(n) 
    // Your code here
}


************************************
Question ID: 739
function dailyTemperatures(temperatures) {
    const result = new Array(temperatures.length).fill(0);
    const stack = [];

    for (let i = 0; i < temperatures.length; i++) {
        while (stack.length > 0 && temperatures[i] > temperatures[stack[stack.length - 1]]) {
            const idx = stack.pop();
            result[idx] = i - idx;
        }
        stack.push(i);
    }

    return result;
}

-----
function dailyTemperatures(temperatures) 
    // Your code here
}

************************************
Question ID: 740
function maxPoints(nums) {
    const dp = new Array(100001).fill(0);
    let max_points = 0;
    for (let num of nums) {
        dp[num]++;
    }
    for (let i = 2; i < dp.length; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + i * dp[i]);
        max_points = Math.max(max_points, dp[i]);
    }
    return max_points;
}

-----
function maxPoints(nums) 
    // Your code here
}

************************************
Question ID: 741
var cherryPickup = function(grid) {
    const N = grid.length;
    const memo = new Array(N).fill(0).map(() => new Array(N).fill(0).map(() => new Array(N).fill(Number.MIN_SAFE_INTEGER)));

    function dp(r1, c1, c2) {
        const r2 = r1 + c1 - c2;
        if (r1 === N || r2 === N || c1 === N || c2 === N || grid[r1][c1] === -1 || grid[r2][c2] === -1) {
            return Number.MIN_SAFE_INTEGER;
        } else if (r1 === N - 1 && c1 === N - 1) {
            return grid[r1][c1];
        } else if (memo[r1][c1][c2] !== Number.MIN_SAFE_INTEGER) {
            return memo[r1][c1][c2];
        } else {
            memo[r1][c1][c2] = grid[r1][c1] + (r1 !== r2 ? grid[r2][c2] : 0);
            const tempMax = Math.max(Math.max(dp(r1 + 1, c1, c2 + 1), dp(r1, c1 + 1, c2 + 1)),
                            Math.max(dp(r1 + 1, c1, c2), dp(r1, c1 + 1, c2)));
            memo[r1][c1][c2] += tempMax;
        }
        return memo[r1][c1][c2];
    }

    return Math.max(0, dp(0, 0, 0));
};


-----
var cherryPickup = function(grid) 
    // Your code here
};


************************************
Question ID: 742
function toLowerCase(s) {
    return s.toLowerCase();
}

-----
function toLowerCase(s) 
    // Your code here
}

************************************
Question ID: 743
function networkDelayTime(times, n, k) {
    const graph = new Map();
    for (const [u, v, w] of times) {
        if (!graph.has(u)) graph.set(u, []);
        graph.get(u).push([v, w]);
    }
    
    const dist = new Array(n + 1).fill(Infinity);
    dist[k] = 0;

    const pq = [[0, k]];

    while (pq.length) {
        pq.sort((a, b) => b[0] - a[0]);
        const [currDist, u] = pq.pop();

        if (graph.has(u)) {
            for (const [v, weight] of graph.get(u)) {
                const newDist = currDist + weight;
                if (newDist < dist[v]) {
                    dist[v] = newDist;
                    pq.push([dist[v], v]);
                }
            }
        }
    }

    const maxTime = Math.max(...dist.slice(1));
    return maxTime === Infinity ? -1 : maxTime;
}


-----
function networkDelayTime(times, n, k) 
    // Your code here
}


************************************
Question ID: 744
function networkDelayTime(times, n, k) {
    const graph = new Map();
    for (const [u, v, w] of times) {
        if (!graph.has(u)) graph.set(u, []);
        graph.get(u).push([v, w]);
    }

    const dist = new Array(n + 1).fill(Infinity);
    dist[k] = 0;

    const pq = [[0, k]];
    while (pq.length) {
        pq.sort((a, b) => b[0] - a[0]);
        const [time, node] = pq.pop();

        if (time > dist[node]) continue;

        if (graph.has(node)) {
            for (const [neighbour, neighbourTime] of graph.get(node)) {
                const candidate_dist = time + neighbourTime;
                if (candidate_dist < dist[neighbour]) {
                    dist[neighbour] = candidate_dist;
                    pq.push([candidate_dist, neighbour]);
                }
            }
        }
    }

    const maxTime = Math.max(...dist.slice(1));
    return maxTime === Infinity ? -1 : maxTime;
}

-----
function networkDelayTime(times, n, k) 
    // Your code here
}

************************************
Question ID: 745
function nextGreatestLetter(letters, target) {
    for (let letter of letters) {
        if (letter > target) {
            return letter;
        }
    }
    return letters[0];
}

-----
function nextGreatestLetter(letters, target) 
    // Your code here
}

************************************
Question ID: 747
function minCostClimbingStairs(cost) {
    for(let i=2; i<cost.length; i++)
        cost[i] += Math.min(cost[i-1], cost[i-2]);
    return Math.min(cost[cost.length-1], cost[cost.length-2]);
}

-----
function minCostClimbingStairs(cost) 
    // Your code here
}

************************************
Question ID: 748
function shortestCompletingWord(licensePlate, words) {
  const lpCount = new Map();
  for (const c of licensePlate)
    if (c.match(/[a-zA-Z]/))
      lpCount.set(c.toLowerCase(), (lpCount.get(c.toLowerCase()) || 0) + 1);

  let result = "";
  for (const word of words) {
    const wordCount = new Map();
    for (const c of word)
      wordCount.set(c, (wordCount.get(c) || 0) + 1);

    let valid = true;
    for (const [ch, count] of lpCount)
      if ((wordCount.get(ch) || 0) < count) {
        valid = false;
        break;
      }

    if (valid && (!result || word.length < result.length))
      result = word;
  }
  return result;
}


-----
function shortestCompletingWord(licensePlate, words) 
    // Your code here
}


************************************
Question ID: 749
function shortestCompletingWord(licensePlate, words) {
    let target = Array(26).fill(0);
    for (let c of licensePlate)
        if (c.toLowerCase() != c.toUpperCase()) target[c.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0)]++;

    let result = "";
    for (let word of words) {
        let current = Array(26).fill(0);
        for (let c of word)
            if (c.toLowerCase() != c.toUpperCase()) current[c.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0)]++;

        if (target.every((a, i) => a <= current[i]) && (result === "" || word.length < result.length)) result = word;
    }

    return result;
}

-----
function shortestCompletingWord(licensePlate, words) 
    // Your code here
}

************************************
Question ID: 750
function countCornerRectangles(grid) {
    let count = 0;
    let m = grid.length;
    let n = grid[0].length;
    
    for (let i = 0; i < m - 1; i++) {
        for (let j = 0; j < n - 1; j++) {
            if (grid[i][j] === 1) {
                for (let k = i + 1; k < m; k++) {
                    for (let l = j + 1; l < n; l++) {
                        if (grid[k][l] === 1 && grid[i][l] === 1 && grid[k][j] === 1) {
                            count++;
                        }
                    }
                }
            }
        }
    }
    return count;
}

-----
function countCornerRectangles(grid) 
    // Your code here
}

************************************
Question ID: 751
function ipToCIDR(ip, n) {
    const [a, b, c, d] = ip.split('.').map(Number);
    let start = (a << 24) + (b << 16) + (c << 8) + d;
    const end = start + n - 1;
    
    const ans = [];
    while (start <= end) {
        let samePrefixBits = Math.clz32(~(start & -start));
        while (((end - start) >> samePrefixBits) < 1)
            --samePrefixBits;
        const range = 1 << samePrefixBits;
        ans.push(`${(start >> 24)}.${((start >> 16) & 255)}.${((start >> 8) & 255)}.${(start & 255)}/${32 - samePrefixBits}`);
        start += range;
    }
    
    return ans;
}


-----
function ipToCIDR(ip, n) 
    // Your code here
}


************************************
Question ID: 752
var openLock = function(deadends, target) {
    const dead = new Set(deadends);
    const visited = new Set();
    const queue = ["0000"];

    if (dead.has("0000")) return -1;

    visited.add("0000");
    let moves = 0;

    while (queue.length) {
        let levelSize = queue.length;
        for (let i = 0; i < levelSize; i++) {
            let cur = queue.shift();

            if (cur === target) return moves;

            for (let j = 0; j < 4; j++) {
                for (let k = -1; k <= 1; k += 2) {
                    let next = cur.slice(0, j) + ((Number(cur[j]) + k + 10) % 10).toString() + cur.slice(j + 1);

                    if (!visited.has(next) && !dead.has(next)) {
                        visited.add(next);
                        queue.push(next);
                    }
                }
            }
        }
        moves++;
    }

    return -1;
};


-----
var openLock = function(deadends, target) 
    // Your code here
};


************************************
Question ID: 753
function openLock(deadends, target) {
    const dead = new Set(deadends);
    const visited = new Set();
    const wheelStates = [["0000", 0]];

    if (dead.has("0000")) return -1;

    while (wheelStates.length > 0) {
        const [currentState, turns] = wheelStates.shift();

        if (currentState === target) return turns;

        for (let i = 0; i < 4; ++i) {
            const upState = currentState.slice(0, i) + ((parseInt(currentState[i]) + 1) % 10).toString() + currentState.slice(i + 1);
            const downState = currentState.slice(0, i) + ((parseInt(currentState[i]) - 1 + 10) % 10).toString() + currentState.slice(i + 1);

            if (!visited.has(upState) && !dead.has(upState)) {
                wheelStates.push([upState, turns + 1]);
                visited.add(upState);
            }

            if (!visited.has(downState) && !dead.has(downState)) {
                wheelStates.push([downState, turns + 1]);
                visited.add(downState);
            }
        }
    }
    return -1;
}

-----
function openLock(deadends, target) 
    // Your code here
}

************************************
Question ID: 754
function reachNumber(target) {
    target = Math.abs(target);
    let step = 0, sum = 0;
    while (sum < target) {
        step++;
        sum += step;
    }
    while ((sum - target) % 2 != 0) {
        step++;
        sum += step;
    }
    return step;
}


-----
function reachNumber(target) 
    // Your code here
}


************************************
Question ID: 755
function minMoves(target) {
    target = Math.abs(target);
    let step = 0;
    let sum = 0;
    while (sum < target || (sum - target) % 2 !== 0) {
        step++;
        sum += step;
    }
    return step;
}


-----
function minMoves(target) 
    // Your code here
}


************************************
Question ID: 756
function pyramidTransition(bottom, allowed) {
    const mapping = {};
    for (const s of allowed) {
        const key = s.substr(0, 2);
        if (!(key in mapping)) mapping[key] = [];
        mapping[key].push(s[2]);
    }
    return pyramidTransitionHelper(bottom, '', 0, mapping);
}

function pyramidTransitionHelper(bottom, top, idx, mapping) {
    if (bottom.length === 1) return true;
    if (idx === bottom.length - 1) return pyramidTransitionHelper(top, '', 0, mapping);
    const key = bottom.substr(idx, 2);
    if (!(key in mapping)) return false;
    for (const c of mapping[key]) {
        if (pyramidTransitionHelper(bottom, top + c, idx + 1, mapping)) return true;
    }
    return false;
}


-----
function pyramidTransition(bottom, allowed) 
    // Your code here
}


************************************
Question ID: 757
function pyramidTransition(bottom, allowed) {
    const mapping = {};
    for (const s of allowed) {
        const key = s.slice(0, 2);
        if (!(key in mapping)) {
            mapping[key] = [];
        }
        mapping[key].push(s[2]);
    }
    return dfs("", bottom, mapping);
}

function dfs(curr, bottom, mapping) {
    if (bottom.length === 1) {
        return true;
    }
    for (let i = 0; i < bottom.length - 1; ++i) {
        if (!(bottom.slice(i, i + 2) in mapping)) {
            return false;
        }
    }
    curr = "";
    for (let i = 0; i < bottom.length - 1; ++i) {
        curr += mapping[bottom.slice(i, i + 2)][0];
    }
    return dfs(curr, curr, mapping);
}


-----
function pyramidTransition(bottom, allowed) 
    // Your code here
}


************************************
Question ID: 758
function addBoldTag(words, s) {
    const bold = new Array(s.length).fill(false);
    for (const word of words) {
        let pos = s.indexOf(word);
        while (pos !== -1) {
            for (let i = pos; i < pos + word.length; i++) {
                bold[i] = true;
            }
            pos = s.indexOf(word, pos + 1);
        }
    }

    let result = "";
    for (let i = 0; i < s.length; i++) {
        if (bold[i] && (i === 0 || !bold[i - 1])) result += "<b>";
        result += s[i];
        if (bold[i] && (i === s.length - 1 || !bold[i + 1])) result += "</b>";
    }

    return result;
}

-----
function addBoldTag(words, s) 
    // Your code here
}

************************************
Question ID: 759
function minSetSize(intervals) {
    intervals.sort((a, b) => a[0] - b[0]);
    const n = intervals.length;
    let end = intervals[0][1];
    let count = 1;

    for (let i = 1; i < n; i++) {
        if (end < intervals[i][0]) {
            end = intervals[i][1];
            count++;
        } else {
            end = Math.min(end, intervals[i][1]);
        }
    }
    return count * 2;
}

-----
function minSetSize(intervals) 
    // Your code here
}

************************************
Question ID: 760
function anagramMappings(nums1, nums2) {
    let num_map = new Map();
    for (let i = 0; i < nums2.length; i++) {
        num_map.set(nums2[i], i);
    }
    let mapping = new Array(nums1.length);
    for (let i = 0; i < nums1.length; i++) {
        mapping[i] = num_map.get(nums1[i]);
    }
    return mapping;
}


-----
function anagramMappings(nums1, nums2) 
    // Your code here
}


************************************
Question ID: 761
function makeLargestSpecial(s) {
    let count = 0, i = 0;
    let subs = [];

    for (let j = 0; j < s.length; j++) {
        if (s[j] === '1') count++;
        else count--;

        if (count === 0) {
            subs.push("1" + makeLargestSpecial(s.slice(i+1, j)) + "0");
            i = j + 1;
        }
    }

    subs.sort((a, b) => b.localeCompare(a));
    return subs.join('');
}


-----
function makeLargestSpecial(s) 
    // Your code here
}


************************************
Question ID: 762
function isPrime(n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 === 0 || n % 3 === 0) return false;
    for (let i = 5; i * i <= n; i += 6)
        if (n % i === 0 || n % (i + 2) === 0) return false;
    return true;
}

function countPrimeSetBits(left, right) {
    let count = 0;
    for (let i = left; i <= right; ++i)
        count += isPrime(i.toString(2).split('1').length - 1) ? 1 : 0;
    return count;
}


-----
function isPrime(n) 
    // Your code here
}


************************************
Question ID: 763
function partitionLabels(s) {
    const last = {};
    for (let i = 0; i < s.length; i++) {
        last[s[i]] = i;
    }
    const ans = [];
    let j = 0, anchor = 0;
    for (let i = 0; i < s.length; i++) {
        j = Math.max(j, last[s[i]]);
        if (i === j) {
            ans.push(i - anchor + 1);
            anchor = i + 1;
        }
    }
    return ans;
}

-----
function partitionLabels(s) 
    // Your code here
}

************************************
Question ID: 764
class Node {
    constructor(val, children) {
        this.val = val;
        this.children = children;
    }
}

function levelOrder(root) {
    const result = [];
    if (!root) return result;

    const toVisit = [root];

    while (toVisit.length > 0) {
        const size = toVisit.length;
        const level = [];

        for (let i = 0; i < size; i++) {
            const currentNode = toVisit.shift();
            level.push(currentNode.val);

            for (const child of currentNode.children) {
                toVisit.push(child);
            }
        }
        result.push(level);
    }

    return result;
}

-----
class Node 
    // Your code here
}

************************************
Question ID: 765
function minSwapsCouples(row) {
    const n = row.length;
    const position = new Array(n);
    for (let i = 0; i < n; ++i)
        position[row[i]] = i;

    let swaps = 0;
    for (let i = 0; i < n; i += 2) {
        const partner = row[i] % 2 === 0 ? row[i] + 1 : row[i] - 1;
        if (row[i + 1] !== partner) {
            [row[position[partner]], row[i + 1]] = [row[i + 1], row[position[partner]]];
            [position[row[i + 1]], position[partner]] = [position[partner], position[row[i + 1]]];
            swaps++;
        }
    }
    return swaps;
}


-----
function minSwapsCouples(row) 
    // Your code here
}


************************************
Question ID: 767
function isPrime(n) {
    if (n <= 1) return false;
    for (let i = 2; i * i <= n; i++) {
        if (n % i === 0) return false;
    }
    return true;
}

function countPrimeSetBits(left, right) {
    let count = 0;
    for (let i = left; i <= right; i++) {
        let bits = i.toString(2).split('1').length - 1;
        if (isPrime(bits)) count++;
    }
    return count;
}

-----
function isPrime(n) 
    // Your code here
}

************************************
Question ID: 768
function partitionLabels(s) {
    const lastPos = {};
    for (let i = 0; i < s.length; i++) {
        lastPos[s[i]] = i;
    }

    const partitions = [];
    let start = 0, end = 0;
    for (let i = 0; i < s.length; i++) {
        end = Math.max(end, lastPos[s[i]]);
        if (i === end) {
            partitions.push(end - start + 1);
            start = i + 1;
        }
    }
    return partitions;
}


-----
function partitionLabels(s) 
    // Your code here
}


************************************
Question ID: 769
function orderOfLargestPlusSign(n, mines) {
    const grid = Array.from({ length: n }, () => Array(n).fill(1));
    for (const mine of mines)
        grid[mine[0]][mine[1]] = 0;

    const left = grid.map(row => [...row]);
    const right = grid.map(row => [...row]);
    const up = grid.map(row => [...row]);
    const down = grid.map(row => [...row]);

    for (let i = 0; i < n; ++i) {
        for (let j = 0; j < n; ++j) {
            if (grid[i][j]) {
                left[i][j] = j > 0 ? left[i][j - 1] + 1 : 1;
                up[i][j] = i > 0 ? up[i - 1][j] + 1 : 1;
            }
            if (grid[n - i - 1][n - j - 1]) {
                right[n - i - 1][n - j - 1] = j > 0 ? right[n - i - 1][n - j] + 1 : 1;
                down[n - i - 1][n - j - 1] = i > 0 ? down[n - i][n - j - 1] + 1 : 1;
            }
        }
    }

    let ans = 0;
    for (let i = 0; i < n; ++i)
        for (let j = 0; j < n; ++j)
            ans = Math.max(ans, Math.min(left[i][j], right[i][j], up[i][j], down[i][j]));

    return ans;
}


-----
function orderOfLargestPlusSign(n, mines) 
    // Your code here
}


************************************
Question ID: 770
function minSwapsCouples(row) {
    const n = row.length / 2;
    let swaps = 0;
    const position = {};

    for (let i = 0; i < row.length; i++) {
        position[row[i]] = i;
    }

    for (let i = 0; i < row.length; i += 2) {
        const couple = (row[i] % 2 === 0) ? row[i] + 1 : row[i] - 1;
        if (row[i + 1] !== couple) {
            [row[i + 1], row[position[couple]]] = [row[position[couple]], row[i + 1]];
            [position[row[i + 1]], position[couple]] = [position[couple], i + 1];
            swaps++;
        }
    }

    return swaps;
}

-----
function minSwapsCouples(row) 
    // Your code here
}

************************************
Question ID: 771
function numJewelsInStones(jewels, stones) {
    let count = 0;
    for (let stone of stones) {
        if (jewels.indexOf(stone) !== -1) {
            count++;
        }
    }
    return count;
}

-----
function numJewelsInStones(jewels, stones) 
    // Your code here
}

************************************
Question ID: 777
function isToeplitzMatrix(matrix) {
    const rows = matrix.length;
    const cols = matrix[0].length;
    for(let i = 0; i < rows - 1; i++) {
        for(let j = 0; j < cols - 1; j++) {
            if(matrix[i][j] !== matrix[i+1][j+1]) return false;
        }
    }
    return true;
}


-----
function isToeplitzMatrix(matrix) 
    // Your code here
}


************************************
Question ID: 778
function rearrangeString(s) {
    const counts = new Map();
    for (const c of s) {
        counts.set(c, (counts.get(c) || 0) + 1);
    }
    
    const pq = Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    
    const result = [];
    let previous = [-1, null];
    
    while (pq.length) {
        const current = pq.shift();
        result.push(current[0]);
        
        if (previous[0] > 0) {
            pq.push(previous);
        }
        
        current[1]--;
        previous = current;
        pq.sort((a, b) => b[1] - a[1]);
    }
    
    const resultStr = result.join('');
    return resultStr.length === s.length ? resultStr : "";
}


-----
function rearrangeString(s) 
    // Your code here
}


************************************
Question ID: 779
function maxChunksToSorted(arr) {
    let max_val = 0, chunks = 0;
    for (let i = 0; i < arr.length; i++) {
        max_val = Math.max(max_val, arr[i]);
        if (max_val === i) {
            chunks++;
        }
    }
    return chunks;
}

-----
function maxChunksToSorted(arr) 
    // Your code here
}

************************************
Question ID: 780
function maxChunksToSorted(arr) {
    let max_so_far = 0, count = 0;
    for (let i = 0; i < arr.length; i++) {
        max_so_far = Math.max(max_so_far, arr[i]);
        if (max_so_far === i) {
            count++;
        }
    }
    return count;
}


-----
function maxChunksToSorted(arr) 
    // Your code here
}


************************************
Question ID: 781
function numRabbits(answers) {
    const count = new Map();
    let rabbits = 0;
    for(let ans of answers) {
        count.set(ans, (count.get(ans) || 0) + 1);
    }
    for(let [ans, cnt] of count.entries()) {
        rabbits += Math.floor((ans + cnt) / (ans + 1)) * (ans + 1);
    }
    return rabbits;
}


-----
function numRabbits(answers) 
    // Your code here
}


************************************
Question ID: 782
function numJewelsInStones(jewels, stones) {
    let count = 0;
    for (let s of stones) {
        if (jewels.includes(s)) {
            count++;
        }
    }
    return count;
}

-----
function numJewelsInStones(jewels, stones) 
    // Your code here
}

************************************
Question ID: 785
var isBipartite = function(graph) {
    function dfs(node, color) {
        if (colors[node] !== 0) {
            return colors[node] === color;
        }

        colors[node] = color;
        for (const neighbor of graph[node]) {
            if (!dfs(neighbor, 3 - color)) {
                return false;
            }
        }

        return true;
    }

    let n = graph.length;
    let colors = new Array(n).fill(0);

    for (let i = 0; i < n; ++i) {
        if (colors[i] === 0 && !dfs(i, 1)) {
            return false;
        }
    }

    return true;
};

-----
var isBipartite = function(graph) 
    // Your code here
};

************************************
Question ID: 786
function kthSmallestPrimeFraction(arr, k) {
    const pq = new PriorityQueue((a, b) => arr[a[0]] * arr[b[1]] - arr[a[1]] * arr[b[0]]);
    for (let i = 0; i < arr.length - 1; i++) {
        pq.push([i, arr.length - 1]);
    }
    while (--k > 0) {
        const tmp = pq.pop();
        if (--tmp[1] > tmp[0]) {
            pq.push(tmp);
        }
    }
    return [arr[pq.top()[0]], arr[pq.top()[1]]];
}

class PriorityQueue {
    constructor(comparator = (a, b) => a - b) {
        this._heap = [];
        this._comparator = comparator;
    }

    size() {
        return this._heap.length;
    }

    isEmpty() {
        return this.size() === 0;
    }

    top() {
        return this._heap[0];
    }

    push(value) {
        this._heap.push(value);
        this._siftUp();
    }

    pop(value) {
        const poppedValue = this.top();
        const bottom = this.size() - 1;
        if (bottom > 0) {
            this._swap(0, bottom);
        }
        this._heap.pop();
        this._siftDown();
        return poppedValue;
    }

    _siftUp() {
        let node = this.size() - 1;
        while (node > 0 && this._greater(node, Math.floor((node - 1) / 2))) {
            this._swap(node, Math.floor((node - 1) / 2));
            node = Math.floor((node - 1) / 2);
        }
    }

    _siftDown() {
        let node = 0;
        while (
            (2 * node + 1 < this.size() && this._greater(2 * node + 1, node)) ||
            (2 * node + 2 < this.size() && this._greater(2 * node + 2, node))
        ) {
            let maxChild = 2 * node + 1;
            if (2 * node + 2 < this.size() && this._greater(2 * node + 2, 2 * node + 1)) {
                maxChild = 2 * node + 2;
            }
            this._swap(node, maxChild);
            node = maxChild;
        }
    }

    _greater(i, j) {
        return this._comparator(this._heap[i], this._heap[j]) > 0;
    }

    _swap(i, j) {
        [this._heap[i], this._heap[j]] = [this._heap[j], this._heap[i]];
        return this;
    }
}

-----
function kthSmallestPrimeFraction(arr, k) 
    // Your code here
}

************************************
Question ID: 787
function slidingPuzzle(board) {
    const m = 2, n = 3;
    const target = "123450";
    let start = "";
    for (const row of board) {
        for (const num of row) {
            start += num;
        }
    }
    const dirs = [[1, 3], [0, 2, 4], [1, 5], [0, 4], [1, 3, 5], [2, 4]];
    const q = [start];
    let res = 0;
    const visited = new Set(q);
    while (q.length > 0) {
        for (let k = q.length; k > 0; --k) {
            const cur = q.shift();
            if (cur === target) return res;
            const zero_idx = cur.indexOf('0');
            for (const dir of dirs[zero_idx]) {
                let neighbor = cur.slice(0, zero_idx) + cur[dir] + cur.slice(zero_idx + 1);
                neighbor = neighbor.slice(0, dir) + '0' + neighbor.slice(dir + 1);
                if (!visited.has(neighbor)) {
                    visited.add(neighbor);
                    q.push(neighbor);
                }
            }
        }
        ++res;
    }
    return -1;
}

-----
function slidingPuzzle(board) 
    // Your code here
}

************************************
Question ID: 788
function rotatedDigits(n) {
    let count = 0;
    for (let i = 1; i <= n; i++) {
        if (isGood(i))
            count++;
    }
    return count;
}

function isGood(num) {
    let changed = false;
    while (num) {
        let digit = num % 10;
        if (digit === 3 || digit === 4 || digit === 7) return false;
        if (digit === 2 || digit === 5 || digit === 6 || digit === 9) changed = true;
        num = Math.floor(num / 10);
    }
    return changed;
}

-----
function rotatedDigits(n) 
    // Your code here
}

************************************
Question ID: 789
class KthLargest {
    constructor(k, nums) {
        this.minHeap = new MinHeap();
        this.k = k;
        for (let num of nums) {
            this.add(num);
        }
    }

    add(val) {
        this.minHeap.offer(val);
        if (this.minHeap.size() > this.k) {
            this.minHeap.poll();
        }
        return this.minHeap.peek();
    }
}

class MinHeap {
    constructor() {
        this.heap = [];
    }

    offer(val) {
        this.heap.push(val);
        this.heap.sort((a, b) => a - b);
    }

    poll() {
        return this.heap.shift();
    }

    peek() {
        return this.heap[0];
    }

    size() {
        return this.heap.length;
    }
}

-----
class KthLargest 
    // Your code here
}

************************************
Question ID: 790
function isIdealPermutation(nums) {
    for (let i = 0; i < nums.length; ++i) {
        if (Math.abs(nums[i] - i) > 1) {
            return false;
        }
    }
    return true;
}


-----
function isIdealPermutation(nums) 
    // Your code here
}


************************************
Question ID: 791
function customSortString(order, s) {
    const priority = new Map();
    for (let i = 0; i < order.length; i++) {
        priority.set(order[i], i);
    }

    const sArr = Array.from(s);
    sArr.sort((a, b) => (priority.has(a) ? priority.get(a) : 0) - (priority.has(b) ? priority.get(b) : 0));
    return sArr.join('');
}

-----
function customSortString(order, s) 
    // Your code here
}

************************************
Question ID: 792
function search(nums, target) {
    let left = 0;
    let right = nums.length - 1;

    while (left <= right) {
        let mid = left + Math.floor((right - left) / 2);

        if (nums[mid] === target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;
}


-----
function search(nums, target) 
    // Your code here
}


************************************
Question ID: 793
function canTransform(start, end) {
    if (start.length !== end.length) return false;

    let i = 0, j = 0;
    const n = start.length;
    while (i < n && j < n) {
        while (i < n && start[i] === 'X') i++;
        while (j < n && end[j] === 'X') j++;

        if (start[i] !== end[j]) return false;

        if ((start[i] === 'R' && i > j) || (start[i] === 'L' && i < j)) return false;

        i++; j++;
    }
    return true;
}

-----
function canTransform(start, end) 
    // Your code here
}

************************************
Question ID: 794
function swim(n, grid) {
    const pq = [[grid[0][0], 0, 0]];
    const visited = Array.from({ length: n }, () => Array(n).fill(false));

    const dr = [-1, 0, 1, 0];
    const dc = [0, 1, 0, -1];

    while (pq.length) {
        pq.sort((a, b) => a[0] - b[0]);
        const [curT, curR, curC] = pq.shift();

        if (curR === n - 1 && curC === n - 1) return curT;

        for (let d = 0; d < 4; d++) {
            const newRow = curR + dr[d];
            const newCol = curC + dc[d];
            if (0 <= newRow && newRow < n && 0 <= newCol && newCol < n && !visited[newRow][newCol]) {
                visited[newRow][newCol] = true;
                pq.push([Math.max(curT, grid[newRow][newCol]), newRow, newCol]);
            }
        }
    }
    return -1;
}

-----
function swim(n, grid) 
    // Your code here
}

************************************
Question ID: 795
function kthSymbolInGrammar(n, k) {
    if (n === 1) return 0;
    if (k % 2 === 0) return 1 - kthSymbolInGrammar(n - 1, Math.floor(k / 2));
    else return kthSymbolInGrammar(n - 1, Math.floor((k + 1) / 2));
}

-----
function kthSymbolInGrammar(n, k) 
    // Your code here
}

************************************
Question ID: 796
function canTransform(sx, sy, tx, ty) {
    while (sx !== tx || sy !== ty) {
        if (sx > tx || sy > ty) return false;
        if (sx < tx) {
            tx -= ty;
        } else {
            ty -= sx;
        }
    }
    return true;
}

-----
function canTransform(sx, sy, tx, ty) 
    // Your code here
}

************************************
Question ID: 797
function numRabbits(answers) {
    let count = {};
    let res = 0;
    for (let a of answers) {
        count[a] = count[a] ? count[a] + 1 : 1;
        if (count[a] === 1) {
            res += (a + 1);
        } else if (count[a] > a + 1) {
            count[a] = 1;
            res += (a + 1);
        }
    }
    return res;
}


-----
function numRabbits(answers) 
    // Your code here
}


************************************
Question ID: 798
function movesToChessboard(board) {
  const N = board.length;
  let row = 0, col = 0, rowCount = 0, colCount = 0;

  for (let i = 0; i < N; i++) {
    for (let j = 0; j < N; j++) {
      if (((board[0][0] ^ board[i][0] ^ board[0][j]) ^ board[i][j]) !== 0) return -1;
    }
  }

  for (let i = 0; i < N; i++) {
    row ^= board[0][i];
    col ^= board[i][0];
    rowCount += board[0][i] === 1 ? 1 : 0;
    colCount += board[i][0] === 1 ? 1 : 0;
  }

  if (row !== 0 && rowCount * 2 !== N) return -1;
  if (col !== 0 && colCount * 2 !== N) return -1;

  if (N % 2 === 1) {
    if (rowCount % 2 === 1) rowCount = N - rowCount;
    if (colCount % 2 === 1) colCount = N - colCount;
  } else {
    rowCount = Math.min(rowCount, N - rowCount);
    colCount = Math.min(colCount, N - colCount);
  }

  return (rowCount + colCount) / 2;
}

-----
function movesToChessboard(board) 
    // Your code here
}

************************************
Question ID: 800
function letterCasePermutation(s) {
    const result = [];
    function backtrack(index) {
        if (index === s.length) {
            result.push(s.join(''));
            return;
        }
        backtrack(index + 1);
        if (s[index] !== s[index].toUpperCase() || s[index] !== s[index].toLowerCase()) {
            s[index] = flipCase(s[index]);
            backtrack(index + 1);
            s[index] = flipCase(s[index]);
        }
    }
    s = s.split('');
    backtrack(0);
    return result;
}

function flipCase(c) {
    return c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase();
}

-----
function letterCasePermutation(s) 
    // Your code here
}

************************************
Question ID: 801
function isBipartite(graph) {
    const colors = new Array(graph.length).fill(0);
    for(let i = 0; i < graph.length; i++){
        if(colors[i] !== 0) continue;
        colors[i] = 1;
        const queue = [i];
        while(queue.length){
            const node = queue.shift();
            for(const neighbor of graph[node]){
                if(colors[neighbor] === 0){
                    colors[neighbor] = -colors[node];
                    queue.push(neighbor);
                } else if(colors[neighbor] === colors[node]){
                    return false;
                }
            }
        }
    }
    return true;
}


-----
function isBipartite(graph) 
    // Your code here
}


************************************
Question ID: 802
function kthSmallestPrimeFraction(arr, k) {
    const pq = new PriorityQueue((a, b) => arr[a[0]] * arr[b[1]] - arr[a[1]] * arr[b[0]]);

    for (let i = 0; i < arr.length - 1; i++) {
        pq.offer([i, arr.length - 1]);
    }

    for (let i = 1; i < k; i++) {
        const curr = pq.poll();
        curr[1]--;
        if (curr[0] < curr[1]) {
            pq.offer(curr);
        }
    }

    return [arr[pq.peek()[0]], arr[pq.peek()[1]]];
}

class PriorityQueue {
    constructor(compareFn) {
        this.elements = [];
        this.compareFn = compareFn;
    }

    offer(element) {
        this.elements.push(element);
        this._bubbleUp(this.elements.length - 1);
    }

    poll() {
        const first = this.elements[0];
        const last = this.elements.pop();
        if (this.elements.length > 0) {
            this.elements[0] = last;
            this._trickleDown(0);
        }
        return first;
    }

    peek() {
        return this.elements[0];
    }

    _bubbleUp(index) {
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if (this.compareFn(this.elements[index], this.elements[parentIndex]) < 0) {
                [this.elements[index], this.elements[parentIndex]] = [this.elements[parentIndex], this.elements[index]];
                index = parentIndex;
            } else {
                break;
            }
        }
    }

    _trickleDown(index) {
        while (index < this.elements.length) {
            let leftChildIndex = 2 * index + 1;
            let rightChildIndex = 2 * index + 2;

            if (leftChildIndex >= this.elements.length) {
                break;
            }

            let minChildIndex = this.compareFn(
                this.elements[leftChildIndex],
                this.elements[rightChildIndex]) < 0 ? leftChildIndex : rightChildIndex;

            if (this.compareFn(this.elements[index], this.elements[minChildIndex]) > 0) {
                [this.elements[index], this.elements[minChildIndex]] = [this.elements[minChildIndex], this.elements[index]];
                index = minChildIndex;
            } else {
                break;
            }
        }
    }
}

-----
function kthSmallestPrimeFraction(arr, k) 
    // Your code here
}

************************************
Question ID: 803
function findCheapestPrice(n, flights, src, dst, k) {
    const graph = Array.from({ length: n }, () => []);
    for (const flight of flights) {
        graph[flight[0]].push([flight[1], flight[2]]);
    }

    const pq = [[0, src, k + 1]];
    while (pq.length) {
        pq.sort((a, b) => a[0] - b[0]);
        const [price, city, stops] = pq.shift();

        if (city === dst) {
            return price;
        }

        if (stops > 0) {
            for (const [nei, prc] of graph[city]) {
                pq.push([price + prc, nei, stops - 1]);
            }
        }
    }

    return -1;
}


-----
function findCheapestPrice(n, flights, src, dst, k) 
    // Your code here
}


************************************
Question ID: 804
function rotatedDigits(n) {
    let count = 0;
    for (let i = 1; i <= n; ++i) {
        let isValidAfterRotation = true;
        let isDifferentAfterRotation = false;
        let num = i;
        while (num !== 0) {
            let digit = num % 10;
            if (digit === 3 || digit === 4 || digit === 7) {
                isValidAfterRotation = false;
                break;
            }
            if (digit === 2 || digit === 5 || digit === 6 || digit === 9) {
                isDifferentAfterRotation = true;
            }
            num = Math.floor(num / 10);
        }
        if (isValidAfterRotation && isDifferentAfterRotation) {
            count++;
        }
    }
    return count;
}

-----
function rotatedDigits(n) 
    // Your code here
}

************************************
Question ID: 805
function escapeGhosts(ghosts, target) {
    let maxDist = Math.abs(target[0]) + Math.abs(target[1]);
    for (let ghost of ghosts) {
        let ghostDist = Math.abs(ghost[0] - target[0]) + Math.abs(ghost[1] - target[1]);
        if (ghostDist <= maxDist) {
            return false;
        }
    }
    return true;
}


-----
function escapeGhosts(ghosts, target) 
    // Your code here
}


************************************
Question ID: 806
function numberOfWays(n) {
    const MOD = 1000000007;
    let dp = new Array(n + 1).fill(0);
    dp[0] = 1;
    dp[1] = 1;

    for (let i = 2; i <= n; i++)
        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD;

    return dp[n];
}


-----
function numberOfWays(n) 
    // Your code here
}


************************************
Question ID: 807
function customSortString(order, s) {
    return s.split('').sort((a, b) => order.indexOf(a) - order.indexOf(b)).join('');
}


-----
function customSortString(order, s) 
    // Your code here
}


************************************
Question ID: 808
function numMatchingSubseq(s, words) {
    const positions = Array.from({ length: 26 }, () => []);

    for (let i = 0; i < s.length; ++i) {
        positions[s.charCodeAt(i) - 'a'.charCodeAt(0)].push(i);
    }

    let count = 0;

    words.forEach(word => {
        let index = -1;
        let isSubsequence = true;

        for (let i = 0; i < word.length; i++) {
            const c = word.charCodeAt(i) - 'a'.charCodeAt(0);
            const pos = positions[c].find(el => el > index);
            if (pos === undefined) {
                isSubsequence = false;
                break;
            }
            index = pos;
        }

        if (isSubsequence) {
            count++;
        }
    });

    return count;
}

-----
function numMatchingSubseq(s, words) 
    // Your code here
}

************************************
Question ID: 809
function num_zeros(k) {
    let x = 0;
    for (let i = 5; Math.floor(k / i) >= 1; i *= 5) {
        x += Math.floor(k / i);
    }
    return x;
}

-----
function num_zeros(k) 
    // Your code here
}

************************************
Question ID: 810
function validTicTacToe(board) {
    let xCount = 0, oCount = 0;
    for (const row of board) {
        for (const c of row) {
            if (c === 'X') xCount++;
            else if (c === 'O') oCount++;
        }
    }
    if (xCount !== oCount && xCount !== oCount + 1) return false;

    let xWin = false, oWin = false;
    for (let i = 0; i < 3; ++i) {
        if (board[i][0] === board[i][1] && board[i][1] === board[i][2])
            board[i][0] === 'X' ? xWin = true : (board[i][0] === 'O' ? oWin = true : 0);
        if (board[0][i] === board[1][i] && board[1][i] === board[2][i])
            board[0][i] === 'X' ? xWin = true : (board[0][i] === 'O' ? oWin = true : 0);
    }
    if (board[0][0] === board[1][1] && board[1][1] === board[2][2])
        board[0][0] === 'X' ? xWin = true : (board[0][0] === 'O' ? oWin = true : 0);
    if (board[0][2] === board[1][1] && board[1][1] === board[2][0])
        board[0][2] === 'X' ? xWin = true : (board[0][2] === 'O' ? oWin = true : 0);

    if (xWin && oWin) return false;
    if (xWin && xCount === oCount) return false;
    if (oWin && xCount > oCount) return false;

    return true;
}


-----
function validTicTacToe(board) 
    // Your code here
}


************************************
Question ID: 811
function numSubarrayBoundedMax(nums, left, right) {
    let result = 0, prev = 0, start = -1;
    for (let i = 0; i < nums.length; ++i) {
        if (nums[i] >= left && nums[i] <= right) {
            prev = i - start;
            result += prev;
        } else if (nums[i] < left) {
            result += prev;
        } else {
            start = i;
            prev = 0;
        }
    }
    return result;
}


-----
function numSubarrayBoundedMax(nums, left, right) 
    // Your code here
}


************************************
Question ID: 812
function isShifted(s, goal) {
    if (s.length !== goal.length) return false;
    
    s = s + s;
    return s.includes(goal);
}

-----
function isShifted(s, goal) 
    // Your code here
}

************************************
Question ID: 813
function allPathsSourceTarget(graph) {
    const result = [];
    const path = [];
    DFS(graph, result, path, 0);
    return result;
}

function DFS(graph, result, path, currentNode) {
    path.push(currentNode);
    if (currentNode === graph.length - 1) {
        result.push(path.slice());
    } else {
        for (const neighbor of graph[currentNode]) {
            DFS(graph, result, path, neighbor);
        }
    }
    path.pop();
}

-----
function allPathsSourceTarget(graph) 
    // Your code here
}

************************************
Question ID: 814
function best_rotation(nums) {
    const n = nums.length;
    const change = new Array(n).fill(0);

    for (let i = 0; i < n; i++) {
        change[(i - nums[i] + 1 + n) % n] -= 1;
        change[(i + 1) % n] += 1;
    }

    let max_score = 0;
    for (let i = 1, cur_score = change[0]; i < n; i++) {
        cur_score += change[i];
        if (cur_score > max_score) {
            max_score = cur_score;
        }
    }

    return max_score;
}


-----
function best_rotation(nums) 
    // Your code here
}


************************************
Question ID: 815
function numBusesToDestination(routes, source, target) {
    if (source === target) return 0;

    const stopRouteMap = new Map();
    for (let i = 0; i < routes.length; i++) {
        for (const stop of routes[i]) {
            if (!stopRouteMap.has(stop)) {
                stopRouteMap.set(stop, new Set());
            }
            stopRouteMap.get(stop).add(i);
        }
    }

    const queue = [source];
    const visitedSources = new Set([source]);
    let transfers = 0;

    while (queue.length) {
        const size = queue.length;
        for (let i = 0; i < size; i++) {
            const curr = queue.shift();
            if (curr === target) return transfers;

            for (const route of stopRouteMap.get(curr)) {
                for (const stop of routes[route]) {
                    if (!visitedSources.has(stop)) {
                        queue.push(stop);
                        visitedSources.add(stop);
                    }
                }
                stopRouteMap.get(curr).delete(route);
            }
        }
        transfers++;
    }
    return -1;
}

-----
function numBusesToDestination(routes, source, target) 
    // Your code here
}

************************************
Question ID: 818
function racecar(target) {
    const memo = new Map();
    
    function dp(pos, speed) {
        if (Math.abs(pos) > 2 * target) {
            return target + 1;
        }
        if (pos === target) {
            return speed === 1 ? 0 : 1;
        }
        const key = pos + "," + speed;
        if (memo.has(key)) {
            return memo.get(key);
        }
        
        let result = ((speed > 0)
            ? dp(pos + Math.floor(speed / 2), -Math.floor(speed / 2))
            : dp(pos - Math.floor(speed / 2), -Math.floor(speed / 2))) + 1;
        
        result = Math.min(result, dp(pos + speed, speed * 2) + 1);
        memo.set(key, result);
        return result;
    }
    
    return dp(0, 1);
}

-----
function racecar(target) 
    // Your code here
}

************************************
Question ID: 819
function minSwaps(nums1, nums2) {
    const n = nums1.length;
    const noSwap = new Array(n).fill(Infinity);
    const doSwap = new Array(n).fill(Infinity);
    noSwap[0] = 0;
    doSwap[0] = 1;

    for (let i = 1; i < n; i++) {
        if (nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) {
            noSwap[i] = noSwap[i - 1];
            doSwap[i] = doSwap[i - 1] + 1;
        }
        if (nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1]) {
            noSwap[i] = Math.min(noSwap[i], doSwap[i - 1]);
            doSwap[i] = Math.min(doSwap[i], noSwap[i - 1] + 1);
        }
    }

    return Math.min(noSwap[n - 1], doSwap[n - 1]);
}

-----
function minSwaps(nums1, nums2) 
    // Your code here
}

************************************
Question ID: 820
var eventualSafeNodes = function(graph) {
    const n = graph.length;
    const color = new Array(n).fill(0);
    const ans = [];

    function hasCycle(node, color, graph) {
        if (color[node] > 0)
            return color[node] === 1;
        color[node] = 1;
        for (const neighbor of graph[node]) {
            if (hasCycle(neighbor, color, graph))
                return true;
        }
        color[node] = 2;
        return false;
    }
    
    for (let i = 0; i < n; ++i) {
        if (!hasCycle(i, color, graph))
            ans.push(i);
    }
    return ans;
};

-----
var eventualSafeNodes = function(graph) 
    // Your code here
};

************************************
Question ID: 821
function hitBricks(grid, hits) {
    function dfs(x, y) {
        if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] <= 0) {
            return 0;
        }
        grid[x][y] = -1;
        let sum = 1;
        for (const [dx, dy] of directions) {
            sum += dfs(x + dx, y + dy);
        }
        return sum;
    }

    const m = grid.length, n = grid[0].length;
    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];

    hits.forEach(([x, y]) => grid[x][y]--);

    for (let i = 0; i < n; ++i) {
        if (grid[0][i] === 1) {
            dfs(0, i);
        }
    }

    const result = [];
    for (const [x, y] of hits) {
        grid[x][y]++;
        if (grid[x][y] !== 1) {
            result.push(0);
            continue;
        }
        for (const [dx, dy] of directions) {
            if (dfs(x + dx, y + dy) !== 0) {
                result.push(dfs(x, y) - 1);
                break;
            }
        }
    }

    return result;
}

-----
function hitBricks(grid, hits) 
    // Your code here
}

************************************
Question ID: 822
function uniqueMorseRepresentations(words) {
    const morse = [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."];
    const transformations = new Set();

    for (const word of words) {
        let morseCode = '';
        for (const c of word) {
            morseCode += morse[c.charCodeAt(0) - 'a'.charCodeAt(0)];
        }
        transformations.add(morseCode);
    }

    return transformations.size;
}

-----
function uniqueMorseRepresentations(words) 
    // Your code here
}

************************************
Question ID: 823
function isPossibleToSplit(nums) {
    const n = nums.length;
    const total_sum = nums.reduce((a, b) => a + b, 0);

    if (total_sum % n !== 0) return false;

    const target_sum = (total_sum * (n / 2)) / n;
    const dp = Array.from(Array(n / 2 + 1), () => Array(target_sum + 1).fill(false));
    dp[0][0] = true;

    for (const num of nums) {
        for (let count = n / 2; count >= 1; --count) {
            for (let sum = target_sum; sum >= num; --sum) {
                dp[count][sum] = dp[count][sum] || dp[count - 1][sum - num];
            }
        }
        if (dp[n / 2][target_sum]) return true;
    }

    return false;
}


-----
function isPossibleToSplit(nums) 
    // Your code here
}


************************************
Question ID: 824
function numberOfLines(widths, s) {
    let lines = 1;
    let currentPixel = 0;
    for (let c of s) {
        let letterPixels = widths[c.charCodeAt(0) - 'a'.charCodeAt(0)];
        if (currentPixel + letterPixels > 100) {
            lines++;
            currentPixel = 0;
        }
        currentPixel += letterPixels;
    }
    return [lines, currentPixel];
}


-----
function numberOfLines(widths, s) 
    // Your code here
}


************************************
Question ID: 825
function maxIncreaseKeepingSkyline(grid) {
    const n = grid.length;
    const row_max = new Array(n).fill(0);
    const col_max = new Array(n).fill(0);
    
    for (let i = 0; i < n; ++i) {
        for (let j = 0; j < n; ++j) {
            row_max[i] = Math.max(row_max[i], grid[i][j]);
            col_max[j] = Math.max(col_max[j], grid[i][j]);
        }
    }
    
    let total_sum = 0;
    for (let i = 0; i < n; ++i) {
        for (let j = 0; j < n; ++j) {
            total_sum += Math.min(row_max[i], col_max[j]) - grid[i][j];
        }
    }
    
    return total_sum;
}


-----
function maxIncreaseKeepingSkyline(grid) 
    // Your code here
}


************************************
Question ID: 826
function maxProfitAssignment(difficulty, profit, worker) {
    const n = difficulty.length;
    const jobs = difficulty.map((d, i) => [d, profit[i]]).sort((a, b) => a[0] - b[0]);

    worker.sort((a, b) => a - b);

    let max_profit = 0;
    let total_profit = 0;
    let job_idx = 0;

    for (const w of worker) {
        while (job_idx < n && w >= jobs[job_idx][0]) {
            max_profit = Math.max(max_profit, jobs[job_idx][1]);
            job_idx++;
        }
        total_profit += max_profit;
    }

    return total_profit;
}


-----
function maxProfitAssignment(difficulty, profit, worker) 
    // Your code here
}


************************************
Question ID: 827
function maxAreaOfIsland(grid) {
    function dfs(x, y) {
        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] === 0) {
            return 0;
        }
        grid[x][y] = 0;
        return dfs(x - 1, y) + dfs(x + 1, y) + dfs(x, y - 1) + dfs(x, y + 1) + 1;
    }
    
    let ans = 0;
    for (let i = 0; i < grid.length; ++i)
        for (let j = 0; j < grid[i].length; ++j)
            if (grid[i][j] === 0) {
                grid[i][j] = 1;
                ans = Math.max(ans, dfs(i, j));
                grid[i][j] = 0;
            }
    return ans;
}

-----
function maxAreaOfIsland(grid) 
    // Your code here
}

************************************
Question ID: 828
function xorGame(nums) {
    let xorSum = 0;
    for (let num of nums) {
        xorSum ^= num;
    }
    return xorSum === 0 || nums.length % 2 === 0;
}

-----
function xorGame(nums) 
    // Your code here
}

************************************
Question ID: 829
function subdomainVisits(cpdomains) {
    const counts = {};
    const result = [];

    for (let cpdomain of cpdomains) {
        let [count, domain] = cpdomain.split(' ');
        count = parseInt(count);

        for (let i = 0; i < domain.length; ++i) {
            if (domain[i] === '.') {
                const sub = domain.slice(i + 1);
                counts[sub] = (counts[sub] || 0) + count;
            }
        }
        counts[domain] = (counts[domain] || 0) + count;
    }

    for (let sub in counts) {
        result.push(`${counts[sub]} ${sub}`);
    }
    
    return result;
}


-----
function subdomainVisits(cpdomains) 
    // Your code here
}


************************************
Question ID: 830
function largestTriangleArea(points) {
    let max_area = 0.0;
    for (let i = 0; i < points.length; ++i) {
        for (let j = i + 1; j < points.length; ++j) {
            for (let k = j + 1; k < points.length; ++k) {
                max_area = Math.max(max_area, 0.5 * Math.abs(points[i][0] * (points[j][1] - points[k][1])
                                                      + points[j][0] * (points[k][1] - points[i][1])
                                                      + points[k][0] * (points[i][1] - points[j][1])));
            }
        }
    }
    return max_area;
}

-----
function largestTriangleArea(points) 
    // Your code here
}

************************************
Question ID: 832
function pruneTree(root) {
    if (!root) return null;
    root.left = pruneTree(root.left);
    root.right = pruneTree(root.right);
    if (root.val === 0 && !root.left && !root.right) return null;
    return root;
}

-----
function pruneTree(root) 
    // Your code here
}

************************************
Question ID: 833
function numBusesToDestination(routes, source, target) {
    if (source === target) return 0;

    const stopToBuses = new Map();
    for (let i = 0; i < routes.length; ++i) {
        for (const stop of routes[i]) {
            if (!stopToBuses.has(stop)) {
                stopToBuses.set(stop, new Set());
            }
            stopToBuses.get(stop).add(i);
        }
    }

    const q = [];
    const visitedBuses = new Set();
    let numBuses = 0;
    q.push(source);

    while (q.length > 0) {
        const size = q.length;
        for (let i = 0; i < size; ++i) {
            const stop = q.shift();
            for (const bus of stopToBuses.get(stop)) {
                if (visitedBuses.has(bus)) continue;
                visitedBuses.add(bus);
                for (const nextStop of routes[bus]) {
                    if (nextStop === target) return numBuses + 1;
                    q.push(nextStop);
                }
            }
        }
        numBuses++;
    }

    return -1;
}

-----
function numBusesToDestination(routes, source, target) 
    // Your code here
}

************************************
Question ID: 834
function ambiguousCoordinates(s) {
    function generateNumber(s) {
        if (s.length === 0 || (s.length > 1 && s[0] === '0' && s[s.length - 1] === '0')) {
            return [];
        }
        if (s.length > 1 && s[0] === '0') {
            return ["0." + s.slice(1)];
        }
        let res = [s];
        if (s.length === 1 || s[s.length - 1] === '0') {
            return res;
        }
        for (let i = 1; i < s.length; i++) {
            res.push(s.slice(0, i) + "." + s.slice(i));
        }
        return res;
    }
    
    let n = s.length;
    let res = [];
    
    for (let i = 2; i < n - 1; i++) {
        let first = generateNumber(s.slice(1, i));
        let second = generateNumber(s.slice(i, n - 1));
        
        for (let f of first) {
            for (let sec of second) {
                res.push("(" + f + ", " + sec + ")");
            }
        }
    }
    return res;
}


-----
function ambiguousCoordinates(s) 
    // Your code here
}


************************************
Question ID: 836
function racecar(target) {
    return dp(0, 1, target, new Map());
}

function dp(position, speed, target, memo) {
    if (Math.abs(position) > 2 * target)
        return Infinity - 1;

    if (position === target)
        return 0;

    let key = position + "," + speed;
    if (memo.has(key))
        return memo.get(key);

    let op1 = dp(position + speed, speed * 2, target, memo) + 1;
    let op2 = dp(position, -speed, target, memo) + 2;

    let ans = Math.min(op1, op2);
    memo.set(key, ans);
    return ans;
}

-----
function racecar(target) 
    // Your code here
}

************************************
Question ID: 837
function mostCommonWord(paragraph, banned) {
    const wordCount = new Map();
    const bannedSet = new Set(banned.map(x => x.toLowerCase()));
    const words = paragraph.toLowerCase().split(/\W+/);

    words.forEach(word => {
        if (!bannedSet.has(word)) {
            wordCount.set(word, (wordCount.get(word) || 0) + 1);
        }
    });
    
    let maxCount = -1;
    let result = '';
    wordCount.forEach((count, word) => {
        if (count > maxCount) {
            maxCount = count;
            result = word;
        }
    });
    
    return result;
}


-----
function mostCommonWord(paragraph, banned) 
    // Your code here
}


************************************
Question ID: 838
function pushDominoes(dominoes) {
    const n = dominoes.length;
    const forces = new Array(n).fill(0);

    let force = 0;
    for (let i = 0; i < n; ++i) {
        if (dominoes[i] === 'R') force = n;
        else if (dominoes[i] === 'L') force = 0;
        else force = Math.max(force - 1, 0);
        forces[i] += force;
    }

    force = 0;
    for (let i = n - 1; i >= 0; --i) {
        if (dominoes[i] === 'L') force = n;
        else if (dominoes[i] === 'R') force = 0;
        else force = Math.max(force - 1, 0);
        forces[i] -= force;
    }

    return forces.map(f => f > 0 ? 'R' : f < 0 ? 'L' : '.').join('');
}


-----
function pushDominoes(dominoes) 
    // Your code here
}


************************************
Question ID: 839
function minimalLengthEncoding(words) {
    const wordSet = new Set(words);

    for (const word of words) {
        for (let i = 1; i < word.length; i++) {
            wordSet.delete(word.slice(i));
        }
    }

    let len = 0;
    for (const word of wordSet) {
        len += word.length + 1;
    }
    return len;
}

-----
function minimalLengthEncoding(words) 
    // Your code here
}

************************************
Question ID: 840
var numMagicSquaresInside = function(grid) {
    let count = 0;
    for (let i = 0; i < grid.length - 2; ++i) {
        for (let j = 0; j < grid[0].length - 2; ++j) {
            if (grid[i][j] <= 9 && grid[i + 1][j + 1] === 5 && isMagic(grid, i, j)) {
                count++;
            }
        }
    }
    return count;
};

function isMagic(grid, x, y) {
    let temp = Array(16).fill(0);
    for (let i = 0; i < 3; ++i) {
        for (let j = 0; j < 3; ++j) {
            let num = grid[x + i][y + j];
            temp[num]++;
            if (num > 9 || temp[num] > 1) {
                return false;
            }
        }
    }
    let sum = grid[x][y] + grid[x][y+1] + grid[x][y+2];
    for (let i = 0; i < 3; ++i) {
        let rowSum = 0, colSum = 0;
        for (let j = 0; j < 3; ++j) {
            rowSum += grid[x + i][y + j];
            colSum += grid[x + j][y + i];
        }
        if (rowSum !== sum || colSum !== sum)
            return false;
    }
    if (grid[x][y] + grid[x + 1][y + 1] + grid[x + 2][y + 2] !== sum)
        return false;
    if (grid[x][y + 2] + grid[x + 1][y + 1] + grid[x + 2][y] !== sum)
        return false;

    return true;
}


-----
var numMagicSquaresInside = function(grid) 
    // Your code here
}


************************************
Question ID: 841
function shortestToChar(s, c) {
    const n = s.length;
    const result = new Array(n).fill(n);
    let pos = -n;

    for (let i = 0; i < n; ++i) {
        if (s.charAt(i) === c)
            pos = i;
        result[i] = i - pos;
    }

    for (let i = pos - 1; i >= 0; --i) {
        if (s.charAt(i) !== c)
            pos = i;
        result[i] = Math.min(result[i], pos - i);
    }

    return result;
}


-----
function shortestToChar(s, c) 
    // Your code here
}


************************************
Question ID: 842
function smallestGoodInteger(fronts, backs) {
    const notGood = new Set();
    const n = fronts.length;
    for (let i = 0; i < n; ++i)
        if (fronts[i] === backs[i]) notGood.add(fronts[i]);
    
    let result = Infinity;
    for (let i = 0; i < n; ++i) {
        if (!notGood.has(fronts[i])) result = Math.min(result, fronts[i]);
        if (!notGood.has(backs[i])) result = Math.min(result, backs[i]);
    }
    return result === Infinity ? 0 : result;
}

-----
function smallestGoodInteger(fronts, backs) 
    // Your code here
}

************************************
Question ID: 843
function numFactoredBinaryTrees(arr) {
    const MOD = 1e9 + 7;
    const n = arr.length;
    arr.sort((a, b) => a - b);
    let dp = new Map();
    for (let i = 0; i < n; ++i) {
        dp.set(arr[i], 1);
        for (let j = 0; j < i; ++j) {
            if (arr[i] % arr[j] === 0 && dp.has(arr[i] / arr[j]))
                dp.set(arr[i], (dp.get(arr[i]) + dp.get(arr[j]) * dp.get(arr[i] / arr[j])) % MOD);
        }
    }
    let ans = 0;
    for (const value of dp.values()) ans = (ans + value) % MOD;
    return ans;
}

-----
function numFactoredBinaryTrees(arr) 
    // Your code here
}

************************************
Question ID: 844
var backspaceCompare = function(s, t) {
    let i = s.length - 1, j = t.length - 1;
    while (true) {
        let back;
        for (back = 0; i >= 0 && (back > 0 || s[i] === '#'); --i)
            back += s[i] === '#' ? 1 : -1;
        for (back = 0; j >= 0 && (back > 0 || t[j] === '#'); --j)
            back += t[j] === '#' ? 1 : -1;
        if (i >= 0 && j >= 0 && s[i] === t[j])
            i--, j--;
        else
            return i === -1 && j === -1;
    }
};

-----
var backspaceCompare = function(s, t) 
    // Your code here
};

************************************
Question ID: 845
function longestMountain(arr) {
    let n = arr.length, res = 0, up = 0, down = 0;

    for (let i = 1; i < n; ++i) {
        if (down && arr[i - 1] < arr[i] || arr[i - 1] == arr[i]) {
            up = down = 0;
        }

        if (arr[i - 1] < arr[i]) up++;
        if (arr[i - 1] > arr[i]) down++;

        if (up && down) {
            res = Math.max(res, up + down + 1);
        }
    }
    return res;
}

-----
function longestMountain(arr) 
    // Your code here
}

************************************
Question ID: 846
function isPossibleDivide(hand, groupSize) {
    const cardCount = new Map();
    for (const card of hand) {
        cardCount.set(card, (cardCount.get(card) || 0) + 1);
    }

    for (const [card, count] of Array.from(cardCount.entries()).sort((a, b) => a[0] - b[0])) {
        if (count > 0) {
            for (let i = 1; i < groupSize; ++i) {
                const tmp = (cardCount.get(card + i) || 0) - count;
                if (tmp < 0) {
                    return false;
                }
                cardCount.set(card + i, tmp);
            }
        }
    }

    return true;
}


-----
function isPossibleDivide(hand, groupSize) 
    // Your code here
}


************************************
Question ID: 847
function shortestPathLength(graph) {
    const n = graph.length;
    const queue = [];
    const visited = Array.from({length: n}, () => Array(1 << n).fill(false));

    for (let i = 0; i < n; i++) {
        queue.push([i, 1 << i, 0]);
        visited[i][1 << i] = true;
    }

    while (queue.length) {
        const [node, bitmask, length] = queue.shift();

        if (bitmask === (1 << n) - 1) return length;

        for (const nei of graph[node]) {
            const next_bitmask = bitmask | (1 << nei);
            if (!visited[nei][next_bitmask]) {
                visited[nei][next_bitmask] = true;
                queue.push([nei, next_bitmask, length + 1]);
            }
        }
    }

    return 0;
}

-----
function shortestPathLength(graph) 
    // Your code here
}

************************************
Question ID: 848
function shiftingLetters(s, shifts) {
    for (let i = shifts.length - 2; i >= 0; i--) {
        shifts[i] = (shifts[i] + shifts[i + 1] % 26) % 26;
    }
    
    let result = s.split('');
    for (let i = 0; i < s.length; i++) {
        result[i] = String.fromCharCode((result[i].charCodeAt(0) - 'a'.charCodeAt(0) + shifts[i] % 26) % 26 + 'a'.charCodeAt(0));
    }
    
    return result.join('');
}

-----
function shiftingLetters(s, shifts) 
    // Your code here
}

************************************
Question ID: 849
function maxDistToClosest(seats) {
    let n = seats.length;
    let maxDist = 0, lastPerson = -1;

    for (let i = 0; i < n; ++i) {
        if (seats[i] === 1) {
            if (lastPerson === -1)
                maxDist = i;
            else
                maxDist = Math.max(maxDist, Math.floor((i - lastPerson) / 2));
            lastPerson = i;
        }
    }
    maxDist = Math.max(maxDist, n - 1 - lastPerson);
    return maxDist;
}

-----
function maxDistToClosest(seats) 
    // Your code here
}

************************************
Question ID: 850
function rectangleArea(rectangles) {
    const mod = 1e9 + 7;
    let n = rectangles.length;
    let X = new Set(), Y = new Set();
    for (const rect of rectangles) {
        X.add(rect[0]);
        X.add(rect[2]);
        Y.add(rect[1]);
        Y.add(rect[3]);
    }
    let sortedX = Array.from(X).sort((a, b) => a - b);
    let sortedY = Array.from(Y).sort((a, b) => a - b);

    let cnt = Array.from({ length: X.size - 1 }, () => Array.from({ length: Y.size - 1 }, () => 0));

    for (const rect of rectangles) {
        let x1_idx = sortedX.indexOf(rect[0]);
        let x2_idx = sortedX.indexOf(rect[2]) - 1;
        let y1_idx = sortedY.indexOf(rect[1]);
        let y2_idx = sortedY.indexOf(rect[3]) - 1;
        for (let i = x1_idx; i <= x2_idx; i++) {
            for (let j = y1_idx; j <= y2_idx; j++) {
                cnt[i][j] = 1;
            }
        }
    }

    let total_area = 0;
    for (let i = 0; i < X.size - 1; i++) {
        for (let j = 0; j < Y.size - 1; j++) {
            if (cnt[i][j]) {
                total_area += (sortedX[i + 1] - sortedX[i]) * (sortedY[j + 1] - sortedY[j]);
                total_area %= mod;
            }
        }
    }

    return total_area;
}

-----
function rectangleArea(rectangles) 
    // Your code here
}

************************************
Question ID: 851
function toGoatLatin(sentence) {
    const words = sentence.split(" ");
    const vowels = new Set("AEIOUaeiou");
    let result = [];
    let suffix = "a";

    words.forEach(word => {
        if (!vowels.has(word[0])) {
            word = word.slice(1) + word[0];
        }
        result.push(word + "ma" + suffix);
        suffix += "a";
    });

    return result.join(" ");
}

-----
function toGoatLatin(sentence) 
    // Your code here
}

************************************
Question ID: 852
function numFriendRequests(ages) {
    const count = new Array(121).fill(0);
    let total_requests = 0;

    for (const age of ages) count[age]++;

    for (let a = 1; a <= 120; a++) {
        for (let b = 1; b <= 120; b++) {
            if (a * 0.5 + 7 >= b) continue;
            if (a < b) continue;
            if (a < b * 2) {
                total_requests += count[a] * count[b];
                if (a === b) total_requests -= count[a];
            }
        }
    }

    return total_requests;
}

-----
function numFriendRequests(ages) 
    // Your code here
}

************************************
Question ID: 853
function maxProfitAssignment(difficulty, profit, worker) {
    const jobs = difficulty.map((d, i) => [d, profit[i]]).sort((a, b) => a[0] - b[0]);
    worker.sort((a, b) => a - b);

    let i = 0, maxProfit = 0, totalProfit = 0;
    for (const ability of worker) {
        while (i < difficulty.length && ability >= jobs[i][0]) {
            maxProfit = Math.max(maxProfit, jobs[i][1]);
            i++;
        }
        totalProfit += maxProfit;
    }
    return totalProfit;
}

-----
function maxProfitAssignment(difficulty, profit, worker) 
    // Your code here
}

************************************
Question ID: 854
function kSimilarity(s1, s2) {
    let k = 0;
    let temp = s1.split('');

    for (let i = 0; i < temp.length; i++) {
        if (temp[i] !== s2[i]) {
            let j = i + 1;
            while (temp[j] !== s2[i] || s2[j] === temp[j]) {
                j++;
            }
            [temp[i], temp[j]] = [temp[j], temp[i]];
            k++;
        }
    }
    return k;
}

-----
function kSimilarity(s1, s2) 
    // Your code here
}

************************************
Question ID: 855
function countUniqueChars(s) {
    const uniqueChars = new Set(s);
    return uniqueChars.size;
}

function sumCountUniqueChars(s) {
    let sum = 0;
    for (let i = 0; i < s.length; ++i) {
        for (let j = i + 1; j <= s.length; ++j) {
            sum += countUniqueChars(s.slice(i, j));
        }
    }
    return sum;
}

-----
function countUniqueChars(s) 
    // Your code here
}

************************************
Question ID: 856
function consecutiveNumbersSum(n) {
    let count = 0;
    for (let i = 1; i * (i - 1) / 2 < n; i++) {
        if ((n - i * (i - 1) / 2) % i === 0) {
            count++;
        }
    }
    return count;
}


-----
function consecutiveNumbersSum(n) 
    // Your code here
}


************************************
Question ID: 857
function largeGroupPositions(s) {
    const result = [];
    let start = 0;
    for (let i = 1; i < s.length; ++i) {
        if (s.charAt(i) !== s.charAt(start)) {
            if (i - start >= 3) {
                result.push([start, i - 1]);
            }
            start = i;
        }
    }
    if (s.length - start >= 3) {
        result.push([start, s.length - 1]);
    }
    return result;
}


-----
function largeGroupPositions(s) 
    // Your code here
}


************************************
Question ID: 858
function maskInformation(s) {
    if (s.includes('@')) {
        s = s.toLowerCase();
        return s[0] + "*****" + s.slice(s.indexOf('@') - 1);
    } else {
        const digits = s.replace(/\D/g, '');
        if (digits.length === 10)
            return "***-***-" + digits.slice(-4);
        const prefix = "*".repeat(digits.length - 10) + "-";
        return '+' + prefix + "***-***-" + digits.slice(-4);
    }
}

-----
function maskInformation(s) 
    // Your code here
}

************************************
Question ID: 859
#

class MyCircularDeque:
    def __init__(self, k):
        self.buffer = [0] * k
        self.front = 0
        self.rear = 0
        self.size = 0

    def insertFront(self, value):
        if self.size == len(self.buffer): return False
        self.front = (self.front - 1 + len(self.buffer)) % len(self.buffer)
        self.buffer[self.front] = value
        self.size += 1
        return True

    def insertLast(self, value):
        if self.size == len(self.buffer): return False
        self.buffer[self.rear] = value
        self.rear = (self.rear + 1) % len(self.buffer)
        self.size += 1
        return True

    def deleteFront(self):
        if self.size == 0: return False
        self.front = (self.front + 1) % len(self.buffer)
        self.size -= 1
        return True

    def deleteLast(self):
        if self.size == 0: return False
        self.rear = (self.rear - 1 + len(self.buffer)) % len(self.buffer)
        self.size -= 1
        return True

    def getFront(self):
        if self.size == 0: return -1
        return self.buffer[self.front]

    def getRear(self):
        if self.size == 0: return -1
        return self.buffer[(self.rear - 1 + len(self.buffer)) % len(self.buffer)]

    def isEmpty(self):
        return self.size == 0

    def isFull(self):
        return self.size == len(self.buffer)

#
-----
#

class MyCircularDeque:
    def __init__(self, k):
        self.buffer = [0] * k
        self.front = 0
        self.rear = 0
        self.size = 0

    def insertFront(self, value):
        if self.size == len(self.buffer): return False
        self.front = (self.front - 1 + len(self.buffer)) % len(self.buffer)
        self.buffer[self.front] = value
        self.size += 1
        return True

    def insertLast(self, value):
        if self.size == len(self.buffer): return False
        self.buffer[self.rear] = value
        self.rear = (self.rear + 1) % len(self.buffer)
        self.size += 1
        return True

    def deleteFront(self):
        if self.size == 0: return False
        self.front = (self.front + 1) % len(self.buffer)
        self.size -= 1
        return True

    def deleteLast(self):
        if self.size == 0: return False
        self.rear = (self.rear - 1 + len(self.buffer)) % len(self.buffer)
        self.size -= 1
        return True

    def getFront(self):
        if self.size == 0: return -1
        return self.buffer[self.front]

    def getRear(self):
        if self.size == 0: return -1
        return self.buffer[(self.rear - 1 + len(self.buffer)) % len(self.buffer)]

    def isEmpty(self):
        return self.size == 0

    def isFull(self):
        return self.size == len(self.buffer)


    // Your code here
#
************************************
Question ID: 861
function flipAndInvertImage(image) {
    for (let row of image) {
        row.reverse();
        for (let j = 0; j < row.length; j++) {
            row[j] = 1 - row[j];
        }
    }
    return image;
}

-----
function flipAndInvertImage(image) 
    // Your code here
}

************************************
Question ID: 862
function findReplaceString(s, indices, sources, targets) {
    const indexMapping = indices
        .map((idx, i) => [s.startsWith(sources[i], idx) ? idx : -1, i])
        .sort((a, b) => a[0] - b[0]);
    let result = "";
    let lastIdx = 0;

    for (const [idx, i] of indexMapping) {
        if (idx >= 0) {
            result += s.slice(lastIdx, idx) + targets[i];
            lastIdx = idx + sources[i].length;
        }
    }

    result += s.slice(lastIdx);
    return result;
}

-----
function findReplaceString(s, indices, sources, targets) 
    // Your code here
}

************************************
Question ID: 863
function sumOfDistancesInTree(n, edges) {
    const tree = new Array(n).fill(0).map(() => []);
    const count = new Array(n).fill(1);
    const res = new Array(n).fill(0);

    for (let edge of edges) {
        tree[edge[0]].push(edge[1]);
        tree[edge[1]].push(edge[0]);
    }

    const dfs = (node, parent) => {
        for (let child of tree[node]) {
            if (child !== parent) {
                dfs(child, node);
                count[node] += count[child];
                res[node] += res[child] + count[child];
            }
        }
    };

    const dfs2 = (node, parent) => {
        for (let child of tree[node]) {
            if (child !== parent) {
                res[child] = res[node] - count[child] + n - count[child];
                dfs2(child, node);
            }
        }
    };

    dfs(0, -1);
    dfs2(0, -1);

    return res;
}


-----
function sumOfDistancesInTree(n, edges) 
    // Your code here
}


************************************
Question ID: 864
function largestOverlap(img1, img2) {
    const n = img1.length;
    const onesImg1 = [];
    const onesImg2 = [];
    for (let i = 0; i < n; ++i) {
        for (let j = 0; j < n; ++j) {
            if (img1[i][j]) onesImg1.push([i, j]);
            if (img2[i][j]) onesImg2.push([i, j]);
        }
    }

    const overlaps = new Map();
    for (const pt1 of onesImg1) {
        for (const pt2 of onesImg2) {
            const dx = pt2[0] - pt1[0];
            const dy = pt2[1] - pt1[1];
            const key = `${dx},${dy}`;
            overlaps.set(key, (overlaps.get(key) || 0) + 1);
        }
    }

    let maxOverlap = 0;
    for (const count of overlaps.values()) {
        maxOverlap = Math.max(maxOverlap, count);
    }
    return maxOverlap;
}

-----
function largestOverlap(img1, img2) 
    // Your code here
}

************************************
Question ID: 866
function isRectangleOverlap(rec1, rec2) {
    return rec1[2] > rec2[0] && rec1[3] > rec2[1] && rec1[0] < rec2[2] && rec1[1] < rec2[3];
}

-----
function isRectangleOverlap(rec1, rec2) 
    // Your code here
}

************************************
Question ID: 867
function new21Game(n, k, maxPts) {
    if (k === 0 || n >= k + maxPts) {
        return 1;
    }

    let dp = new Array(n + 1).fill(0);
    dp[0] = 1;
    let sum = 1, ans = 0;

    for (let i = 1; i <= n; i++) {
        dp[i] = sum / maxPts;
        if (i < k) {
            sum += dp[i];
        } else {
            ans += dp[i];
        }
        if (i >= maxPts) {
            sum -= dp[i - maxPts];
        }
    }

    return ans;
}


-----
function new21Game(n, k, maxPts) 
    // Your code here
}


************************************
Question ID: 868
function pushDominoes(dominoes) {
    let prev, cur = dominoes;
    do {
        prev = cur;
        let curList = prev.split('');
        for (let i = 0; i < prev.length; ++i) {
            if (prev[i] === 'L' && i > 0 && prev[i - 1] === '.')
                curList[i - 1] = 'L';
            else if (prev[i] === 'R' && i < prev.length - 1 && prev[i + 1] === '.')
                curList[i + 1] = 'R';
        }
        cur = curList.join('');
    } while (prev !== cur);
    return cur;
}

-----
function pushDominoes(dominoes) 
    // Your code here
}

************************************
Question ID: 869
function isSimilar(a, b) {
    let diffCount = 0;
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            diffCount++;
            if (diffCount > 2) {
                return false;
            }
        }
    }
    return true;
}

function countGroups(strs) {
    let count = 0;
    let visited = new Array(strs.length).fill(false);
    for (let i = 0; i < strs.length; i++) {
        if (!visited[i]) {
            count++;
            visited[i] = true;
            for (let j = i + 1; j < strs.length; j++) {
                if (isSimilar(strs[i], strs[j])) {
                    visited[j] = true;
                }
            }
        }
    }
    return count;
}


-----
function isSimilar(a, b) 
    // Your code here
}


************************************
Question ID: 870
function advantageCount(nums1, nums2) {
    const sortedNums1 = [...nums1].sort((a, b) => a - b);
    const result = [];
    for (const num of nums2) {
        let index = sortedNums1.findIndex(el => el > num);
        if (index === -1) index = 0;
        result.push(sortedNums1[index]);
        sortedNums1.splice(index, 1);
    }
    return result;
}

-----
function advantageCount(nums1, nums2) 
    // Your code here
}

************************************
Question ID: 871
function canVisitAllRooms(rooms) {
    const visited = new Set();
    const stack = [0];

    while (stack.length > 0) {
        const currentRoom = stack.pop();

        visited.add(currentRoom);

        for (const key of rooms[currentRoom]) {
            if (!visited.has(key)) {
                stack.push(key);
            }
        }
    }

    return visited.size === rooms.length;
}

-----
function canVisitAllRooms(rooms) 
    // Your code here
}

************************************
Question ID: 872
function splitIntoFibonacci(num) {
    const ans = [];
    const backtrack = (index, prev1, prev2) => {
        if (index === num.length) {
            return ans.length >= 3;
        }
        let curr = 0;
        for (let i = index; i < num.length; ++i) {
            if (i > index && num[index] === '0') {
                break;
            }
            curr = curr * 10 + num.charCodeAt(i) - 48;
            if (curr > 2**31 - 1) {
                break;
            }
            
            if (ans.length >= 2) {
                const sum = prev1 + prev2;
                if (curr < sum) {
                    continue;
                } else if (curr > sum) {
                    break;
                }
            }
            
            ans.push(curr);
            if (backtrack(i + 1, prev2, curr)) {
                return true;
            }
            ans.pop();
        }
        return false;
    }
    
    backtrack(0, 0, 0);
    return ans;
}

-----
function splitIntoFibonacci(num) 
    // Your code here
}

************************************
Question ID: 873
function match(a, b) {
    let matches = 0;
    for (let i = 0; i < 6; ++i)
        if (a[i] == b[i]) matches++;
    return matches;
}

function findSecretWord(wordlist, master) {
    let n = wordlist.length;
    for (let i = 0, matchCnt = 0; i < 10 && matchCnt < 6; ++i) {
        let guess = wordlist[Math.floor(Math.random() * n)];
        matchCnt = master.guess(guess);
        let candidates = [];
        for (const word of wordlist)
            if (match(word, guess) == matchCnt)
                candidates.push(word);
        wordlist = candidates;
        n = wordlist.length;
    }
}

-----
function match(a, b) 
    // Your code here
}

************************************
Question ID: 874
function backspaceCompare(s, t) {
    const processBackspaces = (string) => {
        let stack = [];
        for (let c of string) {
            if (c !== '#') {
                stack.push(c);
            } else if (stack.length > 0) {
                stack.pop();
            }
        }
        return stack;
    }

    return processBackspaces(s).join('') === processBackspaces(t).join('');
}

-----
function backspaceCompare(s, t) 
    // Your code here
}

************************************
Question ID: 875
function longestMountain(arr) {
    let n = arr.length;
    let maxLength = 0;
    let i = 1;
    while (i < n - 1) {
        if (arr[i - 1] < arr[i] && arr[i] > arr[i + 1]) {
            let left = i - 1;
            let right = i + 1;
            while (left > 0 && arr[left - 1] < arr[left]) {
                left--;
            }
            while (right < n - 1 && arr[right] > arr[right + 1]) {
                right++;
            }
            maxLength = Math.max(maxLength, right - left + 1);
            i = right;
        } else {
            i++;
        }
    }
    return maxLength;
}


-----
function longestMountain(arr) 
    // Your code here
}


************************************
Question ID: 876
function isNStraightHand(hand, groupSize) {
    const counts = new Map();

    for (let card of hand) {
        counts.set(card, (counts.get(card) || 0) + 1);
    }

    for (let key of [...counts.keys()].sort((a, b) => a - b)) {
        if (counts.get(key) > 0) {
            for (let i = groupSize - 1; i >= 0; --i) {
                if ((counts.get(key + i) || 0) < counts.get(key)) {
                    return false;
                }
                counts.set(key + i, counts.get(key + i) - counts.get(key));
            }
        }
    }
    
    return true;
}


-----
function isNStraightHand(hand, groupSize) 
    // Your code here
}


************************************
Question ID: 877
function shortestPathLength(graph) {
    const n = graph.length;
    const q = [];
    
    for(let i = 0; i < n; i++) {
        q.push([i, 1 << i]);
    }
    let steps = -1;
    const visited = Array.from({length: n}, () => Array(1 << n).fill(false));
    
    while(q.length > 0) {
        steps++;
        const size = q.length;
        
        for(let k = 0; k < size; k++) {
            const [currNode, currVisits] = q.shift();

            if(currVisits.toString(2).split('').filter(v => v === '1').length === n) return steps;
            
            for(const nextNode of graph[currNode]) {
                const nextVisits = currVisits | (1 << nextNode);
                
                if(!visited[nextNode][nextVisits]) {
                    visited[nextNode][nextVisits] = true;
                    q.push([nextNode, nextVisits]);
                }
            }
        }
    }
    
    return -1;
}


-----
function shortestPathLength(graph) 
    // Your code here
}


************************************
Question ID: 878
function shiftingLetters(s, shifts) {
    const n = s.length;
    for (let i = n - 2; i >= 0; i--) {
        shifts[i] = (shifts[i] + shifts[i + 1]) % 26;
    }
    
    let result = "";
    for (let i = 0; i < n; i++) {
        result += String.fromCharCode((s.charCodeAt(i) - 'a'.charCodeAt(0) + shifts[i]) % 26 + 'a'.charCodeAt(0));
    }
    
    return result;
}

-----
function shiftingLetters(s, shifts) 
    // Your code here
}

************************************
Question ID: 879
function maxDistToClosest(seats) {
    let maxDist = 0, lastPerson = -1;
    for (let i = 0; i < seats.length; ++i) {
        if (seats[i] == 1) {
            maxDist = lastPerson < 0 ? i : Math.max(maxDist, ((i - lastPerson) / 2) | 0);
            lastPerson = i;
        }
    }
    return Math.max(maxDist, seats.length - 1 - lastPerson);
}

-----
function maxDistToClosest(seats) 
    // Your code here
}

************************************
Question ID: 880
function rectangleArea(rectangles) {
    const mod = 1e9 + 7;
    const X = Array.from(new Set(rectangles.flatMap(rect => [rect[0], rect[2]]))).sort((a, b) => a - b);
    const Xcompress = new Map(X.map((x, idx) => [x, idx]));

    const events = [];
    for(const rect of rectangles) {
        events.push([Xcompress.get(rect[0]), 1, rect[1], rect[3]]);
        events.push([Xcompress.get(rect[2]), -1, rect[1], rect[3]]);
    }
    events.sort((a, b) => a[0] - b[0]);

    let area = 0;
    const cnt = Array(X.length).fill(0);
    let active = 0;
    for(const [idx, type, y1, y2] of events) {
        area = (area + (X[idx + 1] - X[idx]) * active % mod) % mod;
        cnt[y1] += type;
        cnt[y2] -= type;
        active = 0;
        for(let i = 0; i < idx; ++i) {
            if (cnt[i] > 0) active += X[i+1] - X[i];
        }
    }

    return area;
}

-----
function rectangleArea(rectangles) 
    // Your code here
}

************************************
Question ID: 881
function loudAndRich(richer, quiet) {
    const n = quiet.length;
    const graph = Array.from({ length: n }, () => []);
    richer.forEach(([a, b]) => graph[b].push(a));

    const answer = Array(n).fill(-1);

    function dfs(x) {
        if (answer[x] != -1) return answer[x];
        answer[x] = x;
        for (const y of graph[x]) {
            const cand = dfs(y)
            if (quiet[cand] < quiet[answer[x]])
                answer[x] = cand;
        }
        return answer[x];
    }

    for (let i = 0; i < n; ++i)
        dfs(i)

    return answer;
}


-----
function loudAndRich(richer, quiet) 
    // Your code here
}


************************************
Question ID: 882
function peakIndexInMountainArray(arr) {
    let low = 0, high = arr.length - 1;
    while (low < high) {
        let mid = low + Math.floor((high - low) / 2);
        if (arr[mid] < arr[mid + 1])
            low = mid + 1;
        else
            high = mid;
    }
    return low;
}

-----
function peakIndexInMountainArray(arr) 
    // Your code here
}

************************************
Question ID: 883
function carFleet(target, position, speed) {
  const n = position.length;
  const cars = position.map((pos, i) => [pos, speed[i]]).sort((a, b) => b[0] - a[0]);

  let fleets = 0;
  let lastArrival = -1;

  for (let i = 0; i < n; i++) {
    const arrival = (target - cars[i][0]) / cars[i][1];
    if (arrival > lastArrival) {
      fleets++;
      lastArrival = arrival;
    }
  }

  return fleets;
}


-----
function carFleet(target, position, speed) 
    // Your code here
}


************************************
Question ID: 884
function kSimilarity(s1, s2) {
    let k = 0;
    let a = Array.from(s1);
    let b = Array.from(s2);
    for (let i = 0; i < a.length; ++i) {
        if (a[i] !== b[i]) {
            for (let j = i + 1; j < b.length; ++j) {
                if (a[i] === b[j] && a[j] !== b[j]) {
                    [a[i], a[j]] = [a[j], a[i]];
                    k++;
                    break;
                }
            }
        }
    }
    return k;
}

-----
function kSimilarity(s1, s2) 
    // Your code here
}

************************************
Question ID: 885
class ExamRoom {
    constructor(n) {
        this.n = n;
        this.students = new Set();
    }

    seat() {
        if (this.students.size === 0) {
            this.students.add(0);
            return 0;
        }
        
        let distance = [...this.students][0], seatIndex = 0;
        
        for (let i = 0, prev = distance; i < this.students.size - 1; i++) {
            let srcArr = [...this.students.values()];
            let curr = srcArr[i + 1];
            let d = Math.floor((curr - prev) / 2);

            if (d > distance) {
                distance = d;
                seatIndex = prev + d;
            }
            prev = curr;
        }

        if (this.n - 1 - Array.from(this.students).pop() > distance)
            seatIndex = this.n - 1;

        this.students.add(seatIndex);
        return seatIndex;
    }

    leave(p) {
        this.students.delete(p);
    }
}


-----
class ExamRoom 
    // Your code here
}


************************************
Question ID: 886
function scoreOfParentheses(s) {
    let score = 0, depth = 0;
    for (let i = 0; i < s.length; i++) {
        if (s[i] === '(')
            depth++;
        else {
            depth--;
            if (s[i - 1] === '(')
                score += 1 << depth;
        }
    }
    return score;
}


-----
function scoreOfParentheses(s) 
    // Your code here
}


************************************
Question ID: 887
function mincostToHireWorkers(quality, wage, K) {
    const workers = Array.from({length: quality.length}, (_, i) => [
        wage[i] / quality[i], quality[i],
    ]).sort((a, b) => a[0] - b[0]);

    let sumQuality = 0;
    const maxHeap = new MaxHeap(comparator);

    let result = Infinity;
    for (const [ratio, q] of workers) {
        maxHeap.add(q);
        sumQuality += q;

        if (maxHeap.size() > K) {
            sumQuality -= maxHeap.pop();
        }

        if (maxHeap.size() === K) {
            result = Math.min(result, ratio * sumQuality);
        }
    }

    return result;
}

class MaxHeap {
    constructor(comparator) {
        this._heap = [];
        this._comparator = comparator;
    }

    add(value) {
        this._heap.push(value);
        this.bubbleUp(this.size() - 1);
    }

    pop() {
        if (this.isEmpty()) return undefined;

        this.swap(0, this.size() - 1);
        const result = this._heap.pop();
        this.bubbleDown(0);
        return result;
    }

    size() {
        return this._heap.length;
    }

    isEmpty() {
        return this._heap.length === 0;
    }

    bubbleUp(index) {
        const parent = this.parent(index);
        if (parent >= 0 && this._compare(parent, index)) {
            this.swap(parent, index);
            this.bubbleUp(parent);
        }
    }

    bubbleDown(index) {
        const largest = this.maxChildIndex(index);
        if (largest !== -1 && this._compare(index, largest)) {
            this.swap(index, largest);
            this.bubbleDown(largest);
        }
    }

    parent(index) {
        return index <= 0 ? -1 : Math.floor((index - 1) / 2);
    }

    maxChildIndex(index) {
        const left = index * 2 + 1;
        const right = index * 2 + 2;
        if (left >= this.size()) return -1;

        if (right >= this.size()) return left;

        return this._compare(left, right) ? right : left;
    }

    swap(i, j) {
        [this._heap[i], this._heap[j]] = [this._heap[j], this._heap[i]];
    }

    _compare(i, j) {
        return this._comparator(this._heap[i], this._heap[j]);
    }
}

function comparator(a, b) {
    return a < b;
}

-----
function mincostToHireWorkers(quality, wage, K) 
    // Your code here
}

************************************
Question ID: 888
function mirrorReflection(p, q) {
    function gcd(a, b) {
        return b === 0 ? a : gcd(b, a % b);
    }
    let m = p / gcd(p, q);

    if (m % 2 === 0) return 2;
    if ((q / gcd(p, q)) % 2 === 0) return 0;
    return 1;
}

-----
function mirrorReflection(p, q) 
    // Your code here
}

************************************
Question ID: 889
function areAlmostEqual(s, goal) {
    if (s === goal) return true;
    let count = 0;
    let index1 = -1, index2 = -1;
    for (let i = 0; i < s.length; i++) {
        if (s[i] !== goal[i]) {
            count++;
            if (index1 === -1) index1 = i;
            else index2 = i;
            if (count > 2) return false;
        }
    }
    return (count === 2 && s[index1] === goal[index2] && s[index2] === goal[index1]);
}

-----
function areAlmostEqual(s, goal) 
    // Your code here
}

************************************
Question ID: 890
function lemonadeChange(bills) {
    let five = 0, ten = 0;
    for (let bill of bills) {
        if (bill === 5)
            five++;
        else if (bill === 10) {
            if (five === 0) return false;
            five--;
            ten++;
        } else {
            if (ten > 0 && five > 0) {
                ten--;
                five--;
            } else if (five >= 3)
                five -= 3;
            else
                return false;
        }
    }
    return true;
}

-----
function lemonadeChange(bills) 
    // Your code here
}

************************************
Question ID: 891
function matrixScore(grid) {
    const m = grid.length, n = grid[0].length;
    for (let i = 0; i < m; i++) {
        if (grid[i][0] === 0) {
            for (let j = 0; j < n; j++) {
                grid[i][j] = 1 - grid[i][j];
            }
        }
    }
    for (let j = 1; j < n; j++) {
        let count = 0;
        for (let i = 0; i < m; i++) {
            count += grid[i][j];
        }
        if (count <= m / 2) {
            for (let i = 0; i < m; i++) {
                grid[i][j] = 1 - grid[i][j];
            }
        }
    }
    let sum = 0;
    for (let i = 0; i < m; i++) {
        let num = 0;
        for (let j = 0; j < n; j++) {
            num = num * 2 + grid[i][j];
        }
        sum += num;
    }
    return sum;
}

-----
function matrixScore(grid) 
    // Your code here
}

************************************
Question ID: 892
function shortestSubarray(nums, k) {
    const n = nums.length;
    const prefixSum = new Array(n + 1).fill(0);
    for (let i = 0; i < n; i++) prefixSum[i + 1] = prefixSum[i] + nums[i];

    let res = n + 1;
    const dq = [];
    for (let i = 0; i < n + 1; i++) {
        while (dq.length > 0 && prefixSum[i] - prefixSum[dq[0]] >= k) {
            res = Math.min(res, i - dq.shift());
        }
        while (dq.length > 0 && prefixSum[i] <= prefixSum[dq[dq.length - 1]]) {
            dq.pop();
        }
        dq.push(i);
    }
    return res <= n ? res : -1;
}


-----
function shortestSubarray(nums, k) 
    // Your code here
}


************************************
Question ID: 893
class TreeNode {
    constructor(val) {
        this.val = val;
        this.left = this.right = null;
    }
}

function findNodesAtDistanceK(root, targetVal, k) {
    if (k < 0) return [];

    let parentMap = new Map();
    let visited = new Set();
    let targetNode = initializeParentMap(root, null, targetVal, parentMap);

    let result = [];
    findNodesAtDistanceKHelper(targetNode, k, visited, parentMap, result);
    return result;
}

function initializeParentMap(node, parent, targetVal, parentMap) {
    if (!node) return null;
    if (node.val === targetVal) return node;

    parentMap.set(node, parent);
    let left = initializeParentMap(node.left, node, targetVal, parentMap);
    let right = initializeParentMap(node.right, node, targetVal, parentMap);
    return left ? left : right;
}

function findNodesAtDistanceKHelper(node, k, visited, parentMap, result) {
    if (!node || visited.has(node)) return;

    visited.add(node);
    if (k === 0) {
        result.push(node.val);
        return;
    }

    findNodesAtDistanceKHelper(node.left, k - 1, visited, parentMap, result);
    findNodesAtDistanceKHelper(node.right, k - 1, visited, parentMap, result);
    findNodesAtDistanceKHelper(parentMap.get(node), k - 1, visited, parentMap, result);
}


-----
class TreeNode 
    // Your code here
}


************************************
Question ID: 894
class Solution {
    constructor(n, blacklist) {
        this.blacklistMap = new Map();
        this.reducedN = n - blacklist.length;
        
        for (let b of blacklist) {
            if (b < n) {
                this.blacklistMap.set(b, -1);
            }
        }

        for (let b of blacklist) {
            if (b >= this.reducedN) continue;
            while (this.blacklistMap.has(--n)) {}
            this.blacklistMap.set(b, n);
        }
    }

    pick() {
        const randomInt = Math.floor(Math.random() * this.reducedN);
        return this.blacklistMap.has(randomInt) ? this.blacklistMap.get(randomInt) : randomInt;
    }
}

-----
class Solution 
    // Your code here
}

************************************
Question ID: 895
function shortestPathAllKeys(grid) {
    const m = grid.length, n = grid[0].length;
    let steps = 0, k = 0, x = -1, y = -1, mask = 0;

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (grid[i][j] === '@') {
                x = i;
                y = j;
            } else if (grid[i][j] >= 'a' && grid[i][j] <= 'f') {
                k = Math.max(k, grid[i][j].charCodeAt() - 'a'.charCodeAt() + 1);
            }
        }
    }
    
    const q = [[x, y, 0]];
    const visited = new Set([`${x},${y},${mask}`]);
    
    const dirs = [[-1, 0], [1, 0], [0, 1], [0, -1]];
    
    while (q.length) {
        const qs = q.length;
        
        for (let sz = 0; sz < qs; sz++) {
            const [x, y, mask] = q.shift();
            
            if (mask === (1 << k) - 1) return steps;
            
            dirs.forEach(([dx, dy]) => {
                const nx = x + dx, ny = y + dy;
                let nmask = mask;
                
                if (0 <= nx && nx < m && 0 <= ny && ny < n) {
                    const c = grid[nx][ny];
                    if (c >= 'A' && c <= 'F' && (nmask & (1 << (c.charCodeAt() - 'A'.charCodeAt()))) === 0) return;
                    if (c >= 'a' && c <= 'f') nmask |= (1 << (c.charCodeAt() - 'a'.charCodeAt()));
                    
                    const key = `${nx},${ny},${nmask}`;
                    
                    if (visited.has(key)) return;
                    
                    visited.add(key);
                    q.push([nx, ny, nmask]);
                }
            });
        }
        
        steps++;
    }
    
    return -1;
}


-----
function shortestPathAllKeys(grid) 
    // Your code here
}


************************************
Question ID: 897
function isPrime(n) {
    if (n <= 1) return false;
    for (let i = 2; i * i <= n; i++) {
        if (n % i === 0) return false;
    }
    return true;
}

function isPalindrome(n) {
    const str = n.toString();
    return str === str.split('').reverse().join('');
}

function primePalindrome(n) {
    while (true) {
        if (isPrime(n) && isPalindrome(n)) return n;
        n++;
    }
}

-----
function isPrime(n) 
    // Your code here
}

************************************
Question ID: 898
function transpose(matrix) {
    const rows = matrix.length;
    const cols = matrix[0].length;
    const result = Array.from({ length: cols }, () => Array(rows));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            result[j][i] = matrix[i][j];
        }
    }
    return result;
}

-----
function transpose(matrix) 
    // Your code here
}

************************************
Question ID: 899
function longestDistance(n) {
    let last = -1, longest = 0;
    for (let i = 0; n > 0; n >>= 1, i++) {
        if (n & 1) {
            if (last >= 0)
                longest = Math.max(longest, i - last);
            last = i;
        }
    }
    return longest;
}

-----
function longestDistance(n) 
    // Your code here
}

************************************
Question ID: 900
function reorderedPowerOf2(n) {
    const s = Array.from(String(n));
    s.sort();

    function nextPermutation(arr) {
        let i = arr.length - 2;
        while (i >= 0 && arr[i] >= arr[i + 1]) {
            i--;
        }
        if (i === -1) {
            return false;
        }
        let j = arr.length - 1;
        while (arr[j] <= arr[i]) {
            j--;
        }
        [arr[i], arr[j]] = [arr[j], arr[i]];
        
        let left = i + 1;
        let right = arr.length - 1;
        while (left < right) {
            [arr[left++], arr[right--]] = [arr[right], arr[left - 1]];
        }
        return true;
    }

    do {
        if (s[0] !== '0' && (parseInt(s.join('')).toString(2).split('1').length === 2)) {
            return true;
        }
    } while (nextPermutation(s));
    return false;
}


-----
function reorderedPowerOf2(n) 
    // Your code here
}


************************************
Question ID: 901
function advantageCount(nums1, nums2) {
    const sortedNums1 = [...nums1].sort((a, b) => a - b);
    const res = [];
    
    for (const num of nums2) {
        let idx = binarySearch(sortedNums1, num);
        if (idx === sortedNums1.length) {
            idx = 0;
        }
        res.push(sortedNums1.splice(idx, 1)[0]);
    }
    
    return res;
}

function binarySearch(arr, target) {
    let left = 0, right = arr.length;
    while (left < right) {
        const mid = Math.floor((left + right) / 2);
        if (arr[mid] <= target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}


-----
function advantageCount(nums1, nums2) 
    // Your code here
}


************************************
Question ID: 902
function minRefuelStops(target, startFuel, stations) {
    let i = 0, stops = 0, curFuel = startFuel;
    let pq = new PriorityQueue((a, b) => b - a);
    while (curFuel < target) {
        while (i < stations.length && stations[i][0] <= curFuel) {
            pq.offer(stations[i][1]);
            i++;
        }
        if (pq.isEmpty()) return -1;
        curFuel += pq.poll();
        stops++;
    }
    return stops;
}

class PriorityQueue {
    constructor(comparator) {
        this._heap = [];
        this._comparator = comparator || ((a, b) => a - b);
    }
    size() {
        return this._heap.length;
    }
    isEmpty() {
        return this.size() == 0;
    }
    peek() {
        return this._heap[0];
    }
    offer(value) {
        this._heap.push(value);
        this._siftUp();
    }
    poll() {
        const head = this.peek();
        this._heap[0] = this._heap.pop();
        this._siftDown();
        return head;
    }
    _parent(idx) {
        return Math.floor((idx - 1) / 2);
    }
    _left(idx) {
        return idx * 2 + 1;
    }
    _right(idx) {
        return idx * 2 + 2;
    }
    _siftUp() {
        let node = this.size() - 1;

        while (node > 0 && this._comparator(this._heap[node], this._heap[this._parent(node)]) < 0) {
            [this._heap[node], this._heap[this._parent(node)]] = [this._heap[this._parent(node)], this._heap[node]];
            node = this._parent(node);
        }
    }
    _siftDown() {
        let node = 0;
        while ((this._left(node) < this.size() && this._comparator(this._heap[this._left(node)], this._heap[node]) < 0) ||
            (this._right(node) < this.size() && this._comparator(this._heap[this._right(node)], this._heap[node]) < 0)) {
                
            let minChild = this._left(node);
            if (this._right(node) < this.size() && this._comparator(this._heap[this._right(node)], this._heap[this._left(node)]) < 0) {
                minChild = this._right(node);
            }

            [this._heap[node], this._heap[minChild]] = [this._heap[minChild], this._heap[node]];
            node = minChild;
        }
    }
}


-----
function minRefuelStops(target, startFuel, stations) 
    // Your code here
}


************************************
Question ID: 903
function rand7() {} // Given API

function rand10() {
    let result;
    do {
        result = (rand7() - 1) * 7 + rand7();
    } while (result > 40);
    return result % 10 + 1;
}

-----
function rand7() 
    // Your code here
}

************************************
Question ID: 904
function leafSimilar(root1, root2) {
    let leaves1 = [];
    let leaves2 = [];
    getLeaves(root1, leaves1);
    getLeaves(root2, leaves2);
    return JSON.stringify(leaves1) === JSON.stringify(leaves2);
}

function getLeaves(node, leaves) {
    if (!node) return;
    if (!node.left && !node.right) leaves.push(node.val);
    getLeaves(node.left, leaves);
    getLeaves(node.right, leaves);
}

-----
function leafSimilar(root1, root2) 
    // Your code here
}

************************************
Question ID: 905
function lenLongestFibSubseq(arr) {
    const index = new Map(arr.map((x, i) => [x, i]));

    const longest = new Map();
    let ans = 0;

    for (let k = 0; k < arr.length; ++k) {
        for (let j = 0; j < k; ++j) {
            const i = index.get(arr[k] - arr[j]) || -1;
            if (i >= 0 && i < j) {
                longest.set(j * arr.length + k, (longest.get(i * arr.length + j) || 1) + 1);
                ans = Math.max(ans, longest.get(j * arr.length + k) + 1);
            }
        }
    }

    return ans >= 3 ? ans : 0;
}

-----
function lenLongestFibSubseq(arr) 
    // Your code here
}

************************************
Question ID: 907
function minEatingSpeed(piles, h) {
  let left = 1, right = Math.max(...piles);
  while (left < right) {
    let mid = left + Math.floor((right - left) / 2);
    let totalHours = 0;
    for (let pile of piles)
      totalHours += Math.ceil(pile / mid);
    if (totalHours > h)
      left = mid + 1;
    else
      right = mid;
  }
  return left;
}

-----
function minEatingSpeed(piles, h) 
    // Your code here
}

************************************
Question ID: 909
function aliceWins(piles) {
    const n = piles.length;
    const dp = Array.from({length: n}, (_, _) => Array(n).fill(0));
    for (let gap = 0; gap < n; ++gap) {
        for (let i = 0, j = gap; j < n; ++i, ++j) {
            const x = (i + 2) <= j ? dp[i + 2][j] : 0;
            const y = (i + 1) <= (j - 1) ? dp[i + 1][j - 1] : 0;
            const z = i <= (j - 2) ? dp[i][j - 2] : 0;
            dp[i][j] = Math.max(piles[i] + Math.min(x, y), piles[j] + Math.min(y, z));
        }
    }
    const sum = piles.reduce((acc, val) => acc + val, 0);
    return dp[0][n - 1] > (sum - dp[0][n - 1]);
}

-----
function aliceWins(piles) 
    // Your code here
}

************************************
Question ID: 910
function nthMagicalNumber(n, a, b) {
    const mod = 1e9 + 7;
    const lcm = a * b / gcd(a, b);
    let left = 1, right = 1e14, mid;
    while(left < right) {
        mid = left + Math.trunc((right - left) / 2);
        if (Math.trunc(mid / a + mid / b - mid / lcm) < n) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left % mod;
}

function gcd(a, b) {
    return b === 0 ? a : gcd(b, a % b);
}

-----
function nthMagicalNumber(n, a, b) 
    // Your code here
}

************************************
Question ID: 911
function profitableSchemes(n, minProfit, group, profit) {
    const dp = new Array(n + 1).fill(0).map(() => new Array(minProfit + 1).fill(0));
    const mod = 1e9 + 7;
    dp[0][0] = 1;
    for (let i = 0; i < group.length; ++i) {
        for (let j = n; j >= group[i]; --j) {
            for (let k = minProfit; k >= 0; --k) {
                dp[j][k] = (dp[j][k] + dp[j - group[i]][Math.max(0, k - profit[i])]) % mod;
            }
        }
    }
    let res = 0;
    for (let i = 1; i <= n; ++i) {
        res = (res + dp[i][minProfit]) % mod;
    }
    return res;
}


-----
function profitableSchemes(n, minProfit, group, profit) 
    // Your code here
}


************************************
Question ID: 912
class Solution {
    constructor(w) {
        this.prefixSum = [];
        this.prefixSum[0] = w[0];
        for (let i = 1; i < w.length; i++) {
            this.prefixSum[i] = this.prefixSum[i - 1] + w[i];
        }
    }

    pickIndex() {
        const num = Math.random() * this.prefixSum[this.prefixSum.length - 1];
        let idx = 0;
        while (num >= this.prefixSum[idx]) {
            idx++;
        }
        return idx;
    }
}

-----
class Solution 
    // Your code here
}

************************************
Question ID: 913
class Solution {
    constructor(m, n) {
        this.grid = new Array(m).fill(0).map(() => new Array(n).fill(0));
        this.zeroCount = m * n;
    }

    pick() {
        let index = Math.floor(Math.random() * this.zeroCount);

        for (let i = 0; i < this.grid.length; i++) {
            for (let j = 0; j < this.grid[0].length; j++) {
                if (this.grid[i][j] === 0) {
                    if (index === 0) {
                        this.grid[i][j] = 1;
                        this.zeroCount--;
                        return [i, j];
                    }
                    index--;
                }
            }
        }
        return [-1, -1];  // Should not happen
    }
}

-----
class Solution 
    // Your code here
}

************************************
Question ID: 914
class Solution {
    constructor(rects) {
        this.rects = rects;
        this.totalArea = 0;
        this.areas = new Array(rects.length);

        for (let i = 0; i < rects.length; i++) {
            let area = (rects[i][2] - rects[i][0] + 1) * (rects[i][3] - rects[i][1] + 1);
            this.totalArea += area;
            this.areas[i] = this.totalArea;
        }
    }

    pick() {
        let randomArea = Math.floor(Math.random() * this.totalArea);
        let rectIndex = 0;
        while (this.areas[rectIndex] <= randomArea) {
            rectIndex++;
        }

        let x = this.rects[rectIndex][0] + Math.floor(Math.random() * (this.rects[rectIndex][2] - this.rects[rectIndex][0] + 1));
        let y = this.rects[rectIndex][1] + Math.floor(Math.random() * (this.rects[rectIndex][3] - this.rects[rectIndex][1] + 1));

        return [x, y];
    }
}


-----
class Solution 
    // Your code here
}


************************************
Question ID: 915
class Solution {
    constructor(radius, x_center, y_center) {
        this.radius = radius;
        this.x_center = x_center;
        this.y_center = y_center;
    }
    
    randPoint() {
        const angle = Math.random() * 2 * Math.PI;
        const r = Math.sqrt(Math.random()) * this.radius;
        return [this.x_center + r * Math.cos(angle), this.y_center + r * Math.sin(angle)];
    }
}

-----
class Solution 
    // Your code here
}

************************************
Question ID: 916
function findKthCharacter(s, k) {
    const n = s.length;
    let size = 0;

    for (const c of s) {
        if (/\d/.test(c)) {
            size = size * Number(c);
        } else {
            size++;
        }
    }

    for (let i = n - 1; i >= 0; i--) {
        const c = s.charAt(i);
        k %= size;
        if (k === 0 && !/\d/.test(c)) {
            return c;
        }

        if (/\d/.test(c)) {
            size /= Number(c);
        } else {
            size--;
        }
    }

    return '-';
}

-----
function findKthCharacter(s, k) 
    // Your code here
}

************************************
Question ID: 917
function numRescueBoats(people, limit) {
    people.sort((a, b) => a - b);
    let left = 0, right = people.length - 1;
    let boats = 0;
    while (left <= right) {
        if (people[left] + people[right] <= limit) {
            left++;
        }
        right--;
        boats++;
    }
    return boats;
}

-----
function numRescueBoats(people, limit) 
    // Your code here
}

************************************
Question ID: 918
function reachableNodes(edges, maxMoves, n) {
    const graph = Array.from({length: n}, () => []);
    for (const edge of edges) {
        const [u, v, cnt] = edge;
        graph[u].push([v, cnt + 1]);
        graph[v].push([u, cnt + 1]);
    }

    const visited = new Set();
    const pq = [[maxMoves, 0]];

    while (pq.length) {
        const [moves_left, node] = pq.pop();

        if (visited.has(node)) continue;
        visited.add(node);

        for (const neighbor of graph[node]) {
            const [next_node, moves_needed] = neighbor;
            const moves_left_after = moves_left - moves_needed;

            if (!visited.has(next_node) && moves_left_after > 0) {
                pq.push([moves_left_after, next_node]);
                pq.sort((a, b) => b[0] - a[0]);
            }
        }
    }

    return visited.size;
}


-----
function reachableNodes(edges, maxMoves, n) 
    // Your code here
}


************************************
Question ID: 919
function projectionArea(grid) {
    const n = grid.length;
    let top = 0, front = 0, side = 0;
    for (let i = 0; i < n; i++) {
        let maxFront = 0, maxSide = 0;
        for (let j = 0; j < n; j++) {
            if (grid[i][j] > 0) {
                top++;
            }
            maxFront = Math.max(maxFront, grid[i][j]);
            maxSide = Math.max(maxSide, grid[j][i]);
        }
        front += maxFront;
        side += maxSide;
    }
    return top + front + side;
}

-----
function projectionArea(grid) 
    // Your code here
}

************************************
Question ID: 920
function uncommonFromSentences(s1, s2) {
    const wordCount = new Map();
    const words = (s1 + " " + s2).split(" ");
    
    for (const word of words) {
        wordCount.set(word, (wordCount.get(word) || 0) + 1);
    }

    const result = [];
    for (const [key, value] of wordCount.entries()) {
        if (value === 1) {
            result.push(key);
        }
    }
    
    return result;
}

-----
function uncommonFromSentences(s1, s2) 
    // Your code here
}

************************************
Question ID: 921
function spiral_walk(rows, cols, rStart, cStart) {
    let result = [];
    let dr = [0, 1, 0, -1];
    let dc = [1, 0, -1, 0];
    let moves = rows * cols;
    let r = rStart, c = cStart, dir = 0;
    
    while (result.length < moves) {
        result.push([r, c]);
        r += dr[dir];
        c += dc[dir];
        
        if (r < 0 || r >= rows || c < 0 || c >= cols) {
            r -= dr[dir];
            c -= dc[dir];
            dir = (dir + 1) % 4;
            r += dr[dir];
            c += dc[dir];
        }
    }

    return result;
}

-----
function spiral_walk(rows, cols, rStart, cStart) 
    // Your code here
}

************************************
Question ID: 922
function possibleBipartition(n, dislikes) {
    function dfs(person, group) {
        if (groups[person] !== undefined) {
            return groups[person] === group;
        }
        groups[person] = group;
        for (let other of dislikeList[person]) {
            if (!dfs(other, -group)) {
                return false;
            }
        }
        return true;
    }

    const groups = {};
    const dislikeList = Array.from({ length: n + 1 }, () => []);
    for (let [p1, p2] of dislikes) {
        dislikeList[p1].push(p2);
        dislikeList[p2].push(p1);
    }

    for (let person = 1; person <= n; person++) {
        if (groups[person] === undefined && !dfs(person, 1)) {
            return false;
        }
    }

    return true;
}


-----
function possibleBipartition(n, dislikes) 
    // Your code here
}


************************************
Question ID: 923
function minMoves(k, n) {
    if (k === 1 || n === 0 || n === 1) {
        return n;
    }
    let res = Number.MAX_VALUE;
    for (let i = 1; i <= n; i++) {
        let temp = Math.max(minMoves(k - 1, i - 1), minMoves(k, n - i));
        res = Math.min(res, temp);
    }
    return res + 1;
}

-----
function minMoves(k, n) 
    // Your code here
}

************************************
Question ID: 924
function fairCandySwap(aliceSizes, bobSizes) {
    const aliceTotal = aliceSizes.reduce((a, b) => a + b, 0);
    const bobTotal = bobSizes.reduce((a, b) => a + b, 0);

    const delta = (bobTotal - aliceTotal) / 2;
    for (const a of aliceSizes) {
        for (const b of bobSizes) {
            if (a + delta === b) {
                return [a, b];
            }
        }
    }
    return [];
}

-----
function fairCandySwap(aliceSizes, bobSizes) 
    // Your code here
}

************************************
Question ID: 926
function findAndReplacePatterns(words, pattern) {
    const result = [];
    for (const word of words) {
        if (word.length !== pattern.length) continue;

        const w2p = new Map();
        const p2w = new Map();
        let matches = true;
        for (let i = 0; i < word.length; ++i) {
            const cWord = word[i];
            const cPattern = pattern[i];

            if (!w2p.has(cWord)) w2p.set(cWord, cPattern);
            if (!p2w.has(cPattern)) p2w.set(cPattern, cWord);

            if (w2p.get(cWord) !== cPattern || p2w.get(cPattern) !== cWord) {
                matches = false;
                break;
            }
        }
        if (matches) result.push(word);
    }
    return result;
}


-----
function findAndReplacePatterns(words, pattern) 
    // Your code here
}


************************************
Question ID: 927
function sumOfWidths(nums) {
    const MOD = 1e9 + 7;
    nums.sort((a, b) => a - b);
    let res = 0, c = 1, n = nums.length;

    for (let i = 0; i < n; i++, c = (c * 2) % MOD)
        res = (res + (nums[i] - nums[n - i - 1]) * c) % MOD;

    return res;
}

-----
function sumOfWidths(nums) 
    // Your code here
}

************************************
Question ID: 928
function surfaceArea(grid) {
    const n = grid.length;
    let area = 0;

    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            if (grid[i][j] > 0) {
                area += 4 * grid[i][j] + 2;
                if (i > 0) area -= 2 * Math.min(grid[i][j], grid[i - 1][j]);
                if (j > 0) area -= 2 * Math.min(grid[i][j], grid[i][j - 1]);
            }
        }
    }

    return area;
}


-----
function surfaceArea(grid) 
    // Your code here
}


************************************
Question ID: 929
function numSpecialEquivalentGroups(words) {
    const groups = new Set();

    for (const word of words) {
        let evens = "";
        let odds = "";

        for (let i = 0; i < word.length; ++i) {
            if (i % 2 === 0) evens += word[i];
            else odds += word[i];
        }

        evens = evens.split("").sort().join("");
        odds = odds.split("").sort().join("");

        groups.add(evens + odds);
    }

    return groups.size;
}


-----
function numSpecialEquivalentGroups(words) 
    // Your code here
}


************************************
Question ID: 931
class FreqStack {
    constructor() {
        this.freq = new Map();
        this.group = new Map();
    }

    push(x) {
        let f = (this.freq.get(x) || 0) + 1;
        this.freq.set(x, f);
        let stack = this.group.get(f) || [];
        stack.push(x);
        this.group.set(f, stack);
    }

    pop() {
        let maxFreq = Math.max(...this.group.keys());
        let stack = this.group.get(maxFreq);
        let x = stack.pop();
        this.freq.set(x, this.freq.get(x) - 1);
        if (stack.length === 0) {
            this.group.delete(maxFreq);
        } else {
            this.group.set(maxFreq, stack);
        }
        return x;
    }
}


-----
class FreqStack 
    // Your code here
}


************************************
Question ID: 932
function isMonotonic(nums) {
    let increasing = true, decreasing = true;
    for (let i = 1; i < nums.length; i++) {
        if (nums[i] > nums[i - 1]) decreasing = false;
        if (nums[i] < nums[i - 1]) increasing = false;
    }
    return increasing || decreasing;
}

-----
function isMonotonic(nums) 
    // Your code here
}

************************************
Question ID: 934
function subarrayBitwiseORs(arr) {
    let result = new Set(), current = new Set(), temp;
    for (const num of arr) {
        temp = new Set([num]);
        for (const c of current) {
            temp.add(num | c);
        }
        current = temp;
        for (const c of current) {
            result.add(c);
        }
    }
    return result.size;
}

-----
function subarrayBitwiseORs(arr) 
    // Your code here
}

************************************
Question ID: 935
function lexSmallestString(s, k) {
    let res = s;
    for (let i = 0; i < k; i++) {
        let tmp = s.slice(i) + s.slice(0, i);
        if (tmp < res) {
            res = tmp;
        }
    }
    return res;
}

-----
function lexSmallestString(s, k) 
    // Your code here
}

************************************
Question ID: 938
function numDigitsLessThanN(digits, n) {
    let ans = 0, factor = 1;
    let nStr = String(n);
    for (let i = nStr.length - 1; i >= 0; --i) {
        ans += (upperBound(digits, nStr.charCodeAt(i) - 48)) * factor;
        factor *= digits.length;
    }
    return ans;
}

function upperBound(arr, target) {
    let low = 0, high = arr.length;
    while (low < high) {
        let mid = Math.floor((low + high) / 2);
        if (arr[mid] > target) high = mid;
        else low = mid + 1;
    }
    return low;
}

-----
function numDigitsLessThanN(digits, n) 
    // Your code here
}

************************************
Question ID: 939
function findValidPermutations(s) {
    const n = s.length;
    const MOD = 1000000007;
    let dp = new Array(n + 2).fill(0);
    dp[0] = 1;

    for (const c of s) {
        let new_dp = new Array(n + 2).fill(0);
        if (c === 'I') {
            for (let i = 0; i < n; ++i) {
                new_dp[i + 1] = (new_dp[i + 1] + dp[i]) % MOD;
            }
        } else {
            for (let i = n - 1; i >= 0; --i) {
                new_dp[i] = (new_dp[i + 1] + dp[i + 1]) % MOD;
            }
        }
        dp = new_dp;
    }
    return dp[0];
}

-----
function findValidPermutations(s) 
    // Your code here
}

************************************
Question ID: 940
function totalFruit(fruits) {
    let left = 0, right = 0, max_count = 0;
    const count = new Map();

    while (right < fruits.length) {
        count.set(fruits[right], (count.get(fruits[right]) || 0) + 1);
        while (count.size > 2) {
            count.set(fruits[left], count.get(fruits[left]) - 1);
            if (count.get(fruits[left]) === 0) {
                count.delete(fruits[left]);
            }
            left++;
        }
        max_count = Math.max(max_count, right - left + 1);
        right++;
    }
    return max_count;
}

-----
function totalFruit(fruits) 
    // Your code here
}

************************************
Question ID: 941
function moveEvenOdd(nums) {
    let evenIndex = 0;
    let oddIndex = nums.length - 1;

    while (evenIndex < oddIndex) {
        if (nums[evenIndex] % 2 === 0) {
            evenIndex++;
        } else {
            [nums[evenIndex], nums[oddIndex]] = [nums[oddIndex], nums[evenIndex]];
            oddIndex--;
        }
    }
}

-----
function moveEvenOdd(nums) 
    // Your code here
}

************************************
Question ID: 942
function isPalindrome(num) {
    const str = num.toString();
    const revStr = str.split('').reverse().join('');
    return str === revStr;
}

function superpalindromesInRange(left, right) {
    const l = parseInt(left);
    const r = parseInt(right);
    let cnt = 0;
    for (let base = 1; base * base <= r; ++base) {
        if (isPalindrome(base) && isPalindrome(base * base)) {
            if (base * base >= l) {
                cnt++;
            }
        }
    }
    return cnt;
}


-----
function isPalindrome(num) 
    // Your code here
}


************************************
Question ID: 943
function sumOfMins(arr) {
    let mod = 1e9 + 7;
    let n = arr.length;
    let left = new Array(n), right = new Array(n);
    let st = [];

    for (let i = 0; i < n; i++) {
        while (st.length && arr[st[st.length - 1]] > arr[i]) {
            st.pop();
        }
        left[i] = st.length === 0 ? -1 : st[st.length - 1];
        st.push(i);
    }

    st = [];
    for (let i = n - 1; i >= 0; i--) {
        while (st.length && arr[st[st.length - 1]] > arr[i]) {
            st.pop();
        }
        right[i] = st.length === 0 ? n : st[st.length - 1];
        st.push(i);
    }

    let ans = 0;
    for (let i = 0; i < n; i++) {
        ans = (ans + arr[i] * (i - left[i]) * (right[i] - i)) % mod;
    }
    return ans;
}

-----
function sumOfMins(arr) 
    // Your code here
}

************************************
Question ID: 944
function minDifference(nums, k) {
    if(nums.length <= 1) return 0;
    nums.sort((a, b) => a - b);
    let min_diff = nums[nums.length - 1] - nums[0];
    for(let i = 1; i < nums.length; i++) {
        let high = Math.max(nums[i - 1] + k, nums[nums.length - 1] - k);
        let low = Math.min(nums[i] - k, nums[0] + k);
        min_diff = Math.min(min_diff, high - low);
    }
    return min_diff;
}

-----
function minDifference(nums, k) 
    // Your code here
}

************************************
Question ID: 945
function snakesAndLadders(board) {
  const n = board.length;
  const visited = new Array(n * n + 1).fill(false);
  const queue = [{ pos: 1, steps: 0 }];
  visited[1] = true;

  function getPosition(pos) {
    const row = Math.ceil(pos / n);
    let col = ((row % 2) === 0) ? n - (pos % n) : (pos % n) + 1;
    if (col === n + 1) {
      col = 1;
    }
    return [n - row, col - 1];
  }

  while (queue.length) {
    const { pos, steps } = queue.shift();

    for (let jump = 1; jump <= 6; jump++) {
      let nextPos = pos + jump;
      if (nextPos > n * n) break;
      const [r, c] = getPosition(nextPos);
      if (board[r][c] !== -1) {
        nextPos = board[r][c];
      }
      if (nextPos === n * n) return steps + 1;
      if (!visited[nextPos]) {
        visited[nextPos] = true;
        queue.push({ pos: nextPos, steps: steps + 1 });
      }
    }
  }
  return -1;
}


-----
function snakesAndLadders(board) 
    // Your code here
}


************************************
Question ID: 946
function minimumScore(nums, k) {
    nums.sort((a, b) => a - b);
    const n = nums.length;
    let res = nums[n - 1] - nums[0];

    for (let i = 0; i < n - 1; i++) {
        const high = Math.max(nums[i] + k, nums[n - 1] - k);
        const low = Math.min(nums[i + 1] - k, nums[0] + k);
        res = Math.min(res, high - low);
    }

    return res;
}

-----
function minimumScore(nums, k) 
    // Your code here
}

************************************
Question ID: 947
class TopVotedCandidate {
    constructor(persons, times) {
        this.leaderMap = new Map();
        this.times = times;
        let votes = new Map();
        let leader = -1;
        for (let i = 0; i < times.length; i++) {
            votes.set(persons[i], (votes.get(persons[i]) || 0) + 1);
            if (votes.get(persons[i]) >= (votes.get(leader) || 0)) {
                leader = persons[i];
            }
            this.leaderMap.set(times[i], leader);
        }
    }

    q(t) {
        let idx = this.times.findIndex(time => time > t);
        if (idx == -1) idx = this.times.length;
        return this.leaderMap.get(this.times[idx - 1]);
    }
}

-----
class TopVotedCandidate 
    // Your code here
}

************************************
Question ID: 948
function sortArray(nums) {
    nums.sort((a, b) => a - b);
}

-----
function sortArray(nums) 
    // Your code here
}

************************************
Question ID: 949
function catMouseGame(graph) {
    const n = graph.length;
    const status = [...Array(n)].map(() => [...Array(n)].map(() => Array(3).fill(-1)));
    const queue = [];
    
    for (let i = 1; i < n; ++i) {
        status[i][i][1] = 2;
        status[i][i][2] = 2;
        queue.push([i, i, 2, 2]);
        queue.push([i, i, 1, 2]);
    }

    while (queue.length) {
        const [pos_m, pos_c, t_type, t_result] = queue.shift();

        for (const prev of t_type === 1 ? graph[pos_m] : graph[pos_c]) {
            if ((t_type === 2 && prev === 0) || (t_result === 2 && status[prev][pos_c][3 - t_type] !== -1)) continue;
            if (status[prev][pos_c][3 - t_type] !== -1) continue;
            queue.push([pos_c, prev, 3 - t_type, 3 - t_result]);
            status[prev][pos_c][3 - t_type] = 3 - t_result;
        }
    }
    return status[1][2][1];
}


-----
function catMouseGame(graph) 
    // Your code here
}


************************************
Question ID: 950
function gcd(a, b) {
   if (b === 0) return a;
   return gcd(b, a % b);
}

function hasGroupsSizeX(deck) {
    const counts = {};
    for (const card of deck) {
        if (card in counts) {
            counts[card]++;
        } else {
            counts[card] = 1;
        }
    }
    let gcd_result = 0;
    for (const count in counts) {
        gcd_result = gcd(gcd_result, counts[count]);
    }
    return gcd_result > 1;
}

-----
function gcd(a, b) 
    // Your code here
}

************************************
Question ID: 951
function partitionDisjoint(nums) {
    let leftMax = nums[0], globalMax = nums[0], leftLength = 1;
    for (let i = 1; i < nums.length; ++i) {
        if (nums[i] < leftMax) {
            leftMax = globalMax;
            leftLength = i + 1;
        } else {
            globalMax = Math.max(globalMax, nums[i]);
        }
    }
    return leftLength;
}

-----
function partitionDisjoint(nums) 
    // Your code here
}

************************************
Question ID: 952
function wordSubsets(words1, words2) {
    const maxChars = {};
    for (const word of words2) {
        const chars = {};
        for (const c of word) {
            chars[c] = (chars[c] || 0) + 1;
        }
        for (const c in chars) {
            maxChars[c] = Math.max(maxChars[c] || 0, chars[c]);
        }
    }
    
    const result = [];
    for (const word of words1) {
        const wordChars = {};
        for (const c of word) {
            wordChars[c] = (wordChars[c] || 0) + 1;
        }
        
        let universal = true;
        for (const c in maxChars) {
            if ((wordChars[c] || 0) < maxChars[c]) {
                universal = false;
                break;
            }
        }
        
        if (universal) {
            result.push(word);
        }
    }
    
    return result;
}


-----
function wordSubsets(words1, words2) 
    // Your code here
}


************************************
Question ID: 953
function reverseString(s) {
    return s.split('').reverse().join('');
}


-----
function reverseString(s) 
    // Your code here
}


************************************
Question ID: 954
var canReorderDoubled = function(arr) {
    const count = new Map();
    arr.sort((a, b) => Math.abs(a) - Math.abs(b));
    
    for (const a of arr) {
        if (!count.has(a)) {
            count.set(a, 0);
        }
        count.set(a, count.get(a) + 1);
    }
    
    for (const a of count.keys()) {
        if (count.get(a) > 0) {
            const target = a < 0 ? a / 2 : a * 2;
            if (!count.has(target) || count.get(target) < count.get(a)) {
                return false;
            }
            count.set(target, count.get(target) - count.get(a));
        }
    }

    return true;
};

-----
var canReorderDoubled = function(arr) 
    // Your code here
};

************************************
Question ID: 955
class TreeNode {
    constructor(x) {
        this.val = x;
        this.left = null;
        this.right = null;
    }
}

class CBTInserter {
    constructor(root) {
        this.root = root;
        this.q = [root];
        while (true) {
            let node = this.q[0];
            if (!node.left || !node.right) break;
            this.q.push(node.left);
            this.q.push(node.right);
            this.q.shift();
        }
    }

    insert(v) {
        const newNode = new TreeNode(v);
        const parentNode = this.q[0];
        if (!parentNode.left) {
            parentNode.left = newNode;
        } else {
            parentNode.right = newNode;
            this.q.push(parentNode.left);
            this.q.push(parentNode.right);
            this.q.shift();
        }
        return parentNode.val;
    }

    get_root() {
        return this.root;
    }
}


-----
class TreeNode 
    // Your code here
}


************************************
Question ID: 956
function numMusicPlaylists(n, goal, k) {
    const MOD = 1_000_000_007;
    const dp = Array.from({ length: goal + 1 }, () => Array.from({ length: n + 1 }, () => 0));
    dp[0][0] = 1;
    for (let i = 1; i <= goal; i++) {
        for (let j = 1; j <= n; j++) {
            dp[i][j] = ((dp[i - 1][j - 1] * (n - (j - 1))) % MOD + (dp[i - 1][j] * Math.max(0, j - k)) % MOD) % MOD;
        }
    }
    return dp[goal][n];
}

-----
function numMusicPlaylists(n, goal, k) 
    // Your code here
}

************************************
Question ID: 957
function minAddToMakeValid(s) {
    let result = 0, balance = 0;
    for (let c of s) {
        balance += (c === '(') ? 1 : -1;
        if (balance === -1) {
            result++;
            balance++;
        }
    }
    return result + balance;
}

-----
function minAddToMakeValid(s) 
    // Your code here
}

************************************
Question ID: 958
function sortArrayByParityII(nums) {
    let j = 1;
    for (let i = 0; i < nums.length; i += 2) {
        if (nums[i] % 2 !== 0) {
            while (nums[j] % 2 !== 0) {
                j += 2;
            }
            [nums[i], nums[j]] = [nums[j], nums[i]];
        }
    }
    return nums;
}

-----
function sortArrayByParityII(nums) 
    // Your code here
}

************************************
Question ID: 959
function threeSumMulti(arr, target) {
    const MOD = 1000000007;
    let ans = 0;

    arr.sort((a, b) => a - b);
    const n = arr.length;

    for (let i = 0; i < n - 2; ++i) {
        let j = i + 1, k = n - 1;
        while (j < k) {
            const sum = arr[i] + arr[j] + arr[k];
            if (sum > target) {
                k--;
            } else if (sum < target) {
                j++;
            } else {
                if (arr[j] !== arr[k]) {
                    let left_count = 1, right_count = 1;

                    while (j < n - 1 && arr[j] === arr[j + 1]){
                        left_count++; 
                        j++;
                    }
                    while (k > 0 && arr[k] === arr[k - 1]){
                        right_count++;
                        k--;
                    }

                    ans += left_count * right_count;
                    ans %= MOD;
                    j++; k--;
                } else {
                    ans += (k - j + 1) * (k - j) / 2;
                    ans %= MOD;
                    break;
                }
            }
        }
    }

    return ans;
}


-----
function threeSumMulti(arr, target) 
    // Your code here
}


************************************
Question ID: 960
function minMalwareSpread(graph, initial) {
    const n = graph.length;
    initial.sort((a, b) => a - b);
    
    const malware = new Set(initial);
    
    let minNode = initial[0];
    let minSpread = n + 1;

    for (const node of initial) {
        const q = [];
        const visited = new Array(n).fill(false);

        for (const otherNode of initial) {
            if (node !== otherNode) {
                q.push(otherNode);
                visited[otherNode] = true;
            }
        }

        while (q.length) {
            const cur = q.shift();
            for (let next = 0; next < n; ++next) {
                if (graph[cur][next] === 1 && !visited[next] && !malware.has(next)) {
                    visited[next] = true;
                    q.push(next);
                }
            }
        }
        
        const spread = visited.reduce((acc, v) => acc + (v ? 1 : 0), 0);

        if (spread < minSpread) {
            minNode = node;
            minSpread = spread;
        }
    }
    
    return minNode;
}


-----
function minMalwareSpread(graph, initial) 
    // Your code here
}


************************************
Question ID: 961
function isLongPressedName(name, typed) {
    let i = 0, j = 0;
    while (j < typed.length) {
        if (i < name.length && name[i] === typed[j]) {
            i++;
        } else if (j === 0 || typed[j] !== typed[j - 1]) {
            return false;
        }
        j++;
    }
    return i === name.length;
}

-----
function isLongPressedName(name, typed) 
    // Your code here
}

************************************
Question ID: 962
function minFlipsMonoIncr(s) {
    let flipCount = 0, oneCount = 0;
    for (let c of s) {
        if (c === '1') {
            oneCount++;
        } else {
            flipCount = Math.min(flipCount + 1, oneCount);
        }
    }
    return flipCount;
}

-----
function minFlipsMonoIncr(s) 
    // Your code here
}

************************************
Question ID: 963
function findSameBinaryValueParts(arr) {
    let ones = arr.reduce((sum, n) => sum + n, 0);

    if (ones % 3 !== 0) return [-1, -1];

    let target = Math.floor(ones / 3);
    if (target === 0) return [0, arr.length - 2];

    let count = 0, i = -1, j = -1;
    ones = 0;
    for (let idx = 0; idx < arr.length; ++idx) {
        if (arr[idx] === 1) {
            ones++;
            if (ones === target + 1) count++;
            if (count === 1 && i === -1) i = idx;
            if (count === 2 && j === -1) j = idx;
            if (count === 3) break;
        }
    }

    return [i, j];
}

-----
function findSameBinaryValueParts(arr) 
    // Your code here
}

************************************
Question ID: 964
function minMalwareSpread(graph, initial) {
    const n = graph.length;
    const color = new Array(n).fill(-1);
    let colors = 0;

    for (let i = 0; i < n; ++i) {
        if (color[i] === -1) {
            const q = [i];
            color[i] = colors;

            while (q.length) {
                const t = q.shift();
                for (let j = 0; j < n; ++j) {
                    if (graph[t][j] === 1 && color[j] === -1) {
                        q.push(j);
                        color[j] = colors;
                    }
                }
            }
            ++colors;
        }
    }

    const area = new Array(colors).fill(0);
    const count = new Array(colors).fill(0);
    const initiallyInfected = new Set(initial);

    for (let i = 0; i < n; ++i) {
        ++area[color[i]];
        if (initiallyInfected.has(i)) {
            ++count[color[i]];
        }
    }

    let res = initial[0];
    let minSize = n + 1;
    for (const i of initial) {
        if (count[color[i]] === 1) {
            if (area[color[i]] < minSize) {
                minSize = area[color[i]];
                res = i;
            } else if (area[color[i]] === minSize && i < res) {
                res = i;
            }
        }
    }

    return res;
}

-----
function minMalwareSpread(graph, initial) 
    // Your code here
}

************************************
Question ID: 965
function numUniqueEmails(emails) {
    let unique_emails = new Set();

    emails.forEach((email) => {
        let [local_name, domain_name] = email.split("@");
        local_name = local_name.split("+")[0];
        local_name = local_name.replace(/\./g, "");

        unique_emails.add(local_name + "@" + domain_name);
    });

    return unique_emails.size;
}

-----
function numUniqueEmails(emails) 
    // Your code here
}

************************************
Question ID: 966
function numSubarraysWithSum(nums, goal) {
    const prefixSumCount = {0: 1};
    let sum = 0, result = 0;

    for (const num of nums) {
        sum += num;
        result += (prefixSumCount[sum - goal] || 0);
        prefixSumCount[sum] = (prefixSumCount[sum] || 0) + 1;
    }

    return result;
}

-----
function numSubarraysWithSum(nums, goal) 
    // Your code here
}

************************************
Question ID: 967
function minFallingPathSum(matrix) {
    let n = matrix.length;
    for (let i = 1; i < n; ++i) {
        for (let j = 0; j < n; ++j) {
            let min_val = matrix[i - 1][j];
            if (j > 0) min_val = Math.min(min_val, matrix[i - 1][j - 1]);
            if (j < n - 1) min_val = Math.min(min_val, matrix[i - 1][j + 1]);
            matrix[i][j] += min_val;
        }
    }
    return Math.min(...matrix[n - 1]);
}

-----
function minFallingPathSum(matrix) 
    // Your code here
}

************************************
Question ID: 968
function beautifulArray(n) {
    let result = [1];
    while (result.length < n) {
        let temp = [];
        for (let i of result) {
            if (i * 2 - 1 <= n)
                temp.push(i * 2 - 1);
        }
        for (let i of result) {
            if (i * 2 <= n)
                temp.push(i * 2);
        }
        result = temp;
    }
    return result;
}

-----
function beautifulArray(n) 
    // Your code here
}

************************************
Question ID: 969
class RecentCounter {
    constructor() {
        this.requests = [];
    }

    ping(t) {
        this.requests.push(t);
        while (this.requests[0] < t - 3000) {
            this.requests.shift();
        }
        return this.requests.length;
    }
}

-----
class RecentCounter 
    // Your code here
}

************************************
Question ID: 970
function powerfulIntegers(x, y, bound) {
    const max_i = x === 1 ? 0 : Math.floor(Math.log(bound) / Math.log(x));
    const max_j = y === 1 ? 0 : Math.floor(Math.log(bound) / Math.log(y));
    const resultSet = new Set();
    
    for (let i = 0; i <= max_i; i++) {
        for (let j = 0; j <= max_j; j++) {
            const powerfulNum = Math.pow(x, i) + Math.pow(y, j);
            if (powerfulNum <= bound) {
                resultSet.add(powerfulNum);
            }
        }
    }
    
    return Array.from(resultSet);
}

-----
function powerfulIntegers(x, y, bound) 
    // Your code here
}

************************************
Question ID: 971
function shortestBridge(grid) {
    const n = grid.length;
    const q = [];

    loop:
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            if (grid[i][j] === 1) {
                dfs(grid, q, i, j);
                break loop;
            }
        }
    }

    let steps = 0;
    const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];

    while (q.length) {
        const size = q.length;
        for (let i = 0; i < size; i++) {
            const [x, y] = q.shift();
            for (const [dx, dy] of directions) {
                const nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] !== 2) {
                    if (grid[nx][ny] === 1) return steps;
                    grid[nx][ny] = 2;
                    q.push([nx, ny]);
                }
            }
        }
        steps++;
    }

    return -1;
}

function dfs(grid, q, i, j) {
    const n = grid.length;
    if (i < 0 || i >= n || j < 0 || j >= n || grid[i][j] !== 1) return;
    grid[i][j] = 2;
    q.push([i, j]);

    dfs(grid, q, i - 1, j);
    dfs(grid, q, i + 1, j);
    dfs(grid, q, i, j - 1);
    dfs(grid, q, i, j + 1);
}


-----
function shortestBridge(grid) 
    // Your code here
}


************************************
Question ID: 972
function knightDialer(n) {
  if (n === 1) return 10;
  const MOD = 1e9 + 7;
  const moves = [
    [4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9],
    [], [1, 7, 0], [2, 6], [1, 3], [2, 4]
  ];
  const dp = new Array(10).fill(1);
  for (let i = 2; i <= n; ++i) {
    const new_dp = new Array(10).fill(0);
    for (let j = 0; j < 10; ++j)
      for (const move of moves[j])
        new_dp[j] = (new_dp[j] + dp[move]) % MOD;
    dp.splice(0, dp.length, ...new_dp);
  }
  return dp.reduce((a, b) => (a + b) % MOD);
}

-----
function knightDialer(n) 
    // Your code here
}

************************************
Question ID: 973
function movesToStamp(stamp, target) {
    const result = [];
    const isStamped = new Array(target.length).fill(false);
    let stampCount = 0;
    let targetStr = target.split('');

    while (stampCount < 10 * target.length) {
        let foundStamp = false;
        for (let i = 0; i <= target.length - stamp.length; ++i) {
            if (isStamped[i]) continue;
            let j = 0;
            let overlap = 0;
            while (j < stamp.length && (targetStr[i + j] === '?' || targetStr[i + j] === stamp.charAt(j))) {
                if (targetStr[i + j] === stamp.charAt(j)) overlap++;
                j++;
            }
            if (j === stamp.length && overlap > 0) {
                for (j = 0; j < stamp.length; ++j)
                    targetStr[i + j] = '?';
                result.push(i);
                isStamped[i] = true;
                foundStamp = true;
            }
        }
        if (!foundStamp)
            break;

        stampCount++;
    }
    for (const c of targetStr)
        if (c !== '?') return [];

    return result.reverse();
}


-----
function movesToStamp(stamp, target) 
    // Your code here
}


************************************
Question ID: 974
function subarraysDivByK(nums, k) {
    let prefixSumsModK = new Array(k).fill(0);
    prefixSumsModK[0] = 1;
    let runningSum = 0;
    let count = 0;
    
    for (let i = 0; i < nums.length; ++i) {
        runningSum += nums[i];
        let mod = (runningSum % k + k) % k;
        count += prefixSumsModK[mod]++;
    }
    
    return count;
}

-----
function subarraysDivByK(nums, k) 
    // Your code here
}

************************************
Question ID: 975
function rangeSumBST(root, low, high) {
    if (!root) return 0;
    if (root.val < low) return rangeSumBST(root.right, low, high);
    if (root.val > high) return rangeSumBST(root.left, low, high);
    return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);
}

-----
function rangeSumBST(root, low, high) 
    // Your code here
}

************************************
Question ID: 976
function minAreaRect(points) {
  const pointSet = new Set(points.map(point => point.join(',')));
  let minArea = Infinity;

  for (const p1 of points) {
    for (const p2 of points) {
      if (p1[0] !== p2[0] && p1[1] !== p2[1]) {
        if (pointSet.has([p1[0], p2[1]].join(',')) && pointSet.has([p2[0], p1[1]].join(','))) {
          minArea = Math.min(minArea, Math.abs((p1[0] - p2[0]) * (p1[1] - p2[1])));
        }
      }
    }
  }

  return minArea === Infinity ? 0 : minArea;
}


-----
function minAreaRect(points) 
    // Your code here
}


************************************
Question ID: 977
function distinctSubseqII(s) {
    const mod = 1e9 + 7;
    const n = s.length;
    const dp = new Array(n + 1).fill(0);
    dp[0] = 1;
    const last = new Array(26).fill(-1);

    for (let i = 1; i <= n; ++i) {
        dp[i] = (dp[i - 1] * 2) % mod;
        if (last[s.charCodeAt(i - 1) - 'a'.charCodeAt()] !== -1) {
            dp[i] = (dp[i] - dp[last[s.charCodeAt(i - 1) - 'a'.charCodeAt()]] + mod) % mod;
        }
        last[s.charCodeAt(i - 1) - 'a'.charCodeAt()] = i - 1;
    }

    dp[n] = (dp[n] - 1 + mod) % mod;
    return dp[n];
}


-----
function distinctSubseqII(s) 
    // Your code here
}


************************************
Question ID: 978
function validMountainArray(arr) {
    let n = arr.length, i = 0, j = n - 1;
    while (i + 1 < n && arr[i] < arr[i + 1]) i++;
    while (j > 0 && arr[j - 1] > arr[j]) j--;
    return i > 0 && i === j && j < n - 1;
}

-----
function validMountainArray(arr) 
    // Your code here
}

************************************
Question ID: 979
function decode_permutation(s) {
    const n = s.length;
    const perm = new Array(n + 1);
    let next_zero = 0, next_one = n;

    for (const c of s) {
        if (c === '0') {
            perm[next_zero++] = next_one--;
        } else {
            perm[next_one--] = next_zero++;
        }
    }
    perm[next_zero] = next_one;
    return perm;
}


-----
function decode_permutation(s) 
    // Your code here
}


************************************
Question ID: 980
function smallestSuperstring(words) {
    while (words.length > 1) {
        let maxLength = -1, p1 = 0, p2 = 0;
        let temp = "";
        for (let i = 0; i < words.length; ++i) {
            for (let j = i + 1; j < words.length; ++j) {
                let sharedLength = Math.min(words[i].length, words[j].length);
                for (; sharedLength > maxLength; --sharedLength) {
                    if (words[i].slice(-sharedLength) === words[j].slice(0, sharedLength)) {
                        maxLength = sharedLength;
                        p1 = i;
                        p2 = j;
                        temp = words[i] + words[j].slice(sharedLength);
                        break;
                    }
                }
            }
        }
        words[p1] = temp;
        words.splice(p2, 1);
    }
    return words[0];
}

-----
function smallestSuperstring(words) 
    // Your code here
}

************************************
Question ID: 981
function minDeletionSize(strs) {
    let numDeleted = 0;
    for (let col = 0; col < strs[0].length; col++) {
        for (let row = 1; row < strs.length; row++) {
            if (strs[row][col] < strs[row - 1][col]) {
                numDeleted++;
                break;
            }
        }
    }
    return numDeleted;
}


-----
function minDeletionSize(strs) 
    // Your code here
}


************************************
Question ID: 982
function minMovesUnique(nums) {
    nums.sort((a, b) => a - b);
    let moves = 0;
    for (let i = 1; i < nums.length; i++) {
        if (nums[i] <= nums[i - 1]) {
            const diff = nums[i - 1] - nums[i] + 1;
            moves += diff;
            nums[i] += diff;
        }
    }
    return moves;
}

-----
function minMovesUnique(nums) 
    // Your code here
}

************************************
Question ID: 983
function validateStackSequences(pushed, popped) {
    const stack = [];
    let popIndex = 0;
    
    for (const pushValue of pushed) {
        stack.push(pushValue);
        while (stack.length > 0 && stack[stack.length - 1] === popped[popIndex]) {
            stack.pop();
            popIndex++;
        }
    }
    
    return stack.length === 0;
}


-----
function validateStackSequences(pushed, popped) 
    // Your code here
}


************************************
Question ID: 984
function removeStones(stones) {
    let row_groups = new Map(),
        col_groups = new Map(),
        groups = new Map(),
        group_count = 0;

    for (const [x, y] of stones) {
        if (!row_groups.has(x)) {
            row_groups.set(x, group_count++);
        }
        if (!col_groups.has(y + 10001)) { // Offset by max row index
            col_groups.set(y + 10001, group_count++);
        }
        let group_x = row_groups.get(x),
            group_y = col_groups.get(y + 10001);

        if (!groups.has(group_x)) {
            groups.set(group_x, []);
        }
        if (!groups.has(group_y)) {
            groups.set(group_y, []);
        }
        groups.get(group_x).push(group_y);
        groups.get(group_y).push(group_x);
    }

    let visited = new Array(group_count).fill(false);

    function dfs(groupId) {
        if (visited[groupId]) {
            return 0;
        }
        visited[groupId] = true;
        let size = 1;

        for (const neighbor of groups.get(groupId)) {
            size += dfs(neighbor);
        }

        return size;
    }

    let max_stones = 0;
    for (let groupId = 0; groupId < group_count; groupId++) {
        max_stones += dfs(groupId) - 1;
    }

    return max_stones;
}

-----
function removeStones(stones) 
    // Your code here
}

************************************
Question ID: 985
function bagOfTokensScore(tokens, power) {
    tokens.sort((a, b) => a - b);
    let maxScore = 0, score = 0;
    let left = 0, right = tokens.length - 1;
    
    while (left <= right) {
        if (power >= tokens[left]) {
            power -= tokens[left++];
            score++;
            maxScore = Math.max(maxScore, score);
        } else if (score > 0) {
            power += tokens[right--];
            score--;
        } else {
            break;
        }
    }
    
    return maxScore;
}

-----
function bagOfTokensScore(tokens, power) 
    // Your code here
}

************************************
Question ID: 986
function largestTimeFromDigits(arr) {
    let maxTime = -1;
    for (let i = 0; i < 4; i++) {
        if (arr[i] > 2) continue;
        for (let j = 0; j < 4; j++) {
            if (j === i || (arr[i] === 2 && arr[j] > 3)) continue;
            for (let k = 0; k < 4; k++) {
                if (k === i || k === j || arr[k] > 5) continue;
                let l = 6 - i - j - k;
                let time = 60 * (10 * arr[i] + arr[j]) + 10 * arr[k] + arr[l];
                maxTime = Math.max(maxTime, time);
            }
        }
    }
    if (maxTime === -1) return "";
    else return `${String(Math.trunc(maxTime / 60)).padStart(2, '0')}:${String(maxTime % 60).padStart(2, '0')}`;
}

-----
function largestTimeFromDigits(arr) 
    // Your code here
}

************************************
Question ID: 987
function deckRevealedIncreasing(deck) {
    const n = deck.length;
    const index = [];
    for (let i = 0; i < n; i++) {
        index.push(i);
    }

    const ans = new Array(n);
    deck.sort((a, b) => a - b);

    for (const card of deck) {
        ans[index.shift()] = card;
        if (index.length) {
            index.push(index.shift());
        }
    }
    return ans;
}

-----
function deckRevealedIncreasing(deck) 
    // Your code here
}

************************************
Question ID: 989
function largestComponentSize(nums) {
    function primes(n) {
        for (let i = 2; i * i <= n; ++i) {
            if (n % i === 0) return i;
        }
        return n;
    }

    function dfs(node, visited, graph) {
        if (visited.has(node)) return 0;
        visited.add(node);
        let size = 1;
        for (let neighbor of graph[node]) {
            size += dfs(neighbor, visited, graph);
        }
        return size;
    }

    const graph = new Map();
    const visited = new Set();

    for (const num of nums) {
        const prime = primes(num);
        if (!graph.has(prime)) graph.set(prime, new Set());
        graph.get(prime).add(num);
        if (num !== prime) {
            if (!graph.has(num)) graph.set(num, new Set());
            graph.get(num).add(prime);
        }
    }

    let count = 0;
    for (const num of nums) {
        count = Math.max(count, dfs(num, visited, graph));
    }

    return count;
}

-----
function largestComponentSize(nums) 
    // Your code here
}

************************************
Question ID: 990
function isAlienSorted(words, order) {
    const alien_order = new Map();
    for (let i = 0; i < 26; i++) {
        alien_order.set(order[i], i);
    }

    for (let i = 1; i < words.length; i++) {
        for (let j = 0; j < words[i - 1].length; j++) {
            if (j === words[i].length) {
                return false;
            }

            if (words[i - 1][j] !== words[i][j]) {
                if (alien_order.get(words[i - 1][j]) > alien_order.get(words[i][j])) {
                    return false;
                }
                break;
            }
        }
    }

    return true;
}

-----
function isAlienSorted(words, order) 
    // Your code here
}

************************************
Question ID: 991
function canReorderArray(arr) {
    const count = {};
    for (const n of arr) {
        count[n] = (count[n] || 0) + 1;
    }
    arr.sort((a, b) => a - b);
    for (const x of arr) {
        if (count[x] === 0) {
            continue;
        }
        if (count[2 * x] > 0) {
            count[x]--;
            count[2 * x]--;
        } else {
            return false;
        }
    }
    return true;
}

-----
function canReorderArray(arr) 
    // Your code here
}

************************************
Question ID: 993
function tallestBillboard(rods) {
    const n = rods.length;
    const totalLength = rods.reduce((sum, rod) => sum + rod, 0);
    const dp = Array.from({length: n + 1}, () => Array(totalLength + 1).fill(-1));
    
    dp[0][0] = 0;
    
    for (let i = 1; i <= n; i++) {
        for (let j = 0; j <= totalLength; j++) {
            dp[i][j] = dp[i - 1][j];
            if (rods[i - 1] <= j) {
                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - rods[i - 1]] + rods[i - 1]);
            }
            if (rods[i - 1] <= totalLength - j) {
                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j + rods[i - 1]]);
            }
        }
    }
    
    return dp[n][0] / 2;
}


-----
function tallestBillboard(rods) 
    // Your code here
}


************************************
Question ID: 994
function prisonAfterNDays(cells, n) {
    let temp = new Array(8).fill(0);
    n = n % 14 === 0 ? 14 : n % 14; // Pattern repeats every 14 days

    for (let i = 1; i <= n; ++i) {
        for (let j = 1; j < 7; ++j) {
            temp[j] = cells[j - 1] === cells[j + 1] ? 1 : 0;
        }
        cells = [...temp];
    }

    return cells;
}

-----
function prisonAfterNDays(cells, n) 
    // Your code here
}

************************************
Question ID: 995
function minKBitFlips(nums, k) {
    const n = nums.length;
    const flipped = Array(n).fill(0);
    let flips = 0, ans = 0;
    for (let i = 0; i < n; ++i) {
        if (i >= k) flips -= flipped[i - k];
        if ((flips + nums[i]) % 2 === 0) {
            if (i + k > n) return -1;
            flipped[i] = 1;
            flips++;
            ans++;
        }
    }
    return ans;
}

-----
function minKBitFlips(nums, k) 
    // Your code here
}

************************************
Question ID: 996
function numSquarefulPerms(nums) {
    const counter = new Map();
    nums.forEach(num => counter.set(num, (counter.get(num) || 0) + 1));

    const isSquare = n => {
        const root = Math.sqrt(n);
        return Math.floor(root) * Math.floor(root) === n;
    };

    const dfs = (idx) => {
        if (idx === nums.length)
            return 1;

        let count = 0;
        for (let key of counter.keys()) {
            if (counter.get(key) !== 0 && (idx === 0 || isSquare(nums[idx - 1] + key))) {
                counter.set(key, counter.get(key) - 1);
                nums[idx] = key;
                count += dfs(idx + 1);
                counter.set(key, counter.get(key) + 1);
            }
        }

        return count;
    };

    return dfs(0);
}


-----
function numSquarefulPerms(nums) 
    // Your code here
}


************************************
Question ID: 997
function findJudge(n, trust) {
    let trustCounts = new Array(n + 1).fill(0);
    for (let [a, b] of trust) {
        trustCounts[a]--;
        trustCounts[b]++;
    }
    for (let i = 1; i <= n; i++) {
        if (trustCounts[i] === n - 1)
            return i;
    }
    return -1;
}

-----
function findJudge(n, trust) 
    // Your code here
}

************************************
Question ID: 999
function regionsBySlashes(grid) {
    const n = grid.length;
    const graph = Array.from({ length: n * 3 }, () => Array(n * 3).fill(0));

    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            if (grid[i][j] === '/') {
                graph[i * 3][j * 3 + 2] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3] = 1;
            }
            if (grid[i][j] === '\\') {
                graph[i * 3][j * 3] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3 + 2] = 1;
            }
        }
    }

    let regions = 0;
    for (let i = 0; i < n * 3; i++) {
        for (let j = 0; j < n * 3; j++) {
            if (graph[i][j] === 0) {
                regions++;
                dfs(graph, i, j);
            }
        }
    }

    return regions;
}

function dfs(graph, i, j) {
    const n = graph.length;
    if (i < 0 || j < 0 || i >= n || j >= n || graph[i][j] === 1) return;

    graph[i][j] = 1;
    dfs(graph, i - 1, j);
    dfs(graph, i + 1, j);
    dfs(graph, i, j - 1);
    dfs(graph, i, j + 1);
}

-----
function regionsBySlashes(grid) 
    // Your code here
}

************************************
Question ID: 1000
function minDeletionSize(strs) {
    const rows = strs.length;
    const cols = strs[0].length;
    let count = 0;
    for (let c = 0; c < cols; ++c) {
        for (let r = 1; r < rows; ++r) {
            if (strs[r - 1][c] > strs[r][c]) {
                ++count;
                break;
            }
        }
    }
    return count;
}


-----
function minDeletionSize(strs) 
    // Your code here
}


************************************
Question ID: 1001
function repeatedNTimes(nums) {
    const hashMap = {};
    for (const num of nums) {
        if (hashMap[num]) return num;
        hashMap[num] = 1;
    }
}


-----
function repeatedNTimes(nums) 
    // Your code here
}


************************************
Question ID: 1002

```python
def maxWidthRamp(nums):
    indices = sorted(range(len(nums)), key=lambda i: (nums[i], i))
    
    maxWidth = 0
    minIndex = float('inf')
    for index in indices:
        maxWidth = max(maxWidth, index - minIndex)
        minIndex = min(minIndex, index)
    
    return maxWidth
```


-----

```python
def maxWidthRamp(nums):
    indices = sorted(range(len(nums)), key=lambda i: (nums[i], i))
    
    maxWidth = 0
    minIndex = float('inf')
    for index in indices:
        maxWidth = max(maxWidth, index - minIndex)
        minIndex = min(minIndex, index)
    
    return maxWidth
```

    // Your code here


************************************
Question ID: 1003
function minAreaFreeRect(points) {
    let minArea = Infinity;
    const xGroups = new Map();

    for (const [x, y] of points) {
        if (!xGroups.has(x)) {
            xGroups.set(x, new Set());
        }
        xGroups.get(x).add(y);
    }

    for (const [x1, ys1] of xGroups.entries()) {
        for (const [x2, ys2] of xGroups.entries()) {
            if (x1 === x2) continue;

            for (const y1 of ys1) {
                for (const y2 of ys2) {
                    if (ys1.has(y2) && ys2.has(y1)) {
                        const area = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)) * Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y1, 2));
                        minArea = Math.min(minArea, area);
                    }
                }
            }
        }
    }

    return minArea === Infinity ? 0 : minArea;
}


-----
function minAreaFreeRect(points) 
    // Your code here
}


************************************
Question ID: 1004
function leastOpsExpressTarget(x, target) {
    if (x === target) return 0;
    if (target === 1) return 1;
    if (x > target) return Math.min(2 * target - 1, 2 * (x - target));
    
    let k = 0;
    let p = x;
    while (p < target) {
        k++;
        p *= x;
    }
    
    let ans = Infinity;
    let d = 1;

    for (let i = k - 1; i >= 0; i--) {
        while (p >= target + d * (1 - x)) {
            p -= d;
            ans = Math.min(ans, i + Math.floor(Math.log2(target / d) + 1) + (d === 1 ? -1 : 0));
        }
        d = d * x + 1;
    }

    return ans;
}


-----
function leastOpsExpressTarget(x, target) 
    // Your code here
}


************************************
Question ID: 1005
function isUnivalued(root, val = null) {
    if (!root) return true;
    if (val === null) val = root.val;
    return root.val === val && isUnivalued(root.left, val) && isUnivalued(root.right, val);
}

-----
function isUnivalued(root, val = null) 
    // Your code here
}

************************************
Question ID: 1006
function spellchecker(wordlist, queries) {
    const wordMap = {};
    const wordMapLowerCase = {};
    const wordMapVowelReplaced = {};

    for (const word of wordlist) {
        const lowerWord = word.toLowerCase();
        const vowelReplacedWord = lowerWord.replace(/[aeiou]/g, "#");

        if (!wordMap[word]) wordMap[word] = word;
        if (!wordMapLowerCase[lowerWord]) wordMapLowerCase[lowerWord] = word;
        if (!wordMapVowelReplaced[vowelReplacedWord]) wordMapVowelReplaced[vowelReplacedWord] = word;
    }

    const result = [];
    for (const query of queries) {
        const lowerQuery = query.toLowerCase();
        const vowelReplacedQuery = lowerQuery.replace(/[aeiou]/g, "#");

        if (wordMap[query]) {
            result.push(wordMap[query]);
        } else if (wordMapLowerCase[lowerQuery]) {
            result.push(wordMapLowerCase[lowerQuery]);
        } else if (wordMapVowelReplaced[vowelReplacedQuery]) {
            result.push(wordMapVowelReplaced[vowelReplacedQuery]);
        } else {
            result.push("");
        }
    }

    return result;
}


-----
function spellchecker(wordlist, queries) 
    // Your code here
}


************************************
Question ID: 1007
function numsSameConsecDiff(n, k) {
    let result = [];
    if (n === 1) result.push(0);

    function dfs(current) {
        if (current.length === n) {
            result.push(Number(current));
            return;
        }

        let last_digit = current[current.length - 1];
        if (last_digit - k >= 0) dfs(current + (last_digit - k));
        if (k !== 0 && last_digit + k <= 9) dfs(current + (last_digit + k));
    }

    for (let i = 1; i <= 9; ++i) {
        dfs(String(i));
    }

    return result;
}

-----
function numsSameConsecDiff(n, k) 
    // Your code here
}

************************************
Question ID: 1008
function minCameraCover(root) {
    let ans = { count: 0 };
    return (dfs(root, ans) < 1 ? 1 : 0) + ans.count;
}

function dfs(node, ans) {
    if (!node) return 2;
    let left = dfs(node.left, ans);
    let right = dfs(node.right, ans);
    if (left === 0 || right === 0) {
        ans.count++;
        return 1;
    }
    return left === 1 || right === 1 ? 2 : 0;
}


-----
function minCameraCover(root) 
    // Your code here
}


************************************
Question ID: 1009
function pancakeSort(arr) {
    const flips = [];
    for (let size = arr.length; size > 1; --size) {
        const maxIdx = getMaxIdx(arr, size);
        flips.push(maxIdx + 1);
        flips.push(size);
        reverse(arr, 0, maxIdx);
        reverse(arr, 0, size - 1);
    }
    return flips;
}

function getMaxIdx(arr, size) {
    let maxIdx = 0;
    for (let i = 1; i < size; ++i) {
        if (arr[i] > arr[maxIdx]) {
            maxIdx = i;
        }
    }
    return maxIdx;
}

function reverse(arr, start, end) {
    while (start < end) {
        const temp = arr[start];
        arr[start++] = arr[end];
        arr[end--] = temp;
    }
}

-----
function pancakeSort(arr) 
    // Your code here
}

************************************
Question ID: 1010
function powerfulIntegers(x, y, bound) {
    const result = new Set();
    for (let i = 0; Math.pow(x, i) <= bound; ++i) {
        for (let j = 0; Math.pow(x, i) + Math.pow(y, j) <= bound; ++j) {
            result.add(Math.pow(x, i) + Math.pow(y, j));
        }
    }
    return Array.from(result);
}


-----
function powerfulIntegers(x, y, bound) 
    // Your code here
}


************************************
Question ID: 1011
function flipRecur(node, voyage, flipped, idx) {
    if (!node) return idx;
    if (node.val !== voyage[idx]) {
        flipped[0] = -1;
        return idx;
    }
    idx++;
    if (idx < voyage.length && node.left !== null && node.left.val !== voyage[idx]) {
        flipped.push(node.val);
        idx = flipRecur(node.right, voyage, flipped, idx);
        idx = flipRecur(node.left, voyage, flipped, idx);
    } else {
        idx = flipRecur(node.left, voyage, flipped, idx);
        idx = flipRecur(node.right, voyage, flipped, idx);
    }
    return idx;
}

function flipMatchVoyage(root, voyage) {
    let flipped = [];
    flipRecur(root, voyage, flipped, 0);
    if (flipped.length > 0 && flipped[0] === -1) return [-1];
    return flipped;
}


-----
function flipRecur(node, voyage, flipped, idx) 
    // Your code here
}


************************************
Question ID: 1012
function isRationalEqual(s, t) {
    const evaluate = (s) => {
        let i = s.indexOf('(');
        if (i !== -1) {
            let base = s.substring(0, i);
            let rep = s.substring(i + 1, s.length - 1);
            for (let k = 0; k < 20; ++k) {
                base += rep;
            }
            return parseFloat(base);
        }
        return parseFloat(s);
    };
    return Math.abs(evaluate(s) - evaluate(t)) < 1e-12;
}

-----
function isRationalEqual(s, t) 
    // Your code here
}

************************************
Question ID: 1013
function fib(n) {
    if (n <= 1)
        return n;
    let a = 0, b = 1, c;
    for (let i = 2; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    return b;
}

-----
function fib(n) 
    // Your code here
}

************************************
Question ID: 1014
function kClosest(points, k) {
    return points.sort((a, b) => (a[0] * a[0] + a[1] * a[1]) - (b[0] * b[0] + b[1] * b[1])).slice(0, k);
}

-----
function kClosest(points, k) 
    // Your code here
}

************************************
Question ID: 1015
function smallestRepunitDivByK(k) {
    if (k % 2 === 0 || k % 5 === 0) return -1;
    let n = 0;
    for (let i = 1; i <= k; i++) {
        n = (n * 10 + 1) % k;
        if (n === 0) return i;
    }
    return -1;
}

-----
function smallestRepunitDivByK(k) 
    // Your code here
}

************************************
Question ID: 1016
function subarraysDivByK(nums, k) {
    let counts = new Map();
    counts.set(0, 1);
    let sum = 0, result = 0;

    for (let num of nums) {
        sum += num;
        let mod = ((sum % k) + k) % k;
        result += counts.get(mod) || 0;
        counts.set(mod, (counts.get(mod) || 0) + 1);
    }

    return result;
}

-----
function subarraysDivByK(nums, k) 
    // Your code here
}

************************************
Question ID: 1017
function oddEvenJumps(arr) {
    const n = arr.length;
    const canReachOdd = new Array(n).fill(false);
    const canReachEven = new Array(n).fill(false);
    canReachOdd[n - 1] = canReachEven[n - 1] = true;

    const indexMap = new Map();
    indexMap.set(arr[n - 1], n - 1);

    let goodIndices = 1;
    for (let i = n - 2; i >= 0; --i) {
        const oddJump = [...indexMap.keys()].find((value) => value >= arr[i]);
        const evenJump = [...indexMap.keys()].find((value) => value <= arr[i]);

        if (oddJump !== undefined)
            canReachOdd[i] = canReachEven[indexMap.get(oddJump)];
        if (evenJump !== undefined)
            canReachEven[i] = canReachOdd[indexMap.get(evenJump)];

        if (canReachOdd[i]) ++goodIndices;

        indexMap.set(arr[i], i);
    }

    return goodIndices;
}

-----
function oddEvenJumps(arr) 
    // Your code here
}

************************************
Question ID: 1018
function largestPerimeter(nums) {
    nums.sort((a, b) => b - a);

    for (let i = 0; i < nums.length - 2; ++i) {
        if (nums[i] < nums[i + 1] + nums[i + 2]) {
            return nums[i] + nums[i + 1] + nums[i + 2];
        }
    }

    return 0;
}

-----
function largestPerimeter(nums) 
    // Your code here
}

************************************
Question ID: 1019
function sortedSquares(nums) {
    return nums.map(x => x * x).sort((a, b) => a - b);
}

-----
function sortedSquares(nums) 
    // Your code here
}

************************************
Question ID: 1020
function maxTurbulenceSize(arr) {
    const n = arr.length;
    let result = 1;
    let i = 0;

    while (i < n - 1) {
        if (arr[i] === arr[i + 1]) {
            i++;
            continue;
        }

        let j = i + 1;
        while (j < n - 1 && ((arr[j] > arr[j + 1]) !== (arr[j - 1] > arr[j])))
            j++;
        
        result = Math.max(result, j - i + 1);
        i = j;
    }

    return result;
}


-----
function maxTurbulenceSize(arr) 
    // Your code here
}


************************************
Question ID: 1021
function distributeCoins(root) {
    function dfs(node) {
        if (!node) return 0;
        let left = dfs(node.left);
        let right = dfs(node.right);
        moves[0] += Math.abs(left) + Math.abs(right);
        return node.val + left + right - 1;
    }

    let moves = [0];
    dfs(root);
    return moves[0];
}


-----
function distributeCoins(root) 
    // Your code here
}


************************************
Question ID: 1022
function uniquePathsIII(grid) {
    let x = 0, y = 0, empty = 1;
    for (let i = 0; i < grid.length; ++i) {
        for (let j = 0; j < grid[0].length; ++j) {
            if (grid[i][j] === 1) {
                x = i;
                y = j;
            } else if (grid[i][j] === 0) {
                empty++;
            }
        }
    }
    return dfs(grid, x, y, empty);
}

function dfs(grid, x, y, empty) {
    if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] === -1) {
        return 0;
    }
    if (grid[x][y] === 2) {
        return empty === -1 ? 1 : 0;
    }
    grid[x][y] = -1;
    let paths = dfs(grid, x + 1, y, empty - 1) + dfs(grid, x - 1, y, empty - 1) + dfs(grid, x, y + 1, empty - 1) + dfs(grid, x, y - 1, empty - 1);
    grid[x][y] = 0;
    return paths;
}

-----
function uniquePathsIII(grid) 
    // Your code here
}

************************************
Question ID: 1023
class TimeMap {
    constructor() {
        this.data = new Map();
    }

    set(key, value, timestamp) {
        if (!this.data.has(key)) {
            this.data.set(key, []);
        }
        this.data.get(key).push({ timestamp, value });
    }

    get(key, timestamp) {
        if (!this.data.has(key)) return "";
        const values = this.data.get(key);
        let left = 0, right = values.length - 1;
        while (left < right) {
            let mid = Math.floor((left + right + 1) / 2);
            if (values[mid].timestamp > timestamp) {
                right = mid - 1;
            } else {
                left = mid;
            }
        }
        return values[left].timestamp <= timestamp ? values[left].value : "";
    }
}

-----
class TimeMap 
    // Your code here
}

************************************
Question ID: 1024
function countAndTriples(nums) {
    let count = 0;
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            for (let k = j + 1; k < nums.length; k++) {
                if (nums[i] & nums[j] & nums[k] !== 0)
                    count++;
            }
        }
    }
    return count;
}

-----
function countAndTriples(nums) 
    // Your code here
}

************************************
Question ID: 1025
function mincostTickets(days, costs) {
  const travelDays = new Set(days);
  const dp = new Array(366).fill(0);

  for (let i = 1; i <= 365; ++i) {
    if (!travelDays.has(i)) {
      dp[i] = dp[i - 1];
    } else {
      dp[i] = Math.min(dp[i - 1] + costs[0],
                   Math.min(dp[Math.max(0, i - 7)] + costs[1],
                            dp[Math.max(0, i - 30)] + costs[2]));
    }
  }

  return dp[365];
}

-----
function mincostTickets(days, costs) 
    // Your code here
}

************************************
Question ID: 1027
function sumEvenAfterQueries(nums, queries) {
    const answer = [];
    let even_sum = nums.reduce((sum, num) => num % 2 === 0 ? sum + num : sum, 0);

    for (const [value, index] of queries) {
        if (nums[index] % 2 === 0) {
            even_sum -= nums[index];
        }
        nums[index] += value;
        if (nums[index] % 2 === 0) {
            even_sum += nums[index];
        }
        answer.push(even_sum);
    }

    return answer;
}


-----
function sumEvenAfterQueries(nums, queries) 
    // Your code here
}


************************************
Question ID: 1028
function intervalIntersection(firstList, secondList) {
    const result = [];
    let i = 0, j = 0;

    while (i < firstList.length && j < secondList.length) {
        const start = Math.max(firstList[i][0], secondList[j][0]);
        const end = Math.min(firstList[i][1], secondList[j][1]);

        if (start <= end) {
            result.push([start, end]);
        }

        if (firstList[i][1] < secondList[j][1]) {
            i++;
        } else {
            j++;
        }
    }

    return result;
}

-----
function intervalIntersection(firstList, secondList) 
    // Your code here
}

************************************
Question ID: 1029
class TreeNode {
    constructor(val, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

function verticalTraversal(root) {
    if (!root) return [];
    
    const columns = new Map();
    
    const q = [[root, 0, 0]];
    
    while (q.length) {
        const [node, row, col] = q.shift();
        
        if (!columns.has(col)) columns.set(col, new Map());
        if (!columns.get(col).has(row)) columns.get(col).set(row, []);
        columns.get(col).get(row).push(node.val);
        columns.get(col).get(row).sort((a, b) => a - b);

        if (node.left) q.push([node.left, row + 1, col - 1]);
        if (node.right) q.push([node.right, row + 1, col + 1]);
    }
    
    const result = [];

    for (const columnData of [...columns.entries()].sort((a, b) => a[0] - b[0])) {
        const column = [];
        for (const nodes of columnData[1].values()) {
            column.push(...nodes);
        }
        result.push(column);
    }

    return result;
}

-----
class TreeNode 
    // Your code here
}

************************************
Question ID: 1031
function addToArrayForm(num, k) {
    for (let i = num.length - 1; i >= 0; --i) {
        let sum = num[i] + k % 10;
        k = Math.floor(k / 10);
        if (sum >= 10) {
            sum -= 10;
            k++;
        }
        num[i] = sum;
        if (k === 0)
            break;
    }
    while (k !== 0) {
        num.unshift(k % 10);
        k = Math.floor(k / 10);
    }
    return num;
}


-----
function addToArrayForm(num, k) 
    // Your code here
}


************************************
Question ID: 1032
function equationsPossible(equations) {
    const parent = [...Array(26).keys()];

    const find = (x) => {
        if (parent[x] !== x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    };

    for (let e of equations) {
        if (e[1] === '=') {
            const x = e.charCodeAt(0) - 'a'.charCodeAt(0);
            const y = e.charCodeAt(3) - 'a'.charCodeAt(0);
            parent[find(x)] = find(y);
        }
    }

    for (let e of equations) {
        if (e[1] === '!' && find(e.charCodeAt(0) - 'a'.charCodeAt(0)) === find(e.charCodeAt(3) - 'a'.charCodeAt(0))) {
            return false;
        }
    }

    return true;
}


-----
function equationsPossible(equations) 
    // Your code here
}


************************************
Question ID: 1033
function brokenCalc(startValue, target) {
    let operations = 0;
    while (target > startValue) {
        target = (target % 2 === 0) ? target / 2 : target + 1;
        operations++;
    }
    return operations + startValue - target;
}

-----
function brokenCalc(startValue, target) 
    // Your code here
}

************************************
Question ID: 1034
function good_subarrays(nums, k) {
    let count = 0;
    for (let i = 0; i < nums.length; i++) {
        let frequency = {};
        for (let j = i; j < nums.length; j++) {
            frequency[nums[j]] = (frequency[nums[j]] || 0) + 1;
            if (Object.keys(frequency).length > k) break;
            if (Object.keys(frequency).length === k) count++;
        }
    }
    return count;
}

-----
function good_subarrays(nums, k) 
    // Your code here
}

************************************
Question ID: 1036
function orangesRotting(grid) {
    const m = grid.length;
    const n = grid[0].length;
    let freshOranges = 0;
    const rotten = [];

    for (let i = 0; i < m; ++i) {
        for (let j = 0; j < n; ++j) {
            if (grid[i][j] === 1)
                freshOranges++;
            else if (grid[i][j] === 2)
                rotten.push([i, j]);
        }
    }
    
    let minutes = 0;
    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
    
    while (rotten.length && freshOranges !== 0) {
        const size = rotten.length;
        for (let i = 0; i < size; ++i) {
            const [x, y] = rotten.shift();

            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;

                if (nx < 0 || ny < 0 || nx >= m || ny >= n || grid[nx][ny] !== 1)
                    continue;

                grid[nx][ny] = 2;
                freshOranges--;
                rotten.push([nx, ny]);
            }
        }
        minutes++;
    }
    
    return freshOranges === 0 ? minutes : -1;
}


-----
function orangesRotting(grid) 
    // Your code here
}


************************************
Question ID: 1037
function minKBitFlips(nums, k) {
    const n = nums.length;
    let res = 0, flipped = 0;
    const change = new Array(n).fill(0);
    for (let i = 0; i <= n - k; ++i) {
        flipped ^= change[i];
        if (nums[i] == flipped) {
            res++;
            flipped ^= 1;
            if (i + k < n) change[i + k] ^= 1;
        }
    }
    for (let i = n - k + 1; i < n; ++i) {
        flipped ^= change[i];
        if (nums[i] == flipped) return -1;
    }
    return res;
}


-----
function minKBitFlips(nums, k) 
    // Your code here
}


************************************
Question ID: 1038
function is_squareful(x, y) {
    const s = Math.floor(Math.sqrt(x + y));
    return s * s === x + y;
}

function count_permutations(nums, start) {
    if (start === nums.length) {
        return 1;
    }

    let count = 0;

    for (let i = start; i < nums.length; i++) {
        if (i === start || nums[i] !== nums[start]) {
            if (start === 0 || is_squareful(nums[start - 1], nums[i])) {
                [nums[i], nums[start]] = [nums[start], nums[i]];
                count += count_permutations(nums, start + 1);
                [nums[i], nums[start]] = [nums[start], nums[i]];
            }
        }
    }

    return count;
}

function squareful_perms(nums) {
    nums.sort((a, b) => a - b);
    return count_permutations(nums, 0);
}


-----
function is_squareful(x, y) 
    // Your code here
}


************************************
Question ID: 1039
function findJudge(n, trust) {
    const trustCounts = new Array(n + 1).fill(0);
    for (const relation of trust) {
        trustCounts[relation[0]]--;
        trustCounts[relation[1]]++;
    }

    for (let i = 1; i <= n; i++) {
        if (trustCounts[i] === n - 1) {
            return i;
        }
    }
    return -1;
}


-----
function findJudge(n, trust) 
    // Your code here
}


************************************
Question ID: 1040
function insertIntoMaxTree(root, val) {
    if (!root || val > root.val) {
        const newNode = new TreeNode(val);
        newNode.left = root;
        return newNode;
    }
    root.right = insertIntoMaxTree(root.right, val);
    return root;
}


-----
function insertIntoMaxTree(root, val) 
    // Your code here
}


************************************
Question ID: 1041
function numRookCaptures(board) {
    let x = 0, y = 0, captures = 0;

    outer: for (x = 0; x < 8; x++) {
        for (y = 0; y < 8; y++) {
            if (board[x][y] === 'R') {
                break outer;
            }
        }
    }

    let dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];
    for (let dir of dirs) {
        let nx = x + dir[0];
        let ny = y + dir[1];
        while (nx >= 0 && nx < 8 && ny >= 0 && ny < 8) {
            if (board[nx][ny] === 'p') {
                captures++;
                break;
            } else if (board[nx][ny] === 'B') {
                break;
            }
            nx += dir[0];
            ny += dir[1];
        }
    }
    
    return captures;
}


-----
function numRookCaptures(board) 
    // Your code here
}


************************************
Question ID: 1042
function mergeStones(stones, k) {
    let n = stones.length;
    if ((n - 1) % (k - 1) !== 0) return -1;
    let prefixSum = new Array(n + 1).fill(0);
    let dp = [...Array(n)].map(() => [...Array(n)].map(() => Array(k + 1).fill(0)));

    for (let i = 0; i < n; ++i) {
        prefixSum[i + 1] = prefixSum[i] + stones[i];
    }

    for (let l = 2; l <= n; ++l) {
        for (let i = 0; i <= n - l; ++i) {
            let j = i + l - 1;
            for (let m = 2; m <= k; ++m) {
                for (let p = i; p + m <= j + 1; p += k - 1) {
                    dp[i][j][m] = (dp[i][p][1] + dp[p + 1][j][m - 1]) % (1e9 + 7);
                }
            }
            if ((j - i) % (k - 1) === 0) {
                dp[i][j][1] = (dp[i][j][k] + prefixSum[j + 1] - prefixSum[i]) % (1e9 + 7);
            }
        }
    }
    return dp[0][n - 1][1];
}

-----
function mergeStones(stones, k) 
    // Your code here
}

************************************
Question ID: 1043
function gridIllumination(n, lamps, queries) {
    const lampRows = new Set();
    const lampCols = new Set();
    const lampLeftDiag = new Set();
    const lampRightDiag = new Set();

    for (const lamp of lamps) {
        const [row, col] = lamp;
        lampRows.add(row);
        lampCols.add(col);
        lampLeftDiag.add(row - col);
        lampRightDiag.add(row + col);
    }

    const ans = [];

    for (const query of queries) {
        const [row, col] = query;
        if (lampRows.has(row) || lampCols.has(col) || lampLeftDiag.has(row - col) || lampRightDiag.has(row + col)) {
            ans.push(1);
        } else {
            ans.push(0);
        }
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                const newRow = row + i;
                const newCol = col + j;
                lampRows.delete(newRow);
                lampCols.delete(newCol);
                lampLeftDiag.delete(newRow - newCol);
                lampRightDiag.delete(newRow + newCol);
            }
        }
    }

    return ans;
}


-----
function gridIllumination(n, lamps, queries) 
    // Your code here
}


************************************
Question ID: 1044
function commonChars(words) {
    let merged = {};

    for (const word of words) {
        let wordMap = {};
        for (const char of word) {
            wordMap[char] = (wordMap[char] || 0) + 1;
        }
        if (Object.keys(merged).length === 0) {
            merged = wordMap;
        } else {
            for (const char in merged) {
                merged[char] = Math.min(merged[char], wordMap[char] || 0);
            }
        }
    }

    let result = [];
    for (const char in merged) {
        for (let i = 0; i < merged[char]; i++) {
            result.push(char);
        }
    }
    return result;
}

-----
function commonChars(words) 
    // Your code here
}

************************************
Question ID: 1046
function longestOnes(nums, k) {
    let left = 0, right = 0, maxOnes = 0, zeroCount = 0;
    while (right < nums.length) {
        if (nums[right] === 0) zeroCount++;
        while (zeroCount > k) {
            if (nums[left] === 0) zeroCount--;
            left++;
        }
        maxOnes = Math.max(maxOnes, right - left + 1);
        right++;
    }
    return maxOnes;
}


-----
function longestOnes(nums, k) 
    // Your code here
}


************************************
Question ID: 1047
function maxSumAfterKOperations(nums, k) {
    const pq = new PriorityQueue(nums, (a, b) => a - b);
    while(k--){
        const current = pq.poll();
        pq.offer(-current);
    }
    let sum = 0;
    while(!pq.isEmpty()){
        sum += pq.poll();
    }
    return sum;
}

class PriorityQueue {
    constructor(data=[], compareFunction=(a, b) => a > b){
        this.data = data;
        this.compareFunction = compareFunction;
        this.heapify();
    }
    heapify(){
        if(this.data.length > 0){
            for(let i=Math.floor(this.size()/2); i>=0; i--){
                this.siftDown(i);
            }
        }
    }
    parent(i){ return Math.floor((i-1)/2);}
    left(i){ return 2*i + 1;}
    right(i){ return 2*i + 2;}
    size(){ return this.data.length;}
    isEmpty(){ return this.size()==0;}
    peek(){ return this.data[0];}
    poll(){
        const extracted = this.data.shift();
        if(!this.isEmpty()){
            this.data.unshift(this.data.pop());
            this.siftDown(0);
        }
        return extracted;
    }
    siftDown(i){
        let minIndex = i;
        const l = this.left(i);
        if(l<this.size() && this.compareFunction(this.data[l], this.data[minIndex])) minIndex = l;
        const r = this.right(i);
        if(r<this.size() && this.compareFunction(this.data[r], this.data[minIndex])) minIndex = r;
        if(i!=minIndex){
            [this.data[i], this.data[minIndex]] = [this.data[minIndex], this.data[i]];
            this.siftDown(minIndex);
        }
    }
    offer(value){
        this.data.push(value);
        this.siftUp(this.size()-1);
    }
    siftUp(i){
        while(i>0 && this.compareFunction(this.data[i], this.data[this.parent(i)])){
            [this.data[i], this.data[this.parent(i)]] = [this.data[this.parent(i)], this.data[i]];
            i = this.parent(i);
        }
    }
}

-----
function maxSumAfterKOperations(nums, k) 
    // Your code here
}

************************************
Question ID: 1048
function clumsy(n) {
    if (n <= 2) {
        return n;
    }
    if (n === 3) {
        return 6;
    }
    let result = Math.floor(n * (n - 1) / (n - 2)) + (n - 3);
    n -= 4;
    while (n >= 4) {
        result = result - Math.floor(n * (n - 1) / (n - 2)) + (n - 3);
        n -= 4;
    }
    return result - clumsy(n);
}


-----
function clumsy(n) 
    // Your code here
}


************************************
Question ID: 1049
function min_rotations(tops, bottoms) {
    let res = Infinity;

    let targets = [tops[0], bottoms[0]];

    for (let target of targets) {
        let top_rot = 0;
        let bot_rot = 0;

        for (let i = 0; i < tops.length; ++i) {
            if (tops[i] !== target && bottoms[i] !== target) {
                top_rot = bot_rot = Infinity;
                break;
            }

            if (tops[i] !== target) {
                top_rot++;
            }

            if (bottoms[i] !== target) {
                bot_rot++;
            }
        }
        res = Math.min(res, top_rot, bot_rot);
    }

    return res === Infinity ? -1 : res;
}

-----
function min_rotations(tops, bottoms) 
    // Your code here
}

************************************
Question ID: 1051
function heightChecker(heights) {
    const expected = [...heights].sort((a, b) => a - b);

    let count = 0;
    for (let i = 0; i < heights.length; ++i) {
        if (heights[i] !== expected[i]) {
            ++count;
        }
    }

    return count;
}

-----
function heightChecker(heights) 
    // Your code here
}

************************************
Question ID: 1052
function maxSatisfied(customers, grumpy, minutes) {
    let total_customers = 0, max_extra_customers = 0, extra_customers = 0;
    for (let i = 0; i < customers.length; ++i) {
        if (grumpy[i] === 0) {
            total_customers += customers[i];
        }
        if (i < minutes) {
            extra_customers += customers[i] * grumpy[i];
        } else {
            extra_customers += (customers[i] * grumpy[i]) - (customers[i - minutes] * grumpy[i - minutes]);
        }
        max_extra_customers = Math.max(max_extra_customers, extra_customers);
    }
    return total_customers + max_extra_customers;
}


-----
function maxSatisfied(customers, grumpy, minutes) 
    // Your code here
}


************************************
Question ID: 1053
function prevPermOpt1(arr) {
    const n = arr.length;
    for (let i = n - 2; i >= 0; i--) {
        if (arr[i] > arr[i + 1]) {
            let j = i + 1;
            while (j < n && arr[j] < arr[i]) j++;
            [arr[i], arr[j - 1]] = [arr[j - 1], arr[i]];
            break;
        }
    }
    return arr;
}


-----
function prevPermOpt1(arr) 
    // Your code here
}


************************************
Question ID: 1054
function bitwiseComplement(n) {
    let x = 1;
    while (n > x) {
        x = x * 2 + 1;
    }
    return x - n;
}

-----
function bitwiseComplement(n) 
    // Your code here
}

************************************
Question ID: 1055
function numPairsDivisibleBy60(time) {
    let count = new Array(60).fill(0);
    let pairs = 0;

    for (let t of time) {
        let mod = t % 60;
        pairs += count[(60 - mod) % 60];
        count[mod]++;
    }

    return pairs;
}

-----
function numPairsDivisibleBy60(time) 
    // Your code here
}

************************************
Question ID: 1056

```python
def ship_within_days(weights, days):
    left, right = max(weights), sum(weights)
    while left < right:
        mid = left + (right - left) // 2
        day_count, curr_capacity = 1, 0
        for w in weights:
            curr_capacity += w
            if curr_capacity > mid:
                day_count += 1
                curr_capacity = w
        if day_count > days:
            left = mid + 1
        else:
            right = mid
    return left
```

-----

```python
def ship_within_days(weights, days):
    left, right = max(weights), sum(weights)
    while left < right:
        mid = left + (right - left) // 2
        day_count, curr_capacity = 1, 0
        for w in weights:
            curr_capacity += w
            if curr_capacity > mid:
                day_count += 1
                curr_capacity = w
        if day_count > days:
            left = mid + 1
        else:
            right = mid
    return left
```
    // Your code here


************************************
Question ID: 1057
function numDupDigitsAtMostN(n) {
    let count = 0;
    for (let i = 1; i <= n; i++) {
        let digits = new Set();
        let num = i;
        while (num !== 0) {
            let digit = num % 10;
            if (digits.has(digit)) {
                count++;
                break;
            } else {
                digits.add(digit);
            }
            num = Math.floor(num / 10);
        }
    }
    return count;
}

-----
function numDupDigitsAtMostN(n) 
    // Your code here
}

************************************
Question ID: 1058
function findRoundingError(prices, target) {
    const n = prices.length;
    const decimals = prices.map(price => {
        let num = parseFloat(price);
        return num - Math.floor(num);
    });

    const roundedSum = prices.reduce((sum, price) => {
        return sum + Math.floor(parseFloat(price));
    }, 0);

    if (target < roundedSum || target > roundedSum + n) {
        return '-1 ';
    }

    let ceilCount = target - roundedSum;
    let roundingError = 0;

    for (let d of decimals) {
        if (ceilCount > 0) {
            roundingError += 1 - d;
            ceilCount--;
        } else {
            roundingError += d;
        }
    }
    roundingError = roundingError.toFixed(3);
    return roundingError.toString() + " ";
}


-----
function findRoundingError(prices, target) 
    // Your code here
}


************************************
Question ID: 1059
function leadsToDestination(n, edges, source, destination) {
    const graph = new Map();
    for (const [u, v] of edges) {
        if (!graph.has(u)) graph.set(u, []);
        graph.get(u).push(v);
    }

    const visited = new Array(n).fill(0);
    return dfs(source, graph, visited, destination);
}

function dfs(node, graph, visited, destination) {
    if (!graph.has(node)) return node === destination;
    if (visited[node] !== 0) return visited[node] === 2;

    visited[node] = 1;
    for (const neighbor of graph.get(node)) {
        if (!dfs(neighbor, graph, visited, destination)) return false;
    }

    visited[node] = 2;
    return true;
}

-----
function leadsToDestination(n, edges, source, destination) 
    // Your code here
}

************************************
Question ID: 1060
function findKthPositive(nums, k) {
    let left = 0, right = nums.length;
    while (left < right) {
        let mid = Math.floor(left + (right - left) / 2);
        if (nums[mid] - mid - 1 < k) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left + k;
}


-----
function findKthPositive(nums, k) 
    // Your code here
}


************************************
Question ID: 1061
function lexSmallestEquivalent(s1, s2, baseStr) {
    const parent = {};
    for (let ch = 'a'.charCodeAt(); ch <= 'z'.charCodeAt(); ch++) {
        parent[String.fromCharCode(ch)] = String.fromCharCode(ch);
    }

    for (let i = 0; i < s1.length; i++) {
        let root1 = s1[i], root2 = s2[i];
        while (parent[root1] !== root1) root1 = parent[root1];
        while (parent[root2] !== root2) root2 = parent[root2];
        if (root1 !== root2) {
            const minValue = Math.min(root1.charCodeAt(), root2.charCodeAt());
            parent[root1] = String.fromCharCode(minValue);
            parent[root2] = String.fromCharCode(minValue);
        }
    }

    return baseStr.split('').map(ch => {
        while (parent[ch] !== ch) ch = parent[ch];
        return ch;
    }).join('');
}

-----
function lexSmallestEquivalent(s1, s2, baseStr) 
    // Your code here
}

************************************
Question ID: 1062
function findLongestRepeatingSubstring(s) {
    let n = s.length;
    let maxSubstrLength = 0;
    for (let len = 1; len <= n / 2; ++len) {
        let maxRepeatCount = 0, repeatCount = 0;
        for (let i = 0; i < n - len; ++i) {
            if (s.substring(i, i + len) === s.substring(i + len, i + 2 * len)) {
                repeatCount++;
            } else {
                maxRepeatCount = Math.max(maxRepeatCount, repeatCount);
                repeatCount = 0;
            }
        }
        maxSubstrLength = Math.max(maxSubstrLength, maxRepeatCount * len);
    }
    return maxSubstrLength;
}

-----
function findLongestRepeatingSubstring(s) 
    // Your code here
}

************************************
Question ID: 1063
function maxScoreSightseeingPair(values) {
    let max_score = 0, max_score_left = values[0] + 0;
    for (let j = 1; j < values.length; ++j) {
        max_score = Math.max(max_score, max_score_left + values[j] - j);
        max_score_left = Math.max(max_score_left, values[j] + j);
    }
    return max_score;
}

-----
function maxScoreSightseeingPair(values) 
    // Your code here
}

************************************
Question ID: 1064
function fixedPoint(arr) {
    let left = 0, right = arr.length - 1;
    while (left < right) {
        let middle = left + Math.floor((right - left) / 2);
        if (arr[middle] < middle) {
            left = middle + 1;
        } else {
            right = middle;
        }
    }
    return arr[left] === left ? left : -1;
}

-----
function fixedPoint(arr) 
    // Your code here
}

************************************
Question ID: 1065
function hasAllCodesInRange(s, n) {
    let substrings = new Set();
    let length = n.toString(2).length;
    for (let i = 0; i < s.length - length + 1; ++i) {
        substrings.add(s.substr(i, length));
    }
    return substrings.size == n;
}


-----
function hasAllCodesInRange(s, n) 
    // Your code here
}


************************************
Question ID: 1066
function manhattanDistance(worker, bike) {
    return Math.abs(worker[0] - bike[0]) + Math.abs(worker[1] - bike[1]);
}

function dfs(workers, bikes, used, index, dist, minDist) {
    if (index === workers.length) {
        minDist[0] = Math.min(minDist[0], dist);
        return;
    }

    if (dist >= minDist[0]) {
        return;
    }

    for (let i = 0; i < bikes.length; i++) {
        if (used[i]) {
            continue;
        }
        used[i] = true;
        let curDist = manhattanDistance(workers[index], bikes[i]);
        dfs(workers, bikes, used, index + 1, dist + curDist, minDist);
        used[i] = false;
    }
}

function assignBikes(workers, bikes) {
    let minDist = [Infinity];
    let used = new Array(bikes.length).fill(false);
    dfs(workers, bikes, used, 0, 0, minDist);
    return minDist[0];
}

-----
function manhattanDistance(worker, bike) 
    // Your code here
}

************************************
Question ID: 1067
function countDigit(d, low, high) {
    let count = 0;
    for (let i = low; i <= high; i++) {
        let num = i;
        while (num > 0) {
            if (num % 10 === d) {
                count++;
            }
            num = Math.floor(num / 10);
        }
    }
    return count;
}

-----
function countDigit(d, low, high) 
    // Your code here
}

************************************
Question ID: 1071
function prefixesDivBy5(nums) {
    let result = [];
    let current = 0;
    for (let num of nums) {
        current = ((current << 1) | num) % 5;
        result.push(current === 0);
    }
    return result;
}

-----
function prefixesDivBy5(nums) 
    // Your code here
}

************************************
Question ID: 1073
function addNegabinary(arr1, arr2) {
    const res = [];
    let carry = 0, i = arr1.length - 1, j = arr2.length - 1;
    while (i >= 0 || j >= 0 || carry) {
        if (i >= 0) carry += arr1[i--];
        if (j >= 0) carry += arr2[j--];
        res.unshift(carry & 1);
        carry = -(carry >> 1);
    }
    while (res.length > 1 && res[0] == 0) res.shift();
    return res;
}


-----
function addNegabinary(arr1, arr2) 
    // Your code here
}


************************************
Question ID: 1074
var numSubmatrixSumTarget = function(matrix, target) {
    const rows = matrix.length, cols = matrix[0].length;
    for (let row = 0; row < rows; ++row)
        for (let col = 1; col < cols; ++col)
            matrix[row][col] += matrix[row][col-1];
    
    let count = 0;
    for (let col1 = 0; col1 < cols; ++col1) {
        for (let col2 = col1; col2 < cols; ++col2) {
            const counter = new Map();
            counter.set(0, 1);
            let cur_sum = 0;
            for (let row = 0; row < rows; ++row) {
                cur_sum += matrix[row][col2] - (col1 > 0 ? matrix[row][col1-1] : 0);
                count += (counter.get(cur_sum - target) || 0);
                counter.set(cur_sum, (counter.get(cur_sum) || 0) + 1);
            }
        }
    }
    return count;
};

-----
var numSubmatrixSumTarget = function(matrix, target) 
    // Your code here
};

************************************
Question ID: 1078
function removeOuterParentheses(s) {
    let result = "";
    let opened = 0;

    for (let c of s) {
        if (c === '(' && opened++ > 0) {
            result += c;
        }
        if (c === ')' && opened-- > 1) {
            result += c;
        }
    }

    return result;
}


-----
function removeOuterParentheses(s) 
    // Your code here
}


************************************
Question ID: 1079
function sumRootToLeaf(root, pathValue = 0) {
    if (!root) return 0;
    pathValue = pathValue * 2 + root.val;
    if (!root.left && !root.right) return pathValue;
    return sumRootToLeaf(root.left, pathValue) + sumRootToLeaf(root.right, pathValue);
}

-----
function sumRootToLeaf(root, pathValue = 0) 
    // Your code here
}

************************************
Question ID: 1080
// Definition for a binary tree node.
// function TreeNode(val, left, right) {
//     this.val = (val===undefined ? 0 : val)
//     this.left = (left===undefined ? null : left)
//     this.right = (right===undefined ? null : right)
// }

/**
 * @param {TreeNode} root
 * @param {number} limit
 * @return {TreeNode}
 */
var sufficientSubset = function(root, limit) {
    if(!root) return null;
    if(!root.left && !root.right) {
        if(root.val < limit) return null;
        return root;
    }
    root.left = sufficientSubset(root.left, limit - root.val);
    root.right = sufficientSubset(root.right, limit - root.val);
    if(!root.left && !root.right) return null;

    return root;
};


-----
// Definition for a binary tree node.
// function TreeNode(val, left, right) 
    // Your code here
};


************************************
Question ID: 1081
function videoStitching(clips, time) {
    let dp = new Array(time + 1).fill(Number.MAX_SAFE_INTEGER);
    dp[0] = 0;
    for (let i = 1; i <= time; ++i) {
        for (const clip of clips) {
            if (clip[0] < i && i <= clip[1]) {
                dp[i] = Math.min(dp[i], dp[clip[0]] + 1);
            }
        }
    }
    return dp[time] === Number.MAX_SAFE_INTEGER ? -1 : dp[time];
}

-----
function videoStitching(clips, time) 
    // Your code here
}

************************************
Question ID: 1085
function sumOfDigits(nums) {
    const minVal = Math.min(...nums);
    let digitSum = 0;
    let temp = minVal;
    while (temp > 0) {
        digitSum += temp % 10;
        temp = Math.floor(temp / 10);
    }
    return digitSum % 2 === 0 ? 1 : 0;
}


-----
function sumOfDigits(nums) 
    // Your code here
}


************************************
Question ID: 1086
function aliceWin(n) {
    return n % 2 === 0;
}


-----
function aliceWin(n) 
    // Your code here
}


************************************
Question ID: 1087
function longestArithSeqLength(nums) {
    const n = nums.length;
    let longest = 0;
    const dp = Array.from({ length: n }, () => ({}));
    
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < i; j++) {
            const diff = nums[i] - nums[j];
            dp[i][diff] = (dp[j][diff] || 1) + 1;
            longest = Math.max(longest, dp[i][diff]);
        }
    }
    
    return longest;
}

-----
function longestArithSeqLength(nums) 
    // Your code here
}

************************************
Question ID: 1088
var confusingNumberII = function(n) {
    const validNums = [0, 1, 6, 8, 9];

    function helper(current) {
        let count = 0;
        for (const num of validNums) {
            const nextNum = current * 10 + num;
            if (nextNum > n) break;
            if (current !== 0 || nextNum !== 0) {
                if (nextNum !== rotate(nextNum)) count += 1;
                count += helper(nextNum);
            }
        }
        return count;
    }

    function rotate(num) {
        let rotated = 0;
        while (num > 0) {
            const digit = num % 10;
            if ([2, 3, 4, 5, 7].includes(digit)) return -1;
            rotated = rotated * 10 + (digit === 6 ? 9 : (digit === 9 ? 6 : digit));
            num = Math.floor(num / 10);
        }
        return rotated;
    }

    return helper(0);
};

-----
var confusingNumberII = function(n) 
    // Your code here
};

************************************
Question ID: 1089
function duplicateZeros(arr) {
    const n = arr.length;
    for (let i = 0; i < n - 1; ++i) {
        if (arr[i] === 0) {
            for (let j = n - 1; j > i + 1; --j) {
                arr[j] = arr[j - 1];
            }
            arr[++i] = 0;
        }
    }
}

-----
function duplicateZeros(arr) 
    // Your code here
}

************************************
Question ID: 1090
function largestValsFromLabels(values, labels, numWanted, useLimit) {
    const items = values.map((value, i) => [value, labels[i]]);
    items.sort((a, b) => b[0] - a[0]);

    const labelCount = {};
    let ans = 0;

    for (const [value, label] of items) {
        if (!labelCount.hasOwnProperty(label)) {
            labelCount[label] = 0;
        }
        if (labelCount[label] < useLimit) {
            ans += value;
            labelCount[label]++;
            numWanted--;
            if (numWanted === 0) break;
        }
    }

    return ans;
}


-----
function largestValsFromLabels(values, labels, numWanted, useLimit) 
    // Your code here
}


************************************
Question ID: 1091
function shortestPathBinaryMatrix(grid) {
    const n = grid.length;
    if (grid[0][0] === 1 || grid[n - 1][n - 1] === 1) return -1;

    const dir = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
    const q = [[0, 0]];
    grid[0][0] = 1;

    let pathLength = 1;

    while (q.length > 0) {
        const qlen = q.length;
        for (let i = 0; i < qlen; i++) {
            const [x, y] = q.shift();

            if (x === n - 1 && y === n - 1) return pathLength;

            for (const d of dir) {
                const newX = x + d[0];
                const newY = y + d[1];

                if (newX >= 0 && newX < n && newY >= 0 && newY < n && grid[newX][newY] === 0) {
                    q.push([newX, newY]);
                    grid[newX][newY] = 1;
                }
            }
        }
        pathLength++;
    }

    return -1;
}

-----
function shortestPathBinaryMatrix(grid) 
    // Your code here
}

************************************
Question ID: 1094
function allCellsDistOrder(rows, cols, rCenter, cCenter) {
    const coordinates = [];

    for (let i = 0; i < rows; ++i) {
        for (let j = 0; j < cols; ++j) {
            coordinates.push([i, j]);
        }
    }

    coordinates.sort((a, b) =>
        Math.abs(a[0] - rCenter) + Math.abs(a[1] - cCenter) - Math.abs(b[0] - rCenter) - Math.abs(b[1] - cCenter)
    );

    return coordinates;
}

-----
function allCellsDistOrder(rows, cols, rCenter, cCenter) 
    // Your code here
}

************************************
Question ID: 1095
function twoCitySchedCost(costs) {
    costs.sort((a, b) => (a[0] - a[1]) - (b[0] - b[1]));

    let totalCost = 0;
    const n = costs.length / 2;

    for (let i = 0; i < n; i++) {
        totalCost += costs[i][0] + costs[i + n][1];
    }

    return totalCost;
}

-----
function twoCitySchedCost(costs) 
    // Your code here
}

************************************
Question ID: 1099
function maxSumUnderK(nums, k) {
    let maxSum = -1;
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            let sum = nums[i] + nums[j];
            if (sum < k && sum > maxSum) {
                maxSum = sum;
            }
        }
    }
    return maxSum;
}


-----
function maxSumUnderK(nums, k) 
    // Your code here
}


************************************
Question ID: 1100
function numKLenSubstrNoRepeats(s, k) {
    const n = s.length;
    if (k > n) return 0;
    
    let result = 0;
    const window = new Set();
    
    for (let i = 0, j = 0; j < n; ++j) {
        while (window.has(s[j])) {
            window.delete(s[i++]);
        }
        window.add(s[j]);
        if (j - i + 1 === k) {
            ++result;
            window.delete(s[i++]);
        }
    }
    return result;
}

-----
function numKLenSubstrNoRepeats(s, k) 
    // Your code here
}

************************************
Question ID: 1101
function earliestAcq(logs, n) {
    const parents = new Array(n).fill(0).map((_, idx) => idx);

    logs.sort((a, b) => a[0] - b[0]);

    const find = (x) => {
        if (x !== parents[x]) {
            parents[x] = find(parents[x]);
        }
        return parents[x];
    }

    let group_count = n;
    for (const [timestamp, x, y] of logs) {
        const root_x = find(x);
        const root_y = find(y);
        if (root_x !== root_y) {
            parents[root_x] = root_y;
            group_count--;
        }
        if (group_count === 1) {
            return timestamp;
        }
    }

    return -1;
}

-----
function earliestAcq(logs, n) 
    // Your code here
}

************************************
Question ID: 1102
function maxScore(grid) {
    const m = grid.length, n = grid[0].length;
    
    for (let i = 1; i < n; ++i) {
        grid[0][i] = Math.min(grid[0][i], grid[0][i - 1]);
    }
    
    for (let i = 1; i < m; ++i) {
        grid[i][0] = Math.min(grid[i][0], grid[i - 1][0]);
        
        for (let j = 1; j < n; ++j) {
            grid[i][j] = Math.max(Math.min(grid[i - 1][j], grid[i][j]), 
                                  Math.min(grid[i][j - 1], grid[i][j]));
        }
    }

    return grid[m - 1][n - 1];
}



-----
function maxScore(grid) 
    // Your code here
}



************************************
Question ID: 1103
function distributeCandies(candies, num_people) {
    const result = new Array(num_people).fill(0);
    let i = 0, count = 1;

    while (candies > 0) {
        result[i % num_people] += Math.min(candies, count);
        candies -= count;
        count++;
        i++;
    }

    return result;
}


-----
function distributeCandies(candies, num_people) 
    // Your code here
}


************************************
Question ID: 1104
function colorBorder(grid, row, col, color) {
    function dfs(grid, row, col, current, color) {
        if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] !== current)
            return;

        grid[row][col] = color;
        dfs(grid, row - 1, col, current, color);
        dfs(grid, row + 1, col, current, color);
        dfs(grid, row, col - 1, current, color);
        dfs(grid, row, col + 1, current, color);
    }

    const current = grid[row][col];
    if (current === color)
        return grid;

    dfs(grid, row, col, current, color + 1000);

    for (let i = 0; i < grid.length; i++) {
        for (let j = 0; j < grid[0].length; j++) {
            if (grid[i][j] > 1000)
                grid[i][j] -= 1000;
        }
    }

    return grid;
}

-----
function colorBorder(grid, row, col, color) 
    // Your code here
}

************************************
Question ID: 1105
function maxUncrossedLines(nums1, nums2) {
    let m = nums1.length, n = nums2.length;
    let dp = Array.from({length: m + 1}, () => Array(n + 1).fill(0));

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (nums1[i - 1] === nums2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}


-----
function maxUncrossedLines(nums1, nums2) 
    // Your code here
}


************************************
Question ID: 1106
const MAX_STEPS = 200;

function isEscapePossible(blocked, source, target) {
    const blockedSet = new Set(blocked.map(block => `${block[0]}_${block[1]}`));
    const visited = new Set();

    function dfs(x, y, tx, ty, steps) {
        const pos = `${x}_${y}`;
        if (x < 0 || x >= 1000000 || y < 0 || y >= 1000000 || steps >= MAX_STEPS || blockedSet.has(pos) || visited.has(pos)) {
            return false;
        }

        if (x === tx && y === ty) {
            return true;
        }

        visited.add(pos);

        return dfs(x + 1, y, tx, ty, steps + 1) || dfs(x, y + 1, tx, ty, steps + 1) ||
               dfs(x - 1, y, tx, ty, steps + 1) || dfs(x, y - 1, tx, ty, steps + 1);
    }

    return dfs(source[0], source[1], target[0], target[1], 0);
}


-----
const MAX_STEPS = 200;

function isEscapePossible(blocked, source, target) 
    // Your code here
}


************************************
Question ID: 1108
function defangIPaddr(address) {
    return address.split('.').join('[.]');
}

-----
function defangIPaddr(address) 
    // Your code here
}

************************************
Question ID: 1109
function corpFlightBookings(bookings, n) {
    const seats = new Array(n).fill(0);
    for (const booking of bookings) {
        seats[booking[0] - 1] += booking[2];
        if (booking[1] < n) {
            seats[booking[1]] -= booking[2];
        }
    }
    for (let i = 1; i < n; ++i) {
        seats[i] += seats[i - 1];
    }
    return seats;
}

-----
function corpFlightBookings(bookings, n) 
    // Your code here
}

************************************
Question ID: 1111
function minScoreTriangulation(values) {
    const n = values.length;
    const dp = Array.from({ length: n }, () => Array(n).fill(0));

    for (let len = 3; len <= n; ++len) {
        for (let i = 0; i + len - 1 < n; ++i) {
            const j = i + len - 1;
            dp[i][j] = Infinity;
            for (let k = i + 1; k < j; ++k) {
                dp[i][j] = Math.min(dp[i][j], values[i] * values[j] * values[k] + dp[i][k] + dp[k][j]);
            }
        }
    }

    return dp[0][n - 1];
}


-----
function minScoreTriangulation(values) 
    // Your code here
}


************************************
Question ID: 1118
function numberOfDays(year, month) {
    if (month == 2) {
        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)
            return 29;
        return 28;
    }
    if (month == 4 || month == 6 || month == 9 || month == 11)
        return 30;
    return 31;
}

-----
function numberOfDays(year, month) 
    // Your code here
}

************************************
Question ID: 1119
function isRobotBounded(instructions) {
    let x = 0, y = 0, dir = 0;
    const moves = [[0, 1], [1, 0], [0, -1], [-1, 0]];

    for (const c of instructions) {
        if (c === 'G') {
            x += moves[dir][0];
            y += moves[dir][1];
        } else if (c === 'L') {
            dir = (dir + 3) % 4;
        } else {
            dir = (dir + 1) % 4;
        }
    }

    return (x === 0 && y === 0) || dir !== 0;
}

-----
function isRobotBounded(instructions) 
    // Your code here
}

************************************
Question ID: 1120
function gardenNoAdj(n, paths) {
    const graph = Array.from({ length: n }, () => new Set());
    
    for (const [x, y] of paths) {
        graph[x - 1].add(y - 1);
        graph[y - 1].add(x - 1);
    }
    
    const result = Array(n).fill(0);
    for (let i = 0; i < n; i++) {
        const usedFlowers = new Set(graph[i].map(neighbor => result[neighbor]));
        
        for (let flower = 1; flower <= 4; flower++) {
            if (!usedFlowers.has(flower)) {
                result[i] = flower;
                break;
            }
        }
    }
    return result;
}


-----
function gardenNoAdj(n, paths) 
    // Your code here
}


************************************
Question ID: 1121
function maxSumAfterPartitioning(arr, k) {
    const n = arr.length;
    const dp = new Array(n + 1).fill(0);
    for (let i = 1; i <= n; ++i) {
        let current_max = 0;
        for (let j = 1; j <= k && i - j >= 0; ++j) {
            current_max = Math.max(current_max, arr[i - j]);
            dp[i] = Math.max(dp[i], dp[i - j] + current_max * j);
        }
    }
    return dp[n];
}

-----
function maxSumAfterPartitioning(arr, k) 
    // Your code here
}

************************************
Question ID: 1122
function longestDupSubstring(s) {
    const n = s.length;
    let longest_duplicate = "";
    for (let length = n - 1; length > 0; --length) {
        for (let i = 0; i <= n - length; ++i) {
            const substring = s.substring(i, i + length);
            if (s.indexOf(substring, i + 1) !== -1) {
                longest_duplicate = substring;
                return longest_duplicate;
            }
        }
    }
    return longest_duplicate;
}


-----
function longestDupSubstring(s) 
    // Your code here
}


************************************
Question ID: 1124
function longestWellPerformingInterval(hours) {
    let sum = 0;
    let longest = 0;
    let firstSumIndex = {};

    for (let i = 0; i < hours.length; i++) {
        sum += (hours[i] > 8) ? 1 : -1;
        if (sum > 0) {
            longest = i + 1;
        } else {
            if (sum - 1 in firstSumIndex) {
                longest = Math.max(longest, i - firstSumIndex[sum - 1]);
            }
            if (!(sum in firstSumIndex)) {
                firstSumIndex[sum] = i;
            }
        }
    }
    return longest;
}


-----
function longestWellPerformingInterval(hours) 
    // Your code here
}


************************************
Question ID: 1125
function smallestSufficientTeam(req_skills, people) {
    const skillToId = new Map();
    for (let i = 0; i < req_skills.length; ++i) {
        skillToId.set(req_skills[i], i);
    }

    const n = people.length, m = req_skills.length;
    const dp = Array(1 << m).fill(Number.MAX_SAFE_INTEGER / 2);
    const pre = Array(1 << m).fill(0);
    const skillSet = Array(1 << m).fill(0);

    dp[0] = 0;

    for (let i = 0; i < n; ++i) {
        let skillMask = 0;
        for (let skill of people[i]) {
            skillMask |= 1 << skillToId.get(skill);
        }
        for (let j = (1 << m) - 1; j >= 0; --j) {
            if (dp[j | skillMask] > dp[j] + 1) {
                dp[j | skillMask] = dp[j] + 1;
                pre[j | skillMask] = j;
                skillSet[j | skillMask] = i;
            }
        }
    }

    const res = [];
    let mask = (1 << m) - 1;
    while (mask !== 0) {
        res.push(skillSet[mask]);
        mask = pre[mask];
    }

    return res;
}


-----
function smallestSufficientTeam(req_skills, people) 
    // Your code here
}


************************************
Question ID: 1128
function removeDuplicates(s) {
    const stack = [];
    for (const c of s) {
        if (stack.length > 0 && stack[stack.length - 1] === c) {
            stack.pop();
        } else {
            stack.push(c);
        }
    }
    return stack.join('');
}

-----
function removeDuplicates(s) 
    // Your code here
}

************************************
Question ID: 1129
function longestStrChain(words) {
    words.sort((a, b) => a.length - b.length);
    let dp = new Map();

    let maxLen = 0;
    for (let word of words) {
        for (let i = 0; i < word.length; ++i) {
            let pre = word.slice(0, i) + word.slice(i + 1);
            dp.set(word, Math.max(dp.get(word) || 0, (dp.get(pre) || 0) + 1));
        }
        maxLen = Math.max(maxLen, dp.get(word));
    }

    return maxLen;
}

-----
function longestStrChain(words) 
    // Your code here
}

************************************
Question ID: 1130
function lastStoneWeight(stones) {
    const pq = new MinPriorityQueue({ priority: x => -x });
    stones.forEach(stone => pq.enqueue(stone));
    while (pq.size() > 1) {
        const x = pq.dequeue().element;
        const y = pq.dequeue().element;
        if (x !== y) {
            pq.enqueue(y - x);
        }
    }
    return pq.isEmpty() ? 0 : pq.front().element;
}

-----
function lastStoneWeight(stones) 
    // Your code here
}

************************************
Question ID: 1131
function maxAbsValExpr(arr1, arr2) {
    let result = 0;
    let max_sum = [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER];

    for (let i = 0; i < arr1.length; ++i) {
        max_sum[0] = Math.max(max_sum[0], arr1[i] + arr2[i] + i);
        max_sum[1] = Math.max(max_sum[1], arr1[i] - arr2[i] + i);
        max_sum[2] = Math.max(max_sum[2], -arr1[i] + arr2[i] + i);
        max_sum[3] = Math.max(max_sum[3], -arr1[i] - arr2[i] + i);
    }

    for (let i = 0; i < arr1.length; ++i) {
        result = Math.max(result, max_sum[0] - arr1[i] - arr2[i] - i);
        result = Math.max(result, max_sum[1] - arr1[i] + arr2[i] - i);
        result = Math.max(result, max_sum[2] + arr1[i] - arr2[i] - i);
        result = Math.max(result, max_sum[3] + arr1[i] + arr2[i] - i);
    }

    return result;
}

-----
function maxAbsValExpr(arr1, arr2) 
    // Your code here
}

************************************
Question ID: 1133
function lastSubstring(s) {
    let i = 0, j = 1, k = 0, n = s.length;
    while (j + k < n) {
        if (s.charAt(i + k) === s.charAt(j + k)) {
            k++;
        } else if (s.charAt(i + k) < s.charAt(j + k)) {
            i = j;
            j++;
            k = 0;
        } else {
            j++;
            k = 0;
        }
    }
    return s.substring(i);
}

-----
function lastSubstring(s) 
    // Your code here
}

************************************
Question ID: 1134
function isArmstrong(n) {
    let power_sum = 0;
    let original = n;
    let k = n.toString().length;
    while (n > 0) {
        let digit = n % 10;
        power_sum += Math.pow(digit, k);
        n = Math.floor(n / 10);
    }
    return power_sum === original;
}

-----
function isArmstrong(n) 
    // Your code here
}

************************************
Question ID: 1135
function find(parent, x) {
    if (parent[x] !== x) {
        parent[x] = find(parent, parent[x]);
    }
    return parent[x];
}

function minimumCost(n, connections) {
    connections.sort((a, b) => a[2] - b[2]);

    const parent = Array.from({ length: n + 1 }, (_, i) => i);

    let cost = 0;
    let edges = 0;
    for (const connection of connections) {
        const root_x = find(parent, connection[0]);
        const root_y = find(parent, connection[1]);

        if (root_x !== root_y) {
            parent[root_y] = root_x;
            cost += connection[2];
            edges += 1;
        }

        if (edges === n - 1) {
            break;
        }
    }

    return edges === n - 1 ? cost : -1;
}

-----
function find(parent, x) 
    // Your code here
}

************************************
Question ID: 1136
function minimumSemesters(n, relations) {
    const in_degree = new Array(n + 1).fill(0);
    const graph = new Array(n + 1).fill(null).map(() => []);

    for (let [prev, next] of relations) {
        graph[prev].push(next);
        in_degree[next]++;
    }

    const q = [];
    for (let i = 1; i <= n; i++) {
        if (in_degree[i] === 0) {
            q.push(i);
        }
    }

    let semesters = 0;
    while (q.length) {
        const size = q.length;
        semesters++;
        for (let i = 0; i < size; i++) {
            const course = q.shift();
            n--;

            for (let next of graph[course]) {
                in_degree[next]--;
                if (in_degree[next] === 0) {
                    q.push(next);
                }
            }
        }
    }

    return n === 0 ? semesters : -1;
}

-----
function minimumSemesters(n, relations) 
    // Your code here
}

************************************
Question ID: 1137
function heightChecker(heights) {
    const studentsInTheWrongLine = heights
        .slice()
        .sort((a, b) => a - b)
        .reduce((count, height, idx) => {
            return height === heights[idx] ? count : count + 1;
        }, 0);

    return studentsInTheWrongLine;
}

-----
function heightChecker(heights) 
    // Your code here
}

************************************
Question ID: 1138
function maxSatisfied(customers, grumpy, minutes) {
    let total = 0, maxIncrease = 0, windowIncrease = 0;
    for (let i = 0, j = 0; i < customers.length; ++i) {
        if (i - j === minutes) {
            windowIncrease -= customers[j] * grumpy[j];
            ++j;
        }
        windowIncrease += customers[i] * grumpy[i];
        total += customers[i] * (1 - grumpy[i]);
        maxIncrease = Math.max(maxIncrease, windowIncrease);
    }
    return total + maxIncrease;
}

-----
function maxSatisfied(customers, grumpy, minutes) 
    // Your code here
}

************************************
Question ID: 1139
function prevPermOpt1(arr) {
    let n = arr.length;
    for (let i = n - 2; i >= 0; i--) {
        if (arr[i] > arr[i + 1]) {
            let j = i + 1;
            while (j < n && arr[j] < arr[i]) j++;
            [arr[i], arr[j - 1]] = [arr[j - 1], arr[i]];
            return arr;
        }
    }
    return arr;
}

-----
function prevPermOpt1(arr) 
    // Your code here
}

************************************
Question ID: 1140
function rearrangeBarcodes(barcodes) {
    const count = new Map();
    for (const barcode of barcodes) {
        count.set(barcode, (count.get(barcode) || 0) + 1);
    }

    const pq = Array.from(count.entries());
    pq.sort((a, b) => b[1] - a[1]);

    let index = 0;
    while (pq.length) {
        const curr = pq.shift();
        while (curr[1] > 0) {
            barcodes[index] = curr[0];
            curr[1]--;
            index += 2;
            if (index >= barcodes.length) {
                index = 1;
            }
        }
    }
    return barcodes;
}

-----
function rearrangeBarcodes(barcodes) 
    // Your code here
}

************************************
Question ID: 1143
function longestCommonSubsequence(text1, text2) {
    const m = text1.length;
    const n = text2.length;
    const dp = Array.from({ length: m + 1 }, () => Array.from({ length: n + 1 }, () => 0));
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (text1[i - 1] === text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}

-----
function longestCommonSubsequence(text1, text2) 
    // Your code here
}

************************************
Question ID: 1144
function movesToMakeZigzag(nums) {
    let evenMoves = 0, oddMoves = 0;
    for (let i = 0; i < nums.length; i++) {
        let left = i > 0 ? nums[i - 1] : 1001;
        let right = i < nums.length - 1 ? nums[i + 1] : 1001;
        let minValue = Math.min(left, right);
        if (nums[i] >= minValue) {
            if (i % 2 === 0) {
                evenMoves += nums[i] - minValue + 1;
            } else {
                oddMoves += nums[i] - minValue + 1;
            }
        }
    }
    return Math.min(evenMoves, oddMoves);
}

-----
function movesToMakeZigzag(nums) 
    // Your code here
}

************************************
Question ID: 1146
function gcdOfStrings(str1, str2) {
    if (str1 + str2 !== str2 + str1) {
        return "";
    }
    const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
    return str1.substring(0, gcd(str1.length, str2.length));
}


-----
function gcdOfStrings(str1, str2) 
    // Your code here
}


************************************
Question ID: 1147
function maxEqualRowsAfterFlips(matrix) {
    const count = new Map();
    for (const row of matrix) {
        const rowStr = row.map(val => row[0] ^ val).join('');
        count.set(rowStr, (count.get(rowStr) || 0) + 1);
    }
    let res = 0;
    for (const value of count.values()) {
        res = Math.max(res, value);
    }
    return res;
}

-----
function maxEqualRowsAfterFlips(matrix) 
    // Your code here
}

************************************
Question ID: 1150
function isMajorityElement(nums, target) {
    let count = 0;
    for (const num of nums) {
        if (num === target) count++;
        if (count > nums.length / 2) return true;
    }
    return false;
}

-----
function isMajorityElement(nums, target) 
    // Your code here
}

************************************
Question ID: 1151
function minSwaps(data) {
    let ones = data.reduce((a, b) => a + b);
    let cur_ones = 0, max_ones = 0;
    for (let i = 0; i < data.length; i++) {
        cur_ones += data[i];
        if (i >= ones) {
            cur_ones -= data[i - ones];
        }
        max_ones = Math.max(max_ones, cur_ones);
    }
    return ones - max_ones;
}


-----
function minSwaps(data) 
    // Your code here
}


************************************
Question ID: 1152
var mostVisitedPattern = function(username, timestamp, website) {
    let n = username.length;
    let visitingOrder = [];
    let userVisits = new Map();

    for (let i = 0; i < n; i++) {
        if (!userVisits.has(username[i])) {
            userVisits.set(username[i], []);
        }
        userVisits.get(username[i]).push({time: timestamp[i], index: i});
    }
    
    for (let visits of userVisits.values()) {
        visits.sort((a, b) => a.time - b.time);
        let m = visits.length;
        for (let i = 0; i < m; i++) {
            for (let j = i + 1; j < m; j++) {
                for (let k = j + 1; k < m; k++) {
                    visitingOrder.push([website[visits[i].index], website[visits[j].index], website[visits[k].index]]);
                }
            }
        }
    }
    
    visitingOrder.sort();
    
    let ans = visitingOrder[0];
    let maxScore = 0, score = 1;

    for (let i = 1; i < visitingOrder.length; i++) {
        if (visitingOrder[i].toString() === visitingOrder[i-1].toString()) {
            score++;
        } else {
            score = 1;
        }
        
        if (score > maxScore) {
            maxScore = score;
            ans = visitingOrder[i];
        }
    }
    
    return ans;
};


-----
var mostVisitedPattern = function(username, timestamp, website) 
    // Your code here
};


************************************
Question ID: 1153
function canConvert(str1, str2) {
    if (str1 === str2) return true;
    const conversion = new Map();
    for (let i = 0; i < str1.length; ++i) {
        if (conversion.has(str1[i]) && conversion.get(str1[i]) !== str2[i]) return false;
        conversion.set(str1[i], str2[i]);
    }
    return new Set(str2).size < 26;
}


-----
function canConvert(str1, str2) 
    // Your code here
}


************************************
Question ID: 1154
function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
}

function dayOfYear(date) {
    var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var year = parseInt(date.substr(0, 4));
    var month = parseInt(date.substr(5, 2));
    var day = parseInt(date.substr(8, 2));
    
    if (isLeapYear(year)) {
        daysInMonth[1] = 29;
    }

    var result = 0;
    for (var i = 0; i < month - 1; ++i) {
        result += daysInMonth[i];
    }
    
    return result + day;
}


-----
function isLeapYear(year) 
    // Your code here
}


************************************
Question ID: 1155
function numRollsToTarget(n, k, target) {
    const MOD = 1e9 + 7;
    let dp = Array.from({ length: n + 1 }, () => Array(target + 1).fill(0));
    dp[0][0] = 1;
    for (let i = 1; i <= n; i++) {
        for (let j = i; j <= target; j++) {
            for (let d = 1; d <= k && j - d >= 0; d++) {
                dp[i][j] = (dp[i][j] + dp[i - 1][j - d]) % MOD;
            }
        }
    }
    return dp[n][target];
}

-----
function numRollsToTarget(n, k, target) 
    // Your code here
}

************************************
Question ID: 1156
function findThirdWords(text, first, second) {
    let words = text.split(' ')
    let result = []

    for (let i = 0; i < words.length - 2; i++) {
        if (words[i] === first && words[i + 1] === second) {
            result.push(words[i + 2])
        }
    }

    return result
}

-----
function findThirdWords(text, first, second) 
    // Your code here
}

************************************
Question ID: 1160
function numTilePossibilities(tiles) {
    const freq = new Array(26).fill(0);
    for (const c of tiles) {
        freq[c.charCodeAt(0) - 'A'.charCodeAt(0)]++;
    }

    function dfs(freq) {
        let result = 0;
        for (let i = 0; i < 26; i++) {
            if (freq[i] > 0) {
                freq[i]--;
                result += 1 + dfs(freq);
                freq[i]++;
            }
        }
        return result;
    }

    return dfs(freq);
}

-----
function numTilePossibilities(tiles) 
    // Your code here
}

************************************
Question ID: 1162
function maxDistance(grid) {
    let distance = -1;
    let waterCells = [];
    let n = grid.length;

    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            if (grid[i][j] == 1) {
                waterCells.push([i, j]);
            }
        }
    }

    if (waterCells.length == 0 || waterCells.length == n * n) {
        return distance;
    }

    let directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

    while (waterCells.length !== 0) {
        let size = waterCells.length;
        while (size-- > 0) {
            let [x, y] = waterCells.shift();
            for (const dir of directions) {
                let newX = x + dir[0], newY = y + dir[1];
                if (newX >= 0 && newX < n && newY >= 0 && newY < n && grid[newX][newY] === 0) {
                    grid[newX][newY] = 1;
                    waterCells.push([newX, newY]);
                }
            }
        }
        distance++;
    }

    return distance - 1;
}


-----
function maxDistance(grid) 
    // Your code here
}


************************************
Question ID: 1163
function lastSubstring(s) {
    let maxIndex = 0;
    let curIndex = 1;
    while (curIndex < s.length) {
        let i = 0;
        while (curIndex + i < s.length && s[maxIndex + i] === s[curIndex + i]) {
            i++;
        }
        if (curIndex + i === s.length) break;
        if (s[maxIndex + i] < s[curIndex + i]) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    return s.slice(maxIndex);
}

-----
function lastSubstring(s) 
    // Your code here
}

************************************
Question ID: 1165
function calculateTime(keyboard, word) {
    let time = 0;
    let prevIndex = 0;
    let charToIndex = {};

    for (let i = 0; i < keyboard.length; i++) {
        charToIndex[keyboard[i]] = i;
    }

    for (let c of word) {
        time += Math.abs(charToIndex[c] - prevIndex);
        prevIndex = charToIndex[c];
    }

    return time;
}

-----
function calculateTime(keyboard, word) 
    // Your code here
}

************************************
Question ID: 1167
function connectSticks(sticks) {
    const minHeap = new MinHeap(sticks);
    
    let cost = 0;
    while (minHeap.size() > 1) {
        const first = minHeap.poll();
        const second = minHeap.poll();
        cost += first + second;
        minHeap.offer(first + second);
    }
    return cost;
}

class MinHeap {
    constructor(items) {
        this.heap = [];
        for (const item of items) {
            this.offer(item);
        }
    }
    
    offer(value) {
        this.heap.push(value);
        this.bubbleUp(this.heap.length - 1);
    }
    
    poll() {
        const min = this.heap[0];
        this.heap[0] = this.heap.pop();
        this.bubbleDown(0);
        return min;
    }
    
    size() {
        return this.heap.length;
    }
    
    bubbleUp(index) {
        if (index === 0) return;
        const parentIndex = Math.floor((index - 1) / 2);
        if (this.heap[parentIndex] > this.heap[index]) {
            [this.heap[parentIndex], this.heap[index]] = [this.heap[index], this.heap[parentIndex]];
            this.bubbleUp(parentIndex);
        }
    }
    
    bubbleDown(index) {
        const leftChildIndex = 2 * index + 1;
        const rightChildIndex = 2 * index + 2;
        
        let minIndex = index;
        if (leftChildIndex < this.heap.length && this.heap[leftChildIndex] < this.heap[minIndex]) {
            minIndex = leftChildIndex;
        }
        
        if (rightChildIndex < this.heap.length && this.heap[rightChildIndex] < this.heap[minIndex]) {
            minIndex = rightChildIndex;
        }
        
        if (minIndex !== index) {
            [this.heap[minIndex], this.heap[index]] = [this.heap[index], this.heap[minIndex]];
            this.bubbleDown(minIndex);
        }
    }
}

-----
function connectSticks(sticks) 
    // Your code here
}

************************************
Question ID: 1168
function duplicateZeros(arr) {
    let n = arr.length;
    for (let i = 0; i < n - 1; i++) {
        if (arr[i] === 0) {
            for (let j = n - 2; j > i; j--) {
                arr[j + 1] = arr[j];
            }
            arr[i + 1] = 0;
            i++;
        }
    }
}

-----
function duplicateZeros(arr) 
    // Your code here
}

************************************
Question ID: 1169
function largestValsFromLabels(values, labels, numWanted, useLimit) {
    const items = values.map((value, index) => [value, labels[index]]);
    items.sort((a, b) => b[0] - a[0]);

    const labelCount = new Map();
    let result = 0;
    for (const [value, label] of items) {
        if (numWanted > 0 && (!labelCount.has(label) || labelCount.get(label) < useLimit)) {
            result += value;
            labelCount.set(label, (labelCount.get(label) || 0) + 1);
            numWanted--;
        }
    }

    return result;
}

-----
function largestValsFromLabels(values, labels, numWanted, useLimit) 
    // Your code here
}

************************************
Question ID: 1170
function shortestCommonSupersequence(str1, str2) {
    const m = str1.length;
    const n = str2.length;
    const dp = Array.from({length: m + 1}, () => Array(n + 1).fill(0));

    for (let i = 0; i <= m; i++) {
        for (let j = 0; j <= n; j++) {
            if (i === 0) {
                dp[i][j] = j;
            } else if (j === 0) {
                dp[i][j] = i;
            } else if (str1[i - 1] === str2[j - 1]) {
                dp[i][j] = 1 + dp[i - 1][j - 1];
            } else {
                dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    let i = m, j = n;
    let result = "";

    while (i > 0 && j > 0) {
        if (str1[i - 1] === str2[j - 1]) {
            result = str1[i - 1] + result;
            i--;
            j--;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            j--;
            result = str2[j] + result;
        } else {
            i--;
            result = str1[i] + result;
        }
    }

    while (i > 0) {
        i--;
        result = str1[i] + result;
    }

    while (j > 0) {
        j--;
        result = str2[j] + result;
    }

    return result;
}

-----
function shortestCommonSupersequence(str1, str2) 
    // Your code here
}

************************************
Question ID: 1171
function shortestPathBinaryMatrix(grid) {
    const n = grid.length;
    if (grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;
    const q = [[0, 0]];
    const dirs = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
    grid[0][0] = 1;
    let steps = 1;

    while (q.length !== 0) {
        const size = q.length;
        for (let i = 0; i < size; ++i) {
            const [x, y] = q.shift();

            if (x === n - 1 && y === n - 1) return steps;

            for (const [dx, dy] of dirs) {
                const newX = x + dx;
                const newY = y + dy;

                if (newX >= 0 && newX < n && newY >= 0 && newY < n && grid[newX][newY] === 0) {
                    q.push([newX, newY]);
                    grid[newX][newY] = 1;
                }
            }
        }
        steps++;
    }

    return -1;
}

-----
function shortestPathBinaryMatrix(grid) 
    // Your code here
}

************************************
Question ID: 1175
function numPrimeArrangements(n) {
    function isPrime(num) {
        if (num < 2) return false;
        for (let i = 2; i * i <= num; i++) {
            if (num % i === 0) return false;
        }
        return true;
    }

    let primeCount = 0;
    for (let i = 2; i <= n; i++) {
        if (isPrime(i)) primeCount++;
    }
    let compositeCount = n - primeCount;

    const MOD = 10**9 + 7;
    let res = 1;
    for (let i = 1; i <= primeCount; i++) {
        res = res * i % MOD;
    }
    for (let i = 1; i <= compositeCount; i++) {
        res = res * i % MOD;
    }

    return res;
}

-----
function numPrimeArrangements(n) 
    // Your code here
}

************************************
Question ID: 1176
function dietPlanPerformance(calories, k, lower, upper) {
    let points = 0;
    let T = 0;

    for(let i = 0; i < calories.length; i++) {
        T += calories[i];
        if(i >= k) {
            T -= calories[i-k];
        }
        if(i >= k-1) {
            if(T < lower) points--;
            if(T > upper) points++;
        }
    }

    return points;
}

-----
function dietPlanPerformance(calories, k, lower, upper) 
    // Your code here
}

************************************
Question ID: 1177
function canMakePaliQueries(s, queries) {
    const answer = [];
    const prefixSum = new Array(s.length + 1).fill(0);

    for (let i = 0; i < s.length; ++i) {
        prefixSum[i + 1] = prefixSum[i] ^ (1 << (s.charCodeAt(i) - 'a'.charCodeAt(0)));
    }

    for (const query of queries) {
        const left = query[0], right = query[1], k = query[2];
        const diffCount = (prefixSum[right + 1] ^ prefixSum[left]).toString(2).split('0').length - 1;
        answer.push((diffCount / 2) <= k);
    }

    return answer;
}


-----
function canMakePaliQueries(s, queries) 
    // Your code here
}


************************************
Question ID: 1178
function findNumOfValidWords(words, puzzles) {
    const result = [];
    for (const puzzle of puzzles) {
        let count = 0;
        const puzzleSet = new Set(puzzle);
        for (const word of words) {
            if (word.includes(puzzle[0])) {
                if (Array.from(word).every(c => puzzleSet.has(c))) {
                    count++;
                }
            }
        }
        result.push(count);
    }
    return result;
}


-----
function findNumOfValidWords(words, puzzles) 
    // Your code here
}


************************************
Question ID: 1180
function countLetters(s) {
    let count = 0;
    let current = 1;

    for (let i = 1; i < s.length; i++) {
        if (s[i] === s[i - 1]) {
            current++;
        } else {
            count += (current * (current + 1)) / 2;
            current = 1;
        }
    }

    count += (current * (current + 1)) / 2;
    return count;
}

-----
function countLetters(s) 
    // Your code here
}

************************************
Question ID: 1181
function beforeAndAfterPuzzles(phrases) {
    const firstWordMap = new Map();
    const result = new Set();

    for (const phrase of phrases) {
        const firstWord = phrase.split(' ')[0];
        if (!firstWordMap.has(firstWord)) {
            firstWordMap.set(firstWord, new Set());
        }
        firstWordMap.get(firstWord).add(phrase);
    }

    for (const phrase of phrases) {
        const lastWord = phrase.split(' ').pop();
        if (firstWordMap.has(lastWord)) {
            for (const curPhrase of firstWordMap.get(lastWord)) {
                if (phrase !== curPhrase) {
                    result.add(phrase + curPhrase.slice(curPhrase.indexOf(' ')));
                }
            }
        }
    }

    return Array.from(result).sort();
}

-----
function beforeAndAfterPuzzles(phrases) 
    // Your code here
}

************************************
Question ID: 1182
function shortestDistance(colors, queries) {
    const result = [];
    const positions = [[], [], []];

    colors.forEach((color, i) => {
        positions[color - 1].push(i);
    });

    queries.forEach(query => {
        const indexPositions = positions[query[1] - 1];

        if (!indexPositions.length) {
            result.push(-1);
        } else {
            let dist = Infinity;

            indexPositions.forEach(pos => {
                dist = Math.min(dist, Math.abs(pos - query[0]));
            });

            result.push(dist);
        }
    });

    return result;
}

-----
function shortestDistance(colors, queries) 
    // Your code here
}

************************************
Question ID: 1183
function sampleStats(count) {
    let minVal = -1, maxVal = -1, mode = 0, median = 0, mean = 0;
    let totalCount = 0, modeCount = 0, curCount = 0;
    let sum = 0;

    for (let i = 0; i <= 255; i++) {
        if (count[i] > 0) {
            if (minVal === -1) minVal = i;
            maxVal = i;
            sum += i * count[i];
            totalCount += count[i];
            if (count[i] > modeCount) {
                modeCount = count[i];
                mode = i;
            }
        }
    }

    mean = sum / totalCount;
    let isEven = (totalCount % 2 === 0);
    let mid1 = Math.floor(totalCount / 2), mid2 = mid1 - 1;
    if (isEven) mid2++;

    for (let i = 0; i <= 255; i++) {
        curCount += count[i];
        if (isEven && curCount >= mid2) {
            median += i;
            mid2 = totalCount;
            isEven = false;
        }

        if (curCount >= mid1) {
            median += i;
            break;
        }
    }

    if (!isEven) median /= 2;
    return [minVal, maxVal, mean, median, mode];
}

-----
function sampleStats(count) 
    // Your code here
}

************************************
Question ID: 1184
function carPooling(trips, capacity) {
    const stops = new Array(1001).fill(0);
    for (const [num, start, end] of trips) {
        stops[start] += num;
        stops[end] -= num;
    }
    for (const passengers of stops) {
        capacity -= passengers;
        if (capacity < 0) {
            return false;
        }
    }
    return true;
}

-----
function carPooling(trips, capacity) 
    // Your code here
}

************************************
Question ID: 1185
function dayOfTheWeek(day, month, year) {
    let days = ["Sunday ", "Monday ", "Tuesday ", "Wednesday ", "Thursday ", "Friday ", "Saturday "];
    let date = new Date(year, month - 1, day);
    return days[date.getDay()];
}

-----
function dayOfTheWeek(day, month, year) 
    // Your code here
}

************************************
Question ID: 1186
const { Semaphore } = require('await-semaphore');

class H2O {
  constructor() {
    this.hydrogenSemaphore = new Semaphore(2);
    this.oxygenSemaphore = new Semaphore(1);
  }

  async hydrogen(releaseHydrogen) {
    await this.hydrogenSemaphore.acquire();
    releaseHydrogen();
    this.oxygenSemaphore.release();
  }

  async oxygen(releaseOxygen) {
    await this.oxygenSemaphore.acquire();
    releaseOxygen();
    this.hydrogenSemaphore.release(2);
  }
}


-----
const 
    // Your code here
}


************************************
Question ID: 1187
class FooBar {
  constructor(n) {
    this.n = n;
    this.fooPromiseResolver = null;
    this.fooPromise = new Promise((resolve) => (this.fooPromiseResolver = resolve));
    this.barPromiseResolver = null;
    this.barPromise = new Promise((resolve) => (this.barPromiseResolver = resolve));
  }

  async foo(printFoo) {
    for (let i = 0; i < this.n; i++) {
      await this.fooPromise;
      printFoo();
      this.barPromiseResolver();
      this.fooPromise = new Promise((resolve) => (this.fooPromiseResolver = resolve));
    }
  }

  async bar(printBar) {
    for (let i = 0; i < this.n; i++) {
      await this.barPromise;
      printBar();
      this.fooPromiseResolver();
      this.barPromise = new Promise((resolve) => (this.barPromiseResolver = resolve));
    }
  }
}

-----
class FooBar 
    // Your code here
}

************************************
Question ID: 1189
function maxNumberOfBalloons(text) {
    const letter_count = [0, 0, 0, 0, 0];
    for (let c of text) {
        if (c === 'b') letter_count[0]++;
        if (c === 'a') letter_count[1]++;
        if (c === 'l') letter_count[2]++;
        if (c === 'o') letter_count[3]++;
        if (c === 'n') letter_count[4]++;
    }
    letter_count[2] = Math.floor(letter_count[2] / 2);
    letter_count[3] = Math.floor(letter_count[3] / 2);
    return Math.min(...letter_count);
}

-----
function maxNumberOfBalloons(text) 
    // Your code here
}

************************************
Question ID: 1190
function reverseParentheses(s) {
    const stack = [];
    for (let i = 0; i < s.length; i++) {
        if (s[i] === '(') {
            stack.push(i);
        } else if (s[i] === ')') {
            const start = stack.pop();
            const end = i;
            const substring = s.slice(start + 1, end).split('').reverse().join('');
            s = s.slice(0, start) + substring + s.slice(end + 1);
        }
    }
    let result = '';
    for (let i = 0; i < s.length; i++) {
        if (s[i] !== '(' && s[i] !== ')') {
            result += s[i];
        }
    }
    return result;
}

-----
function reverseParentheses(s) 
    // Your code here
}

************************************
Question ID: 1191
function kConcatenationMaxSum(arr, k) {
    const mod = 1e9 + 7;
    let n = arr.length;
    let sum = 0, maxSum = 0, tempSum = 0, maxLeft = 0, maxRight = 0;

    for (let i = 0; i < n; i++) {
        sum += arr[i];
        tempSum += arr[i];
        maxSum = Math.max(maxSum, tempSum);
        tempSum = Math.max(0, tempSum);
        maxLeft = Math.max(maxLeft, sum);
    }

    let temp = sum;
    for (let i = n - 1; i >= 0; i--) {
        temp -= arr[i];
        maxRight = Math.max(maxRight, temp);
    }
    
    let ans = Math.max(maxSum, maxLeft + maxRight + sum * (k - 2), 0);
    return ans % mod;
}

-----
function kConcatenationMaxSum(arr, k) 
    // Your code here
}

************************************
Question ID: 1192
function criticalConnections(n, connections) {
    const graph = new Map();
    for (const [fr, to] of connections) {
        if (!graph.has(fr)) {
            graph.set(fr, []);
        }
        if (!graph.has(to)) {
            graph.set(to, []);
        }
        graph.get(fr).push(to);
        graph.get(to).push(fr);
    }

    const rank = new Array(n).fill(-1);
    const result = [];
    dfs(0, -1, 0, rank, graph, result);
    return result;
}

function dfs(node, parent, depth, rank, graph, result) {
    rank[node] = depth;
    for (const neighbor of graph.get(node)) {
        if (neighbor === parent) {
            continue;
        }
        if (rank[neighbor] === -1) {
            dfs(neighbor, node, depth + 1, rank, graph, result);
        }
        rank[node] = Math.min(rank[node], rank[neighbor]);
        if (rank[neighbor] === depth + 1) {
            result.push([node, neighbor]);
        }
    }
}


-----
function criticalConnections(n, connections) 
    // Your code here
}


************************************
Question ID: 1196
function minHeightShelves(books, shelfWidth) {
    const n = books.length;
    const dp = new Array(n + 1).fill(1000000);
    dp[0] = 0;
    
    for (let i = 1; i <= n; i++) {
        let width = 0, height = 0;
        for (let j = i; j >= 1; j--) {
            width += books[j - 1][0];
            height = Math.max(height, books[j - 1][1]);
            
            if (width <= shelfWidth)
                dp[i] = Math.min(dp[i], dp[j - 1] + height);
        }
    }
    
    return dp[n];
}

-----
function minHeightShelves(books, shelfWidth) 
    // Your code here
}

************************************
Question ID: 1197
function parseBoolExpr(expression, pos = [0]) {
    const current = expression[pos[0]++];
    if (current === 't') return true;
    if (current === 'f') return false;
    if (current === '!') {
        pos[0]++;
        return !parseBoolExpr(expression, pos);
    }
    if (current === '&') {
        pos[0]++;
        let result = true;
        while (expression[pos[0]] !== ')') {
            result &= parseBoolExpr(expression, pos);
            if (expression[pos[0]] === ',') pos[0]++;
        }
    } else if (current === '|') {
        pos[0]++;
        let result = false;
        while (expression[pos[0]] !== ')') {
            result |= parseBoolExpr(expression, pos);
            if (expression[pos[0]] === ',') pos[0]++;
        }
    }
    pos[0]++;
    return result;
}

-----
function parseBoolExpr(expression, pos = [0]) 
    // Your code here
}

************************************
Question ID: 1198
function smallestCommonElement(mat) {
    const counts = new Map();
    for (const row of mat) {
        for (const num of row) {
            counts.set(num, (counts.get(num) || 0) + 1);
            if (counts.get(num) === mat.length) {
                return num;
            }
        }
    }
    return -1;
}

-----
function smallestCommonElement(mat) 
    // Your code here
}

************************************
Question ID: 1199
function minBuildTime(blocks, split) {
    const pq = new PriorityQueue();
    for (const block of blocks) {
        pq.add(block);
    }
    
    while (pq.size() > 1) {
        const a = pq.poll();
        const b = pq.poll();
        pq.add(b + split);
    }
    
    return pq.poll();
}

-----
function minBuildTime(blocks, split) 
    // Your code here
}

************************************
Question ID: 1200
function minimumAbsDifference(arr) {
    arr.sort((a, b) => a - b);
    let minDiff = Infinity;
    for (let i = 1; i < arr.length; i++) {
        minDiff = Math.min(minDiff, arr[i] - arr[i - 1]);
    }

    const result = [];
    for (let i = 1; i < arr.length; i++) {
        if (arr[i] - arr[i - 1] === minDiff) {
            result.push([arr[i - 1], arr[i]]);
        }
    }

    return result;
}

-----
function minimumAbsDifference(arr) 
    // Your code here
}

************************************
Question ID: 1201
function gcd(a, b) {
    return b === 0 ? a : gcd(b, a % b);
}

function nthUglyNumber(n, a, b, c) {
    let left = 1, right = 2e9;
    let lcm_ab = a / gcd(a, b) * b, lcm_ac = a / gcd(a, c) * c, lcm_bc = b / gcd(b, c) * c;
    let lcm_abc = a / gcd(a, lcm_bc) * lcm_bc;

    while (left < right) {
        let mid = left + Math.floor((right - left) / 2);
        let count = Math.floor(mid / a) + Math.floor(mid / b) + Math.floor(mid / c) - Math.floor(mid / lcm_ab) - Math.floor(mid / lcm_ac) - Math.floor(mid / lcm_bc) + Math.floor(mid / lcm_abc);
        if (count < n) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}

-----
function gcd(a, b) 
    // Your code here
}

************************************
Question ID: 1202
/**
 * @param {string} s
 * @param {number[][]} pairs
 * @return {string}
 */
const smallestStringWithSwaps = (s, pairs) => {
    const n = s.length;
    const p = Array.from({length: n}, (_, i) => i);
    
    const find = x => {
        if (p[x] !== x) p[x] = find(p[x]);
        return p[x];
    };

    for (const [x, y] of pairs) {
        p[find(y)] = find(x);
    }

    const groups = Array.from({length: n}, () => []);
    for (let i = 0; i < n; i++) {
        const root = find(i);
        groups[root].push(s[i]);
    }
    
    for (const group of groups) {
        group.sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0));
    }
    
    let result = '';
    for (let i = 0; i < n; i++) {
        const root = find(i);
        result += groups[root].pop();
    }

    return result;
};


-----
/**
 * @param 
    // Your code here
};


************************************
Question ID: 1203
class Foo {
    constructor() {
        this.order = 1;
        this.cv = new Map(); // empty map to hold promises
    }

    async first(printFirst) {
        // printFirst() outputs "first". Do not change or remove this line.
        await printFirst();
        this.order = 2;
        if (this.cv.has(2)) {
            this.cv.get(2)(); // resolve promise
        }
    }

    async second(printSecond) {
        if (this.order < 2) {
            // creates a new promise
            await new Promise((resolve) => this.cv.set(2, resolve));
        }
        // printSecond() outputs "second". Do not change or remove this line.
        await printSecond();
        this.order = 3;
        if (this.cv.has(3)) {
            this.cv.get(3)(); // resolve promise
        }
    }

    async third(printThird) {
        if (this.order < 3) {
            // creates a new promise
            await new Promise((resolve) => this.cv.set(3, resolve));
        }
        // printThird() outputs "third". Do not change or remove this line.
        await printThird();
    }
}

-----
class Foo 
    // Your code here
}

************************************
Question ID: 1206
function corpFlightBookings(bookings, n) {
    let answer = new Array(n).fill(0);
    for (let booking of bookings) {
        answer[booking[0] - 1] += booking[2];
        if (booking[1] < n) {
            answer[booking[1]] -= booking[2];
        }
    }
    for (let i = 1; i < n; i++) {
        answer[i] += answer[i - 1];
    }
    return answer;
}

-----
function corpFlightBookings(bookings, n) 
    // Your code here
}

************************************
Question ID: 1208
function splitString(seq) {
    const result = new Array(seq.length);
    let count = 0;

    for (let i = 0; i < seq.length; ++i) {
        if (seq[i] === '(') {
            result[i] = count % 2;
            count++;
        } else {
            count--;
            result[i] = count % 2;
        }
    }

    return result;
}


-----
function splitString(seq) 
    // Your code here
}


************************************
Question ID: 1209
function removeDuplicates(s, k) {
    let stack = [];
    for (let c of s) {
        if (stack.length === 0 || stack[stack.length - 1][0] !== c) {
            stack.push([c, 1]);
        } else if (++stack[stack.length - 1][1] === k) {
            stack.pop();
        }
    }
    let result = "";
    for (let pair of stack) {
        result += pair[0].repeat(pair[1]);
    }
    return result;
}


-----
function removeDuplicates(s, k) 
    // Your code here
}


************************************
Question ID: 1210
function trimmedMean(arr) {
    const n = arr.length;
    const remove = Math.floor(n * 0.05);
    arr.sort((a, b) => a - b);
    let sum = 0.0;
    for (let i = remove; i < n - remove; i++) {
        sum += arr[i];
    }
    return sum / (n - 2 * remove);
}


-----
function trimmedMean(arr) 
    // Your code here
}


************************************
Question ID: 1213
function arraysIntersection(arr1, arr2, arr3) {
    let i = 0, j = 0, k = 0;
    let result = [];
    while (i < arr1.length && j < arr2.length && k < arr3.length) {
        if (arr1[i] === arr2[j] && arr2[j] === arr3[k]) {
            result.push(arr1[i]);
            i++; j++; k++;
        } else {
            if (arr1[i] <= arr2[j] && arr1[i] <= arr3[k]) i++;
            else if (arr2[j] <= arr3[k]) j++;
            else k++;
        }
    }
    return result;
}

-----
function arraysIntersection(arr1, arr2, arr3) 
    // Your code here
}

************************************
Question ID: 1215
function countSteppingNumbers(low, high) {
    const results = [];
    for (let i = low; i <= high; i++) {
        let prev = -1;
        let j = i;
        let isStepping = true;
        while (j > 0) {
            const digit = j % 10;
            if (prev !== -1 && Math.abs(prev - digit) !== 1) {
                isStepping = false;
                break;
            }
            prev = digit;
            j = Math.floor(j / 10);
        }
        if (isStepping) results.push(i);
    }
    return results;
}


-----
function countSteppingNumbers(low, high) 
    // Your code here
}


************************************
Question ID: 1216
class ZeroEvenOdd {
    constructor(n) {
        this.n = n;
        this.cnt = 1;
        this.lock = new Promise(resolve => this.unlock = resolve);
    }

    async zero(printNumber) {
        for(let i = 1; i <= this.n; i++) {
            await this.lock;
            while(this.cnt % 2 === 0) {
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            printNumber(0);
            this.cnt++;
            this.unlock();
        }
    }

    async even(printNumber) {
        for(let i = 2; i <= this.n; i+=2) {
            await this.lock;
            while(this.cnt !== 2 * i) {
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            printNumber(i);
            this.cnt++;
            this.unlock();
        }
    }

    async odd(printNumber) {
        for(let i = 1; i <= this.n; i+=2) {
            await this.lock;
            while(this.cnt !== 2 * i - 1) {
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            printNumber(i);
            this.cnt++;
            this.unlock();
        }
    }
}

-----
class ZeroEvenOdd 
    // Your code here
}

************************************
Question ID: 1217
function sortArray(arr1, arr2) {
    const counts = new Map();

    for (const num of arr1) {
        counts.set(num, (counts.get(num) || 0) + 1);
    }

    const result = [];

    for (const num of arr2) {
        while (counts.get(num) > 0) {
            result.push(num);
            counts.set(num, counts.get(num) - 1);
        }
    }

    Array.from(counts.entries())
        .sort(([a], [b]) => a - b)
        .forEach(([num, count]) => {
            while (count--) {
                result.push(num);
            }
        });

    return result;
}

-----
function sortArray(arr1, arr2) 
    // Your code here
}

************************************
Question ID: 1219
function longestWPI(hours) {
    let score = 0;
    let maxLength = 0;
    let firstOccurrence = new Map();

    for (let i = 0; i < hours.length; ++i) {
        score += hours[i] > 8 ? 1 : -1;
        if (score > 0) maxLength = i + 1;
        else {
            if (!firstOccurrence.has(score))
                firstOccurrence.set(score, i);
            if (firstOccurrence.has(score - 1))
                maxLength = Math.max(maxLength, i - firstOccurrence.get(score - 1));
        }
    }
    return maxLength;
}

-----
function longestWPI(hours) 
    // Your code here
}

************************************
Question ID: 1220
function smallestSufficientTeam(req_skills, people) {
    const skill_to_int = new Map()
    req_skills.forEach((v, i) => skill_to_int.set(v, i))

    const people_int = people.map(person =>
        person.reduce((skills, p) => skills | 1 << skill_to_int.get(p), 0)
    )

    const n = req_skills.length
    const INF = 64
    const dp = Array(1 << n).fill(INF)
    const parent = Array(1 << n).fill(0)

    dp[0] = 0

    for (let i = 0; i < people.length; i++) {
        for (let skills_done = (1 << n) - 1; skills_done >= 0; skills_done--) {
            const with_person_skills = skills_done | people_int[i]
            if (dp[with_person_skills] > dp[skills_done] + 1) {
                dp[with_person_skills] = dp[skills_done] + 1
                parent[with_person_skills] = skills_done
            }
        }
    }

    const result = Array(dp[(1 << n) - 1])
    let cur = (1 << n) - 1
    let t = result.length - 1

    for (let i = people.length - 1; i >= 0; i--) {
        const old = parent[cur]
        const diff = cur ^ old
        const is_essential = (people_int[i] & diff) > 0
        if (is_essential) {
            result[t] = i
            t -= 1
        }
        cur = old
    }

    return result
}

-----
function smallestSufficientTeam(req_skills, people) 
    // Your code here
}

************************************
Question ID: 1221
function findSpecialInteger(arr) {
    let n = arr.length, requiredCount = Math.floor(n / 4);
    for (let i = 0; i < n; i++) {
        if (arr[i] === arr[i + requiredCount]) {
            return arr[i];
        }
    }
    return -1;
}

-----
function findSpecialInteger(arr) 
    // Your code here
}

************************************
Question ID: 1222
function removeCoveredIntervals(intervals) {
    intervals.sort((a, b) => {
        if (a[0] === b[0]) return b[1] - a[1];
        return a[0] - b[0];
    });
    
    let count = 0;
    let end = 0;
    for (let i of intervals) {
        if (i[1] > end) {
            count++;
            end = i[1];
        }
    }
    return count;
}


-----
function removeCoveredIntervals(intervals) 
    // Your code here
}


************************************
Question ID: 1223
function areConnected(n, threshold, queries) {
    const answer = new Array(queries.length).fill(false);
    const parent = Array.from({ length: n + 1 }, (v, i) => i);
    const rank = new Array(n + 1).fill(0);

    function find(x) {
        if (parent[x] !== x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    function unite(x, y) {
        let rootx = find(x);
        let rooty = find(y);
        if (rootx !== rooty) {
            if (rank[rootx] > rank[rooty]) {
                [rootx, rooty] = [rooty, rootx];
            }
            parent[rootx] = rooty;
            if (rank[rootx] === rank[rooty]) {
                rank[rooty]++;
            }
        }
    }

    for (let i = threshold + 1; i <= n; i++) {
        for (let j = 2 * i; j <= n; j += i) {
            unite(i, j);
        }
    }

    for (let i = 0; i < queries.length; i++) {
        answer[i] = find(queries[i][0]) === find(queries[i][1]);
    }

    return answer;
}

-----
function areConnected(n, threshold, queries) 
    // Your code here
}

************************************
Question ID: 1224
function minFallingPathSum(grid) {
    const n = grid.length;
    for (let i = 1; i < n; i++) {
        for (let j = 0; j < n; j++) {
            let minVal = Infinity;
            for (let k = 0; k < n; k++) {
                if (k === j) continue;
                minVal = Math.min(minVal, grid[i - 1][k]);
            }
            grid[i][j] += minVal;
        }
    }
    return Math.min(...grid[n - 1]);
}

-----
function minFallingPathSum(grid) 
    // Your code here
}

************************************
Question ID: 1227
function numEquivDominoPairs(dominoes) {
    const freq = {};
    let result = 0;
    for (const domino of dominoes) {
        const key = Math.min(domino[0], domino[1]) * 10 + Math.max(domino[0], domino[1]);
        result += (freq[key] || 0);
        freq[key] = (freq[key] || 0) + 1;
    }
    return result;
}

-----
function numEquivDominoPairs(dominoes) 
    // Your code here
}

************************************
Question ID: 1228
function mctFromLeafValues(arr) {
    const n = arr.length;
    const dp = Array(n).fill(0).map(() => Array(n).fill(0));
    const maxs = Array(n).fill(0).map(() => Array(n).fill(0));

    for (let i = 0; i < n; ++i) {
        for (let j = i; j < n; ++j) {
            maxs[i][j] = Math.max(...arr.slice(i, j + 1));
        }
    }

    for (let len = 1; len < n; ++len) {
        for (let i = 0; i + len < n; ++i) {
            let j = i + len;
            dp[i][j] = Number.MAX_SAFE_INTEGER;
            for (let k = i; k < j; ++k) {
                dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j] + maxs[i][k] * maxs[k + 1][j]);
            }
        }
    }
    return dp[0][n - 1];
}

-----
function mctFromLeafValues(arr) 
    // Your code here
}

************************************
Question ID: 1229
function shortestAlternatingPaths(n, redEdges, blueEdges) {
    const adjList = new Array(n).fill(null).map(_ => new Array(2).fill(null).map(_ => []));

    for (const edge of redEdges) {
        adjList[edge[0]][0].push(edge[1]);
    }

    for (const edge of blueEdges) {
        adjList[edge[0]][1].push(edge[1]);
    }

    const dist = new Array(n).fill(null).map(_ => new Array(2).fill(-1));
    dist[0][0] = 0;
    dist[0][1] = 0;

    const q = [[0, 0], [0, 1]];

    while (q.length > 0) {
        const [node, color] = q.shift();
        const next_color = color ^ 1;

        for (const neighbor of adjList[node][next_color]) {
            if (dist[neighbor][next_color] === -1) {
                dist[neighbor][next_color] = dist[node][color] + 1;
                q.push([neighbor, next_color]);
            }
        }
    }

    const result = new Array(n);
    for (let i = 0; i < n; i++) {
        result[i] = Math.min(dist[i][0], dist[i][1]);
        if (dist[i][0] === -1 || dist[i][1] === -1) {
            result[i] = Math.max(dist[i][0], dist[i][1]);
        }
    }
    return result;
}


-----
function shortestAlternatingPaths(n, redEdges, blueEdges) 
    // Your code here
}


************************************
Question ID: 1230
function maxValue(arr1, arr2) {
    let max1 = -Infinity, max2 = -Infinity, max3 = -Infinity, max4 = -Infinity;
    let min1 = Infinity, min2 = Infinity, min3 = Infinity, min4 = Infinity;
    let n = arr1.length;

    for (let i = 0; i < n; i++) {
        max1 = Math.max(max1, arr1[i] - arr2[i] + i);
        max2 = Math.max(max2, arr1[i] + arr2[i] + i);
        max3 = Math.max(max3, -arr1[i] + arr2[i] + i);
        max4 = Math.max(max4, -arr1[i] - arr2[i] + i);

        min1 = Math.min(min1, arr1[i] - arr2[i] + i);
        min2 = Math.min(min2, arr1[i] + arr2[i] + i);
        min3 = Math.min(min3, -arr1[i] + arr2[i] + i);
        min4 = Math.min(min4, -arr1[i] - arr2[i] + i);
    }
    return Math.max(Math.max(max1 - min1, max2 - min2),
            Math.max(max3 - min3, max4 - min4));
}


-----
function maxValue(arr1, arr2) 
    // Your code here
}


************************************
Question ID: 1231
function replaceElements(arr) {
    let n = arr.length;
    let maxElement = -1;
    for (let i = n - 1; i >= 0; i--) {
        let temp = arr[i];
        arr[i] = maxElement;
        maxElement = Math.max(maxElement, temp);
    }
    return arr;
}

-----
function replaceElements(arr) 
    // Your code here
}

************************************
Question ID: 1232
function findBestValue(arr, target) {
    let left = 0;
    let right = Math.max(...arr);
    let result = -1;
    let min_diff = Infinity;

    while (left <= right) {
        let mid = Math.floor(left + (right - left) / 2);
        let sum = 0;
        for (let num of arr) {
            sum += Math.min(num, mid);
        }
        if (sum === target) {
            return mid;
        }
        else if (sum > target) {
            right = mid - 1;
        }
        else {
            left = mid + 1;
        }
        if (Math.abs(target - sum) < min_diff || (Math.abs(target - sum) === min_diff && mid < result)) {
            min_diff = Math.abs(target - sum);
            result = mid;
        }
    }
    return result;
}

-----
function findBestValue(arr, target) 
    // Your code here
}

************************************
Question ID: 1233
function removeSubfolders(folder) {
    let result = [];
    folder.sort();
    let prefix = "/";
    
    for (let path of folder) {
        if (!path.startsWith(prefix)) {
            result.push(path);
            prefix = path + "/";
        }
    }
    return result;
}

-----
function removeSubfolders(folder) 
    // Your code here
}

************************************
Question ID: 1234
function getMaxSumAndCount(board) {
    const mod = 1000000007;
    const n = board.length;
    const dp = Array.from({ length: n }, () => Array.from({ length: n }, () => [0, 0]));
    dp[n - 1][n - 1] = [0, 1];

    for (let i = n - 1; i >= 0; i--) {
        for (let j = n - 1; j >= 0; j--) {
            if (board[i][j] === 'X' || (i === n - 1 && j === n - 1)) continue;
            const currVal = board[i][j] === 'E' ? 0 : parseInt(board[i][j]);
            const up = i > 0 ? dp[i - 1][j] : [-1, 0];
            const left = j > 0 ? dp[i][j - 1] : [-1, 0];
            const diag = i > 0 && j > 0 ? dp[i - 1][j - 1] : [-1, 0];

            const maxArray = getMax(up, left, diag);
            if (maxArray[0] === -1) continue;

            dp[i][j][0] = maxArray[0] + currVal;
            if (arraysEqual(up, maxArray)) dp[i][j][1] = (dp[i][j][1] + up[1] % mod) % mod;
            if (arraysEqual(left, maxArray)) dp[i][j][1] = (dp[i][j][1] + left[1] % mod) % mod;
            if (arraysEqual(diag, maxArray)) dp[i][j][1] = (dp[i][j][1] + diag[1] % mod) % mod;
        }
    }
    return dp[0][0];
}

function getMax(a, b, c) {
    if (a[0] >= b[0] && a[0] >= c[0]) return a;
    if (b[0] >= a[0] && b[0] >= c[0]) return b;
    return c;
}

function arraysEqual(a, b) {
    return a.length === b.length && a.every((val, index) => val === b[index]);
}


-----
function getMaxSumAndCount(board) 
    // Your code here
}


************************************
Question ID: 1235
function jobScheduling(startTime, endTime, profit) {
    const n = startTime.length;
    const jobs = [];

    for (let i = 0; i < n; i++) {
        jobs.push([endTime[i], startTime[i], profit[i]]);
    }

    jobs.sort((a, b) => a[0] - b[0]);
    const dp = new Array(n);
    dp[0] = jobs[0][2];

    for (let i = 1; i < n; i++) {
        let L = -1;
        for (let j = i - 1; j >= 0; j--) {
            if (jobs[j][1] >= jobs[L === -1 ? i : L][0]) {
                L = j;
            }
        }
        dp[i] = Math.max(dp[i - 1], (L === -1 ? 0 : dp[L]) + jobs[i][2]);
    }

    return dp[n - 1];
}

-----
function jobScheduling(startTime, endTime, profit) 
    // Your code here
}

************************************
Question ID: 1236
function tribonacci(n) {
    if(n==0) return 0;
    if(n==1 || n==2) return 1;
    let a = 0, b = 1, c = 1, d;
    for(let i = 3; i <= n; ++i) {
        d = a + b + c;
        a = b;
        b = c;
        c = d;
    }
    return c;
}

-----
function tribonacci(n) 
    // Your code here
}

************************************
Question ID: 1237
var findSolution = function(customFunction, z) {
    let results = [];
    for (let x = 1; x <= 1000; x++) {
        for (let y = 1; y <= 1000; y++) {
            if (customFunction.f(x, y) === z) {
                results.push([x, y]);
            } else if (customFunction.f(x, y) > z) {
                break;
            }
        }
    }
    return results;
};

-----
var findSolution = function(customFunction, z) 
    // Your code here
};

************************************
Question ID: 1238
function alphabetBoardPath(target) {
    let res = '';
    let startX = 0;
    let startY = 0;
    
    for (let t of target) {
        let newPos = t.charCodeAt(0) - 'a'.charCodeAt(0);
        let targetX = Math.floor(newPos / 5);
        let targetY = newPos % 5;
        
        while (startX > targetX) {
            res += 'U';
            startX--;
        }
        while (startY > targetY) {
            res += 'L';
            startY--;
        }
        while (startX < targetX) {
            res += 'D';
            startX++;
        }
        while (startY < targetY) {
            res += 'R';
            startY++;
        }
        res += '!';
    }
    return res;
}


-----
function alphabetBoardPath(target) 
    // Your code here
}


************************************
Question ID: 1239
function largest1BorderedSquare(grid) {
    const m = grid.length;
    const n = grid[0].length;
    const horizontal = Array.from({ length: m }, () => Array(n).fill(0));
    const vertical = Array.from({ length: m }, () => Array(n).fill(0));

    let maxSquareSize = 0;

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (grid[i][j] === 1) {
                horizontal[i][j] = (j === 0) ? 1 : horizontal[i][j - 1] + 1;
                vertical[i][j] = (i === 0) ? 1 : vertical[i - 1][j] + 1;

                let minSize = Math.min(horizontal[i][j], vertical[i][j]);
                while (minSize > maxSquareSize) {
                    if (horizontal[i - minSize + 1][j] >= minSize &&
                        vertical[i][j - minSize + 1] >= minSize) {
                        maxSquareSize = minSize;
                    }
                    minSize--;
                }
            }
        }
    }

    return maxSquareSize * maxSquareSize;
}

-----
function largest1BorderedSquare(grid) 
    // Your code here
}

************************************
Question ID: 1240
function stoneGameII(piles) {
    let n = piles.length;
    let memo = new Array(n).fill(0).map(() => new Array(n + 1).fill(0));
    
    for (let i = n - 2 ; i >= 0; --i) {
        piles[i] += piles[i + 1];
    }

    function search(idx, M) {
        if (idx + 2 * M >= n) {
            return piles[idx];
        }
        
        if (memo[idx][M] > 0) {
            return memo[idx][M];
        }
        
        memo[idx][M] = 0;
        
        for (let x = 1; x <= 2 * M; ++x) {
            memo[idx][M] = Math.max(memo[idx][M], piles[idx] - search(idx + x, Math.max(M, x)));
        }
        
        return memo[idx][M];
    }
    
    return search(0, 1);
}

-----
function stoneGameII(piles) 
    // Your code here
}

************************************
Question ID: 1243
function sumEvenGrandparent(root, parent = null, grandparent = null) {
    if (!root) return 0;
    let sum = 0;
    if (grandparent && grandparent.val % 2 === 0) {
        sum += root.val;
    }
    sum += sumEvenGrandparent(root.left, root, parent) + sumEvenGrandparent(root.right, root, parent);
    return sum;
}


-----
function sumEvenGrandparent(root, parent = null, grandparent = null) 
    // Your code here
}


************************************
Question ID: 1244
function numDistinctRepeatedSubstrings(s) {
  let seen = new Set();
  for (let len = Math.floor(s.length / 2); len >= 1; len--) {
    for (let i = 0; i <= s.length - 2 * len; i++) {
      let substr = s.slice(i, i + len);
      if (s.indexOf(substr, i + len) !== -1)
        seen.add(substr);
    }
  }
  return seen.size;
}


-----
function numDistinctRepeatedSubstrings(s) 
    // Your code here
}


************************************
Question ID: 1245
/**
 * @param {number[][]} edges
 * @return {number}
 */
var treeDiameter = function(edges) {
    const tree = new Map();
    
    for (const edge of edges) {
        if (!tree.has(edge[0])) tree.set(edge[0], []);
        if (!tree.has(edge[1])) tree.set(edge[1], []);
        
        tree.get(edge[0]).push(edge[1]);
        tree.get(edge[1]).push(edge[0]);
    }
    
    const queue = [[0, 0]];
    let furthest = 0;
    let maxDistance = 0;
    
    while (queue.length > 0) {
        const [node, distance] = queue.shift();
        if (distance > maxDistance) {
            maxDistance = distance;
            furthest = node;
        }
        
        for (const neighbor of tree.get(node)) {
            tree.get(neighbor).splice(tree.get(neighbor).indexOf(node), 1);
            queue.push([neighbor, distance + 1]);
        }
    }
    
    queue.push([furthest, 0]);
    maxDistance = 0;
    
    while (queue.length > 0) {
        const [node, distance] = queue.shift();
        if (distance > maxDistance) {
            maxDistance = distance;
        }
        
        for (const neighbor of tree.get(node)) {
            tree.get(neighbor).splice(tree.get(neighbor).indexOf(node), 1);
            queue.push([neighbor, distance + 1]);
        }
    }
    
    return maxDistance;
};

-----
/**
 * @param 
    // Your code here
};

************************************
Question ID: 1246
var minimumMoves = function (arr) {
    let dp = [];
    for (let i = 0; i < arr.length; i++) {
        dp[i] = Array.from({ length: arr.length }, () => -1);
    }

    function minRemovals(i, j) {
        if (i > j) return 0;
        if (i == j) return 1;
        if (dp[i][j] != -1) return dp[i][j];

        let ans = minRemovals(i + 1, j) + 1;
        for (let k = i + 1; k <= j; k++) {
            if (arr[i] == arr[k])
                ans = Math.min(ans, minRemovals(i + 1, k - 1) + minRemovals(k + 1, j));
        }
        dp[i][j] = ans;
        return ans;
    }

    return minRemovals(0, arr.length - 1);
};

-----
var minimumMoves = function (arr) 
    // Your code here
};

************************************
Question ID: 1247
function movesToMakeZigzag(nums) {
    let moves1 = 0, moves2 = 0;
    for (let i = 0; i < nums.length; i++) {
        let left = i > 0 ? nums[i - 1] : Number.MAX_VALUE;
        let right = i + 1 < nums.length ? nums[i + 1] : Number.MAX_VALUE;
        let diff1 = nums[i] - Math.min(left, right) + 1;
        let diff2 = nums[i] - Math.min(left, right) + 1;
        if (i % 2 === 0) {
            moves1 += Math.max(0, diff1);
        } else {
            moves2 += Math.max(0, diff2);
        }
    }
    return Math.min(moves1, moves2);
}

-----
function movesToMakeZigzag(nums) 
    // Your code here
}

************************************
Question ID: 1250
function gcd(a, b) {
    return b === 0 ? a : gcd(b, a % b);
}

function isGoodArray(nums) {
    let res = nums[0];
    for (let num of nums) {
        res = gcd(res, num);
    }
    return res === 1;
}

-----
function gcd(a, b) 
    // Your code here
}

************************************
Question ID: 1252
function breakPalindrome(palindrome) {
    const n = palindrome.length;
    if (n < 2) return "";
    
    let arr = palindrome.split("");
    for (let i = 0; i < Math.floor(n / 2); i++) {
        if (arr[i] !== 'a') {
            arr[i] = 'a';
            return arr.join("");
        }
    }
    
    arr[n - 1] = 'b';
    return arr.join("");
}

-----
function breakPalindrome(palindrome) 
    // Your code here
}

************************************
Question ID: 1253
function diagonalSort(mat) {
    const m = mat.length, n = mat[0].length;
    for (let i = 0; i < m; ++i) {
        let pq = [];
        let [row, col] = [i, 0];
        while (row < m && col < n) {
            pq.push(mat[row++][col++]);
        }
        pq.sort((a, b) => a - b);
        [row, col] = [i, 0];
        while (row < m && col < n) {
            mat[row++][col++] = pq.shift();
        }
    }
    for (let i = 1; i < n; ++i) {
        let pq = [];
        let [row, col] = [0, i];
        while (row < m && col < n) {
            pq.push(mat[row++][col++]);
        }
        pq.sort((a, b) => a - b);
        [row, col] = [0, i];
        while (row < m && col < n) {
            mat[row++][col++] = pq.shift();
        }
    }
    return mat;
}


-----
function diagonalSort(mat) 
    // Your code here
}


************************************
Question ID: 1254
function closedIsland(grid) {
    function dfs(grid, i, j) {
        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length) {
            return false;
        }

        if (grid[i][j] == 1) {
            return true;
        }

        grid[i][j] = 1;

        const up = dfs(grid, i - 1, j);
        const down = dfs(grid, i + 1, j);
        const left = dfs(grid, i, j - 1);
        const right = dfs(grid, i, j + 1);

        return up && down && left && right;
    }

    let count = 0;
    for (let i = 0; i < grid.length; i++) {
        for (let j = 0; j < grid[0].length; j++) {
            if (grid[i][j] == 0 && dfs(grid, i, j)) {
                count++;
            }
        }
    }

    return count;
}


-----
function closedIsland(grid) 
    // Your code here
}


************************************
Question ID: 1255
function maxValueAfterReverse(nums) {
    let total = 0, diff = 0;
    let min2 = Infinity, max2 = -Infinity;
    for (let i = 0; i < nums.length - 1; ++i) {
        total += Math.abs(nums[i] - nums[i + 1]);
        min2 = Math.min(min2, Math.max(nums[i], nums[i + 1]));
        max2 = Math.max(max2, Math.min(nums[i], nums[i + 1]));
        diff = Math.max(diff, Math.abs(nums[i + 1] - nums[0]) - Math.abs(nums[i + 1] - nums[i]));
        diff = Math.max(diff, Math.abs(nums[i] - nums[nums.length - 1]) - Math.abs(nums[i] - nums[i + 1]));
    }
    return total + Math.max(diff, 2 * (max2 - min2));
}

-----
function maxValueAfterReverse(nums) 
    // Your code here
}

************************************
Question ID: 1256
function arrayRankTransform(arr) {
    const sortedArr = [...arr].sort((a, b) => a - b);
    const rankMap = {};
    let rank = 1;

    for(const num of sortedArr) {
        if(!(num in rankMap)) {
            rankMap[num] = rank++;
        }
    }

    return arr.map(num => rankMap[num]);
}

-----
function arrayRankTransform(arr) 
    // Your code here
}

************************************
Question ID: 1257
function matrixRankTransform(matrix) {
    function* neighbours(r, c) {
        for (let i = 0; i < m; ++i) if (i != r) yield [i, c];
        for (let i = 0; i < n; ++i) if (i != c) yield [r, i];
    }

    const m = matrix.length, n = matrix[0].length;
    const rank = Array.from({length: m}, () => Array(n).fill(0));
    const sorted_row = new Array(m).fill(0);
    const sorted_col = new Array(n).fill(0);

    for (let bound = 0; bound <= 200000; bound++) {
        const q = [];
        for (let i = 0; i < m; ++i) {
            for (let j = 0; j < n; ++j) {
                if (matrix[i][j] == bound && rank[i][j] == 0) {
                    q.push([i, j]);
                }
            }
        }
        if (q.length === 0) break;
        while (q.length > 0) {
            const [r, c] = rc = q.shift();
            let potential_rank = sorted_row[r] + 1;
            for (const [row, col] of neighbours(r, c)) {
                if (matrix[row][col] <= matrix[r][c]) {
                    potential_rank = Math.max(potential_rank, rank[row][col] + (matrix[row][col] < matrix[r][c] ? 0 : 1));
                }
            }
            if (potential_rank === (sorted_col[c] + 1)) {
                rank[r][c] = sorted_row[r] = sorted_col[c] = potential_rank;
            } else {
                q.push(rc);
            }
        }
    }
    return rank;
}

-----
function matrixRankTransform(matrix) 
    // Your code here
}

************************************
Question ID: 1258
function generateSentences(synonyms, text) {
    const synonymMap = new Map();

    for (const [s, t] of synonyms) {
        if (!synonymMap.has(s)) {
            synonymMap.set(s, new Set([s]));
        }
        if (!synonymMap.has(t)) {
            synonymMap.set(t, new Set([t]));
        }
        synonymMap.get(s).add(t);
        synonymMap.get(t).add(s);
    }

    const words = text.split(" ");
    const results = [];

    function helper(index, curSentence) {
        if (index === words.length) {
            results.push(curSentence.join(" "));
        } else {
            const synSet = synonymMap.get(words[index]) || new Set([words[index]]);

            for (const w of synSet) {
                curSentence.push(w);
                helper(index + 1, curSentence);
                curSentence.pop();
            }
        }
    }

    helper(0, []);

    return results.sort();
}


-----
function generateSentences(synonyms, text) 
    // Your code here
}


************************************
Question ID: 1259
function numberOfWays(numPeople) {
    const MOD = 1000000007;
    let dp = new Array(numPeople / 2 + 1).fill(0);
    dp[0] = 1;
    for (let i = 1; i <= numPeople / 2; ++i) {
        for (let j = 1; j <= i; ++j) {
            dp[i] = (dp[i] + (dp[i - j] * dp[j - 1]) % MOD) % MOD;
        }
    }
    return dp[numPeople / 2];
}


-----
function numberOfWays(numPeople) 
    // Your code here
}


************************************
Question ID: 1260
function dayOfYear(date) {
    let [year, month, day] = date.split('-').map(x => parseInt(x, 10));

    let daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    if (year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)) {
        daysInMonth[2] = 29;
    }

    let dayOfYear = 0;
    for (let i = 1; i < month; i++) {
        dayOfYear += daysInMonth[i];
    }
    dayOfYear += day;

    return dayOfYear;
}

-----
function dayOfYear(date) 
    // Your code here
}

************************************
Question ID: 1262
class MajorityChecker {
    constructor(arr) {
        this.arr = arr;
        this.positions = new Map();
        for(let i = 0; i < arr.length; i++) {
            if (!this.positions.has(arr[i])) this.positions.set(arr[i], []);
            this.positions.get(arr[i]).push(i);
        }
    }

    query(left, right, threshold) {
        for(let i = 0; i < 20; i++) {
            let randomIndex = Math.floor(Math.random() * (right - left + 1)) + left;
            let num = this.positions.get(this.arr[randomIndex]).length;
            if (num >= threshold) {
                let lb = this.lower_bound(this.positions.get(this.arr[randomIndex]), left);
                let ub = this.upper_bound(this.positions.get(this.arr[randomIndex]), right);
                if(ub - lb >= threshold) return this.arr[randomIndex];
            }
        }
        return -1;
    }

    lower_bound(nums, target) {
        let l = 0, r = nums.length;
        while (l < r) {
            let mid = Math.floor((l + r) / 2);
            if (nums[mid] < target) l = mid + 1;
            else r = mid;
        }
        return l;
    }

    upper_bound(nums, target) {
        let l = 0, r = nums.length;
        while (l < r) {
            let mid = Math.floor((l + r) / 2);
            if (nums[mid] <= target) l = mid + 1;
            else r = mid;
        }
        return l;
    }
}

-----
class MajorityChecker 
    // Your code here
}

************************************
Question ID: 1263
function numRollsToTarget(n, k, target) {
    const MOD = 1e9 + 7;
    let dp = Array.from({ length: n + 1 }, () => Array(target + 1).fill(0));
    dp[0][0] = 1;
    
    for (let i = 1; i <= n; ++i) {
        for (let j = 1; j <= target; ++j) {
            for (let l = 1; l <= k; ++l) {
                if (j >= l) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - l]) % MOD;
                }
            }
        }
    }
    return dp[n][target];
}

-----
function numRollsToTarget(n, k, target) 
    // Your code here
}

************************************
Question ID: 1265
function printLinkedListInReverse(head) {
    if (head !== null) {
        printLinkedListInReverse(head.getNext());
        head.printValue();
    }
}

-----
function printLinkedListInReverse(head) 
    // Your code here
}

************************************
Question ID: 1266
function minTimeToVisitAllPoints(points) {
    let time = 0;
    for (let i = 1; i < points.length; i++) {
        let dx = Math.abs(points[i][0] - points[i - 1][0]);
        let dy = Math.abs(points[i][1] - points[i - 1][1]);
        time += Math.max(dx, dy);
    }
    return time;
}

-----
function minTimeToVisitAllPoints(points) 
    // Your code here
}

************************************
Question ID: 1267
function removeZeroSumSublists(head) {
    const dummy = new ListNode(0);
    dummy.next = head;
    let current = dummy;

    while (current) {
        let sum = 0;
        while (head) {
            sum += head.val;
            if (sum === 0) {
                current.next = head.next;
            }
            head = head.next;
        }
        current = current.next;
        if (current) {
            head = current.next;
        }
    }

    return dummy.next;
}


-----
function removeZeroSumSublists(head) 
    // Your code here
}


************************************
Question ID: 1268
function suggestedProducts(products, searchWord) {
    let result = [];
    products.sort();
    
    for (let i = 0; i < searchWord.length; ++i) {
        let suggestions = [];
        for (let product of products) {
            if (product.length > i && product[i] === searchWord[i]) {
                suggestions.push(product);
                if (suggestions.length === 3) break;
            }
        }
        result.push(suggestions);
    }
    
    return result;
}


-----
function suggestedProducts(products, searchWord) 
    // Your code here
}


************************************
Question ID: 1269
const mod = 1e9 + 7;

function numOfWays(steps, arrLen) {
  const maxPos = Math.min(Math.floor(steps / 2), arrLen - 1);
  const dp = [[], []];
  dp[0][0] = 1;

  for (let s = 1; s <= steps; s++) {
    for (let p = 0; p <= maxPos; p++) {
      dp[s % 2][p] = dp[(s - 1) % 2][p];
      if (p > 0) {
        dp[s % 2][p] += dp[(s - 1) % 2][p - 1];
      }
      if (p < maxPos) {
        dp[s % 2][p] += dp[(s - 1) % 2][p + 1];
      }
      dp[s % 2][p] %= mod;
    }
  }
  return dp[steps % 2][0];
}


-----
const mod = 1e9 + 7;

function numOfWays(steps, arrLen) 
    // Your code here
}


************************************
Question ID: 1271
function toHexspeak(num) {
    let n = BigInt(num);
    let hex = '';
    while (n) {
        let rem = Number(n % 16n);
        if (rem === 1) hex = 'I' + hex;
        else if (rem === 0) hex = 'O' + hex;
        else if (rem > 9) hex = String.fromCharCode(rem - 10 + 'A'.charCodeAt(0)) + hex;
        else return 'ERROR';
        n /= 16n;
    }
    return hex;
}

-----
function toHexspeak(num) 
    // Your code here
}

************************************
Question ID: 1272
function invalidTransactions(transactions) {
    const trans_map = new Map();

    for (let trans of transactions) {
        let temp = trans.split(",");
        if (!trans_map.has(temp[0])) {
            trans_map.set(temp[0], []);
        }
        trans_map.get(temp[0]).push(temp);
    }

    let ans = [];

    for (let trans of transactions) {
        let temp = trans.split(",");

        if (parseInt(temp[2]) > 1000) {
            ans.push(trans);
            continue;
        }

        let others = trans_map.get(temp[0]);

        for (let other of others) {
            if (other[3] !== temp[3] && Math.abs(parseInt(other[1]) - parseInt(temp[1])) <= 60) {
                ans.push(trans);
                break;
            }
        }
    }

    return ans;
}


-----
function invalidTransactions(transactions) 
    // Your code here
}


************************************
Question ID: 1273
function countSmallerFrequencies(words, queries) {
    const freqWords = words.map(word => {
        const minChar = Math.min(...word);
        return word.split(minChar).length - 1;
    });
    
    const ans = [];
    for (const query of queries) {
        const minChar = Math.min(...query);
        const freqQuery = query.split(minChar).length - 1;
        
        ans.push(freqWords.filter(f => f > freqQuery).length);
    }
    
    return ans;
}

-----
function countSmallerFrequencies(words, queries) 
    // Your code here
}

************************************
Question ID: 1274
function countDaysBetweenDates(date1, date2) {
    const d1 = new Date(date1);
    const d2 = new Date(date2);
    const difference = Math.abs(d2 - d1);
    return Math.floor(difference / (1000 * 3600 * 24));
}

-----
function countDaysBetweenDates(date1, date2) 
    // Your code here
}

************************************
Question ID: 1275
function validateBinaryTreeNodes(n, leftChild, rightChild) {
    const parent = new Array(n).fill(-1);
    for (let i = 0; i < n; i++) {
        if (leftChild[i] !== -1) {
            if (parent[leftChild[i]] !== -1) return false;
            parent[leftChild[i]] = i;
        }
        if (rightChild[i] !== -1) {
            if (parent[rightChild[i]] !== -1) return false;
            parent[rightChild[i]] = i;
        }
    }
    let root = -1;
    for (let i = 0; i < n; i++) {
        if (parent[i] === -1) {
            if (root !== -1) return false;
            root = i;
        }
    }
    return root !== -1;
}


-----
function validateBinaryTreeNodes(n, leftChild, rightChild) 
    // Your code here
}


************************************
Question ID: 1276
function closestFactors(num) {
    let factor1 = Math.floor(Math.sqrt(num + 2));
    while (true) {
        let factor2 = Math.floor((num + 2) / factor1);
        if (factor1 * factor2 === num + 2) {
            return [factor1, factor2];
        }
        factor2 = Math.floor((num + 1) / factor1);
        if (factor1 * factor2 === num + 1) {
            return [factor1, factor2];
        }
        factor1--;
    }
}

-----
function closestFactors(num) 
    // Your code here
}

************************************
Question ID: 1277
function largestMultipleOfThree(digits) {
    let sum = 0, count = [0, 0, 0];

    for (let d of digits) {
        sum += d;
        count[d % 3]++;
    }

    if (sum % 3 === 1) {
        if (count[1] >= 1) count[1]--; 
        else count[2] -= 2;
    }
    else if (sum % 3 === 2) {
        if (count[2] >= 1) count[2]--;
        else count[1] -= 2;
    }

    let res = "";
    for (let i = 0; i <= 9; ++i) {
        let n = count[i % 3];
        while (n--) res += i;
    }

    if (res.length !== 0 && res[res.length - 1] === '0') return "0";
    return res.split("").reverse().join("");
}

-----
function largestMultipleOfThree(digits) 
    // Your code here
}

************************************
Question ID: 1278
function palindromePartition(s, k) {
    const n = s.length;
    const dp = Array.from(Array(n), () => Array(n).fill(0));

    for (let len = 2; len <= n; ++len) {
        for (let i = 0; i <= n - len; ++i) {
            const j = i + len - 1;
            dp[i][j] = dp[i + 1][j - 1] + (s[i] !== s[j] ? 1 : 0);
        }
    }

    const memo = Array(n).fill(1e9);
    for (let i = 0; i < n; ++i) {
        if (dp[0][i] === 0) {
            memo[i] = 0;
        } else {
            for (let j = 0; j < i; ++j) {
                memo[i] = Math.min(memo[i], memo[j] + dp[j + 1][i]);
            }
        }
    }

    return memo[memo.length - 1] + k;
}


-----
function palindromePartition(s, k) 
    // Your code here
}


************************************
Question ID: 1281
function canMakePaliQueries(s, queries) {
    const result = [];
    for (const query of queries) {
        const [left, right, k] = query;
        const count = Array(26).fill(0);
        for (let i = left; i <= right; i++) {
            count[s.charCodeAt(i) - 97]++;
        }
        const odd_count = count.reduce((acc, val) => acc + (val % 2), 0);
        result.push(Math.floor(odd_count / 2) <= k);
    }
    return result;
}

-----
function canMakePaliQueries(s, queries) 
    // Your code here
}

************************************
Question ID: 1282
function groupThePeople(groupSizes) {
    const groups = {};
    const result = [];

    for (let i = 0; i < groupSizes.length; i++) {
        const size = groupSizes[i];
        if (!groups[size]) {
            groups[size] = [];
        }
        groups[size].push(i);

        if (groups[size].length === size) {
            result.push(groups[size]);
            groups[size] = [];
        }
    }

    return result;
}

-----
function groupThePeople(groupSizes) 
    // Your code here
}

************************************
Question ID: 1283
function formatDate(date) {
    const months = {
        "Jan": "01",
        "Feb": "02",
        "Mar": "03",
        "Apr": "04",
        "May": "05",
        "Jun": "06",
        "Jul": "07",
        "Aug": "08",
        "Sep": "09",
        "Oct": "10",
        "Nov": "11",
        "Dec": "12",
    };

    const [day, month, year] = date.split(" ");
    return `${year}-${months[month]}-${day}`;
}

-----
function formatDate(date) 
    // Your code here
}

************************************
Question ID: 1284
function sumOfDivisorsWithFourDivisors(nums) {
    let sum = 0;
    for (let num of nums) {
        let divCount = 0;
        let divSum = 0;

        for (let i = 1; i * i <= num; ++i) {
            if (num % i === 0) {
                divSum += i;
                ++divCount;

                if (num / i !== i) {
                    divSum += (num / i);
                    ++divCount;
                }
            }

            if (divCount > 4) {
                break;
            }
        }

        if (divCount === 4) {
            sum += divSum;
        }
    }

    return sum;
}


-----
function sumOfDivisorsWithFourDivisors(nums) 
    // Your code here
}


************************************
Question ID: 1286
function maxSumSubsequence(nums, k) {
    const n = nums.length;
    const dp = new Array(n).fill(0);
    let result = 0;

    for (let i = 0; i < n; ++i) {
        dp[i] = nums[i];
        for (let j = Math.max(0, i - k); j < i; ++j) {
            dp[i] = Math.max(dp[i], dp[j] + nums[i]);
        }
        result = Math.max(result, dp[i]);
    }

    return result;
}

-----
function maxSumSubsequence(nums, k) 
    // Your code here
}

************************************
Question ID: 1287
function shortestDistance(distance, start, destination) {
    let total_distance = 0, clockwise_distance = 0;
    
    for (let i = 0; i < distance.length; ++i) {
        total_distance += distance[i];
        if (i >= start && i < destination) {
            clockwise_distance += distance[i];
        }
    }
    
    return Math.min(clockwise_distance, total_distance - clockwise_distance);
}

-----
function shortestDistance(distance, start, destination) 
    // Your code here
}

************************************
Question ID: 1288
function maximumSum(arr) {
    const n = arr.length;
    const sumWithoutDeletion = new Array(n).fill(0);
    const sumWithDeletion = new Array(n).fill(0);
    sumWithoutDeletion[0] = arr[0];
    sumWithDeletion[0] = 0;
    let maxSum = arr[0];

    for (let i = 1; i < n; i++) {
        sumWithoutDeletion[i] = Math.max(arr[i], sumWithoutDeletion[i - 1] + arr[i]);
        sumWithDeletion[i] = Math.max(sumWithDeletion[i - 1] + arr[i], sumWithoutDeletion[i - 1]);
        maxSum = Math.max(maxSum, Math.max(sumWithoutDeletion[i], sumWithDeletion[i]));
    }
    return maxSum;
}

-----
function maximumSum(arr) 
    // Your code here
}

************************************
Question ID: 1289
function dayOfTheWeek(day, month, year) {
    const days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    if (month < 3) {
        month += 12;
        year -= 1;
    }
    const k = year % 100;
    const j = Math.floor(year / 100);
    const dayOfWeek = (day + Math.floor(13 * (month + 1) / 5) + k + Math.floor(k / 4) + 5 * j + Math.floor(j / 4)) % 7;
    return days[dayOfWeek];
}

-----
function dayOfTheWeek(day, month, year) 
    // Your code here
}

************************************
Question ID: 1290
function minOperations(arr1, arr2) {
    const n = arr1.length;
    const dp = new Array(n).fill(Number.MAX_VALUE);
    for (const a of arr2) {
        const new_dp = new Array(n).fill(Number.MAX_VALUE);
        let p = 0;
        for (let i = 0; i < n; i++) {
            if (a < arr1[i]) new_dp[i] = p;
            if (i > 0 && dp[i - 1] < p) p = dp[i - 1];
            if (arr1[i] > arr1[i + 1]) return -1;
        }
        dp.splice(0, dp.length, ...new_dp);
    }
    return dp[n - 1];
}

-----
function minOperations(arr1, arr2) 
    // Your code here
}

************************************
Question ID: 1291
function sequentialDigits(low, high) {
    const result = [];
    for (let i = 1; i <= 9; ++i) {
        let number = i;
        for (let j = i + 1; j <= 9; ++j) {
            number = number * 10 + j;
            if (number >= low && number <= high) {
                result.push(number);
            }
        }
    }
    return result.sort((a, b) => a - b);
}

-----
function sequentialDigits(low, high) 
    // Your code here
}

************************************
Question ID: 1292
function maxSideLength(mat, threshold) {
    const m = mat.length, n = mat[0].length;
    const preSum = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));
    for (let i = 1; i <= m; ++i) {
        for (let j = 1; j <= n; ++j) {
            preSum[i][j] = mat[i - 1][j - 1] + preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1];
        }
    }

    let maxSide = 0;
    for (let i = 1; i <= m; ++i) {
        for (let j = 1; j <= n; ++j) {
            for (let k = 1; k <= Math.min(m, n); ++k) {
                const endX = i + k - 1, endY = j + k - 1;
                if (endX <= m && endY <= n) {
                    const sum = preSum[endX][endY] - preSum[endX][j - 1] - preSum[i - 1][endY] + preSum[i - 1][j - 1];
                    if (sum <= threshold) {
                        maxSide = Math.max(maxSide, k);
                    }
                } else {
                    break;
                }
            }
        }
    }
    return maxSide;
}


-----
function maxSideLength(mat, threshold) 
    // Your code here
}


************************************
Question ID: 1293
function shortestPath(grid, k) {
    const m = grid.length;
    const n = grid[0].length;
    const visited = Array.from({ length: m }, () => Array.from({ length: n }, () => Array(k + 1).fill(false)));
    const q = [[0, 0, 0, k]];
    const moves = [[0, 1], [0, -1], [1, 0], [-1, 0]];
    let steps = 0;

    while (q.length > 0) {
        const size = q.length;
        for (let i = 0; i < size; i++) {
            const [x, y, , k_remaining] = q.shift();
            if (x === m - 1 && y === n - 1) return steps;

            for (let [dx, dy] of moves) {
                const newX = x + dx;
                const newY = y + dy;
                if (newX >= 0 && newX < m && newY >= 0 && newY < n) {
                    const newKRemaining = k_remaining - grid[newX][newY];
                    if (newKRemaining >= 0 && !visited[newX][newY][newKRemaining]) {
                        visited[newX][newY][newKRemaining] = true;
                        q.push([newX, newY, steps + 1, newKRemaining]);
                    }
                }
            }
        }
        steps++;
    }

    return -1;
}

-----
function shortestPath(grid, k) 
    // Your code here
}

************************************
Question ID: 1295
function minPerimeter(neededApples) {
    let layer = 0;
    let apples = 0;

    while (apples < neededApples) {
        layer++;
        apples += 12 * layer;
    }

    return 8 * layer;
}

-----
function minPerimeter(neededApples) 
    // Your code here
}

************************************
Question ID: 1297
function maxNumberOfBalloons(text) {
    let freqs = Array(26).fill(0);
    for (let c of text) {
        freqs[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;
    }
    let subs = [freqs['b'.charCodeAt(0) - 'a'.charCodeAt(0)], freqs['a'.charCodeAt(0) - 'a'.charCodeAt(0)], Math.floor(freqs['l'.charCodeAt(0) - 'a'.charCodeAt(0)] / 2), Math.floor(freqs['o'.charCodeAt(0) - 'a'.charCodeAt(0)] / 2), freqs['n'.charCodeAt(0) - 'a'.charCodeAt(0)]];
    return Math.min(...subs);
}


-----
function maxNumberOfBalloons(text) 
    // Your code here
}


************************************
Question ID: 1298
function reverseParentheses(s) {
    const st = [];
    let result = "";

    for (const c of s) {
        if (c !== ')') {
            st.push(c);
        } else {
            let temp = "";
            while (st.length > 0 && st[st.length - 1] !== '(') {
                temp += st.pop();
            }
            if (st.length > 0) st.pop(); // Remove '('
            for (const t of temp) {
                st.push(t);
            }
        }
    }

    result = st.join("");
    return result;
}


-----
function reverseParentheses(s) 
    // Your code here
}


************************************
Question ID: 1299
function kConcatenationMaxSum(arr, k) {
    const M = 1_000_000_007;
    let sum = 0, maxSum = 0, curMax = 0;
    for (let i = 0; i < arr.length; i++) {
        sum += arr[i];
        curMax = Math.max(arr[i], curMax + arr[i]);
        maxSum = Math.max(maxSum, curMax);
    }
    if (k === 1) return maxSum % M;
    let twoConcatenation = 0, twoConcatenationMax = 0;
    for (let i = 0; i < 2 * arr.length; i++) {
        twoConcatenation = Math.max(arr[i % arr.length], twoConcatenation + arr[i % arr.length]);
        twoConcatenationMax = Math.max(twoConcatenationMax, twoConcatenation);
    }
    return Math.max(Math.max(maxSum, twoConcatenationMax + (k - 2) * Math.max(0, sum)), 0) % M;
}

-----
function kConcatenationMaxSum(arr, k) 
    // Your code here
}

************************************
Question ID: 1300
function criticalConnections(n, connections) {
    const graph = new Array(n).fill(null).map(() => []);
    for (const [u, v] of connections) {
        graph[u].push(v);
        graph[v].push(u);
    }

    const ans = [];
    const low = new Array(n).fill(-1), disc = new Array(n).fill(-1);
    let time = 0;

    function dfs(u, parent) {
        low[u] = disc[u] = time++;
        for (const v of graph[u]) {
            if (v === parent) continue;
            if (disc[v] === -1) {
                dfs(v, u);
                low[u] = Math.min(low[u], low[v]);
                if (low[v] > disc[u]) ans.push([u, v]);
            } else {
                low[u] = Math.min(low[u], disc[v]);
            }
        }
    }

    dfs(0, -1);
    return ans;
};

-----
function criticalConnections(n, connections) 
    // Your code here
};

************************************
Question ID: 1301
const MOD = 1000000007;

function pathsWithMaxScore(board) {
    const n = board.length;
    const dp = Array.from({length: n}, () => Array(n).fill(0));
    const cnt = Array.from({length: n}, () => Array(n).fill(0));

    board[0] = '0' + board[0].slice(1);
    board[n - 1] = board[n - 1].slice(0, -1) + '0';
    cnt[n - 1][n - 1] = 1;

    for (let i = n-1; i >= 0; i--) {
        for (let j = n-1; j >= 0; j--) {
            if (board[i][j] !== 'X') {
                const neighbors = [[i-1, j], [i, j-1], [i-1, j-1]];
                for (const [x, y] of neighbors) {
                    if (x >= 0 && y >= 0) {
                        if (dp[i][j] < dp[x][y] + parseInt(board[i][j])) {
                            dp[i][j] = dp[x][y] + parseInt(board[i][j]);
                            cnt[i][j] = cnt[x][y];
                        } else if (dp[i][j] === dp[x][y] + parseInt(board[i][j])) {
                            cnt[i][j] = (cnt[i][j] + cnt[x][y]) % MOD;
                        }
                    }
                }
            }
        }
    }

    return [dp[0][0], cnt[0][0]];
}


-----
const MOD = 1000000007;

function pathsWithMaxScore(board) 
    // Your code here
}


************************************
Question ID: 1302
function makeFancyString(s) {
    let result = s[0];
    let count = 1;

    for (let i = 1; i < s.length; i++) {
        if (s[i] === s[i - 1]) {
            count++;
        } else {
            count = 1;
        }
        if (count < 3) {
            result += s[i];
        }
    }

    return result;
}


-----
function makeFancyString(s) 
    // Your code here
}


************************************
Question ID: 1304
function longestHappyString(a, b, c) {
    let res = "";
    let pq = [];

    if (a) pq.push([-a, 'a']);
    if (b) pq.push([-b, 'b']);
    if (c) pq.push([-c, 'c']);

    pq.sort((x, y) => x[0] - y[0]);

    while (pq.length) {
        let curr = pq.pop();
        if (res.length >= 2 && res[res.length - 1] === curr[1] && res[res.length - 2] === curr[1]) {
            if (!pq.length) break;
            let next = pq.pop();
            res += next[1];
            if (next[0] < -1) pq.push([next[0] + 1, next[1]]);
            pq.push(curr);
        } else {
            res += curr[1];
            if (curr[0] < -1) pq.push([curr[0] + 1, curr[1]]);
        }
        pq.sort((x, y) => x[0] - y[0]);
    }

    return res;
}


-----
function longestHappyString(a, b, c) 
    // Your code here
}


************************************
Question ID: 1305
function peopleCanSee(heights) {
    const n = heights.length;
    const ans = new Array(n).fill(0);
    const st = [];

    for (let i = n - 1; i >= 0; --i) {
        while (st.length > 0 && heights[st[st.length - 1]] < heights[i]) {
            const idx = st.pop();
            ans[i]++;
            ans[i] += ans[idx];
        }
        st.push(i);
    }

    return ans;
}


-----
function peopleCanSee(heights) 
    // Your code here
}


************************************
Question ID: 1306
function minimumAbsDifference(arr) {
    arr.sort((a, b) => a - b);
    let min_difference = Infinity;
    let result = [];

    for (let i = 1; i < arr.length; ++i) {
        let difference = arr[i] - arr[i - 1];
        if (difference < min_difference) {
            min_difference = difference;
            result = [[arr[i - 1], arr[i]]];
        } else if (difference === min_difference) {
            result.push([arr[i - 1], arr[i]]);
        }
    }

    return result;
}

-----
function minimumAbsDifference(arr) 
    // Your code here
}

************************************
Question ID: 1307
function nthUglyNumber(n, a, b, c) {
    const gcd = (x, y) => y === 0 ? x : gcd(y, x % y);

    let ab = a * b / gcd(a, b);
    let ac = a * c / gcd(a, c);
    let bc = b * c / gcd(b, c);
    let abc = a * (b * c / gcd(b, c)) / gcd(a, (b * c / gcd(b, c)));

    let left = 0, right = 2e9;
    while (left < right) {
        let mid = left + Math.floor((right - left) / 2);
        let cnt = Math.floor(mid / a) + Math.floor(mid / b) + Math.floor(mid / c) - Math.floor(mid / ab) -
                  Math.floor(mid / ac) - Math.floor(mid / bc) + Math.floor(mid / abc);
        if (cnt < n) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}

-----
function nthUglyNumber(n, a, b, c) 
    // Your code here
}

************************************
Question ID: 1309
function sortItems(n, m, group, beforeItems) {
  function topologicalSort(outdegree, edges) {
    const res = [];
    const q = [];
    for (let i = 0; i < outdegree.length; i++) {
      if (outdegree[i] === 0) q.push(i);
    }
    while (q.length) {
      const u = q.pop();
      res.push(u);
      for (const v of edges.get(u)) {
        outdegree[v]--;
        if (outdegree[v] === 0) {
          q.push(v);
        }
      }
    }
    return res;
  }

  // Calculate outdegrees and dependencies for groups and items
  const groupOutdegree = new Array(m).fill(0);
  const groupEdges = new Map(Array.from({length: m}, () => []));

  const itemOutdegree = new Array(n).fill(0);
  const itemEdges = new Map(Array.from({length: n}, () => []));

  for (let i = 0; i < group.length; i++) {
    for (const dep of beforeItems[i]) {
      const a = group[i], b = group[dep];
      if (a !== -1 && a !== b && !(groupEdges.get(b).length > 0 && groupEdges.get(b)[groupEdges.get(b).length - 1] === a)) {
        groupEdges.get(b).push(a);
        groupOutdegree[a]++;
      }
      if (a !== b) {
        itemEdges.get(dep).push(i);
        itemOutdegree[i]++;
      }
    }
  }

  const groupOrder = topologicalSort(groupOutdegree, groupEdges);
  if (groupOrder.length < m) {
    return [];
  }

  const itemOrder = topologicalSort(itemOutdegree, itemEdges);
  if (itemOrder.length < n) {
    return [];
  }

  // Combine orders
  const res = [];
  for (const gi of groupOrder) {
    for (const idx of itemOrder) {
      if (group[idx] === gi) {
        res.push(idx);
      }
    }
  }

  return res;
}


-----
function sortItems(n, m, group, beforeItems) 
    // Your code here
}


************************************
Question ID: 1310
function waterPlants(plants, capacity) {
    let steps = 0;
    let waterLeft = 0;

    for (let i = 0; i < plants.length; ++i) {
        if (waterLeft < plants[i]) {
            steps += 2 * i + 1; // Refill the watering can
            waterLeft = capacity;
        }
        waterLeft -= plants[i];
        steps++; // Move to the next plant
    }

    return steps;
}


-----
function waterPlants(plants, capacity) 
    // Your code here
}


************************************
Question ID: 1311
function largestMagicSquare(grid) {
    const m = grid.length, n = grid[0].length;
    const row = Array.from({length: m}, () => Array(n + 1).fill(0));
    const col = Array.from({length: m + 1}, () => Array(n).fill(0));
    
    for (let i = 0; i < m; ++i) {
        for (let j = 0; j < n; ++j) {
            row[i][j + 1] = row[i][j] + grid[i][j];
            col[i + 1][j] = col[i][j] + grid[i][j];
        }
    }
    
    for (let k = Math.min(m, n); k > 1; --k) {
        for (let i = 0; i + k - 1 < m; ++i) {
            for (let j = 0; j + k - 1 < n; ++j) {
                const sum = row[i][j + k] - row[i][j];
                let ok = true;
                for (let t = 1; t < k; ++t) {
                    if (row[i + t][j + k] - row[i + t][j] !== sum || col[i + k][j + t] - col[i][j + t] !== sum) {
                        ok = false;
                        break;
                    }
                }
                if (!ok) continue;
                
                let diag1 = 0, diag2 = 0;
                for (let t = 0; t < k; ++t) {
                    diag1 += grid[i + t][j + t];
                    diag2 += grid[i + t][j + k - 1 - t];
                }
                if (diag1 === sum && diag2 === sum) return k;
            }
        }
    }
    
    return 1;
}


-----
function largestMagicSquare(grid) 
    // Your code here
}


************************************
Question ID: 1312
function extractArtifacts(n, artifacts, dig) {
    const artifactCells = new Map();
    const artifactCount = new Map();

    for (let i = 0; i < artifacts.length; i++) {
        for (let r = artifacts[i][0]; r <= artifacts[i][2]; r++) {
            for (let c = artifacts[i][1]; c <= artifacts[i][3]; c++) {
                const cell = r * n + c;
                if (!artifactCells.has(cell)) {
                    artifactCells.set(cell, new Set());
                }
                artifactCells.get(cell).add(i);
                artifactCount.set(i, (artifactCount.get(i) || 0) + 1);
            }
        }
    }
    
    let ans = 0;
    for (const [r, c] of dig) {
        const cell = r * n + c;
        if (artifactCells.has(cell)) {
            for (const artifactId of artifactCells.get(cell)) {
                const remaining = artifactCount.get(artifactId) - 1;
                artifactCount.set(artifactId, remaining);
                if (remaining === 0) ans++;
            }
            artifactCells.delete(cell);
        }
    }
    return ans;
}

-----
function extractArtifacts(n, artifacts, dig) 
    // Your code here
}

************************************
Question ID: 1313
const MOD = 1e9 + 7;

function addRooms(idx, children, memo) {
    if (children[idx].length === 0) return 1;
    if (memo[idx] !== -1) return memo[idx];

    let res = 1;
    let cnt = 0;
    for (const child of children[idx]) {
        cnt++;
        res = (res * addRooms(child, children, memo)) % MOD;
    }

    for (let i = 2; i <= cnt; i++) {
        res = (res * i) % MOD;
    }

    memo[idx] = res;
    return res;
}

function numOfWays(prevRoom) {
    const n = prevRoom.length;
    const children = new Array(n).fill(0).map(() => []);
    for (let i = 1; i < n; i++) {
        children[prevRoom[i]].push(i);
    }

    const memo = new Array(n).fill(-1);
    return addRooms(0, children, memo);
}

-----
const MOD = 1e9 + 7;

function addRooms(idx, children, memo) 
    // Your code here
}

************************************
Question ID: 1314
function matrixBlockSum(mat, k) {
    const m = mat.length;
    const n = mat[0].length;
    const answer = new Array(m).fill(null).map(() => new Array(n).fill(0));

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            for (let r = Math.max(0, i - k); r <= Math.min(m - 1, i + k); r++) {
                for (let c = Math.max(0, j - k); c <= Math.min(n - 1, j + k); c++) {
                    answer[i][j] += mat[r][c];
                }
            }
        }
    }

    return answer;
}

-----
function matrixBlockSum(mat, k) 
    // Your code here
}

************************************
Question ID: 1317
function noZeroIntegers(n) {
    for (let a = 1; a < n; ++a) {
        if (!String(a).includes('0') && !String(n - a).includes('0')) {
            return [a, n - a];
        }
    }
    return [0, 0]; // never gets here
}

-----
function noZeroIntegers(n) 
    // Your code here
}

************************************
Question ID: 1318
function minFlips(a, b, c) {
    let count = 0;
    for (let i = 0; i < 32; ++i) {
        let bitA = (a >> i) & 1;
        let bitB = (b >> i) & 1;
        let bitC = (c >> i) & 1;
        if (bitC === 0) {
            count += bitA + bitB;
        } else {
            count += 1 - (bitA | bitB);
        }
    }
    return count;
}

-----
function minFlips(a, b, c) 
    // Your code here
}

************************************
Question ID: 1319
function uniqueOccurrences(arr) {
    const counts = {};
    for (let num of arr) {
        counts[num] = (counts[num] || 0) + 1;
    }

    const uniqueCounts = new Set();
    for (let count in counts) {
        if (uniqueCounts.has(counts[count])) {
            return false;
        }
        uniqueCounts.add(counts[count]);
    }

    return true;
}

-----
function uniqueOccurrences(arr) 
    // Your code here
}

************************************
Question ID: 1320
function removeDuplicates(s, k) {
    let stack = [];
    for (let c of s) {
        if (stack.length > 0 && stack[stack.length - 1][0] === c) {
            stack[stack.length - 1][1]++;
            if (stack[stack.length - 1][1] === k) stack.pop();
        } else {
            stack.push([c, 1]);
        }
    }
    return stack.map(([c, n]) => c.repeat(n)).join('');
}

-----
function removeDuplicates(s, k) 
    // Your code here
}

************************************
Question ID: 1323
function maximum69Number(num) {
    let numStr = num.toString();
    let numArr = Array.from(numStr);
    for (let i = 0; i < numArr.length; i++) {
        if (numArr[i] == '6') {
            numArr[i] = '9';
            break;
        }
    }
    return parseInt(numArr.join(''));
}

-----
function maximum69Number(num) 
    // Your code here
}

************************************
Question ID: 1324
function findBall(grid) {
    const m = grid.length;
    const n = grid[0].length;
    const result = new Array(n).fill(-1);

    for (let i = 0; i < n; i++) {
        let x = 0, y = i;

        while (x < m) {
            let nx = x + 1;
            let ny = y + grid[x][y];
            if (ny < 0 || ny >= n || grid[x][ny] !== grid[x][y]) break;
            x = nx;
            y = ny;
        }

        if (x === m) {
            result[i] = y;
        }
    }

    return result;
}


-----
function findBall(grid) 
    // Your code here
}


************************************
Question ID: 1325
function maxProbability(n, edges, succProb, start, end) {
  const graph = new Array(n).fill(null).map(() => []);
  for (let i = 0; i < edges.length; i++) {
    const [a, b] = edges[i];
    graph[a].push([b, succProb[i]]);
    graph[b].push([a, succProb[i]]);
  }

  const maxProb = new Array(n).fill(0);
  maxProb[start] = 1;

  const pq = [[1, start]];

  while (pq.length) {
    const [prob, node] = pq.pop();

    if (node === end) {
      return prob;
    }

    if (prob < maxProb[node]) {
      continue;
    }

    for (const [neighbor, edgeProb] of graph[node]) {
      const newProb = prob * edgeProb;
      if (newProb > maxProb[neighbor]) {
        maxProb[neighbor] = newProb;
        pq.push([newProb, neighbor]);

        // Re-sort the queue, so it stays a max heap.
        pq.sort(([a], [b]) => b - a);
      }
    }
  }

  return 0;
}


-----
function maxProbability(n, edges, succProb, start, end) 
    // Your code here
}


************************************
Question ID: 1326
function sumOfFlooredPairs(nums) {
    const mod = 1e9 + 7;
    const maxVal = Math.max(...nums);
    const count = Array(maxVal + 1).fill(0);
    const prefSum = Array(maxVal + 1).fill(0);

    for (let num of nums) {
        count[num]++;
    }

    for (let i = 1; i <= maxVal; i++) {
        prefSum[i] = (prefSum[i - 1] + count[i]) % mod;
    }

    let res = 0;
    for (let x = 1; x <= maxVal; x++) {
        for (let k = 1, nx = x; nx <= maxVal; k++, nx += x) {
            res = (res + ((prefSum[nx] - prefSum[nx - x] + mod) % mod) * k % mod * count[x] % mod) % mod;
        }
    }
    return res;
}

-----
function sumOfFlooredPairs(nums) 
    // Your code here
}

************************************
Question ID: 1328
function breakPalindrome(palindrome) {
    const length = palindrome.length;
    if (length === 1) return "";
    
    let chars = palindrome.split("");
    for (let i = 0; i < Math.floor(length / 2); i++) {
        if (chars[i] !== 'a') {
            chars[i] = 'a';
            return chars.join("");
        }
    }
    
    chars[length - 1] = 'b';
    return chars.join("");
}

-----
function breakPalindrome(palindrome) 
    // Your code here
}

************************************
Question ID: 1329
function minCostToMoveChips(position) {
    let evenCount = 0, oddCount = 0;
    for (let i of position) {
        if (i % 2 === 0)
            evenCount++;
        else
            oddCount++;
    }
    return Math.min(evenCount, oddCount);
}

-----
function minCostToMoveChips(position) 
    // Your code here
}

************************************
Question ID: 1330
function longestSubsequence(arr, difference) {
    const dp = new Map();
    let maxLength = 0;
    for (let num of arr) {
        dp.set(num, (dp.get(num - difference) || 0) + 1);
        maxLength = Math.max(maxLength, dp.get(num));
    }
    return maxLength;
}


-----
function longestSubsequence(arr, difference) 
    // Your code here
}


************************************
Question ID: 1331
function getMaximumGold(grid) {
    let m = grid.length, n = grid[0].length, maxGold = 0;

    const getMaximumGoldHelper = (x, y) => {
        if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] === 0) return 0;

        let originalGold = grid[x][y];
        grid[x][y] = 0;

        let maxGold = 0;
        maxGold = Math.max(maxGold, getMaximumGoldHelper(x + 1, y));
        maxGold = Math.max(maxGold, getMaximumGoldHelper(x - 1, y));
        maxGold = Math.max(maxGold, getMaximumGoldHelper(x, y + 1));
        maxGold = Math.max(maxGold, getMaximumGoldHelper(x, y - 1));

        grid[x][y] = originalGold;
        return maxGold + originalGold;
    };

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (grid[i][j] !== 0) {
                maxGold = Math.max(maxGold, getMaximumGoldHelper(i, j));
            }
        }
    }
    return maxGold;
}


-----
function getMaximumGold(grid) 
    // Your code here
}


************************************
Question ID: 1332
function countStrings(n) {
    const mod = 1e9 + 7;
    let a = 1, b = 1;
    for (let i = 0; i < n; i++) {
        a = (a * 2) % mod;
        b = (b * 3) % mod;
    }
    return (b - a + mod) % mod;
}


-----
function countStrings(n) 
    // Your code here
}


************************************
Question ID: 1333
function sortBasedOnMapping(mapping, nums) {
    const mappedValue = num => {
        return parseInt([...num.toString()].map(d => mapping[parseInt(d)]).join(''));
    };

    return nums.sort((a, b) => mappedValue(a) - mappedValue(b));
}

-----
function sortBasedOnMapping(mapping, nums) 
    // Your code here
}

************************************
Question ID: 1334
function findTheCity(n, edges, distanceThreshold) {
    const distance = Array.from({ length: n }, () => Array(n).fill(10001));

    for (const edge of edges) {
        distance[edge[0]][edge[1]] = edge[2];
        distance[edge[1]][edge[0]] = edge[2];
    }

    for (let i = 0; i < n; i++) distance[i][i] = 0;

    for (let k = 0; k < n; k++) {
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                distance[i][j] = Math.min(distance[i][j], distance[i][k] + distance[k][j]);
            }
        }
    }

    let res = 0, minReachable = n;
    for (let i = 0; i < n; i++) {
        let reachable = 0;
        for (let j = 0; j < n; j++) {
            if (distance[i][j] <= distanceThreshold) reachable++;
        }
        if (reachable <= minReachable) {
            minReachable = reachable;
            res = i;
        }
    }
    return res;
}


-----
function findTheCity(n, edges, distanceThreshold) 
    // Your code here
}


************************************
Question ID: 1335
function maxCandies(candies, k) {
    let left = 1;
    let right = Math.max(...candies);

    while (left <= right) {
        let mid = left + Math.floor((right - left) / 2);
        let count = candies.reduce((acc, candy) => acc + Math.floor(candy / mid), 0);
        if (count >= k) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return right;
}

-----
function maxCandies(candies, k) 
    // Your code here
}

************************************
Question ID: 1337
var kWeakestRows = function(mat, k) {
    const soldiersCount = mat.map((row, idx) => [row.filter(x => x === 1).length, idx]);
    soldiersCount.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
    return soldiersCount.slice(0, k).map(x => x[1]);
};

-----
var kWeakestRows = function(mat, k) 
    // Your code here
};

************************************
Question ID: 1338
function minSetSize(arr) {
    let freq_map = new Map();
    for (let x of arr)
        freq_map.set(x, (freq_map.get(x) || 0) + 1);
    let max_heap = Array.from(freq_map.values());
    max_heap.sort((a, b) => b - a);
    let half = arr.length / 2;
    let cnt = 0;
    let size = 0;
    for (let i = 0; size < half; i++) {
        size += max_heap[i];
        cnt++;
    }
    return cnt;
}

-----
function minSetSize(arr) 
    // Your code here
}

************************************
Question ID: 1340
class DiningPhilosophers {
    constructor() {
        this.forks = Array.from({ length: 5 }, () => new Mutex());
        this.notBusy = Array.from({ length: 5 }, (_, i) => new ConditionVariable(this.forks[i]));
    }

    async wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork) {
        const leftFork = philosopher;
        const rightFork = (philosopher + 1) % 5;

        await this.forks[leftFork].lock();
        try {
            await this.notBusy[leftFork].wait(async () => !(await this.forks[rightFork].tryLock()));
            pickLeftFork();

            try {
                await this.forks[rightFork].lock();
                pickRightFork();
                eat();
                putRightFork();
                this.forks[rightFork].unlock();
                this.notBusy[rightFork].signalAll();

                putLeftFork();
            } finally {
                this.forks[leftFork].unlock();
            }
        } finally {
            this.notBusy[leftFork].signalAll();
        }
    }
}

-----
class DiningPhilosophers 
    // Your code here
}

************************************
Question ID: 1342
function queensAttacktheKing(queens, king) {
    const result = [];
    for (let x = -1; x <= 1; x++) {
        for (let y = -1; y <= 1; y++) {
            if (x === 0 && y === 0) continue;
            let posX = king[0] + x;
            let posY = king[1] + y;
            while (posX >= 0 && posY >= 0 && posX < 8 && posY < 8) {
                for (const queen of queens) {
                    if (posX === queen[0] && posY === queen[1]) {
                        result.push([queen[0], queen[1]]);
                        break;
                    }
                }
                posX += x;
                posY += y;
            }
        }
    }
    return result;
}

-----
function queensAttacktheKing(queens, king) 
    // Your code here
}

************************************
Question ID: 1343
function dieSimulator(n, rollMax) {
    const MOD = 1000000007;
    const dp = Array.from({ length: 6 }, () => Array(n + 1).fill(0));
    const sum = Array(n + 1).fill(0);

    for (let i = 0; i < 6; i++) dp[i][1] = 1;
    sum[1] = 6;

    for (let j = 2; j <= n; j++) {
        let cur_sum = 0;
        for (let i = 0; i < 6; i++) {
            dp[i][j] = sum[j - 1];
            if (j - rollMax[i] - 1 >= 0) {
                dp[i][j] = (dp[i][j] - sum[j - rollMax[i] - 1] + MOD) % MOD;
                if (j - rollMax[i] - 1 >= 1) {
                    dp[i][j] = (dp[i][j] + dp[i][j - rollMax[i] - 1]) % MOD;
                }
            }
            cur_sum = (cur_sum + dp[i][j]) % MOD;
        }
        sum[j] = cur_sum;
    }

    return sum[n];
}

-----
function dieSimulator(n, rollMax) 
    // Your code here
}

************************************
Question ID: 1344
function maxEqualFreq(nums) {
    let count = new Map(), freq = new Map();
    let max_len = 0, max_freq = 0;
    for (let i = 0; i < nums.length; i++) {
        count.set(nums[i], (count.get(nums[i]) || 0) + 1);
        freq.set(count.get(nums[i]) - 1, (freq.get(count.get(nums[i]) - 1) || 0) - 1);
        freq.set(count.get(nums[i]), (freq.get(count.get(nums[i])) || 0) + 1);

        max_freq = Math.max(max_freq, count.get(nums[i]));
        if (max_freq * (i + 1) == i || max_freq * ((freq.get(max_freq - 1) || 0) + 1) + (max_freq - 1) * (freq.get(max_freq - 1) || 0) == i) {
            max_len = i + 1;
        }
    }
    return max_len;
}


-----
function maxEqualFreq(nums) 
    // Your code here
}


************************************
Question ID: 1345
/**
 * @param {number[]} arr
 * @return {number}
 */
function minJumps(arr) {
  const n = arr.length;
  if (n <= 1) return 0;

  const valueIndices = new Map();

  for (let i = 0; i < n; ++i) {
    if (!valueIndices.has(arr[i])) valueIndices.set(arr[i], []);
    valueIndices.get(arr[i]).push(i);
  }

  const q = [0];
  const visited = new Array(n).fill(false);
  visited[0] = true;
  let steps = 0;

  while (q.length) {
    const size = q.length;

    for (let i = 0; i < size; ++i) {
      const index = q.shift();

      if (index === n - 1) return steps;

      if (index > 0 && !visited[index - 1]) {
        q.push(index - 1);
        visited[index - 1] = true;
      }

      if (index < n - 1 && !visited[index + 1]) {
        q.push(index + 1);
        visited[index + 1] = true;
      }

      for (const neighbor of valueIndices.get(arr[index])) {
        if (!visited[neighbor]) {
          q.push(neighbor);
          visited[neighbor] = true;
        }
      }

      valueIndices.set(arr[index], []);
    }

    ++steps;
  }

  return -1;
}

-----
/**
 * @param 
    // Your code here
}

************************************
Question ID: 1346
function maxValueInStack(nums, k) {
    let n = nums.length;
    if (k >= n) return -1;

    let max_val = Number.MIN_SAFE_INTEGER;
    for (let i = 0; i <= k; ++i) {
        max_val = Math.max(max_val, nums[i]);
    }
    return max_val;
}

-----
function maxValueInStack(nums, k) 
    // Your code here
}

************************************
Question ID: 1347
function minSteps(s, t) {
    const s_Count = new Array(26).fill(0);
    const t_Count = new Array(26).fill(0);
    for(let c of s) s_Count[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;
    for(let c of t) t_Count[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;
    let res = 0;
    for(let i = 0; i < 26; i++) {
        res += Math.abs(s_Count[i] - t_Count[i]);
    }
    return res / 2;
}

-----
function minSteps(s, t) 
    // Your code here
}

************************************
Question ID: 1348
class TweetCounts {
    constructor() {
        this.data = new Map();
    }

    recordTweet(tweetName, time) {
        if (!this.data.has(tweetName)) {
            this.data.set(tweetName, new Map());
        }
        const times = this.data.get(tweetName);
        times.set(time, (times.get(time) || 0) + 1);
    }

    getTweetCountsPerFrequency(freq, tweetName, startTime, endTime) {
        const step = freq === "minute" ? 60 : freq === "hour" ? 3600 : 86400;
        const chunks = new Array(Math.floor((endTime - startTime) / step) + 1).fill(0);

        if (this.data.has(tweetName)) {
            for (const [time, count] of this.data.get(tweetName)) {
                const chunkIndex = Math.floor((time - startTime) / step);
                if (chunkIndex >= 0 && chunkIndex < chunks.length) {
                    chunks[chunkIndex] += count;
                }
            }
        }

        return chunks;
    }
}

-----
class TweetCounts 
    // Your code here
}

************************************
Question ID: 1349
var checkStraightLine = function(coordinates) {
    let dx = coordinates[1][0] - coordinates[0][0];
    let dy = coordinates[1][1] - coordinates[0][1];

    for(let i = 2; i < coordinates.length; i++) {
        let x = coordinates[i][0] - coordinates[0][0];
        let y = coordinates[i][1] - coordinates[0][1];
        if(dx * y != dy * x) return false;
    }

    return true;
};

-----
var checkStraightLine = function(coordinates) 
    // Your code here
};

************************************
Question ID: 1351
function balancedString(s) {
    const n = s.length;
    const freq_map = {};
    for (const c of s)
        freq_map[c] = (freq_map[c] || 0) + 1;
    
    let i = 0, result = n;
    for (let j = 0; j < n; j++) {
        freq_map[s[j]]--;
        while (i < n && ['Q', 'W', 'E', 'R'].every(c => (freq_map[c] || 0) <= n / 4)) {
            result = Math.min(result, j - i + 1);
            freq_map[s[i]]++;
            i++;
        }
    }
    return result;
}

-----
function balancedString(s) 
    // Your code here
}

************************************
Question ID: 1352
class Job {
    constructor(start, end, profit) {
        this.start = start;
        this.end = end;
        this.profit = profit;
    }
}

function findNextJob(jobs, i) {
    for (let j = i + 1; j < jobs.length; j++) {
        if (jobs[j].start >= jobs[i].end) {
            return j;
        }
    }
    return -1;
}

function maxProfitHelper(jobs, memo, i) {
    if (i === -1) return 0;
    if (memo[i] !== -1) return memo[i];

    const nextJob = findNextJob(jobs, i);
    const inclCurrJob = jobs[i].profit + maxProfitHelper(jobs, memo, nextJob);
    const exclCurrJob = maxProfitHelper(jobs, memo, i - 1);
    
    memo[i] = Math.max(inclCurrJob, exclCurrJob);
    return memo[i];
}

function maxProfit(startTime, endTime, profit) {
    const n = startTime.length;
    const jobs = startTime.map((_, i) => new Job(startTime[i], endTime[i], profit[i]));

    jobs.sort((a, b) => a.end - b.end);

    const memo = Array(n).fill(-1);
    return maxProfitHelper(jobs, memo, n - 1);
}

-----
class Job 
    // Your code here
}

************************************
Question ID: 1353
function maxEvents(events) {
    events.sort((a, b) => a[0] - b[0]);
    const minHeap = [];
    let eventCount = 0, day = 0;

    for (let event of events) {
        while (minHeap.length && minHeap[0] < event[0]) {
            minHeap.shift();
        }
        minHeap.push(event[1]);
        minHeap.sort((a, b) => a - b);
        eventCount++;
        day++;
    }

    return eventCount;
}


-----
function maxEvents(events) 
    // Your code here
}


************************************
Question ID: 1354
function winnersAndLosers(matches) {
    const winners = new Set();
    const losers = new Set();

    for (const match of matches) {
        winners.add(match[0]);
        losers.add(match[1]);
    }

    return [Array.from(winners).sort((a, b) => a - b), Array.from(losers).sort((a, b) => a - b)];
}

-----
function winnersAndLosers(matches) 
    // Your code here
}

************************************
Question ID: 1356
function minMovesToPalindrome(s) {
    let moves = 0;
    s = s.split('');
    let left = 0, right = s.length - 1;

    while (left < right) {
        if (s[left] !== s[right]) {
            let temp_right = right;

            while (s[left] !== s[temp_right]) {
                temp_right--;
            }
            s.splice(right, 0, s.splice(temp_right, 1)[0]);
            moves += right - temp_right;
        }
        left++;
        right--;
    }

    return moves;
}

-----
function minMovesToPalindrome(s) 
    // Your code here
}

************************************
Question ID: 1358
function findPairs(z) {
    let pairs = [];

    function f(x, y) {
        return x + y;
    }
    
    for (let x = 1; x <= z; x++) {
        for (let y = 1; y <= z; y++) {
            if (f(x, y) === z) {
                pairs.push([x, y]);
            }
        }
    }
    return pairs;
}

-----
function findPairs(z) 
    // Your code here
}

************************************
Question ID: 1359
function circularPermutation(n, start) {
    let result = new Array(1 << n);
    for (let i = 0; i < (1 << n); ++i) {
        result[i] = start ^ (i ^ (i >> 1));
    }
    return result;
}


-----
function circularPermutation(n, start) 
    // Your code here
}


************************************
Question ID: 1360
function maxLength(arr) {
    let dp = [''];
    let maxLen = 0;

    arr.forEach(s => {
        if (new Set(s).size < s.length) return;
        for (let i = dp.length - 1; i >= 0; --i) {
            let tmp = dp[i] + s;
            if (new Set(tmp).size === tmp.length) {
                dp.push(tmp);
                maxLen = Math.max(maxLen, tmp.length);
            }
        }
    });

    return maxLen;
}

-----
function maxLength(arr) 
    // Your code here
}

************************************
Question ID: 1361
function tilingRectangle(n, m) {
    if (n > m) [n, m] = [m, n];
    if (n === 1) return m;
    if (n === m) return 1;

    let res = Infinity;
    for (let a = 1; a <= Math.floor(n/2); a++) {
        res = Math.min(res, tilingRectangle(a, m) + tilingRectangle(n - a, m));
    }
    for (let b = 1; b <= Math.floor(m/2); b++) {
        res = Math.min(res, tilingRectangle(n, b) + tilingRectangle(n, m - b));
    }
    return res;
}


-----
function tilingRectangle(n, m) 
    // Your code here
}


************************************
Question ID: 1362
function findClosestDivisors(num) {
    for (let i = Math.floor(Math.sqrt(num + 2)); i >= 1; i--) {
        if ((num + 1) % i === 0) return [i, (num + 1) / i];
        if ((num + 2) % i === 0) return [i, (num + 2) / i];
    }
    return [];
}

-----
function findClosestDivisors(num) 
    // Your code here
}

************************************
Question ID: 1363
function largestMultipleOfThree(digits) {
    digits.sort((a, b) => b - a);
    const sum = digits.reduce((a, b) => a + b, 0);

    if (sum % 3 === 0) {
        if (digits[digits.length - 1] === 0) return "0";
        return digits.join("");
    }

    let mod = new Array(3).fill(null).map(() => []);
    for (let digit of digits) {
        mod[digit % 3].push(digit);
    }

    if (sum % 3 === 1) {
        if (mod[1].length > 0) {
            mod[1].pop();
        } else {
            mod[2].pop(), mod[2].pop();
        }
    } else {
        if (mod[2].length > 0) {
            mod[2].pop();
        } else {
            mod[1].pop(), mod[1].pop();
        }
    }

    let result = mod.flat().join("");
    result = Array.from(result).sort((a, b) => b - a).join("");

    if (!result || result[0] === "0") {
        return "0";
    }

    return result;
}


-----
function largestMultipleOfThree(digits) 
    // Your code here
}


************************************
Question ID: 1365
function smallerNumbersThanCurrent(nums) {
    let result = [];
    for (let i = 0; i < nums.length; i++) {
        let count = 0;
        for (let j = 0; j < nums.length; j++) {
            if (i !== j && nums[j] < nums[i]) {
                count++;
            }
        }
        result.push(count);
    }
    return result;
}

-----
function smallerNumbersThanCurrent(nums) 
    // Your code here
}

************************************
Question ID: 1366
function rankTeams(votes) {
    const n = votes.length;
    const m = votes[0].length;
    const count = Array.from({ length: 26 }, () => Array(m).fill(0));
    let res = votes[0];

    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            count[votes[i].charCodeAt(j) - 'A'.charCodeAt(0)][j]++;
        }
    }

    res = res.split('').sort((a, b) => {
        for (let i = 0; i < m; i++) {
            if (count[a.charCodeAt(0) - 'A'.charCodeAt(0)][i]
                !== count[b.charCodeAt(0) - 'A'.charCodeAt(0)][i]) {
                return count[b.charCodeAt(0) - 'A'.charCodeAt(0)][i]
                    - count[a.charCodeAt(0) - 'A'.charCodeAt(0)][i];
            }
        }
        return a < b ? -1 : 1;
    });

    return res.join('');
}


-----
function rankTeams(votes) 
    // Your code here
}


************************************
Question ID: 1367
function maxHeight(cuboids) {
    cuboids.forEach(cuboid => cuboid.sort((a, b) => a - b));
    cuboids.sort((a, b) => a[0] - b[0]);

    const n = cuboids.length;
    const dp = new Array(n).fill(0);
    let ans = 0;

    for (let i = 0; i < n; i++) {
        dp[i] = cuboids[i][2];
        for (let j = 0; j < i; j++) {
            if (cuboids[j][0] <= cuboids[i][0] && cuboids[j][1] <= cuboids[i][1] && cuboids[j][2] <= cuboids[i][2]) {
                dp[i] = Math.max(dp[i], dp[j] + cuboids[i][2]);
            }
        }
        ans = Math.max(ans, dp[i]);
    }
    return ans;
}

-----
function maxHeight(cuboids) 
    // Your code here
}

************************************
Question ID: 1368
var minCost = function(grid) {
    let m = grid.length, n = grid[0].length, cost = 0;

    let visited = new Array(m).fill(null).map(() => new Array(n).fill(1000000));
    let q = [{i: 0, j: 0}];
    visited[0][0] = 0;

    while (q.length !== 0) {
        let {i, j} = q.shift();
        if (i === m - 1 && j === n - 1) {
            cost = visited[i][j];
            break;
        }

        let dx = [1, 0, -1, 0];
        let dy = [0, 1, 0, -1];

        for (let dir = 0; dir < 4; ++dir) {
            let newI = i + dx[dir], newJ = j + dy[dir];
            if (0 <= newI && newI < m && 0 <= newJ && newJ < n) {
                let newCost = visited[i][j] + ((dir + 1 !== grid[i][j]) ? 1 : 0);
                if (newCost < visited[newI][newJ]) {
                    visited[newI][newJ] = newCost;
                    q.push({i: newI, j: newJ});
                }
            }
        }
    }
    return cost;
};

-----
var minCost = function(grid) 
    // Your code here
};

************************************
Question ID: 1370
function numberOfSubarrays(nums, k) {
    let n = nums.length, result = 0, count = 0;
    let oddCount = new Array(n + 1).fill(0);

    oddCount[0] = 1;
    for (let i = 0; i < n; i++) {
        count += nums[i] % 2;
        if (count >= k) result += oddCount[count - k];
        oddCount[count]++;
    }

    return result;
}

-----
function numberOfSubarrays(nums, k) 
    // Your code here
}

************************************
Question ID: 1371
function minRemoveToMakeValid(s) {
    const stk = [];
    const result = s.split('');

    for (let i = 0; i < s.length; i++) {
        if (s[i] == '(') {
            stk.push(i);
        } else if (s[i] == ')') {
            if (stk.length > 0) {
                stk.pop();
            } else {
                result[i] = '';
            }
        }
    }

    while (stk.length > 0) {
        result[stk.pop()] = '';
    }

    return result.join('');
}


-----
function minRemoveToMakeValid(s) 
    // Your code here
}


************************************
Question ID: 1372
function isGoodArray(nums) {
    let gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
    let gcdValue = nums.reduce((a, b) => gcd(a, b));
    return gcdValue === 1;
}


-----
function isGoodArray(nums) 
    // Your code here
}


************************************
Question ID: 1374
function generateTheString(n) {
    let result = 'a'.repeat(n);
    if (n % 2 === 0) {
        result = result.slice(0, -1) + 'b';
    }
    return result;
}

-----
function generateTheString(n) 
    // Your code here
}

************************************
Question ID: 1375
function findKthPalindrome(k, intLength) {
    let mid = Math.floor((intLength + 1) / 2);
    let limit = Math.pow(10, mid) - 1;

    for (let i = 0; i <= limit; i++) {
        let num = i.toString();
        let rev = num.split('').reverse().join('');
        if (intLength % 2 !== 0) 
            rev = rev.slice(1);
        let palindrome = parseInt(num + rev);
        if (palindrome > 0)
            k--;
        if (k === 0)
            return palindrome;
    }
    return -1;
}

function palindromeQueries(queries, intLength) {
    return queries.map(query => findKthPalindrome(query, intLength));
}


-----
function findKthPalindrome(k, intLength) 
    // Your code here
}


************************************
Question ID: 1376
function numOfMinutes(n, headID, manager, informTime) {
    const subordinates = Array.from({length: n}, () => []);
    for (let i = 0; i < n; ++i) {
        if (manager[i] !== -1) {
            subordinates[manager[i]].push(i);
        }
    }
    return dfs(headID, subordinates, informTime);
}

function dfs(employee, subordinates, informTime) {
    if (informTime[employee] === 0) {
        return 0;
    }
    let max_time = 0;
    for (const i of subordinates[employee]) {
        max_time = Math.max(max_time, dfs(i, subordinates, informTime));
    }
    return max_time + informTime[employee];
}


-----
function numOfMinutes(n, headID, manager, informTime) 
    // Your code here
}


************************************
Question ID: 1377
function dfs(node, parent, t, target, graph, prob, ans) {
    if (t === 0) {
        if (node === target) ans[0] += prob;
        return;
    }

    let hasChild = false;
    for (let neighbor of graph[node]) {
        if (neighbor !== parent) {
            hasChild = true;
            dfs(neighbor, node, t - 1, target, graph, prob / (graph[node].length - (node !== 1 ? 1 : 0)), ans);
        }
    }

    if (!hasChild && node === target) ans[0] += prob;
}

function frogPosition(n, edges, t, target) {
    const graph = new Map();
    for (let i = 1; i <= n; ++i) {
        graph.set(i, []);
    }
    for (let i = 0; i < n - 1; ++i) {
        const a = edges[i][0],
              b = edges[i][1];
        graph.get(a).push(b);
        graph.get(b).push(a);
    }

    const ans = [0.0];
    dfs(1, -1, t, target, graph, 1.0, ans);
    return ans[0];
}


-----
function dfs(node, parent, t, target, graph, prob, ans) 
    // Your code here
}


************************************
Question ID: 1379
function reconstructMatrix(upper, lower, colsum) {
    const result = Array.from({length: 2}, () => Array(colsum.length).fill(0));

    for (let i = 0; i < colsum.length; i++) {
        if (colsum[i] === 2) {
            result[0][i] = 1;
            result[1][i] = 1;
            upper--;
            lower--;
        } else if (colsum[i] === 1) {
            if (upper > lower) {
                result[0][i] = 1;
                upper--;
            } else {
                result[1][i] = 1;
                lower--;
            }
        }

        if (upper < 0 || lower < 0) {
            return [];
        }
    }

    if (upper > 0 || lower > 0) {
        return [];
    }

    return result;
}

-----
function reconstructMatrix(upper, lower, colsum) 
    // Your code here
}

************************************
Question ID: 1380
const dx = [-1, 1, 0, 0];
const dy = [0, 0, -1, 1];

function dfs(grid, x, y) {
    const n = grid.length, m = grid[0].length;
    grid[x][y] = 1;
    for (let i = 0; i < 4; i++) {
        const nx = x + dx[i], ny = y + dy[i];
        if (0 <= nx && nx < n && 0 <= ny && ny < m && grid[nx][ny] === 0) {
            dfs(grid, nx, ny);
        }
    }
}

function closedIsland(grid) {
    const n = grid.length, m = grid[0].length;
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            if (i === 0 || i === n - 1 || j === 0 || j === m - 1) {
                if (grid[i][j] === 0) {
                    dfs(grid, i, j);
                }
            }
        }
    }
    let res = 0;
    for (let i = 1; i < n - 1; i++) {
        for (let j = 1; j < m - 1; j++) {
            if (grid[i][j] === 0) {
                dfs(grid, i, j);
                res++;
            }
        }
    }
    return res;
}


-----
const dx = [-1, 1, 0, 0];
const dy = [0, 0, -1, 1];

function dfs(grid, x, y) 
    // Your code here
}


************************************
Question ID: 1381
function getMaxScore(word, score) {
    let sum = 0;
    for (let c of word) {
        sum += score[c.charCodeAt(0) - 'a'.charCodeAt(0)];
    }
    return sum;
}

function getMaxScoreHelper(words, score, letters, i) {
    if (i == words.length) {
        return 0;
    }
    let withoutCurrentWord = getMaxScoreHelper(words, score, letters, i + 1);
    for (let c of words[i]) {
        if (--letters[c.charCodeAt(0) - 'a'.charCodeAt(0)] < 0) {
            break;
        }
    }
    let withCurrentWord = getMaxScore(words[i], score) + getMaxScoreHelper(words, score, letters, i + 1);
    return Math.max(withCurrentWord, withoutCurrentWord);
}

function maxScoreWords(words, letters, score) {
    return getMaxScoreHelper(words, score, Array.from(letters), 0);
}
```
-----
function getMaxScore(word, score) 
    // Your code here
}
```
************************************
Question ID: 1383
function maxPerformance(n, k, speed, efficiency) {
    const engineers = efficiency.map((e, i) => [e, speed[i]]).sort((a, b) => b[0] - a[0]);
    const minHeap = new MinHeap();

    let speedSum = 0;
    let maxPerformance = 0;

    for (const [e, s] of engineers) {
        speedSum += s;
        minHeap.insert(s);

        if (minHeap.size() > k) {
            speedSum -= minHeap.extractMin();
        }

        maxPerformance = Math.max(maxPerformance, speedSum * e);
    }

    return maxPerformance % (10**9 + 7);
}

class MinHeap {
    constructor() {
        this.heap = [];
    }
    insert(value) {
        this.heap.push(value);
        this.bubbleUp(this.heap.length - 1);
    }
    extractMin() {
        const min = this.heap[0];
        this.heap[0] = this.heap.pop();
        this.bubbleDown(0);
        return min;
    }
    size() {
        return this.heap.length;
    }
    bubbleUp(index) {
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if (this.heap[index] >= this.heap[parentIndex]) {
                break;
            }
            [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];
            index = parentIndex;
        }
    }
    bubbleDown(index) {
        while (true) {
            let minIndex = index;
            const leftChildIndex = 2 * index + 1;
            const rightChildIndex = 2 * index + 2;
            if (leftChildIndex < this.heap.length && this.heap[leftChildIndex] < this.heap[minIndex]) {
                minIndex = leftChildIndex;
            }
            if (rightChildIndex < this.heap.length && this.heap[rightChildIndex] < this.heap[minIndex]) {
                minIndex = rightChildIndex;
            }
            if (minIndex === index) {
                break;
            }
            [this.heap[index], this.heap[minIndex]] = [this.heap[minIndex], this.heap[index]];
            index = minIndex;
        }
    }
}

-----
function maxPerformance(n, k, speed, efficiency) 
    // Your code here
}

************************************
Question ID: 1385
function findTheDistanceValue(arr1, arr2, d) {
    let distance = 0;
    for (let a of arr1) {
        let found = true;
        for (let b of arr2) {
            if (Math.abs(a - b) <= d) {
                found = false;
                break;
            }
        }
        if (found) distance++;
    }
    return distance;
}

-----
function findTheDistanceValue(arr1, arr2, d) 
    // Your code here
}

************************************
Question ID: 1386
function shiftGrid(grid, k) {
    const m = grid.length, n = grid[0].length;
    k %= (m * n);
    const res = Array.from({length: m}, () => Array(n).fill(0));
    for (let i = 0; i < m; ++i) {
        for (let j = 0; j < n; ++j) {
            let idx = (i * n + j + k) % (m * n);
            res[Math.floor(idx / n)][idx % n] = grid[i][j];
        }
    }
    return res;
}


-----
function shiftGrid(grid, k) 
    // Your code here
}


************************************
Question ID: 1388
function maxSumDivThree(nums) {
    let dp = [0, 0, 0];
    for (let num of nums) {
        let temp = [...dp];
        for (let s of temp) {
            dp[(s + num) % 3] = Math.max(dp[(s + num) % 3], s + num);
        }
    }
    return dp[0];
}

-----
function maxSumDivThree(nums) 
    // Your code here
}

************************************
Question ID: 1390
function sumOfFourDivisors(nums) {
    let sum = 0;
    for (let num of nums) {
        let count = 0;
        let div_sum = 0;
        for (let i = 1; i * i <= num; ++i) {
            if (num % i === 0) {
                count += (i * i === num) ? 1 : 2;
                div_sum += i + (num / i);
                if (count > 4) break;
            }
        }
        if (count === 4) sum += div_sum;
    }
    return sum;
}

-----
function sumOfFourDivisors(nums) 
    // Your code here
}

************************************
Question ID: 1391
function hasValidPath(grid) {
    const m = grid.length;
    const n = grid[0].length;

    const directions = [[0, -1], [-1, 0], [0, 1], [1, 0]];
    const allowed = [[], [0, 2], [1, 3], [0, 1], [0, 3], [1, 2], [1, 0]];

    const visited = Array.from({ length: m }, () => Array(n).fill(false));

    const dfs = (i, j) => {
        if (i === m - 1 && j === n - 1) return true;
        visited[i][j] = true;
        for (const dir of allowed[grid[i][j]]) {
            const x = i + directions[dir][0];
            const y = j + directions[dir][1];
            if (x >= 0 && y >= 0 && x < m && y < n && !visited[x][y] && allowed[grid[x][y]].includes((dir + 2) % 4)) {
                if (dfs(x, y)) return true;
            }
        }
        return false;
    };

    return dfs(0, 0);
}

-----
function hasValidPath(grid) 
    // Your code here
}

************************************
Question ID: 1394
function findLucky(arr) {
    const freq = {};
    for (const num of arr) {
        if (!freq[num]) {
            freq[num] = 0;
        }
        freq[num]++;
    }
    let maxLucky = -1;
    for (const [num, count] of Object.entries(freq)) {
        if ( parseInt(num) === count) {
            maxLucky = Math.max(maxLucky, parseInt(num));
        }
    }
    return maxLucky;
}

-----
function findLucky(arr) 
    // Your code here
}

************************************
Question ID: 1395
function minTimeToVisitAllPoints(points) {
    let time = 0;
    for(let i = 1; i < points.length; ++i) {
        let dx = Math.abs(points[i][0] - points[i-1][0]);
        let dy = Math.abs(points[i][1] - points[i-1][1]);
        time += Math.max(dx, dy);
    }
    return time;
}


-----
function minTimeToVisitAllPoints(points) 
    // Your code here
}


************************************
Question ID: 1397
function suggestedProducts(products, searchWord) {
    products.sort();
    
    let result = [];
    let currentPrefix = "";
    
    for (let letter of searchWord) {
        currentPrefix += letter;
        
        let index = products.findIndex(product => product.startsWith(currentPrefix));
        
        let suggestions = [];
        for (let i = 0; i < 3 && index < products.length && products[index].startsWith(currentPrefix); i++) {
            suggestions.push(products[index]);
            index++;
        }
        
        result.push(suggestions);
    }
    
    return result;
}

-----
function suggestedProducts(products, searchWord) 
    // Your code here
}

************************************
Question ID: 1399
function countLargestGroup(n) {
    const groups = new Array(37).fill(0);
    let largest_group_size = 0;
    let count_largest_groups = 0;

    for (let i = 1; i <= n; i++) {
        const sum = i.toString().split('').reduce((a, b) => a + parseInt(b), 0);
        groups[sum]++;
        if (groups[sum] > largest_group_size) {
            largest_group_size = groups[sum];
            count_largest_groups = 1;
        } else if (groups[sum] === largest_group_size) {
            count_largest_groups++;
        }
    }
    return count_largest_groups;
};

-----
function countLargestGroup(n) 
    // Your code here
};

************************************
Question ID: 1400
function tictactoe(moves) {
    const grid = Array.from({ length: 3 }, () => new Array(3).fill(0));
    let player = 1;
    for (const move of moves) {
        const [row, col] = move;
        grid[row][col] = player;
        if ((Array(3).fill().every((_, i) => grid[i][col] === player)) ||
            (Array(3).fill().every((_, i) => grid[row][i] === player)) ||
            (row === col && Array(3).fill().every((_, i) => grid[i][i] === player)) ||
            (row + col === 2 && Array(3).fill().every((_, i) => grid[i][2 - i] === player))) {
            return player === 1 ? "A" : "B";
        }
        player = 3 - player;
    }
    return moves.length === 9 ? "Draw" : "Pending";
}


-----
function tictactoe(moves) 
    // Your code here
}


************************************
Question ID: 1401
function checkOverlap(radius, xCenter, yCenter, x1, y1, x2, y2) {
    const xClosest = Math.max(x1, Math.min(xCenter, x2));
    const yClosest = Math.max(y1, Math.min(yCenter, y2));
    return (xCenter - xClosest) * (xCenter - xClosest) + (yCenter - yClosest) * (yCenter - yClosest) <= radius * radius;
}

-----
function checkOverlap(radius, xCenter, yCenter, x1, y1, x2, y2) 
    // Your code here
}

************************************
Question ID: 1402
function countSquares(matrix) {
    const m = matrix.length, n = matrix[0].length;
    let ans = 0, dp = Array.from({length: m}, () => Array(n));
    for(let i = 0; i < m; i++) {
        for(let j = 0; j < n; j++) {
            if(i === 0 || j === 0) dp[i][j] = matrix[i][j];
            else if(matrix[i][j]) dp[i][j] = Math.min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1;
            ans += dp[i][j];
        }
    }
    return ans;
}

-----
function countSquares(matrix) 
    // Your code here
}

************************************
Question ID: 1403
function minChangesToDivideString(s, k) {
    let n = s.length;
    if (n % k !== 0) {
        return -1;
    }
    let chunkCount = n / k;
    let res = 0;
    for (let i = 0; i < k; ++i) {
        let counts = new Array(26).fill(0);
        for (let j = i; j < n; j += k) {
            ++counts[s.charCodeAt(j) - 'a'.charCodeAt(0)];
        }
        let maxCount = Math.max(...counts);
        res += chunkCount - maxCount;
    }
    return res;
}

-----
function minChangesToDivideString(s, k) 
    // Your code here
}

************************************
Question ID: 1404
function numSteps(s) {
    let steps = 0, carry = 0;
    for (let i = s.length - 1; i > 0; --i) {
        const bit = parseInt(s[i]);
        if (bit && carry) {
            carry = 1;
            steps += 2;
        } else if (bit || carry) {
            carry ^= 1;
            steps += 2;
        } else {
            steps++;
        }
    }

    return steps + carry;
}

-----
function numSteps(s) 
    // Your code here
}

************************************
Question ID: 1405
var longestDiverseString = function(a, b, c) {
    let result = "";
    let pq = new PriorityQueue(([cnt1, _], [cnt2, __]) => cnt1 > cnt2);
    if (a !== 0) pq.enqueue([a, 'a']);
    if (b !== 0) pq.enqueue([b, 'b']);
    if (c !== 0) pq.enqueue([c, 'c']);
    
    while (!pq.isEmpty()) {
        let [firstCnt, firstChar] = pq.dequeue();
        if (result.length === 0 || result[result.length - 1] !== firstChar) {
            result += firstChar;
            firstCnt--;
            if (firstCnt !== 0) pq.enqueue([firstCnt, firstChar]);
        } else if (!pq.isEmpty()) {
            let [secondCnt, secondChar] = pq.dequeue();
            result += secondChar;
            secondCnt--;
            if (secondCnt !== 0) pq.enqueue([secondCnt, secondChar]);
            pq.enqueue([firstCnt, firstChar]);
        } else {
            break;
        }
    }
    return result;
};

-----
var longestDiverseString = function(a, b, c) 
    // Your code here
};

************************************
Question ID: 1406
var stoneGameIII = function(stoneValue) {
    let n = stoneValue.length;
    let dp = new Array(n + 1).fill(Number.MIN_SAFE_INTEGER);
    dp[n] = 0;
    
    for (let i = n - 1; i >= 0; --i) {
        let curr = 0;
        for (let j = 0; j < 3 && i + j < n; ++j) {
            curr += stoneValue[i + j];
            dp[i] = Math.max(dp[i], curr - dp[i + j + 1]);
        }
    }
    
    return dp[0] === 0 ? "Tie " : dp[0] > 0 ? "Alice " : "Bob ";
};


-----
var stoneGameIII = function(stoneValue) 
    // Your code here
};


************************************
Question ID: 1408
function smallestDivisor(nums, threshold) {
    let left = 1, right = 10**6;
    while (left < right) {
        let mid = Math.floor((left + right) / 2);
        let sum = nums.reduce((acc, n) => acc + Math.ceil(n / mid), 0);
        if (sum > threshold) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}

-----
function smallestDivisor(nums, threshold) 
    // Your code here
}

************************************
Question ID: 1409
function minNumberOfFlips(mat) {
    const m = mat.length, n = mat[0].length;
    let steps = 0;
    const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0], [0, 0]];

    function encode(i, j) {
        return i * n + j;
    }

    while (true) {
        let flipped = 0;
        const que = [];

        for (let i = 0; i < m; ++i) {
            for (let j = 0; j < n; ++j) {
                if (mat[i][j] === 1) {
                    que.push(encode(i, j));
                }
            }
        }

        while (que.length > 0) {
            const cur = que.shift();
            const cur_i = Math.floor(cur / n), cur_j = cur % n;

            for (const dir of dirs) {
                const ni = cur_i + dir[0], nj = cur_j + dir[1];
                if (ni >= 0 && ni < m && nj >= 0 && nj < n) {
                    mat[ni][nj] ^= 1;
                    ++flipped;
                }
            }
        }

        if (flipped === 0) {
            break;
        }
        steps += flipped;
    }

    for (const row of mat) {
        for (const cell of row) {
            if (cell === 1) {
                return -1;
            }
        }
    }

    return steps;
}

-----
function minNumberOfFlips(mat) 
    // Your code here
}

************************************
Question ID: 1410
function entityParser(text) {
    const entities = {
        "&quot;": "\"",
        "&apos;": "\'",
        "&amp;": "&",
        "&gt;": ">",
        "&lt;": "<",
        "&frasl;": "/",
    };
    
    let result = '';
    let currentEntity = '';
    let inEntity = false;
    
    for (const c of text) {
        if (inEntity) {
            currentEntity += c;
            if (c === ';') {
                if (entities.hasOwnProperty(currentEntity)) {
                    result += entities[currentEntity];
                } else {
                    result += currentEntity;
                }
                inEntity = false;
                currentEntity = '';
            }
        } else {
            if (c === '&') {
                inEntity = true;
                currentEntity += c;
            } else {
                result += c;
            }
        }
    }
    
    return result;
}

-----
function entityParser(text) 
    // Your code here
}

************************************
Question ID: 1413
function maxSideLength(mat, threshold) {
    const m = mat.length;
    const n = mat[0].length;
    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
    let ans = 0;

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            dp[i][j] = mat[i - 1][j - 1] + dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1];
            const k = ans + 1;
            if (i >= k && j >= k && dp[i][j] - dp[i][j - k] - dp[i - k][j] + dp[i - k][j - k] <= threshold) {
                ans++;
            }
        }
    }
    return ans;
}

-----
function maxSideLength(mat, threshold) 
    // Your code here
}

************************************
Question ID: 1414
function shortestPath(grid, k) {
    const m = grid.length;
    const n = grid[0].length;
    const queue = [[0, 0, 0, k]];
    const visited = new Array(m).fill(null).map(() => new Array(n).fill(null).map(() => new Array(k + 1).fill(false)));

    while (queue.length) {
        const [x, y, step, remainingK] = queue.shift();

        if (x === m - 1 && y === n - 1) return step;
        if (visited[x][y][remainingK]) continue;
        visited[x][y][remainingK] = true;

        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

        for (const [dx, dy] of directions) {
            const nx = x + dx;
            const ny = y + dy;

            if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                if (grid[nx][ny] === 1 && remainingK > 0) {
                    queue.push([nx, ny, step + 1, remainingK - 1]);
                } else if (grid[nx][ny] === 0) {
                    queue.push([nx, ny, step + 1, remainingK]);
                }
            }
        }
    }

    return -1;
}

-----
function shortestPath(grid, k) 
    // Your code here
}

************************************
Question ID: 1416
function numDecodings(s, k) {
    const n = s.length;
    const dp = new Array(n + 1).fill(0);
    dp[n] = 1;
    const MOD = 1000000007;

    for (let i = n - 1; i >= 0; i--) {
        let num = 0;
        for (let j = i; j < n && num <= k; j++) {
            num = num * 10 + parseInt(s[j]);
            if (num >= 1 && num <= k) {
                dp[i] = (dp[i] + dp[j + 1]) % MOD;
            }
        }
    }

    return dp[0];
}

-----
function numDecodings(s, k) 
    // Your code here
}

************************************
Question ID: 1417
function reformat(s) {
    const letters = [], digits = [];

    for (const c of s) {
        if (c.charCodeAt(0) > 57) letters.push(c);
        else digits.push(c);
    }

    if (Math.abs(letters.length - digits.length) > 1) return "";

    let result = "";
    let useLetter = letters.length > digits.length;

    while (letters.length || digits.length) {
        if (useLetter) {
            result += letters.shift();
        } else {
            result += digits.shift();
        }
        useLetter = !useLetter;
    }

    return result;
}

-----
function reformat(s) 
    // Your code here
}

************************************
Question ID: 1418
function displayTable(orders) {
    const tables = new Map();
    const foodSet = new Set();

    for (const order of orders) {
        const tableNumber = parseInt(order[1]);
        const foodItem = order[2];
        if (!tables.has(tableNumber)) tables.set(tableNumber, new Map());
        const table = tables.get(tableNumber);
        table.set(foodItem, (table.get(foodItem) || 0) + 1);
        foodSet.add(foodItem);
    }

    const foodList = [...foodSet].sort();
    const result = [["Table", ...foodList]];

    for (const [tableNumber, table] of [...tables.entries()].sort((a, b) => a[0] - b[0])) {
        const row = [tableNumber.toString()];
        row.push(...foodList.map(foodItem => (table.get(foodItem) || 0).toString()));
        result.push(row);
    }

    return result;
}

-----
function displayTable(orders) 
    // Your code here
}

************************************
Question ID: 1419
var minNumberOfFrogs = function(croakOfFrogs) {
    let counter = new Array(5).fill(0);
    let frogs = 0, max_frogs = 0;
    for (const ch of croakOfFrogs) {
        let idx = "croak".indexOf(ch);
        counter[idx]++;
        if (idx === 0) {
            max_frogs = Math.max(max_frogs, ++frogs);
        } else if (--counter[idx - 1] < 0) {
            return -1;
        } else if (idx === 4) {
            frogs--;
        }
    }
    return (counter[0] === counter[1] && counter[1] === counter[2] && counter[2] === counter[3] && counter[3] === counter[4]) ? max_frogs : -1;
};

-----
var minNumberOfFrogs = function(croakOfFrogs) 
    // Your code here
};

************************************
Question ID: 1420
function waysToBuildArray(n, m, k) {
    const mod = 1e9 + 7;
    const dp = Array.from({ length: n+1 }, () => Array(k+1).fill(0));
    dp[0][0] = 1;
    for (let i = 1; i <= n; ++i) {
        for (let j = 0; j <= k; ++j) {
            for (let x = 1; x <= m; ++x) {
                if (j < i * (x-1)) {
                    dp[i][j] = (dp[i][j] + dp[i-1][j-(i-1)*(x-1)]) % mod;
                }
            }
        }
    }
    return dp[n][k];
}

-----
function waysToBuildArray(n, m, k) 
    // Your code here
}

************************************
Question ID: 1422
function isPossibleDivide(nums, k) {
    const counts = new Map();
    for (const num of nums) counts.set(num, (counts.get(num) || 0) + 1);
    
    for (const [key, value] of [...counts.entries()].sort((a, b) => a[0] - b[0])) {
        if (value > 0) {
            for (let i = k - 1; i >= 0; --i) {
                if ((counts.get(key + i) || 0) < value) return false;
                counts.set(key + i, counts.get(key + i) - value);
            }
        }
    }
    
    return true;
}

-----
function isPossibleDivide(nums, k) 
    // Your code here
}

************************************
Question ID: 1423
function maxSubstringOccurrences(s, k) {
    const n = s.length;
    let res = 0;
    const freq = new Map();
    for (let i = 0; i < n; ++i) {
        const c = s.charAt(i);
        freq.set(c, (freq.get(c) || 0) + 1);
        if (freq.size <= k) {
            res = Math.max(res, freq.get(c));
        }
    }
    return (freq.size > k) ? 0 : res;
}


-----
function maxSubstringOccurrences(s, k) 
    // Your code here
}


************************************
Question ID: 1424
function maxCandies(status, candies, keys, containedBoxes, initialBoxes) {
    let maxCandies = 0;
    let visited = new Set();
    let toProcess = initialBoxes.slice();

    while (toProcess.length > 0) {
        let box = toProcess.shift();

        if (visited.has(box)) {
            continue;
        }

        visited.add(box);

        if (status[box]) {
            maxCandies += candies[box];
            for (let key of keys[box]) {
                status[key] = 1;
                if (visited.has(key)) {
                    toProcess.push(key);
                }
            }
            for (let contained of containedBoxes[box]) {
                toProcess.push(contained);
            }
        } else {
            toProcess.push(box);
        }
    }

    return maxCandies;
}

-----
function maxCandies(status, candies, keys, containedBoxes, initialBoxes) 
    // Your code here
}

************************************
Question ID: 1425
function maxSum(nums, k) {
    const n = nums.length;
    const pq = new PriorityQueue((a, b) => b - a);
    const dp = new Array(n + 1).fill(0);
    let sum = 0;

    for (let i = 0; i < n; i++) {
        if (i >= k) pq.poll(); // Maintain the maximum size of k
        pq.offer(dp[i] - nums[i]);
        dp[i + 1] = Math.max(dp[i], nums[i] + pq.peek());
        sum = Math.max(sum, dp[i + 1]);
    }

    return sum;
}

class PriorityQueue {
    constructor(comparator = (a, b) => a - b) {
        this._heap = [];
        this._comparator = comparator;
    }

    size() {
        return this._heap.length;
    }

    isEmpty() {
        return this.size() === 0;
    }

    peek() {
        return this._heap[0];
    }

    push(value) {
        this._heap.push(value);
        this._shiftUp();
    }

    poll() {
        const rootNode = this.peek();
        this._heap[0] = this._heap.pop();
        this._shiftDown();
        return rootNode;
    }

    _parent(idx) {
        return Math.floor((idx - 1) / 2);
    }

    _left(idx) {
        return idx * 2 + 1;
    }

    _right(idx) {
        return idx * 2 + 2;
    }

    _hasLeft(idx) {
        return this._left(idx) < this._heap.length;
    }

    _hasRight(idx) {
        return this._right(idx) < this._heap.length;
    }

    _shiftUp() {
        let nodeIdx = this.size() - 1;
        while (
            nodeIdx > 0 &&
            this._comparator(this._heap[nodeIdx], this._heap[this._parent(nodeIdx)]) < 0
        ) {
            this._swap(nodeIdx, this._parent(nodeIdx));
            nodeIdx = this._parent(nodeIdx);
        }
    }

    _shiftDown() {
        let nodeIdx = 0;
        while (this._hasLeft(nodeIdx)) {
            let smallerChildIdx = this._left(nodeIdx);
            if (
                this._hasRight(nodeIdx) &&
                this._comparator(this._heap[this._right(nodeIdx)], this._heap[this._left(nodeIdx)]) < 0
            ) {
                smallerChildIdx = this._right(nodeIdx);
            }
            if (this._comparator(this._heap[nodeIdx], this._heap[smallerChildIdx]) < 0) {
                break;
            }
            this._swap(smallerChildIdx, nodeIdx);
            nodeIdx = smallerChildIdx;
        }
    }

    _swap(i, j) {
        const tmp = this._heap[i];
        this._heap[i] = this._heap[j];
        this._heap[j] = tmp;
    }
}

-----
function maxSum(nums, k) 
    // Your code here
}

************************************
Question ID: 1426
function sumZero(n) {
    const res = [];
    for (let i = 1; i <= Math.floor(n / 2); i++) {
        res.push(i);
        res.push(-i);
    }
    if (n % 2 !== 0) {
        res.push(0);
    }
    return res;
}

-----
function sumZero(n) 
    // Your code here
}

************************************
Question ID: 1428
function canReach(arr, start) {
    if (start >= 0 && start < arr.length && arr[start] >= 0) {
        if (arr[start] === 0)
            return true;

        let jump = arr[start];
        arr[start] = -arr[start];
        return canReach(arr, start + jump) || canReach(arr, start - jump);
    }
    return false;
}

-----
function canReach(arr, start) 
    // Your code here
}

************************************
Question ID: 1429
function isSolvable(words, result) {
    let sum = 0;
    for (let key in words) {
        sum += words[key];
    }
    return sum % 10 === result % 10;
}

-----
function isSolvable(words, result) 
    // Your code here
}

************************************
Question ID: 1431
function findAncestors(node, adjList, visited, ancestors) {
    if (visited[node]) return;
    visited[node] = true;
    for (const ancestor of adjList[node]) {
        ancestors.push(ancestor);
        findAncestors(ancestor, adjList, visited, ancestors);
    }
}

function findAncestorsInDAG(n, edges) {
    const adjList = new Array(n).fill(0).map(() => []);
    const ans = new Array(n).fill(0).map(() => []);
    for (const edge of edges) {
        adjList[edge[1]].push(edge[0]);
    }
    for (let i = 0; i < n; ++i) {
        const visited = new Array(n).fill(false);
        findAncestors(i, adjList, visited, ans[i]);
        ans[i].sort((a, b) => a - b);
    }
    return ans;
}


-----
function findAncestors(node, adjList, visited, ancestors) 
    // Your code here
}


************************************
Question ID: 1432
function maxDiff(num) {
    let a = -1, b = -1;
    const numStr = num.toString();
    for (const c of numStr) {
        if (a === -1 && c !== '9') {
            a = parseInt(c);
        }
        if (b === -1 && c > '1') {
            b = parseInt(c);
        }
        if (a !== -1 && b !== -1) {
            break;
        }
    }
    let result = 0;
    for (const c of numStr) {
        if (parseInt(c) === a) {
            result = result * 10 + 9;
        } else if (parseInt(c) === b) {
            result = result * 10 + ((c === numStr[0]) ? 1 : 0);
        } else {
            result = result * 10 + parseInt(c);
        }
    }
    return result - num;
}


-----
function maxDiff(num) 
    // Your code here
}


************************************
Question ID: 1434
function freqAlphabets(s) {
    let result = [];
    for (let i = 0; i < s.length;) {
        if (i + 2 < s.length && s[i + 2] === "#") {
            result.push(String.fromCharCode("a".charCodeAt(0) + parseInt(s.substring(i, i + 2)) - 1));
            i += 3;
        } else {
            result.push(String.fromCharCode("a".charCodeAt(0) + parseInt(s[i]) - 1));
            i++;
        }
    }
    return result.join('');
}

-----
function freqAlphabets(s) 
    // Your code here
}

************************************
Question ID: 1436
function watchedVideosByFriends(watchedVideos, friends, id, level) {
    const visited = new Set();
    const q = [{ id, level: 0 }];
    const videoFreq = new Map();

    while (q.length !== 0) {
        const { id: currentId, level: currentLevel } = q.shift();

        if (currentLevel === level) {
            for (const video of watchedVideos[currentId]) {
                videoFreq.set(video, (videoFreq.get(video) || 0) + 1);
            }
        } else if (currentLevel < level) {
            for (const friendId of friends[currentId]) {
                if (!visited.has(friendId)) {
                    visited.add(friendId);
                    q.push({ id: friendId, level: currentLevel + 1 });
                }
            }
        }
    }

    const result = Array.from(videoFreq.keys());
    result.sort((a, b) => {
        if (videoFreq.get(a) === videoFreq.get(b)) {
            return a.localeCompare(b);
        } else {
            return videoFreq.get(a) - videoFreq.get(b);
         }
    });

    return result;
}

-----
function watchedVideosByFriends(watchedVideos, friends, id, level) 
    // Your code here
}

************************************
Question ID: 1437
function minStepsToMakePalindrome(s) {
    const n = s.length;
    const dp = Array.from({ length: n }, () => Array(n).fill(0));

    for (let i = n - 2; i >= 0; i--) {
        for (let j = i + 1; j < n; j++) {
            if (s[i] === s[j]) {
                dp[i][j] = dp[i + 1][j - 1];
            } else {
                dp[i][j] = 1 + Math.min(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }

    return dp[0][n - 1];
}

-----
function minStepsToMakePalindrome(s) 
    // Your code here
}

************************************
Question ID: 1438
function longestSubarray(nums, limit) {
    const maxDeque = [], minDeque = [];
    let left = 0, right = 0, longest = 0;
    
    while (right < nums.length) {
        while (maxDeque.length && nums[right] > maxDeque[maxDeque.length - 1]) maxDeque.pop();
        while (minDeque.length && nums[right] < minDeque[minDeque.length - 1]) minDeque.pop();
        
        maxDeque.push(nums[right]);
        minDeque.push(nums[right]);
        
        while (maxDeque[0] - minDeque[0] > limit) {
            if (maxDeque[0] === nums[left]) maxDeque.shift();
            if (minDeque[0] === nums[left]) minDeque.shift();
            left++;
        }
        
        longest = Math.max(longest, right - left + 1);
        right++;
    }
    return longest;
}

-----
function longestSubarray(nums, limit) 
    // Your code here
}

************************************
Question ID: 1439
function kthSmallest(mat, k) {
    let m = mat.length, n = mat[0].length;
    let minHeap = new PriorityQueue((a, b) => a[0] - b[0]);
    minHeap.push([mat[0][0], 0, 0]);

    let visited = new Set([0 * n]);
    let count = 0;

    while (minHeap.length) {
        let [sum, row, col] = minHeap.pop();

        count++;
        if (count === k) {
            return sum;
        }

        if (row + 1 < m && !visited.has((row + 1) * n + col)) {
            visited.add((row + 1) * n + col);
            minHeap.push([sum - mat[row][col] + mat[row + 1][col], row + 1, col]);
        }
        
        if (col + 1 < n && !visited.has(row * n + (col + 1))) {
            visited.add(row * n + (col + 1));
            minHeap.push([sum - mat[row][col] + mat[row][col + 1], row, col + 1]);
        }
    }
    
    return -1;
}

class PriorityQueue {
    constructor(comparator) {
        this.heap = [];
        this.comparator = comparator;
    }

    get length() {
        return this.heap.length;
    }

    push(value) {
        this.heap.push(value);
        this._bubbleUp();
    }

    pop() {
        const top = this.heap[0];
        const bottom = this.heap.pop();
        if (this.heap.length) {
            this.heap[0] = bottom;
            this._siftDown();
        }
        return top;
    }

    _bubbleUp() {
        let index = this.heap.length - 1;
        const element = this.heap[index];
        
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            const parent = this.heap[parentIndex];

            if (this.comparator(element, parent) >= 0) break;
            
            this.heap[index] = parent;
            this.heap[parentIndex] = element;
            index = parentIndex;
        }
    }

    _siftDown() {
        let parentIndex = 0;
        
        while (true) {
            const leftChildIndex = (parentIndex * 2) + 1;
            const rightChildIndex = (parentIndex * 2) + 2;
            let newIndex = parentIndex;

            if (leftChildIndex < this.heap.length && this.comparator(this.heap[leftChildIndex], this.heap[newIndex]) < 0) {
                newIndex = leftChildIndex;
            }

            if (rightChildIndex < this.heap.length && this.comparator(this.heap[rightChildIndex], this.heap[newIndex]) < 0) {
                newIndex = rightChildIndex;
            }

            if (newIndex === parentIndex) break;
            
            [this.heap[parentIndex], this.heap[newIndex]] = [this.heap[newIndex], this.heap[parentIndex]];
            parentIndex = newIndex;
        }
    }
}

-----
function kthSmallest(mat, k) 
    // Your code here
}

************************************
Question ID: 1441
function buildArray(target, n) {
    let result = [];
    let current = 1;
    for (let num of target) {
        while (current < num) {
            result.push("Push ");
            result.push("Pop ");
            current++;
        }
        result.push("Push ");
        current++;
    }
    return result;
}

-----
function buildArray(target, n) 
    // Your code here
}

************************************
Question ID: 1442
function makeConnected(n, connections) {
    const adjList = Array.from({ length: n }, () => []);
    const visited = Array(n).fill(false);
    let components = 0, extraEdges = 0;

    for (const [a, b] of connections) {
        adjList[a].push(b);
        adjList[b].push(a);
    }

    for (let i = 0; i < n; i++) {
        if (!visited[i]) {
            components++;
            const stack = [i];

            while (stack.length) {
                const current = stack.pop();

                if (!visited[current]) {
                    visited[current] = true;

                    for (const neighbor of adjList[current]) {
                        if (!visited[neighbor]) {
                            stack.push(neighbor);
                        } else {
                            extraEdges++;
                        }
                    }
                }
            }
        }
    }

    const extraNeeded = components - 1;

    if (extraEdges >= extraNeeded) {
        return extraNeeded;
    }

    return -1;
}


-----
function makeConnected(n, connections) 
    // Your code here
}


************************************
Question ID: 1443
function minimumDistance(word) {
    return dp(-1, -1, 0 and word);

    function dp(first, second, pos, word) {
        if(pos == word.length) return 0;

        let ans = 1e9;
        for (let i of [first, second]) {
            if (i != -1) {
                let dx = Math.abs(word.charCodeAt(pos) - word.charCodeAt(i)) % 6;
                let dy = Math.abs(word.charCodeAt(pos) - word.charCodeAt(i)) / 6;
                ans = Math.min(ans, Math.min(dx, dy) * 2 + Math.max(dx,  dy));
            }
        }
        ans += dp(first, second, pos + 1, word);

        if (first == -1 || second == -1) {
            ans = Math.min(ans, dp(first == -1 ? pos : first, word.charCodeAt(pos), pos + 1, word ));
        }

        return ans;
    }
}


-----
function minimumDistance(word) 
    // Your code here
}


************************************
Question ID: 1444
function numberOfSteps(num) {
    let steps = 0;
    while (num) {
        steps += (num % 2 === 0) ? 1 : 2;
        num >>= 1;
    }
    return steps - 1;
}

-----
function numberOfSteps(num) 
    // Your code here
}

************************************
Question ID: 1446
function angleClock(hour, minutes) {
    let minuteAngle = 6 * minutes;
    let hourAngle = 30 * hour + 0.5 * minutes;
    let angle = Math.abs(hourAngle - minuteAngle);
    return Math.min(angle, 360 - angle);
}

-----
function angleClock(hour, minutes) 
    // Your code here
}

************************************
Question ID: 1447
function minJumps(arr) {
    let n = arr.length;
    let maxReach = arr[0];
    let step = arr[0];
    let jumps = 1;

    if(n === 1) return 0;

    for(let i = 1; i < n; i++) {
        if(i === n - 1) return jumps;

        maxReach = Math.max(maxReach, i + arr[i]);

        step--;

        if(step === 0) {
            jumps++;
            step = maxReach - i;
        }
    }
    return -1;
}

-----
function minJumps(arr) 
    // Your code here
}

************************************
Question ID: 1448
function maximum69Number(num) {
    let numStr = num.toString();
    let numChars = numStr.split("");
    for (let i = 0; i < numChars.length; i++) {
        if (numChars[i] === "6") {
            numChars[i] = "9";
            break;
        }
    }
    return parseInt(numChars.join(""));
}

-----
function maximum69Number(num) 
    // Your code here
}

************************************
Question ID: 1449
function largestNumber(cost, target) {
    const dp = new Array(target + 1).fill("");
    dp[0] = "";

    for (let i = 0; i < 9; ++i) {
        for (let j = cost[i]; j <= target; ++j) {
            if (dp[j - cost[i]].length < j - cost[i] && dp[j - cost[i]].length + 1 > dp[j].length) {
                dp[j] = dp[j - cost[i]] + (i + 1).toString();
            }
        }
    }

    return dp[target] || "0";
}

-----
function largestNumber(cost, target) 
    // Your code here
}

************************************
Question ID: 1450
function removeLeafNodes(root, target) {
    if (!root) return null;
    root.left = removeLeafNodes(root.left, target);
    root.right = removeLeafNodes(root.right, target);
    if (!root.left && !root.right && root.val === target) {
        return null;
    }
    return root;
}


-----
function removeLeafNodes(root, target) 
    // Your code here
}


************************************
Question ID: 1451
function minTaps(n, ranges) {
    let intervals = new Array(n + 1).fill(0);
    for (let i = 0; i <= n; i++) {
        let left = Math.max(0, i - ranges[i]);
        let right = Math.min(n, i + ranges[i]);
        intervals[left] = Math.max(intervals[left], right - left);
    }

    let position = 0, total_taps = 0, max_reach = 0;
    while (position < n) {
        max_reach = Math.max(max_reach, position + intervals[position]);
        if (max_reach == position) return -1;
        position = max_reach;
        total_taps++;
    }
    return total_taps;
}

-----
function minTaps(n, ranges) 
    // Your code here
}

************************************
Question ID: 1452
var peopleIndexes = function(favoriteCompanies) {
    const result = [];
    const companySets = favoriteCompanies.map(companies => new Set(companies));
    
    for (let i = 0; i < companySets.length; ++i) {
        let isSubset = false;
        for (let j = 0; j < companySets.length; ++j) {
            if (i !== j && isSubsetOf(companySets[i], companySets[j])) {
                isSubset = true;
                break;
            }
        }
        if (!isSubset) result.push(i);
    }
    
    return result;
};

function isSubsetOf(setA, setB) {
    for (let elem of setA) {
        if (!setB.has(elem)) return false;
    }
    return true;
}

-----
var peopleIndexes = function(favoriteCompanies) 
    // Your code here
}

************************************
Question ID: 1453
function numPoints(darts, r) {
    const n = darts.length;
    let result = 1;
    
    for (let i = 0; i < n; ++i) {
        for (let j = 0; j < n; ++j) {
            let cnt = 0;
            for (let k = 0; k < n; ++k) {
                const dx = darts[i][0] - darts[k][0];
                const dy = darts[i][1] - darts[k][1];
                if (Math.sqrt(dx * dx + dy * dy) <= r) cnt++;
            }
            
            if (cnt > result) result = cnt;
        }
    }
    return result;
}

-----
function numPoints(darts, r) 
    // Your code here
}

************************************
Question ID: 1455
function filterRestaurants(restaurants, veganFriendly, maxPrice, maxDistance) {
    const filteredRestaurants = restaurants.filter(r => (veganFriendly === 0 || r[2] === veganFriendly) && r[3] <= maxPrice && r[4] <= maxDistance);
    filteredRestaurants.sort((a, b) => a[1] === b[1] ? b[0] - a[0] : b[1] - a[1]);

    return filteredRestaurants.map(r => r[0]);
}

-----
function filterRestaurants(restaurants, veganFriendly, maxPrice, maxDistance) 
    // Your code here
}

************************************
Question ID: 1456
function findTheCity(n, edges, distanceThreshold) {
    const INF = Infinity;
    const dist = Array.from({ length: n }, () => Array(n).fill(INF));

    for (let i = 0; i < n; ++i) dist[i][i] = 0;

    for (const [fr, to, w] of edges) {
        dist[fr][to] = dist[to][fr] = w;
    }

    for (let k = 0; k < n; ++k) {
        for (let i = 0; i < n; ++i) {
            for (let j = 0; j < n; ++j) {
                dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
            }
        }
    }

    let res = -1, minReachable = n + 1;
    for (let i = 0; i < n; ++i) {
        let cnt = 0;
        for (const d of dist[i]) {
            if (d <= distanceThreshold) ++cnt;
        }
        if (cnt <= minReachable) {
            minReachable = cnt;
            res = i;
        }
    }
    return res;
}


-----
function findTheCity(n, edges, distanceThreshold) 
    // Your code here
}


************************************
Question ID: 1457
function minDifficulty(jobDifficulty, d) {
    let n = jobDifficulty.length;
    if (n < d) return -1;
    let dp = Array.from({ length: d }, () => new Array(n).fill(Infinity));

    dp[0][0] = jobDifficulty[0];
    for (let i = 1; i < n; ++i) {
        dp[0][i] = Math.max(dp[0][i-1], jobDifficulty[i]);
    }

    for (let i = 1; i < d; ++i) {
        for (let j = i; j < n; ++j) {
            let maxD = jobDifficulty[j];
            for (let k = j; k >= i; --k) {
                maxD = Math.max(maxD, jobDifficulty[k]);
                dp[i][j] = Math.min(dp[i][j], dp[i-1][k-1] + maxD);
            }
        }
    }
    return dp[d-1][n-1];
}


-----
function minDifficulty(jobDifficulty, d) 
    // Your code here
}


************************************
Question ID: 1458
function sortByBits(arr) {
    function countOnes(n) {
        let count = 0;
        while (n > 0) {
            count += n & 1;
            n >>= 1;
        }
        return count;
    }

    return arr.sort((a, b) => {
        let diff = countOnes(a) - countOnes(b);
        return diff !== 0 ? diff : a - b;
    });
}


-----
function sortByBits(arr) 
    // Your code here
}


************************************
Question ID: 1460
function numberOfSubstrings(s) {
    let res = 0, left = 0;
    let count = [0, 0, 0];

    for (let right = 0; right < s.length; right++) {
        count[s.charCodeAt(right) - 'a'.charCodeAt(0)]++;

        while (count[0] > 0 && count[1] > 0 && count[2] > 0) {
            count[s.charCodeAt(left) - 'a'.charCodeAt(0)]--;
            left++;
        }

        res += left;
    }

    return res;
}

-----
function numberOfSubstrings(s) 
    // Your code here
}

************************************
Question ID: 1461
function countOrders(n) {
    let MOD = 1e9 + 7;
    let ans = 1;
    for (let i = 1; i <= n; ++i) {
        ans = ans * (2 * i - 1) * i % MOD;
    }
    return ans;
}

-----
function countOrders(n) 
    // Your code here
}

************************************
Question ID: 1462
function checkIfPrerequisite(numCourses, prerequisites, queries) {
    const adj_matrix = Array.from({ length: numCourses }, () => Array(numCourses).fill(false));
    for (const pre of prerequisites) {
        adj_matrix[pre[0]][pre[1]] = true;
    }
    
    for (let k = 0; k < numCourses; k++) {
        for (let i = 0; i < numCourses; i++) {
            for (let j = 0; j < numCourses; j++) {
                adj_matrix[i][j] = adj_matrix[i][j] || (adj_matrix[i][k] && adj_matrix[k][j]);
            }
        }
    }

    return queries.map(query => adj_matrix[query[0]][query[1]]);
}


-----
function checkIfPrerequisite(numCourses, prerequisites, queries) 
    // Your code here
}


************************************
Question ID: 1463
function kWeakestRows(mat, k) {
    const soldierRows = mat.map((row, i) => [row.reduce((count, val) => count + val, 0), i]);
    soldierRows.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
    return soldierRows.slice(0, k).map(row => row[1]);
}


-----
function kWeakestRows(mat, k) 
    // Your code here
}


************************************
Question ID: 1464
function minSetSize(arr) {
    const count = new Map();
    for (const value of arr)
        count.set(value, (count.get(value) || 0) + 1);

    const freq = Array.from(count.values());
    freq.sort((a, b) => b - a);

    let removed = 0, setSize = 0;
    for (const f of freq) {
        removed += f;
        setSize++;
        if (removed * 2 >= arr.length)
            return setSize;
    }

    return 0;
}


-----
function minSetSize(arr) 
    // Your code here
}


************************************
Question ID: 1466
function maxJumps(arr, d) {
    const n = arr.length;
    const dp = new Array(n).fill(1);

    function helper(idx) {
        if (dp[idx] > 1) {
            return dp[idx];
        }
        let maximum = 1;

        for (let i = 1; i <= d; i++) {
            if (idx + i < n && arr[idx] <= arr[idx + i]) break;
            if (idx + i < n)
                maximum = Math.max(maximum, 1 + helper(idx + i));

            if (idx - i >= 0 && arr[idx] <= arr[idx - i]) break;
            if (idx - i >= 0)
                maximum = Math.max(maximum, 1 + helper(idx - i));
        }
        dp[idx] = maximum;
        return maximum;
    }

    for (let i = 0; i < n; i++) {
        helper(i);
    }

    return Math.max(...dp);
}


-----
function maxJumps(arr, d) 
    // Your code here
}


************************************
Question ID: 1467
function factorial(num) {
    let result = 1;
    for (let i = 1; i <= num; i++)
        result *= i;
    return result;
}

function countCombinations(balls, combinations, currBall) {
    let totalCombinations = 1;
    for (let i = 0; i < currBall; i++)
        totalCombinations *= factorial(balls[i] + combinations[i]) / (factorial(balls[i]) * factorial(combinations[i]));

    return totalCombinations;
}

function dfs(balls, combinations, currBall) {
    if (currBall === balls.length) {
        if (combinations[combinations.length - 1] === combinations[0])
            return countCombinations(balls, combinations, currBall);
        else
            return 0;
    }

    let result = 0;
    for (let i = 0; i <= balls[currBall]; i++) {
        combinations.push(i);
        result += dfs(balls, combinations, currBall + 1);
        combinations.pop();
    }

    return result;
}

function getProbability(balls) {
    let sumBalls = balls.reduce((a, b) => a + b);

    let totalCombinations = 1;
    for (let ball of balls)
        totalCombinations *= factorial(ball);

    let combinations = [];
    return dfs(balls, combinations, 0) / totalCombinations;
}

-----
function factorial(num) 
    // Your code here
}

************************************
Question ID: 1469
function minSteps(s, t) {
    const countS = new Array(26).fill(0);
    const countT = new Array(26).fill(0);
    let steps = 0;

    for (let c of s) countS[c.charCodeAt() - 'a'.charCodeAt()]++;
    for (let c of t) countT[c.charCodeAt() - 'a'.charCodeAt()]++;

    for (let i = 0; i < 26; i++) {
        steps += Math.abs(countS[i] - countT[i]);
    }

    return steps / 2;
}

-----
function minSteps(s, t) 
    // Your code here
}

************************************
Question ID: 1470
class TweetCounts {
    constructor() {
        this.tweetRecords = new Map();
    }

    recordTweet(tweetName, time) {
        if (!this.tweetRecords.has(tweetName)) {
            this.tweetRecords.set(tweetName, new Map());
        }
        const tweetTimeMap = this.tweetRecords.get(tweetName);
        tweetTimeMap.set(time, (tweetTimeMap.get(time) || 0) + 1);
    }

    getTweetCountsPerFrequency(freq, tweetName, startTime, endTime) {
        const interval = freq === "minute" ? 60 : freq === "hour" ? 3600 : 86400;
        const result = new Array(Math.floor((endTime - startTime) / interval) + 1).fill(0);
        if (!this.tweetRecords.has(tweetName)) return result;
        const tweetTimeMap = this.tweetRecords.get(tweetName);

        for (const [time, count] of tweetTimeMap.entries()) {
            if (time >= startTime && time <= endTime) {
                result[Math.floor((time - startTime) / interval)] += count;
            }
        }

        return result;
    }
}


-----
class TweetCounts 
    // Your code here
}


************************************
Question ID: 1471
function maxStudents(seats) {
    const m = seats.length;
    const n = seats[0].length;
    let validRows = new Array(m);
    const max_valid = (1 << n) - 1;

    for (let i = 0; i < m; i++) {
        let state = 0;
        for (let j = 0; j < n; j++) {
            state |= (seats[i][j] === '.') << j;
        }
        validRows[i] = state;
    }

    const memo = Array.from({ length: m }, () => Array(1 << n).fill(-1));
    return dfs(0, 0, validRows, m, n, max_valid, memo);
}

function dfs(rowIndex, prevState, validRows, m, n, max_valid, memo) {
    if (rowIndex === m) {
        return 0;
    }

    if (memo[rowIndex][prevState] !== -1) {
        return memo[rowIndex][prevState];
    }

    let maxStudents = 0;
    for (let curState = 0; curState <= max_valid; curState++) {
        if ((curState & validRows[rowIndex]) !== curState) continue;
        if (curState & (curState << 1)) continue;
        if (curState & (prevState << 1) || prevState & (curState << 1)) continue;

        const curStateCount = curState.toString(2).split("").reduce((sum, bit) => sum + (bit === '1' ? 1 : 0), 0);
        maxStudents = Math.max(maxStudents, dfs(rowIndex + 1, curState, validRows, m, n, max_valid, memo) + curStateCount);
    }

    memo[rowIndex][prevState] = maxStudents;
    return maxStudents;
}

-----
function maxStudents(seats) 
    // Your code here
}

************************************
Question ID: 1472
function sortString(s) {
    const freqMap = new Map([...s]
        .sort()
        .reduce((acc, c) => {
            acc.set(c, (acc.get(c) || 0) + 1);
            return acc;
        }, new Map()));
    let result = '';

    while (freqMap.size) {
        for (const [key, val] of freqMap) {
            result += key;
            if (val - 1 === 0) {
                freqMap.delete(key);
            } else {
                freqMap.set(key, val - 1);
            }
        }

        for (const [key, val] of [...freqMap].reverse()) {
            result += key;
            if (val - 1 === 0) {
                freqMap.delete(key);
            } else {
                freqMap.set(key, val - 1);
            }
        }
    }

    return result;
}

-----
function sortString(s) 
    // Your code here
}

************************************
Question ID: 1473
function findTheLongestSubstring(s) {
    const pos = new Map();
    pos.set(0, -1);
    let ans = 0, n = s.length, i, cur = 0;
    for (i = 0; i < n; ++i) {
        switch (s.charAt(i)) {
            case 'a': cur ^= 1; break;
            case 'e': cur ^= 2; break;
            case 'i': cur ^= 4; break;
            case 'o': cur ^= 8; break;
            case 'u': cur ^= 16; break;
        }
        if(!pos.has(cur)) pos.set(cur, i);
        ans = Math.max(ans, i - pos.get(cur));
    }
    return ans;
}

-----
function findTheLongestSubstring(s) 
    // Your code here
}

************************************
Question ID: 1476
function countNegatives(grid) {
    const m = grid.length, n = grid[0].length;
    let count = 0, i = 0, j = n - 1;
    while (i < m && j >= 0) {
        if (grid[i][j] < 0) {
            count += j + 1;
            i++;
        } else {
            j--;
        }
    }
    return count;
}

-----
function countNegatives(grid) 
    // Your code here
}

************************************
Question ID: 1478
function maxEvents(events) {
    events.sort((a, b) => a[1] - b[1]);

    let count = 0;
    let lastDay = -1;

    for (const event of events) {
        if (event[0] > lastDay) {
            count++;
            lastDay = event[1];
        }
    }

    return count;
}

-----
function maxEvents(events) 
    // Your code here
}

************************************
Question ID: 1480
function runningSum(nums) {
    for(let i = 1; i < nums.length; i++) {
        nums[i] += nums[i - 1];
    }
    return nums;
}

-----
function runningSum(nums) 
    // Your code here
}

************************************
Question ID: 1481
function findLeastNumOfUniqueInts(arr, k) {
    let count = {};
    for (let n of arr) {
        count[n] = (count[n] || 0) + 1;
    }
    let pq = Object.values(count).sort((a, b) => a - b);
    while (k > 0) {
        k -= pq.shift();
    }
    return k === 0 ? pq.length : pq.length + 1;
}

-----
function findLeastNumOfUniqueInts(arr, k) 
    // Your code here
}

************************************
Question ID: 1482
function smallerNumbersThanCurrent(nums) {
    const result = new Array(nums.length).fill(0);
    for (let i = 0; i < nums.length; i++) {
        for (let j = 0; j < nums.length; j++) {
            if (nums[j] < nums[i]) {
                result[i]++;
            }
        }
    }
    return result;
}

-----
function smallerNumbersThanCurrent(nums) 
    // Your code here
}

************************************
Question ID: 1483
function rankTeams(votes) {
    const teams = votes[0].length;
    const ranks = Array.from({ length: 26 }, () => Array(teams).fill(0));

    for (const vote of votes) {
        for (let i = 0; i < teams; ++i) {
            ranks[vote.charCodeAt(i) - "A".charCodeAt(0)][i]++;
        }
    }

    const result = [...votes[0]];
    result.sort((a, b) => {
        for (let i = 0; i < teams; ++i) {
            if (ranks[a.charCodeAt(0) - "A".charCodeAt(0)][i] !== ranks[b.charCodeAt(0) - "A".charCodeAt(0)][i]) {
                return ranks[b.charCodeAt(0) - "A".charCodeAt(0)][i] - ranks[a.charCodeAt(0) - "A".charCodeAt(0)][i];
            }
        }
        return a.localeCompare(b);
    });

    return result.join("");
}


-----
function rankTeams(votes) 
    // Your code here
}


************************************
Question ID: 1485
function minCost(grid) {
    function dfs(r, c, d) {
        if (r >= 0 && c >= 0 && r < m && c < n && d < cost[r][c]) {
            cost[r][c] = d;
            q.push([r, c]);
        }
    }

    const m = grid.length;
    const n = grid[0].length;
    const cost = Array.from({length: m}, () => new Array(n).fill(1e6));
    const q = [];
    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

    dfs(0, 0, 0);

    while (q.length) {
        const [r, c] = q.shift();
        for (let i = 0; i < 4; i++) {
            const nr = r + directions[i][0];
            const nc = c + directions[i][1];
            dfs(nr, nc, cost[r][c] + (grid[r][c] !== i + 1));
        }
    }
    
    return cost[m - 1][n - 1];
}

-----
function minCost(grid) 
    // Your code here
}

************************************
Question ID: 1486
function findTheDistanceValue(arr1, arr2, d) {
    let count = 0;
    for (let i = 0; i < arr1.length; i++) {
        let valid = true;
        for (let j = 0; j < arr2.length; j++) {
            if (Math.abs(arr1[i] - arr2[j]) <= d) {
                valid = false;
                break;
            }
        }
        if (valid) count++;
    }
    return count;
}

-----
function findTheDistanceValue(arr1, arr2, d) 
    // Your code here
}

************************************
Question ID: 1487
function maxNumberOfFamilies(n, reservedSeats) {
    const rows = {};
    for (const seat of reservedSeats) {
        rows[seat[0]] = (rows[seat[0]] || 0) | (1 << (seat[1] - 1));
    }
    
    let max_groups = (n - Object.keys(rows).length) * 2;
    for (const row in rows) {
        const rowMasks = rows[row];
        const seats = ~(rowMasks | (rowMasks >> 1) | (rowMasks >> 2) | (rowMasks >> 3)) & 0x3FF;
        max_groups += (seats & (seats >> 1) & (seats >> 2) & (seats >> 3)) !== 0 ? 1 : 0;
    }
    
    return max_groups;
}

-----
function maxNumberOfFamilies(n, reservedSeats) 
    // Your code here
}

************************************
Question ID: 1488
function getPower(x) {
    let steps = 0;
    while (x !== 1) {
        if (x % 2 === 0) x /= 2;
        else x = 3 * x + 1;
        steps++;
    }
    return steps;
}

function sortByPower(lo, hi, k) {
    let nums = [];
    for (let i = lo; i <= hi; i++) {
        nums.push([getPower(i), i]);
    }
    nums.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
    return nums[k - 1][1];
}

-----
function getPower(x) 
    // Your code here
}

************************************
Question ID: 1489
function maxSizeSlices(slices) {
    function maxSum(slices, start, end, n, memo) {
        if (n === 0) return 0;
        if (end - start + 1 < n * 2) return Number.NEGATIVE_INFINITY;
        if (memo[start][n] !== -1) return memo[start][n];

        const pick = maxSum(slices, start + 2, end, n - 1, memo) + slices[start];
        const notPick = maxSum(slices, start + 1, end, n, memo);

        memo[start][n] = Math.max(pick, notPick);
        return memo[start][n];
    }

    const n = slices.length / 3;
    const memo1 = Array.from({ length: slices.length }, () => Array(n + 1).fill(-1));
    const memo2 = Array.from({ length: slices.length }, () => Array(n + 1).fill(-1));

    return Math.max(maxSum(slices, 0, slices.length - 1, n, memo1),
                   maxSum(slices, 1, slices.length, n, memo2));
}


-----
function maxSizeSlices(slices) 
    // Your code here
}


************************************
Question ID: 1490
function generateTheString(n) {
    let result = "";
    for (let i = 0; i < n - 1; i++) {
        result += 'a';
    }
    if (n % 2 === 0) {
        result += 'b';
    } else {
        result += 'a';
    }
    return result;
}

-----
function generateTheString(n) 
    // Your code here
}

************************************
Question ID: 1491
function countPrefixAligned(flips) {
    let count = 0;
    for (let i = 0; i < flips.length; i++) {
        if (flips[i] === i + 1) {
            count++;
        }
    }
    return count;
}

-----
function countPrefixAligned(flips) 
    // Your code here
}

************************************
Question ID: 1492
function numOfMinutes(n, headID, manager, informTime) {
    const subordinates = new Array(n).fill(0).map(() => []);
    for (let i = 0; i < n; i++) {
        if (manager[i] !== -1) {
            subordinates[manager[i]].push(i);
        }
    }

    const queue = [[headID, 0]];
    let totalTime = 0;

    while (queue.length) {
        const [current, time] = queue.shift();
        totalTime = Math.max(totalTime, time);
        for (const sub of subordinates[current]) {
            queue.push([sub, time + informTime[current]]);
        }
    }

    return totalTime;
}


-----
function numOfMinutes(n, headID, manager, informTime) 
    // Your code here
}


************************************
Question ID: 1493
function frogPosition(n, edges, t, target) {
    const graph = Array.from({ length: n + 1 }, () => []);
    for (const edge of edges) {
        graph[edge[0]].push(edge[1]);
        graph[edge[1]].push(edge[0]);
    }
    return dfs(1, -1, t, target, graph);
}

function dfs(node, parent, t, target, graph) {
    if (t === 0) {
        return node === target ? 1.0 : 0.0;
    }
    let probability = 0.0;
    for (const neighbor of graph[node]) {
        if (neighbor !== parent) {
            probability += dfs(neighbor, node, t - 1, target, graph);
        }
    }
    return probability / (graph[node].length - (parent === -1 ? 0 : 1));
}


-----
function frogPosition(n, edges, t, target) 
    // Your code here
}


************************************
Question ID: 1494
function minNumberOfSemesters(n, relations, k) {
    const indegree = new Array(n + 1).fill(0);
    const graph = new Array(n + 1).fill().map(() => []);
  
    for (const [prevCourse, nextCourse] of relations) {
        graph[prevCourse].push(nextCourse);
        indegree[nextCourse]++;
    }
  
    let semesters = 0;
    while (n > 0) {
        const zero_indegree = [];
        for (let i = 1; i < indegree.length; i++) {
            if (indegree[i] === 0) {
                zero_indegree.push(i);
                indegree[i] = -1;
            }
        }
  
        let courses = 0;
        while (zero_indegree.length > 0 && courses < k) {
            const curr_course = zero_indegree.shift();
            n--;
  
            for (const next_course of graph[curr_course]) {
                indegree[next_course]--;
            }
            courses++;
        }
        semesters++;
    }
    return semesters;
}

-----
function minNumberOfSemesters(n, relations, k) 
    // Your code here
}

************************************
Question ID: 1496
function luckyNumbers(matrix) {
    const m = matrix.length, n = matrix[0].length;
    const luckyNumbers = [];

    for (let i = 0; i < m; i++) {
        let minRow = matrix[i][0];
        let minRowIndex = 0;
        for (let j = 0; j < n; j++) {
            if (matrix[i][j] < minRow) {
                minRow = matrix[i][j];
                minRowIndex = j;
            }
        }

        let isLucky = true;
        for (let k = 0; k < m; k++) {
            if (matrix[k][minRowIndex] > minRow) {
                isLucky = false;
                break;
            }
        }

        if (isLucky)
            luckyNumbers.push(minRow);
    }

    return luckyNumbers;
}

-----
function luckyNumbers(matrix) 
    // Your code here
}

************************************
Question ID: 1498
function getTargetCopy(original, cloned, target) {
    if (original === null)
        return null;
    if (original === target)
        return cloned;

    let left = getTargetCopy(original.left, cloned.left, target);
    return left ? left : getTargetCopy(original.right, cloned.right, target);
}

-----
function getTargetCopy(original, cloned, target) 
    // Your code here
}

************************************
Question ID: 1499
function maxPerformance(n, k, speed, efficiency) {
  const engineers = efficiency.map((e, i) => [e, speed[i]]);
  engineers.sort((a, b) => b[0] - a[0]);

  let sum = 0, result = 0;
  const minHeap = new MinHeap();
  for (const [e, s] of engineers) {
    if (minHeap.size() >= k) {
      sum -= minHeap.poll();
    }
    minHeap.offer(s);
    sum += s;
    result = Math.max(result, e * sum);
  }

  return result % 1000000007;
}

class MinHeap {
  constructor() {
    this.data = [];
  }

  offer(value) {
    this.data.push(value);
    this._bubbleUp(this.data.length - 1);
  }

  poll() {
    if (this.data.length === 0) {
      return null;
    }
    if (this.data.length === 1) {
      return this.data.pop();
    }
    const result = this.data[0];
    this.data[0] = this.data.pop();
    this._sinkDown(0);

    return result;
  }

  size() {
    return this.data.length;
  }

  _bubbleUp(index) {
    while (index > 0) {
      const parentIndex = Math.floor((index - 1) / 2);
      const value = this.data[index];
      const parentValue = this.data[parentIndex];
      if (value >= parentValue) {
        break;
      }
      this.data[parentIndex] = value;
      this.data[index] = parentValue;
      index = parentIndex;
    }
  }

  _sinkDown(index) {
    const last = this.data.length - 1;
    while (true) {
      const leftChildIndex = index * 2 + 1;
      const rightChildIndex = leftChildIndex + 1;
      let swapIndex = index;

      if (leftChildIndex <= last && this.data[leftChildIndex] < this.data[swapIndex]) {
        swapIndex = leftChildIndex;
      }
      if (rightChildIndex <= last && this.data[rightChildIndex] < this.data[swapIndex]) {
        swapIndex = rightChildIndex;
      }
      if (swapIndex === index) {
        break;
      }
      [this.data[index], this.data[swapIndex]] = [this.data[swapIndex], this.data[index]];
      index = swapIndex;
    }
  }
}

-----
function maxPerformance(n, k, speed, efficiency) 
    // Your code here
}

************************************
Question ID: 1500
function countLargestGroup(n) {
    let freq = new Array(37).fill(0);
    let maxGroupSize = 0, maxGroupCount = 0;
    
    for (let i = 1; i <= n; i++) {
        let sum = 0, num = i;
        while (num !== 0) {
            sum += num % 10;
            num = Math.floor(num / 10);
        }
        freq[sum]++;
        maxGroupSize = Math.max(maxGroupSize, freq[sum]);
    }

    for (let i = 0; i < 37; i++) {
        if (freq[i] === maxGroupSize) {
            maxGroupCount++;
        }
    }
    
    return maxGroupCount;
}


-----
function countLargestGroup(n) 
    // Your code here
}


************************************
Question ID: 1502
function canConstruct(s, k) {
    let charCounts = new Array(26).fill(0);

    for (let c of s) 
        charCounts[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;

    let oddCount = charCounts.reduce((acc, count) => acc + (count % 2), 0);

    return oddCount <= k && k <= s.length;
}


-----
function canConstruct(s, k) 
    // Your code here
}


************************************
Question ID: 1503
function maxSatisfaction(satisfaction) {
    satisfaction.sort((a, b) => b - a);
    let ans = 0, total = 0, sum = 0;
    for (let i of satisfaction) {
        total += i;
        if (total > 0) {
            sum += total;
            ans = Math.max(ans, sum);
        }
    }
    return ans;
}

-----
function maxSatisfaction(satisfaction) 
    // Your code here
}

************************************
Question ID: 1504
function numSubmat(mat) {
    const m = mat.length, n = mat[0].length;
    const dp = Array.from({ length: m }, () => Array.from({ length: n }, () => 0));
    let ans = 0;

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (mat[i][j] === 1) {
                dp[i][j] = j === 0 ? 1 : dp[i][j-1] + 1;
                let width = dp[i][j];
                for (let k = i; k >= 0; k--) {
                    width = Math.min(width, dp[k][j]);
                    ans += width;
                }
            }
        }
    }
    return ans;
}

-----
function numSubmat(mat) 
    // Your code here
}

************************************
Question ID: 1505
function createTargetArray(nums, index) {
    let target = [];
    for (let i = 0; i < nums.length; ++i) {
        target.splice(index[i], 0, nums[i]);
    }
    return target;
}

-----
function createTargetArray(nums, index) 
    // Your code here
}

************************************
Question ID: 1507
function hasValidPath(grid) {
    const m = grid.length;
    const n = grid[0].length;
    const visited = new Array(m).fill(null).map(() => new Array(n).fill(false));

    return dfs(grid, 0, 0, m, n, visited);
}

function dfs(grid, x, y, m, n, visited) {
    if (x < 0 || y < 0 || x >= m || y >= n || visited[x][y]) return false;
    if (x === m - 1 && y === n - 1) return true;

    visited[x][y] = true;

    const next_x = [-1, 0, 1, 0];
    const next_y = [0, 1, 0, -1];

    for (let i = 0; i < 4; i++) {
        const dx = x + next_x[i];
        const dy = y + next_y[i];

        if (dfs(grid, dx, dy, m, n, visited)) return true;
    }

    return false;
}

-----
function hasValidPath(grid) 
    // Your code here
}

************************************
Question ID: 1508
function longestHappyPrefix(s) {
    let n = s.length;
    let lps = new Array(n).fill(0);
    let len = 0;
    let i = 1;
    while (i < n) {
        if (s.charAt(i) === s.charAt(len)) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len !== 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    return s.substring(0, lps[n - 1]);
}

-----
function longestHappyPrefix(s) 
    // Your code here
}

************************************
Question ID: 1509
function minDifference(nums) {
    let n = nums.length;
    if (n <= 4) return 0;
    nums.sort((a, b) => a - b);
    let res = Number.MAX_SAFE_INTEGER;
    for (let i = 0; i <= 3; ++i)
        res = Math.min(res, nums[n - 4 + i] - nums[i]);
    return res;
}

-----
function minDifference(nums) 
    // Your code here
}

************************************
Question ID: 1510
function findLucky(arr) {
    let freq = {};

    for (let n of arr) {
        if (n in freq) {
            freq[n]++;
        } else {
            freq[n] = 1;
        }
    }

    let lucky = -1;
    for (let key in freq) {
        let value = freq[key];
        if (parseInt(key) === value) {
            lucky = Math.max(lucky, key);
        }
    }

    return lucky;
}

-----
function findLucky(arr) 
    // Your code here
}

************************************
Question ID: 1513
const MOD = 1e9 + 7;

function countGoodStrings(s1, s2, evil) {
    let n = s1.length;
    let m = evil.length;
    let dp = Array.from({length: n + 1}, () => Array(m).fill(0));

    // Preprocess the KMP prefix function for the evil string
    let lps = new Array(m).fill(0);
    let len = 0;
    for (let i = 1; i < m;) {
        if (evil[i] === evil[len]) {
            lps[i++] = ++len;
        } else if (len) {
            len = lps[len - 1];
        } else {
            ++i;
        }
    }

    dp[0][0] = 1;
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            for (let k = 0; k < 2; k++) {
                for (let c = 'a'.charCodeAt(0); c <= (k ? s2.charCodeAt(i) : 'z'.charCodeAt(0)); c++) {
                    let e = j;
                    while (e && (String.fromCharCode(c) !== evil[e])) {
                        e = lps[e - 1];
                    }

                    if (String.fromCharCode(c) !== evil[e]) {
                        e++;
                    }

                    if (e !== m) {
                        dp[i + 1][k | (c < s2.charCodeAt(i))] += dp[i][k];
                        dp[i + 1][k | (c < s2.charCodeAt(i))] %= MOD;
                    }
                }
            }
        }
    }

    return (dp[n][1] - dp[n][0] + MOD) % MOD;
}


-----
const MOD = 1e9 + 7;

function countGoodStrings(s1, s2, evil) 
    // Your code here
}


************************************
Question ID: 1514
function minStartValue(nums) {
    let min_sum = 0, sum = 0;
    for (const num of nums) {
        sum += num;
        min_sum = Math.min(min_sum, sum);
    }
    return 1 - min_sum;
}

-----
function minStartValue(nums) 
    // Your code here
}

************************************
Question ID: 1515
function findMinFibonacciNumbers(k) {
    if (k === 0) return 0;
    let a = 0, b = 1;
    while (b <= k) {
        [a, b] = [b, a + b];
    }
    return 1 + findMinFibonacciNumbers(k - a);
}

-----
function findMinFibonacciNumbers(k) 
    // Your code here
}

************************************
Question ID: 1516
function getHappyString(n, k) {
    const happyStrings = [];
    const dfs = (s, prev) => {
        if (s.length === n) {
            happyStrings.push(s);
            return;
        }
        for (let c = 'a'.charCodeAt(); c <= 'c'.charCodeAt(); c++) {
            const char = String.fromCharCode(c);
            if (char !== prev) {
                dfs(s + char, char);
            }
        }
    };
    dfs('', ' ');
    return k <= happyStrings.length ? happyStrings[k - 1] : "";
}

-----
function getHappyString(n, k) 
    // Your code here
}

************************************
Question ID: 1518
function numWaterBottles(numBottles, numExchange) {
    let totalBottles = numBottles;
    while (numBottles >= numExchange) {
        let newBottles = Math.floor(numBottles / numExchange);
        totalBottles += newBottles;
        numBottles = newBottles + numBottles % numExchange;
    }
    return totalBottles;
}

-----
function numWaterBottles(numBottles, numExchange) 
    // Your code here
}

************************************
Question ID: 1519
function minSubsequence(nums) {
    nums.sort((a, b) => b - a);
    const totalSum = nums.reduce((a, b) => a + b, 0);
    let currentSum = 0;
    const result = [];
    for (const num of nums) {
        currentSum += num;
        result.push(num);
        if (currentSum > totalSum - currentSum) {
            break;
        }
    }
    return result;
}

-----
function minSubsequence(nums) 
    // Your code here
}

************************************
Question ID: 1520
function numSteps(s) {
    let steps = 0, carry = 0;
    for (let i = s.length - 1; i > 0; --i) {
        let current = parseInt(s[i]) + carry;
        if (current == 1) {
            steps += 2;
            carry = 1;
        } else {
            steps += carry;
            carry = current;
        }
    }

    return steps + carry;
}

-----
function numSteps(s) 
    // Your code here
}

************************************
Question ID: 1521
function closestToTarget(arr, target) {
    let minDiff = Infinity;
    let prefix = new Set();

    for (const n of arr) {
        let nextPrefix = new Set();
        for (const p of prefix) {
            nextPrefix.add(p & n);
        }
        nextPrefix.add(n);

        for (const p of nextPrefix) {
            minDiff = Math.min(minDiff, Math.abs(p - target));
        }
        prefix = nextPrefix;
    }
    return minDiff;
}

-----
function closestToTarget(arr, target) 
    // Your code here
}

************************************
Question ID: 1522
function stoneGameIII(stoneValue) {
    const n = stoneValue.length;
    const dp = new Array(n + 1).fill(0);
    dp[n - 1] = stoneValue[n - 1];
    for (let i = n - 2; i >= 0; --i) {
        dp[i] = stoneValue[i] - dp[i + 1];
        for (let j = 1; j < 3; ++j) {
            if (i + j < n)
                dp[i] = Math.max(dp[i], stoneValue[i + j] - dp[i + j + 1]);
        }
    }
    if (dp[0] > 0) return "Alice";
    if (dp[0] < 0) return "Bob";
    return "Tie";
}

-----
function stoneGameIII(stoneValue) 
    // Your code here
}

************************************
Question ID: 1523
function countOdds(low, high) {
    return Math.floor((high - low) / 2) + ((low % 2 === 1 || high % 2 === 1) ? 1 : 0);
}

-----
function countOdds(low, high) 
    // Your code here
}

************************************
Question ID: 1524
function stringMatching(words) {
    const result = [];
    for (const word1 of words) {
        for (const word2 of words) {
            if (word1 !== word2 && word2.includes(word1)) {
                result.push(word1);
                break;
            }
        }
    }
    return result;
}

-----
function stringMatching(words) 
    // Your code here
}

************************************
Question ID: 1525
function processQueries(queries, m) {
    const nums = Array.from({ length: m }, (_, i) => i + 1);
    const result = [];
    for (const q of queries) {
        const pos = nums.indexOf(q);
        result.push(pos);
        nums.splice(pos, 1);
        nums.unshift(q);
    }
    return result;
}

-----
function processQueries(queries, m) 
    // Your code here
}

************************************
Question ID: 1526
function entityParser(text) {
    const entities = {
        "&quot;": '\"',
        "&apos;": '\'',
        "&amp;": '&',
        "&gt;": '>',
        "&lt;": '<',
        "&frasl;": '/'
    };

    let result = '';
    for (let i = 0; i < text.length; ++i) {
        if (text[i] === '&') {
            let temp = '';
            for (let j = i; j < text.length && j < i + 7; ++j) {
                temp += text[j];
                if (temp in entities) {
                    result += entities[temp];
                    i = j;
                    break;
                }
            }
            if (temp[temp.length - 1] !== ';') result += text[i];
        } else {
            result += text[i];
        }
    }
    return result;
}


-----
function entityParser(text) 
    // Your code here
}


************************************
Question ID: 1528
function kidsWithCandies(candies, extraCandies) {
    let maxCandies = Math.max(...candies);
    let result = candies.map(candy => candy + extraCandies >= maxCandies);
    return result;
}

-----
function kidsWithCandies(candies, extraCandies) 
    // Your code here
}

************************************
Question ID: 1529
function maxDifference(num) {
    const a = num + 9 - (num % 10);
    const b = num - (Math.floor(num / 1000) % 10) * 111;

    return a - b;
}

-----
function maxDifference(num) 
    // Your code here
}

************************************
Question ID: 1530
function checkIfCanBreak(s1, s2) {
    let sorted1 = [...s1].sort();
    let sorted2 = [...s2].sort();

    let canBreak1 = true, canBreak2 = true;
    for(let i = 0; i < sorted1.length; i++) {
        if(sorted1[i] < sorted2[i]) canBreak1 = false;
        if(sorted2[i] < sorted1[i]) canBreak2 = false;
    }
    return canBreak1 || canBreak2;
}


-----
function checkIfCanBreak(s1, s2) 
    // Your code here
}


************************************
Question ID: 1531
function numberWays(hats) {
    const kMod = 1000000007;
    const kMaxHats = 40;

    const num_people = hats.length;
    const people_with_hat = Array.from({length: kMaxHats}, () => []);

    for (let i = 0; i < num_people; ++i) {
        for (const hat of hats[i]) {
            people_with_hat[hat - 1].push(i);
        }
    }

    const dp = Array.from({length: 1 << num_people}, () => Array(kMaxHats + 1).fill(0));
    dp[0][0] = 1;

    for (let hat = 0; hat < kMaxHats; ++hat) {
        for (let mask = (1 << num_people) - 1; mask >= 0; --mask) {
            dp[mask][hat + 1] = (dp[mask][hat + 1] + dp[mask][hat]) % kMod;
            for (const person of people_with_hat[hat]) {
                if ((mask & (1 << person)) === 0) {
                    dp[mask | (1 << person)][hat + 1] = (dp[mask | (1 << person)][hat + 1] + dp[mask][hat]) % kMod;
                }
            }
        }
    }

    return dp[(1 << num_people) - 1][kMaxHats];
}

-----
function numberWays(hats) 
    // Your code here
}

************************************
Question ID: 1533
function displayTable(orders) {
    const foodItems = new Set();
    const tableOrders = new Map();

    for (const order of orders) {
        foodItems.add(order[2]);
        const tableNumber = parseInt(order[1]);
        if (!tableOrders.has(tableNumber)) {
            tableOrders.set(tableNumber, new Map());
        }
        const table = tableOrders.get(tableNumber);
        table.set(order[2], (table.get(order[2]) || 0) + 1);
    }

    const sortedFoodItems = Array.from(foodItems).sort();
    const header = ['Table', ...sortedFoodItems];
    const result = [header];

    for (const [tableNumber, foodOrder] of [...tableOrders.entries()].sort((a, b) => a[0] - b[0])) {
        const row = [tableNumber.toString(), ...sortedFoodItems.map(food => (foodOrder.get(food) || 0).toString())];
        result.push(row);
    }

    return result;
}


-----
function displayTable(orders) 
    // Your code here
}


************************************
Question ID: 1534
function minNumberOfFrogs(croakOfFrogs) {
    let counts = Array(5).fill(0);
    let max_frogs = 0;

    for (let c of croakOfFrogs) {
        let index = "croak".indexOf(c);
        if (index === 0) {
            counts[0]++;
            max_frogs = Math.max(max_frogs, counts[0]);
        } else if (counts[index - 1] > 0) {
            counts[index - 1]--;
            counts[index]++;
        } else {
            return -1;
        }
    }

    if (counts[0] === counts[4]) {
        return max_frogs;
    } else {
        return -1;
    }
}

-----
function minNumberOfFrogs(croakOfFrogs) 
    // Your code here
}

************************************
Question ID: 1535
function numberOfWays(n, m, k, mod = 1_000_000_007) {
    if (k > 1) {
        let result = 1;
        for (let i = 0; i < n; ++i) {
            result = (result * m) % mod;
        }
        return result;
    }
    return n % 2 === 0 ? 1 : m;
}

-----
function numberOfWays(n, m, k, mod = 1_000_000_007) 
    // Your code here
}

************************************
Question ID: 1536
function minSwaps(grid) {
    const n = grid.length;
    let steps = 0;

    for (let i = 0; i < n; ++i) {
        let row = -1;
        for (let j = i; j < n; ++j) {
            if (grid[j][i] === 0) {
                row = j;
                break;
            }
        }
        if (row === -1) {
            return -1;
        }

        while (row > i) {
            [grid[row], grid[row - 1]] = [grid[row - 1], grid[row]];
            steps++;
            row--;
        }
    }
    return steps;
}


-----
function minSwaps(grid) 
    // Your code here
}


************************************
Question ID: 1537
function maxScore(s) {
    let left_zeros = 0, right_ones = 0, max_score = 0;
    for(let c of s) if(c === '1') right_ones++;
        
    for(let i = 0; i < s.length - 1; i++) {
        if(s[i] === '0') left_zeros++;
        else right_ones--;
        max_score = Math.max(max_score, left_zeros + right_ones);
    }
    return max_score;
}

-----
function maxScore(s) 
    // Your code here
}

************************************
Question ID: 1538
function maxScore(cardPoints, k) {
    let n = cardPoints.length;
    let total = 0;
    for (let i = 0; i < k; i++) {
        total += cardPoints[i];
    }

    let maxScore = total;
    for (let i = k - 1, j = n - 1; i >= 0; i--, j--) {
        total += cardPoints[j] - cardPoints[i];
        maxScore = Math.max(maxScore, total);
    }

    return maxScore;
}


-----
function maxScore(cardPoints, k) 
    // Your code here
}


************************************
Question ID: 1539
function findDiagonalOrder(nums) {
    const diagonals = {};
    const m = nums.length;
    const res = [];

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < nums[i].length; j++) {
            if (!diagonals[i + j]) {
                diagonals[i + j] = [];
            }
            diagonals[i + j].push(nums[i][j]);
        }
    }

    for (const key in diagonals) {
        res.push(...diagonals[key].reverse());
    }

    return res;
}

-----
function findDiagonalOrder(nums) 
    // Your code here
}

************************************
Question ID: 1540
function canConvertString(s, t, k) {
    if (s.length !== t.length) return false;
    const count = new Array(26).fill(0);
    for (let i = 0; i < s.length; i++) {
        const diff = (t.charCodeAt(i) - s.charCodeAt(i) + 26) % 26;
        if (diff > 0) {
            count[diff]++;
        }
    }
    for (let i = 1; i < 26; i++) {
        if (count[i] > 0) {
            if (count[i] * 26 - 26 + i > k) {
                return false;
            }
        }
    }
    return true;
}

-----
function canConvertString(s, t, k) 
    // Your code here
}

************************************
Question ID: 1541
function minInsertions(s) {
    let left = 0, res = 0;
    const n = s.length;
    for (let i = 0; i < n; i++) {
        if (s[i] === '(') {
            left++;
        } else {
            if (left === 0) res++;
            else left--;
            if (i === n - 1 || s[i + 1] !== ')') {
                res++;
                i++;
            }
        }
    }
    return res + left * 2;
}

-----
function minInsertions(s) 
    // Your code here
}

************************************
Question ID: 1542
function maxPower(s) {
    let maxPower = 0, currentPower = 1;

    for (let i = 1; i < s.length; i++) {
        if (s[i] === s[i-1]) {
            currentPower++;
        } else {
            maxPower = Math.max(maxPower, currentPower);
            currentPower = 1;
        }
    }

    return Math.max(maxPower, currentPower);
}

-----
function maxPower(s) 
    // Your code here
}

************************************
Question ID: 1544
function goodNodes(root, maxVal = Number.MIN_SAFE_INTEGER) {
    if (!root) return 0;
    let result = 0;
    if (root.val >= maxVal) {
        result = 1;
        maxVal = root.val;
    }
    return result + goodNodes(root.left, maxVal) + goodNodes(root.right, maxVal);
}

-----
function goodNodes(root, maxVal = Number.MIN_SAFE_INTEGER) 
    // Your code here
}

************************************
Question ID: 1545
function largestNumber(cost, target) {
    const dp = new Array(target + 1).fill("");
    dp[0] = "";
    
    for (let t = 1; t <= target; ++t) {
        for (let i = 1; i <= 9; ++i) {
            if (t >= cost[i - 1] && dp[t - cost[i - 1]] !== "") {
                const temp = dp[t - cost[i - 1]] + i.toString();
                if (dp[t].length <= temp.length) {
                    dp[t] = temp;
                }
            }
        }
    }

    return dp[target] === "" ? "0" : dp[target];
}


-----
function largestNumber(cost, target) 
    // Your code here
}


************************************
Question ID: 1546
function maxNonOverlapping(nums, target) {
    const prefixSum = new Map();
    let sum = 0, count = 0;
    prefixSum.set(0, 0);
    for (const num of nums) {
        sum += num;
        if (prefixSum.has(sum - target)) {
            count = Math.max(count, 1 + prefixSum.get(sum - target));
        }
        prefixSum.set(sum, count);
    }
    return count;
}

-----
function maxNonOverlapping(nums, target) 
    // Your code here
}

************************************
Question ID: 1547
function destCity(paths) {
    const startingCities = new Set();

    for (const path of paths)
        startingCities.add(path[0]);

    for (const path of paths) {
        if (!startingCities.has(path[1]))
            return path[1];
    }

    return "";
}

-----
function destCity(paths) 
    // Your code here
}

************************************
Question ID: 1548
function kLengthApart(nums, k) {
    let last_one = -1;
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] === 1) {
            if (last_one !== -1 && i - last_one <= k) {
                return false;
            }
            last_one = i;
        }
    }
    return true;
}

-----
function kLengthApart(nums, k) 
    // Your code here
}

************************************
Question ID: 1550
function kthSmallest(mat, k) {
    const m = mat.length, n = mat[0].length;
    
    const minHeap = [[mat[0][0], 0, 0]].sort((a, b) => a[0] - b[0]);
    const visited = Array(m).fill().map(_ => Array(n).fill(false));
    visited[0][0] = true;
    
    let res = 0;
    while (k-- > 0) {
        const [val, i, j] = minHeap.shift();
        res = val;
        
        if (i < m - 1 && !visited[i+1][j]) {
            minHeap.push([res - mat[i][j] + mat[i + 1][j], i + 1, j]);
            visited[i+1][j] = true;
        }
        if (j < n - 1 && !visited[i][j+1]) {
            minHeap.push([res - mat[i][j] + mat[i][j + 1], i, j + 1]);
            visited[i][j+1] = true;
        }
        
        minHeap.sort((a, b) => a[0] - b[0]);
    }
    
    return res;
}

-----
function kthSmallest(mat, k) 
    // Your code here
}

************************************
Question ID: 1551
function minOperations(n) {
    return Math.floor(n * n / 4);
}

-----
function minOperations(n) 
    // Your code here
}

************************************
Question ID: 1552
function buildArray(target, n) {
    const result = [];
    let current = 1;
    for (const num of target) {
        while (current < num) {
            result.push("Push");
            result.push("Pop");
            current++;
        }
        result.push("Push");
        current++;
    }
    return result;
}

-----
function buildArray(target, n) 
    // Your code here
}

************************************
Question ID: 1553
function countTriplets(arr) {
    let n = arr.length;
    let XOR = new Array(n + 1).fill(0);
    
    for (let i = 0; i < n; i++) {
        XOR[i+1] = XOR[i] ^ arr[i];
    }
    
    let count = 0;
    for (let i = 0; i < n; i++) {
        for (let k = i+1; k < n; k++) {
            if (XOR[i] === XOR[k+1]) {
                count += (k-i);
            }
        }
    }
    return count;
}

-----
function countTriplets(arr) 
    // Your code here
}

************************************
Question ID: 1554
function minTime(n, edges, hasApple) {
  const graph = Array.from({ length: n }, () => new Map());

  for (const [a, b] of edges) {
    graph[a].set(b, 0);
    graph[b].set(a, 0);
  }

  function dfs(v, parent) {
    let ans = 0;
    for (const [u, _] of graph[v]) {
      if (u === parent) continue;
      ans += dfs(u, v) * 2;
    }

    return ans + (hasApple[v] || ans > 0 ? 1 : 0);
  }

  return dfs(0, -1);
}

-----
function minTime(n, edges, hasApple) 
    // Your code here
}

************************************
Question ID: 1556
function canBeEqual(target, arr) {
    target.sort((a, b) => a - b);
    arr.sort((a, b) => a - b);
    return JSON.stringify(target) === JSON.stringify(arr);
}


-----
function canBeEqual(target, arr) 
    // Your code here
}


************************************
Question ID: 1557
function hasAllCodes(s, k) {
    const need = 1 << k;
    const got = new Set();
    
    for (let i = 0; i <= s.length - k; i++) {
        got.add(s.slice(i, i + k));
    }
    
    return got.size === need;
}


-----
function hasAllCodes(s, k) 
    // Your code here
}


************************************
Question ID: 1558
function DFS(src, graph, visited, transitiveClosure, dest) {
    if (src === dest) {
        transitiveClosure[dest] = true;
        return;
    }
    if (visited[src]) return;
    visited[src] = true;
    for (let neighbor of graph[src]) {
        DFS(neighbor, graph, visited, transitiveClosure, dest);
        if (transitiveClosure[dest]) return;
    }
}

function checkIfPrerequisite(numCourses, prerequisites, queries) {
    const graph = new Map();

    for (let pre of prerequisites) {
        if (!graph.has(pre[0])) {
            graph.set(pre[0], []);
        }
        graph.get(pre[0]).push(pre[1]);
    }

    const result = [];

    for (let i = 0; i < queries.length; ++i) {
        const visited = new Array(numCourses).fill(false);
        const transitiveClosure = new Array(numCourses).fill(false);
        DFS(queries[i][0], graph, visited, transitiveClosure, queries[i][1]);
        result.push(transitiveClosure[queries[i][1]]);
    }

    return result;
}

-----
function DFS(src, graph, visited, transitiveClosure, dest) 
    // Your code here
}

************************************
Question ID: 1559
function cherryPickup(grid) {
    let rows = grid.length;
    let cols = grid[0].length;
    let dp = new Array(rows).fill(0).map(() => new Array(cols).fill(0).map(() => new Array(cols).fill(0)));

    for (let row = rows - 1; row >= 0; --row) {
        for (let col1 = 0; col1 < cols; ++col1) {
            for (let col2 = 0; col2 < cols; ++col2) {
                let currentCell = row < rows - 1 ? dp[row + 1][col1][col2] : 0;
                currentCell += grid[row][col1] + (col1 !== col2 ? grid[row][col2] : 0);

                let maxVal = 0;
                for (let move1 = -1; move1 <= 1; ++move1) {
                    for (let move2 = -1; move2 <= 1; ++move2) {
                        let newCol1 = col1 + move1;
                        let newCol2 = col2 + move2;
                        if (newCol1 >= 0 && newCol1 < cols && newCol2 >= 0 && newCol2 < cols) {
                            maxVal = Math.max(maxVal, dp[row][newCol1][newCol2]);
                        }
                    }
                }

                dp[row][col1][col2] = currentCell + maxVal;
            }
        }
    }

    return dp[0][0][cols - 1];
}


-----
function cherryPickup(grid) 
    // Your code here
}


************************************
Question ID: 1560
function busyStudent(startTime, endTime, queryTime) {
    let count = 0;
    for (let i = 0; i < startTime.length; i++) {
        if (startTime[i] <= queryTime && endTime[i] >= queryTime) {
            count++;
        }
    }
    return count;
}

-----
function busyStudent(startTime, endTime, queryTime) 
    // Your code here
}

************************************
Question ID: 1561
function arrangeWords(text) {
    const words = text.toLowerCase().split(' ').sort((a, b) => a.length - b.length);
    words[0] = words[0].charAt(0).toUpperCase() + words[0].slice(1);
    return words.join(' ');
}

-----
function arrangeWords(text) 
    // Your code here
}

************************************
Question ID: 1562
function peopleIndexes(favoriteCompanies) {
    const result = [];
    for (let i = 0; i < favoriteCompanies.length; i++) {
        let isSubset = false;
        for (let j = 0; j < favoriteCompanies.length && !isSubset; j++) {
            if (i !== j && favoriteCompanies[j].every(company => favoriteCompanies[i].includes(company))) {
                isSubset = true;
            }
        }
        if (!isSubset) result.push(i);
    }
    return result;
}

-----
function peopleIndexes(favoriteCompanies) 
    // Your code here
}

************************************
Question ID: 1563
function maxNumberOfDarts(darts, r) {
    const n = darts.length;
    let maxDarts = 1;

    function distance(x1, y1, x2, y2) {
        return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
    }

    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            const dist = distance(darts[j][0], darts[j][1], darts[i][0], darts[i][1]);
            if (dist > 2.0 * r) continue;

            const angle = Math.acos(dist / (2.0 * r));
            for (let k = 0; k < 2; k++) {
                const locAngle = angle * (k === 0 ? 1 : -1);
                const cx = darts[i][0] + r * (darts[j][0] - darts[i][0]) / dist * Math.cos(locAngle) - r * (darts[j][1] - darts[i][1]) / dist * Math.sin(locAngle);
                const cy = darts[i][1] + r * (darts[j][0] - darts[i][0]) / dist * Math.sin(locAngle) + r * (darts[j][1] - darts[i][1]) / dist * Math.cos(locAngle);

                let cnt = 0;
                for (let l = 0; l < n; l++) {
                    const newDist = distance(darts[l][0], darts[l][1], cx, cy);
                    if (newDist <= r + 1e-5) cnt++;
                }

                maxDarts = Math.max(maxDarts, cnt);
            }
        }
    }

    return maxDarts;
}

-----
function maxNumberOfDarts(darts, r) 
    // Your code here
}

************************************
Question ID: 1564
function maxBoxesInWarehouse(boxes, warehouse) {
    let n = warehouse.length;
    for (let i = 1; i < n; i++)
        warehouse[i] = Math.min(warehouse[i], warehouse[i - 1]);
    boxes.sort((a, b) => b - a);
    let boxIndex = 0;
    let boxesCount = 0;
    for (let i = 0; i < n && boxIndex < boxes.length; i++) {
        if (boxes[boxIndex] <= warehouse[i]) {
            boxesCount++;
            boxIndex++;
        }
    }
    return boxesCount;
}


-----
function maxBoxesInWarehouse(boxes, warehouse) 
    // Your code here
}


************************************
Question ID: 1566
function isPrefixOfWord(sentence, searchWord) {
    const words = sentence.split(" ");
    for (let i = 0; i < words.length; i++) {
        if (words[i].startsWith(searchWord)) {
            return i + 1;
        }
    }
    return -1;
}

-----
function isPrefixOfWord(sentence, searchWord) 
    // Your code here
}

************************************
Question ID: 1567
function maxVowels(s, k) {
    let max_count = 0, count = 0;
    for (let i = 0; i < s.length; i++) {
        count += isVowel(s[i]) ? 1 : 0;
        if (i >= k)
            count -= isVowel(s[i - k]) ? 1 : 0;
        max_count = Math.max(max_count, count);
    }
    return max_count;
}

function isVowel(c) {
    return c === 'a' || c === 'e' || c === 'i' || c === 'o' || c === 'u';
}


-----
function maxVowels(s, k) 
    // Your code here
}


************************************
Question ID: 1568
function pseudoPalindromicPaths(root, cnt = 0) {
    if (!root) return 0;
    cnt ^= 1 << (root.val - 1);
    if (!root.left && !root.right)
        return (cnt & (cnt - 1)) == 0 ? 1 : 0;
    return pseudoPalindromicPaths(root.left, cnt) + pseudoPalindromicPaths(root.right, cnt);
}


-----
function pseudoPalindromicPaths(root, cnt = 0) 
    // Your code here
}


************************************
Question ID: 1569
function maxDotProduct(nums1, nums2) {
    const n = nums1.length, m = nums2.length;
    const dp = Array.from(Array(n + 1), () => Array(m + 1).fill(Number.MIN_SAFE_INTEGER));
    for (let i = 1; i <= n; ++i) {
        for (let j = 1; j <= m; ++j) {
            dp[i][j] = Math.max(dp[i][j], dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1], nums1[i - 1] * nums2[j - 1]);
        }
    }
    return dp[n][m];
}

-----
function maxDotProduct(nums1, nums2) 
    // Your code here
}

************************************
Question ID: 1570
function finalPrices(prices) {
    for(let i = 0; i < prices.length; i++) {
        for(let j = i + 1; j < prices.length; j++) {
            if(prices[j] <= prices[i]) {
                prices[i] -= prices[j];
                break;
            }
        }
    }
    return prices;
}

-----
function finalPrices(prices) 
    // Your code here
}

************************************
Question ID: 1573
function minSumOfLengths(arr, target) {
    const n = arr.length, mp = new Map();
    let sum = 0, minLen = Infinity, result = Infinity;
    mp.set(0, -1);

    for (let i = 0; i < n; ++i) {
        sum += arr[i];
        if (sum >= target && mp.has(sum - target)) {
            if (mp.get(sum - target) > -1 && minLen !== Infinity) {
                result = Math.min(result, i - mp.get(sum - target) + minLen);
            }
            minLen = Math.min(minLen, i - mp.get(sum - target));
        }
        mp.set(sum, i);
    }
    return result === Infinity ? -1 : result;
}


-----
function minSumOfLengths(arr, target) 
    // Your code here
}


************************************
Question ID: 1574
function findLengthOfShortestSubarray(arr) {
    const n = arr.length;
    let left = 0, right = n - 1;
    while (left < n - 1 && arr[left] <= arr[left + 1]) left++;
    if (left === n - 1) return 0;
    while (right > 0 && arr[right] >= arr[right - 1]) right--;
    let result = Math.min(n - left - 1, right);
    let i = 0, j = right;
    while (i <= left && j < n) {
        if (arr[i] <= arr[j]) {
            result = Math.min(result, j - i - 1);
            i++;
        } else {
            j++;
        }
    }
    return result;
}

-----
function findLengthOfShortestSubarray(arr) 
    // Your code here
}

************************************
Question ID: 1575
function maxArea(h, w, horizontalCuts, verticalCuts) {
    horizontalCuts.sort((a, b) => a - b);
    verticalCuts.sort((a, b) => a - b);

    let maxH = Math.max(horizontalCuts[0], h - horizontalCuts[horizontalCuts.length - 1]);
    let maxV = Math.max(verticalCuts[0], w - verticalCuts[verticalCuts.length - 1]);

    for (let i = 1; i < horizontalCuts.length; ++i) {
        maxH = Math.max(maxH, horizontalCuts[i] - horizontalCuts[i - 1]);
    }

    for (let i = 1; i < verticalCuts.length; ++i) {
        maxV = Math.max(maxV, verticalCuts[i] - verticalCuts[i - 1]);
    }

    return BigInt(maxH) * BigInt(maxV) % 1000000007n;
}

-----
function maxArea(h, w, horizontalCuts, verticalCuts) 
    // Your code here
}

************************************
Question ID: 1576
function dfs(node, parent, graph, count) {
    if (node !== 0 && parent === 0) count[0]++;
    
    for (let neighbor of graph[node]) {
        if (neighbor !== parent) {
            dfs(neighbor, node, graph, count);
        }
    }
}

function minReorder(n, connections) {
    const graph = Array.from({length: n}, () => []);
    for (const [a, b] of connections) {
        graph[a].push(b);
        graph[b].push(a);
    }

    const count = [0];
    dfs(0, -1, graph, count);
    return count[0];
}

-----
function dfs(node, parent, graph, count) 
    // Your code here
}

************************************
Question ID: 1578
function minTime(colors, neededTime) {
    let res = 0, prev = -1;
    for (let i = 0; i < colors.length - 1; i++) {
        if (colors[i] === colors[i + 1]) {
            if (prev === -1 || neededTime[i] < neededTime[prev]) prev = i;
            if (neededTime[i + 1] < neededTime[prev]) prev = i + 1;
            res += neededTime[prev];
            neededTime[prev] = 1000000;
            prev = -1;
        }
    }
    return res;
}

-----
function minTime(colors, neededTime) 
    // Your code here
}

************************************
Question ID: 1580
function shuffle(nums, n) {
    const shuffled = [];
    for(let i = 0; i < n; i++) {
        shuffled.push(nums[i]);
        shuffled.push(nums[i+n]);
    }
    return shuffled;
}

-----
function shuffle(nums, n) 
    // Your code here
}

************************************
Question ID: 1583
function minCost(houses, cost, m, n, target) {
    const dp = Array.from({length: m}, () => Array.from({length: n}, () => Array(target + 1).fill(Infinity)));

    if (houses[0] !== 0) {
        dp[0][houses[0] - 1][1] = 0;
    } else {
        for (let j = 0; j < n; j++) {
           dp[0][j][1] = cost[0][j]; 
        }
    }

    for (let i = 1; i < m; i++) {
        for (let j = 0; j < n; j++) {
            for (let k = 1; k <= target; k++) {
                if (houses[i] !== 0 && houses[i] !== j + 1) {
                    continue;
                }
                const paint_cost = (houses[i] !== 0) ? 0 : cost[i][j];

                for (let l = 0; l < n; l++) {
                    if (l === j) {
                        dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][l][k] + paint_cost);
                    } else {
                        dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][l][k - 1] + paint_cost);
                    }
                }
            }
        }
    }

    let ans = Infinity;
    for (let j = 0; j < n; j++) {
        ans = Math.min(ans, dp[m - 1][j][target]);
    }
    return (ans === Infinity) ? -1 : ans;
}


-----
function minCost(houses, cost, m, n, target) 
    // Your code here
}


************************************
Question ID: 1584
function average(salary) {
    let sum = 0, minSalary = Math.min(...salary), maxSalary = Math.max(...salary);
    for (let s of salary) {
        sum += s;
    }
    sum -= (minSalary + maxSalary);
    return sum / (salary.length - 2);
}

-----
function average(salary) 
    // Your code here
}

************************************
Question ID: 1585
function kthFactor(n, k) {
    for (let i = 1; i <= n; ++i) {
        if (n % i === 0) {
            --k;
            if (k === 0) return i;
        }
    }
    return -1;
}


-----
function kthFactor(n, k) 
    // Your code here
}


************************************
Question ID: 1586
function findMaxLength(nums) {
    let max_length = 0, zeroes = 0, ones = 0;
    let count_map = new Map();
    count_map.set(0, -1);

    for(let i = 0; i < nums.length; ++i) {
        if(nums[i] === 0)
            zeroes++;
        else
            ones++;

        if(!count_map.has(zeroes - ones))
            count_map.set(zeroes - ones, i);
        else
            max_length = Math.max(max_length, i - count_map.get(zeroes - ones));
    }
    return max_length;
}

-----
function findMaxLength(nums) 
    // Your code here
}

************************************
Question ID: 1588
function sumOddLengthSubarrays(arr) {
    let sum = 0, n = arr.length;
    for (let i = 0; i < n; i++) {
        let oddSubarrays = Math.floor(((i + 1) * (n - i) + 1) / 2);
        sum += arr[i] * oddSubarrays;
    }
    return sum;
}

-----
function sumOddLengthSubarrays(arr) 
    // Your code here
}

************************************
Question ID: 1589
function maxSumRangeQuery(nums, requests) {
    const n = nums.length;
    const count = new Array(n).fill(0);
    const MOD = 1000000007;

    for (const request of requests) {
        count[request[0]]++;
        if (request[1] + 1 < n) {
            count[request[1] + 1]--;
        }
    }
    for (let i = 1; i < n; i++) {
        count[i] += count[i - 1];
    }

    nums.sort((a, b) => a - b);
    count.sort((a, b) => a - b);

    let ans = 0;
    for (let i = 0; i < n; i++) {
        ans = (ans + nums[i] * count[i]) % MOD;
    }

    return ans;
}

-----
function maxSumRangeQuery(nums, requests) 
    // Your code here
}

************************************
Question ID: 1590
function minSubarray(nums, p) {
    let n = nums.length, res = n, need = 0, cur = 0;
    for (let num of nums)
        need = (need + num) % p;
    if (need === 0) return 0;
    let last_seen = new Map();
    last_seen.set(0, -1);
    for (let i = 0; i < n; i++) {
        cur = (cur + nums[i]) % p;
        last_seen.set(cur, i);
        res = Math.min(res, i - (last_seen.get((cur - need + p) % p) || -n));
    }
    return res < n ? res : -1;
}

-----
function minSubarray(nums, p) 
    // Your code here
}

************************************
Question ID: 1591
const isPrintable = (targetGrid) => {
    const m = targetGrid.length, n = targetGrid[0].length;
    const colorBounds = new Map();
    for (let i = 0; i < m; ++i) {
        for (let j = 0; j < n; ++j) {
            const color = targetGrid[i][j];
            if (!colorBounds.has(color)) colorBounds.set(color, [i, j, i, j]);
            else {
                colorBounds.get(color)[0] = Math.min(colorBounds.get(color)[0], i);
                colorBounds.get(color)[1] = Math.min(colorBounds.get(color)[1], j);
                colorBounds.get(color)[2] = Math.max(colorBounds.get(color)[2], i);
                colorBounds.get(color)[3] = Math.max(colorBounds.get(color)[3], j);
            }
        }
    }

    const remainingColors = new Set(colorBounds.keys());
    while (remainingColors.size) {
        let progress = false;
        for (const color of Array.from(remainingColors)) {
            const bounds = colorBounds.get(color);
            let contained = true;
            for (let i = bounds[0]; i <= bounds[2] && contained; ++i) {
                for (let j = bounds[1]; j <= bounds[3]; ++j) {
                    if (targetGrid[i][j] !== color && targetGrid[i][j] !== -1) {
                        contained = false;
                        break;
                    }
                }
            }
            if (contained) {
                for (let i = bounds[0]; i <= bounds[2]; ++i) {
                    for (let j = bounds[1]; j <= bounds[3]; ++j) {
                        targetGrid[i][j] = -1;
                    }
                }
                remainingColors.delete(color);
                progress = true;
            }
        }
        if (!progress) return false;
    }
    return true;
};

-----
const isPrintable = (targetGrid) => 
    // Your code here
};

************************************
Question ID: 1592
function reorderSpaces(text) {
    const spaces = text.split(' ').length - 1;
    const words = text.trim().split(/\s+/);
    const numWords = words.length;
    
    const spacesBetweenWords = numWords === 1 ? 0 : Math.floor(spaces / (numWords - 1));
    const extraSpaces = spaces - spacesBetweenWords * (numWords - 1);
    
    return words.join(' '.repeat(spacesBetweenWords)) + ' '.repeat(extraSpaces);
}

-----
function reorderSpaces(text) 
    // Your code here
}

************************************
Question ID: 1593
function maxUniqueSplit(s, start = 0, seen = new Set()) {
    if (start === s.length) {
        return 0;
    }
    let maxUnique = -1;
    for (let i = start + 1; i <= s.length; ++i) {
        let sub = s.slice(start, i);
        if (!seen.has(sub)) {
            seen.add(sub);
            let unique = maxUniqueSplit(s, i, seen);
            if (unique !== -1) {
                maxUnique = Math.max(maxUnique, unique + 1);
            }
            seen.delete(sub);
        }
    }
    return maxUnique;
}

-----
function maxUniqueSplit(s, start = 0, seen = new Set()) 
    // Your code here
}

************************************
Question ID: 1594
const maxProductPath = (grid) => {
    const m = grid.length, n = grid[0].length, mod = 1e9 + 7;
    let dp = Array.from(Array(m), () => Array.from(Array(n), () => [0, 0]));
    dp[0][0] = [grid[0][0], grid[0][0]];
    for (let i = 1; i < m; ++i) dp[i][0] = [grid[i][0] * dp[i - 1][0][0], grid[i][0] * dp[i - 1][0][0]];
    for (let j = 1; j < n; ++j) dp[0][j] = [grid[0][j] * dp[0][j - 1][0], grid[0][j] * dp[0][j - 1][0]];
    for (let i = 1; i < m; ++i) {
        for (let j = 1; j < n; ++j) {
            if (grid[i][j] < 0) {
                dp[i][j][0] = Math.min(grid[i][j] * dp[i - 1][j][1], grid[i][j] * dp[i][j - 1][1]);
                dp[i][j][1] = Math.max(grid[i][j] * dp[i - 1][j][0], grid[i][j] * dp[i][j - 1][0]);
            } else {
                dp[i][j][0] = Math.min(grid[i][j] * dp[i - 1][j][0], grid[i][j] * dp[i][j - 1][0]);
                dp[i][j][1] = Math.max(grid[i][j] * dp[i - 1][j][1], grid[i][j] * dp[i][j - 1][1]);
            }
        }
    }
    return dp[m - 1][n - 1][1] < 0 ? -1 : dp[m - 1][n - 1][1] % mod;
};

-----
const maxProductPath = (grid) => 
    // Your code here
};

************************************
Question ID: 1595
function connectTwoGroups(cost) {
    const size1 = cost.length, size2 = cost[0].length;
    const min_cost = Array(size2).fill(Infinity);

    for (let i = 0; i < size1; i++) {
        for (let j = 0; j < size2; j++) {
            min_cost[j] = Math.min(min_cost[j], cost[i][j]);
        }
    }

    let total_cost = 0;
    for (let i = 0; i < size1; i++) {
        total_cost += Math.min(...cost[i]);
    }

    for (let j = 0; j < size2; j++) {
        total_cost += min_cost[j];
    }

    return total_cost;
}


-----
function connectTwoGroups(cost) 
    // Your code here
}


************************************
Question ID: 1598
function minOperations(logs) {
    let depth = 0;
    for (const log of logs) {
        if (log === "../") {
            depth = Math.max(0, depth - 1);
        } else if (log !== "./") {
            depth += 1;
        }
    }
    return depth;
}

-----
function minOperations(logs) 
    // Your code here
}

************************************
Question ID: 1599
function minOperationsMaxProfit(customers, boardingCost, runningCost) {
    let waiting = 0;
    let profit = 0;
    let max_profit = 0;
    let rotations = 0;
    let result = -1;

    for (let i = 0; i < customers.length || waiting > 0; ++i) {
        if (i < customers.length) {
            waiting += customers[i];
        }
        const boarding = Math.min(waiting, 4);
        waiting -= boarding;
        profit += boarding * boardingCost - runningCost;

        if (profit > max_profit) {
            max_profit = profit;
            result = rotations + 1;
        }
        rotations++;
    }
    return result;
}


-----
function minOperationsMaxProfit(customers, boardingCost, runningCost) 
    // Your code here
}


************************************
Question ID: 1601
function maximumRequests(n, requests) {
    const req_size = requests.length;
    let max_requests = 0;

    for (let i = 0; i < (1 << req_size); ++i) {
        const net_transfers = new Array(n).fill(0);
        let count = 0;

        for (let j = 0; j < req_size; ++j) {
            if (i & (1 << j)) {
                net_transfers[requests[j][0]]--;
                net_transfers[requests[j][1]]++;
                count++;
            }
        }

        const valid = net_transfers.every(val => val === 0);

        if (valid) {
            max_requests = Math.max(max_requests, count);
        }
    }

    return max_requests;
}

-----
function maximumRequests(n, requests) 
    // Your code here
}

************************************
Question ID: 1603
function runningSum(nums) {
    for (let i = 1; i < nums.length; i++) {
        nums[i] += nums[i - 1];
    }
    return nums;
}

-----
function runningSum(nums) 
    // Your code here
}

************************************
Question ID: 1604
function findLeastNumOfUniqueInts(arr, k) {
    let freqMap = {};
    for (let n of arr) {
        freqMap[n] = (freqMap[n] || 0) + 1;
    }

    let minHeap = Object.values(freqMap).sort((a, b) => a - b);

    while (k > 0) {
        k -= minHeap.shift();
    }

    return k === 0 ? minHeap.length : minHeap.length + 1;
}

-----
function findLeastNumOfUniqueInts(arr, k) 
    // Your code here
}

************************************
Question ID: 1605
function minDays(bloomDay, m, k) {
    let left = Math.min(...bloomDay), right = Math.max(...bloomDay);

    while (left < right) {
        let mid = left + Math.floor((right - left) / 2);
        let bouquets = 0, flowers = 0;
        for (let day of bloomDay) {
            if (day > mid) {
                flowers = 0;
            } else {
                flowers++;
                if (flowers === k) {
                    bouquets++;
                    flowers = 0;
                }
            }
        }
        if (bouquets >= m) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return m === 0 ? -1 : left;
}

-----
function minDays(bloomDay, m, k) 
    // Your code here
}

************************************
Question ID: 1606
function busiestServers(k, arrival, load) {
    let server_status = new Array(k).fill(-1);
    let server_request_count = new Array(k).fill(0);

    for (let i = 0; i < arrival.length; i++) {
        let index = i % k;
        for (let j = 0; j < k; j++) {
            if (server_status[index] <= arrival[i]) {
                server_status[index] = arrival[i] + load[i];
                server_request_count[index]++;
                break;
            }
            index = (index + 1) % k;
        }
    }

    let max_requests = Math.max(...server_request_count);
    let busiest_servers = [];
    for (let i = 0; i < k; i++) {
        if (server_request_count[i] === max_requests) {
            busiest_servers.push(i);
        }
    }
    return busiest_servers;
}

-----
function busiestServers(k, arrival, load) 
    // Your code here
}

************************************
Question ID: 1608
function specialArray(nums) {
    let max_val = Math.max(...nums);
    for (let x = 1; x <= max_val; ++x) {
        let count = 0;
        for (let num of nums) {
            if (num >= x) count++;
        }
        if (count === x) return x;
    }
    return -1;
}

-----
function specialArray(nums) 
    // Your code here
}

************************************
Question ID: 1609
function TreeNode(val, left, right) {
    this.val = (val === undefined ? 0 : val);
    this.left = (left === undefined ? null : left);
    this.right = (right === undefined ? null : right);
}

function isEvenOddTree(root) {
    if (!root) return false;
    
    const q = [root];
    let level = 0;
    
    while (q.length > 0) {
        const size = q.length;
        let prevVal = (level % 2 === 0) ? 0 : 1000001;
        
        for (let i = 0; i < size; ++i) {
            const curr = q.shift();

            if ((level % 2 === 0 && (curr.val % 2 === 0 || curr.val <= prevVal)) || 
                (level % 2 !== 0 && (curr.val % 2 !== 0 || curr.val >= prevVal))) {
                return false;
            }

            prevVal = curr.val;

            if (curr.left !== null) q.push(curr.left);
            if (curr.right !== null) q.push(curr.right);
        }
        
        level++;
    }
    
    return true;
}

-----
function TreeNode(val, left, right) 
    // Your code here
}

************************************
Question ID: 1610
function xorOperation(n, start) {
    let xorResult = 0;
    for (let i = 0; i < n; i++) {
        xorResult ^= (start + 2 * i);
    }
    return xorResult;
}

-----
function xorOperation(n, start) 
    // Your code here
}

************************************
Question ID: 1611
function getFolderNames(names) {
    const nameCount = {};
    const ans = [];

    for (let name of names) {
        if (nameCount[name] === undefined) {
            ans.push(name);
            nameCount[name] = 1;
        } else {
            let k = nameCount[name];
            let newName = `${name}(${k})`;
            while (nameCount[newName] !== undefined) {
                k++;
                newName = `${name}(${k})`;
            }
            ans.push(newName);
            nameCount[newName] = 1;
            nameCount[name] = k + 1;
        }
    }

    return ans;
}

-----
function getFolderNames(names) 
    // Your code here
}

************************************
Question ID: 1612
function avoidFlood(rains) {
    const res = new Array(rains.length).fill(-1);
    const filledLakes = new Map();
    const dryDays = new Set();

    for (let i = 0; i < rains.length; i++) {
        if (rains[i] === 0) {
            dryDays.add(i);
        } else {
            const lake = rains[i];
            if (filledLakes.has(lake)) {
                const day = [...dryDays].find(d => d > filledLakes.get(lake));
                if (day === undefined) return [];
                res[day] = lake;
                dryDays.delete(day);
            }
            filledLakes.set(lake, i);
        }
    }

    for (const day of dryDays) {
        res[day] = 1;
    }

    return res;
}


-----
function avoidFlood(rains) 
    // Your code here
}


************************************
Question ID: 1614
function maxDepth(s) {
    let depth = 0, maxDepth = 0;

    for (const c of s) {
        if (c === '(') {
            depth++;
            maxDepth = Math.max(depth, maxDepth);
        } else if (c === ')') {
            depth--;
        }
    }

    return maxDepth;
}

-----
function maxDepth(s) 
    // Your code here
}

************************************
Question ID: 1615
function rangeSum(nums, n, left, right) {
    const MOD = 10**9 + 7;
    let sums = [];
    for (let i = 0; i < n; ++i) {
        let sum = 0;
        for (let j = i; j < n; ++j) {
            sum += nums[j];
            sums.push(sum);
        }
    }
    sums.sort((a, b) => a - b);
    let result = 0;
    for (let i = left - 1; i < right; ++i) {
        result = (result + sums[i]) % MOD;
    }
    return result;
}

-----
function rangeSum(nums, n, left, right) 
    // Your code here
}

************************************
Question ID: 1616
function minDifference(nums) {
    let size = nums.length;
    if (size < 5) return 0;

    nums.sort((a, b) => a - b);

    return Math.min(nums[size-1] - nums[3], nums[size-2] - nums[2], nums[size-3] - nums[1], nums[size-4] - nums[0]);
}

-----
function minDifference(nums) 
    // Your code here
}

************************************
Question ID: 1617
function winnerSquareGame(n) {
    const dp = new Array(n + 1).fill(false);
    for (let i = 1; i <= n; i++) {
        for (let j = 1; j * j <= i; j++) {
            if (!dp[i - j * j]) {
                dp[i] = true;
                break;
            }
        }
    }
    return dp[n];
}

-----
function winnerSquareGame(n) 
    // Your code here
}

************************************
Question ID: 1618
function maxFontSize(text, w, h, fonts, fontInfo) {
    let left = 0, right = fonts.length - 1, mid, ans = -1;
    while (left <= right) {
        mid = left + ((right - left) / 2) | 0;
        let fontSize = fonts[mid];
        let width = 0, height = fontInfo.getHeight(fontSize);
        for (let ch of text)
            width += fontInfo.getWidth(fontSize, ch);
        if (width <= w && height <= h) {
            ans = fontSize;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return ans;
}

-----
function maxFontSize(text, w, h, fonts, fontInfo) 
    // Your code here
}

************************************
Question ID: 1619
function isPathCrossing(path) {
    const visited = new Set(['0,0']);
    let x = 0, y = 0;
    for (const dir of path) {
        if (dir === 'N') y++;
        else if (dir === 'S') y--;
        else if (dir === 'E') x++;
        else if (dir === 'W') x--;
        const location = `${x},${y}`;
        if (visited.has(location)) return true;
        visited.add(location);
    }
    return false;
}

-----
function isPathCrossing(path) 
    // Your code here
}

************************************
Question ID: 1620
function canArrange(arr, k) {
    let counts = new Array(k).fill(0);
    for (let num of arr) {
        counts[(num % k + k) % k]++;
    }
    if (counts[0] % 2 != 0) {
        return false;
    }
    for (let i = 1; i <= k / 2; i++) {
        if (counts[i] !== counts[k - i]) {
            return false;
        }
    }
    return true;
}

-----
function canArrange(arr, k) 
    // Your code here
}

************************************
Question ID: 1621
function numSubseq(nums, target) {
    nums.sort((a, b) => a - b);
    const n = nums.length;
    const mod = 1e9 + 7;

    const power = new Array(n).fill(1);
    for (let i = 1; i < n; ++i) {
        power[i] = (power[i - 1] * 2) % mod;
    }

    let ans = 0;
    let r = n;
    for (let l = 0; l < n; ++l) {
        while (r > l && nums[l] + nums[r - 1] > target) {
            --r;
        }

        ans = (ans + power[r - l]) % mod;
    }

    return ans;
}


-----
function numSubseq(nums, target) 
    // Your code here
}


************************************
Question ID: 1622
function findMaxValueOfEquation(points, k) {
    let res = -Infinity;
    let q = [];
    
    for (let p of points) {
        while (q.length > 0 && p[0] - q[0][1] > k)
            q.shift();
        
        if (q.length > 0)
            res = Math.max(res, p[1] + p[0] + q[0][0]);
        
        while (q.length > 0 && p[1] - p[0] >= q[q.length - 1][0])
            q.pop();
        
        q.push([p[1] - p[0], p[0]]);
    }
    
    return res;
}


-----
function findMaxValueOfEquation(points, k) 
    // Your code here
}


************************************
Question ID: 1624
function maxLengthBetweenEqualCharacters(s) {
    let result = -1;
    let char_map = {};

    for (let i = 0; i < s.length; ++i) {
        let c = s.charAt(i);
        if (!char_map.hasOwnProperty(c)) {
            char_map[c] = i;
        } else {
            result = Math.max(result, i - char_map[c] - 1);
        }
    }
    return result;
}

-----
function maxLengthBetweenEqualCharacters(s) 
    // Your code here
}

************************************
Question ID: 1625
function findLexSmallestString(s, a, b) {
    function rotate(s, k) {
        k %= s.length;
        return s.slice(s.length - k) + s.slice(0, s.length - k);
    }

    function addAtIndex(s, a, index) {
        const arr = [...s];
        arr[index] = (arr[index] - '0' + a) % 10 + '0';
        return arr.join('');
    }

    function addOdd(s, a) {
        return s.split('').map((ch, idx) => idx % 2 ? (parseInt(ch) + a) % 10 : ch).join('');
    }

    let smallest = s;
    for (let i = 0; i < s.length; i++) {
        for (let j = 0; j < 10; j++) {
            const rotated = rotate(s, b);
            const temp = addOdd(rotated, a);
            smallest = smallest < temp ? smallest : temp;
            s = rotated;
        }
        s = addAtIndex(s, a, s.length - i - 1);
    }
    return smallest;
}

-----
function findLexSmallestString(s, a, b) 
    // Your code here
}

************************************
Question ID: 1626
function canMakeArithmeticProgression(arr) {
    arr.sort((a, b) => a - b);
    const difference = arr[1] - arr[0];
    for (let i = 2; i < arr.length; i++) {
        if (arr[i] - arr[i - 1] !== difference) {
            return false;
        }
    }
    return true;
}

-----
function canMakeArithmeticProgression(arr) 
    // Your code here
}

************************************
Question ID: 1627
function lastMoment(n, left, right) {
    let max_left = 0;
    let min_right = n;

    for (let position of left) {
        max_left = Math.max(max_left, position);
    }

    for (let position of right) {
        min_right = Math.min(min_right, position);
    }

    return Math.max(max_left, n - min_right);
}

-----
function lastMoment(n, left, right) 
    // Your code here
}

************************************
Question ID: 1628
function numSubmat(mat) {
    const m = mat.length, n = mat[0].length;
    const dp = Array.from({ length: m }, () => Array(n).fill(0));
    let count = 0;

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (mat[i][j] === 1) {
                dp[i][j] = (j === 0) ? 1 : dp[i][j - 1] + 1;
                let minWidth = dp[i][j];
                for (let k = i; k >= 0; k--) {
                    minWidth = Math.min(minWidth, dp[k][j]);
                    count += minWidth;
                }
            }
        }
    }
    return count;
}

-----
function numSubmat(mat) 
    // Your code here
}

************************************
Question ID: 1629
function minInteger(num, k) {
    if (k === 0) return num;
    num = num.split('');
    const n = num.length;
    for (let i = 0; i < n; ++i) {
        let idx = i;
        for (let j = i + 1; j < n && j - i <= k; ++j) {
            if (num[j] < num[idx]) {
                idx = j;
            }
        }
        const minDigit = num[idx];
        for (let j = idx; j > i; --j) {
            num[j] = num[j - 1];
        }
        num[i] = minDigit;
        k -= idx - i;
    }
    return num.join('');
}

-----
function minInteger(num, k) 
    // Your code here
}

************************************
Question ID: 1630
function countOdds(low, high) {
    return Math.floor((high + 1) / 2) - Math.floor(low / 2);
}

-----
function countOdds(low, high) 
    // Your code here
}

************************************
Question ID: 1631
function numOfSubarrays(arr) {
    let odd = 0, even = 1, sum = 0, result = 0;
    let mod = 1e9 + 7;
    for (let x of arr) {
        sum = (sum + x) % 2;
        if (sum % 2 === 0) {
            even++;
        } else {
            odd++;
        }
        result = (result + odd) % mod;
    }
    return result;
}

-----
function numOfSubarrays(arr) 
    // Your code here
}

************************************
Question ID: 1632
function numSplits(s) {
    const leftSet = new Set(), rightSet = new Set();
    const left = new Array(s.length).fill(0), right = new Array(s.length).fill(0);
    let count = 0;

    for (let i = 0; i < s.length; i++) {
        leftSet.add(s[i]);
        left[i] = leftSet.size;
    }

    for (let i = s.length - 1; i > 0; i--) {
        rightSet.add(s[i]);
        right[i] = rightSet.size;
    }

    for (let i = 0; i < s.length - 1; i++) {
        if (left[i] === right[i + 1]) {
            count++;
        }
    }

    return count;
}

-----
function numSplits(s) 
    // Your code here
}

************************************
Question ID: 1636
function numSub(s) {
    const mod = 1000000007;
    let result = 0;
    let count = 0;
    for (let c of s) {
        count = (c === '1') ? count + 1 : 0;
        result = (result + count) % mod;
    }
    return result;
}

-----
function numSub(s) 
    // Your code here
}

************************************
Question ID: 1637
function min_length_encoded(s, k) {
    const n = s.length;
    const dp = Array.from({ length: n + 1 }, () => new Array(k + 1).fill(0));
    
    for (let i = 1; i <= n; ++i) {
        for (let j = 0; j <= k; ++j) {
            let cnt = 1;
            dp[i][j] = i - j;
            for (let l = i - 2; l >= 0 && i - 2 - l <= j; --l) {
                if (s[l] === s[i - 1]) cnt++;
                else cnt = 1;
                const used = i - 2 - l;
                let new_aposition = i - 1 - cnt - used + 1;
                if (cnt >= 100) new_aposition += 4;
                else if (cnt >= 10) new_aposition += 3;
                else if (cnt >= 2) new_aposition += 2;
                else new_aposition++;
                dp[i][j] = Math.min(dp[i][j], new_aposition + dp[l][j - used]);
            }
        }
    }
    return dp[n][k];
}

-----
function min_length_encoded(s, k) 
    // Your code here
}

************************************
Question ID: 1638
function getMinDistSum(positions) {
    let x = 0;
    let y = 0;
    const n = positions.length;
    for (let i = 0; i < n; i++) {
        x += positions[i][0];
        y += positions[i][1];
    }
    x /= n;
    y /= n;
    return x;
}

-----
function getMinDistSum(positions) 
    // Your code here
}

************************************
Question ID: 1639
function numWays(words, target) {
    const n = words.length;
    const m = target.length;
    const count = Array.from({length: n}, () => Array(26).fill(0));
    const dp = Array.from({length: m}, () => Array(n).fill(0));
    const mod = 1e9 + 7;

    for (let i = 0; i < n; i++) {
        for (let c of words[i]) {
            count[i][c.charCodeAt(0) - 'a'.charCodeAt(0)]++;
        }
    }

    for (let i = 0; i < n; i++) {
        dp[0][i] = count[i][target.charCodeAt(0) - 'a'.charCodeAt(0)];
    }

    for (let i = 1; i < m; i++) {
        for (let j = 0; j < n; j++) {
            for (let k = 0; k < n; k++) {
                dp[i][j] = (dp[i][j] + dp[i-1][k] * count[j][target.charCodeAt(i) - 'a'.charCodeAt(0)]) % mod;
            }
        }
    }

    return dp[m-1].reduce((acc, val) => (acc + val) % mod, 0);
}

-----
function numWays(words, target) 
    // Your code here
}

************************************
Question ID: 1640
function canFormArray(arr, pieces) {
    const map = new Map(pieces.map(piece => [piece[0], piece]));

    let i = 0;
    while (i < arr.length) {
        if (!map.has(arr[i])) {
            return false;
        }
        const piece = map.get(arr[i]);
        for (const num of piece) {
            if (num !== arr[i]) {
                return false;
            }
            i++;
        }
    }
    return true;
}


-----
function canFormArray(arr, pieces) 
    // Your code here
}


************************************
Question ID: 1641
function countVowelStrings(n) {
    let dp = [1, 1, 1, 1, 1];
    for (let i = 2; i <= n; i++) {
        for (let j = 3; j >= 0; j--) {
            dp[j] = dp[j] + dp[j + 1];
        }
    }
    return dp.reduce((a, b) => a + b, 0);
}

-----
function countVowelStrings(n) 
    // Your code here
}

************************************
Question ID: 1642
function maxWaterBottles(numBottles, numExchange) {
    let total = numBottles;
    while (numBottles >= numExchange) {
        const newBottles = Math.floor(numBottles / numExchange);
        total += newBottles;
        numBottles = newBottles + numBottles % numExchange;
    }
    return total;
}


-----
function maxWaterBottles(numBottles, numExchange) 
    // Your code here
}


************************************
Question ID: 1643
function dfs(node, tree, labels, ans, count) {
  const prevCount = count[labels[node]];
  count[labels[node]]++;
  ans[node] = count[labels[node]] - prevCount;

  for (const child of tree[node]) {
    dfs(child, tree, labels, ans, count);
  }

  count[labels[node]] = prevCount;
}

function countSubTrees(n, edges, labels) {
  const tree = new Array(n).fill(0).map(() => []);
  for (const edge of edges) {
    tree[edge[1]].push(edge[0]);
  }

  const ans = new Array(n).fill(0);
  const count = new Array(26).fill(0);
  dfs(0, tree, labels, ans, count);

  return ans;
}

-----
function dfs(node, tree, labels, ans, count) 
    // Your code here
}

************************************
Question ID: 1644
function maxNumOfSubstrings(s) {
    const last = new Array(26).fill(-1);
    for (let i = 0; i < s.length; ++i) {
        last[s.charCodeAt(i) - 'a'.charCodeAt(0)] = i;
    }
    
    let res = [];
    let pre = -1;
    let maxRight = -1;
    for (let i = 0; i < s.length; ++i) {
        maxRight = Math.max(maxRight, last[s.charCodeAt(i) - 'a'.charCodeAt(0)]);
        if (maxRight === i) {
            res.push(s.substring(pre + 1, maxRight + 1));
            pre = i;
        }
    }
    
    return res;
}

-----
function maxNumOfSubstrings(s) 
    // Your code here
}

************************************
Question ID: 1646
function findKthPositive(arr, k) {
    let i = 0, num = 1;
    while (k > 0) {
        if (i < arr.length && arr[i] === num) {
            i++;
        } else {
            k--;
        }
        num++;
    }
    return num - 1;
}

-----
function findKthPositive(arr, k) 
    // Your code here
}

************************************
Question ID: 1647
function canConvert(s, t, k) {
    let diff = 0;
    for (let i = 0; i < s.length; i++) {
        let curr_diff = (t.charCodeAt(i) - s.charCodeAt(i) + 26) % 26;
        if (curr_diff > 0) {
            diff += curr_diff;
            k -= curr_diff;
        }
    }
    return k >= 0 && k >= diff - s.length && k % 26 === 0;
}

-----
function canConvert(s, t, k) 
    // Your code here
}

************************************
Question ID: 1648
function minInsertions(s) {
    let ans = 0, depth = 0;
    for (let i = 0; i < s.length; ++i) {
        if (s[i] === '(') {
            depth += 2;
        } else {
            if (s[i - 1] === '(') {
                --depth;
            } else {
                depth -= 2;
            }
            if (depth < 0) {
                ans -= depth;
                depth = 0;
            }
        }
    }
    return ans + depth;
}

-----
function minInsertions(s) 
    // Your code here
}

************************************
Question ID: 1649
function maxNonOverlapping(nums, target) {
    let prefixSum = {};
    let sumSoFar = 0;
    let count = 0;
    prefixSum[0] = 1;
    for (const num of nums) {
        sumSoFar += num;
        if (prefixSum.hasOwnProperty(sumSoFar - target)) {
            count++;
            prefixSum = {};
            prefixSum[0] = 1;
            sumSoFar = 0;
        } else {
            if (!prefixSum.hasOwnProperty(sumSoFar)) {
                prefixSum[sumSoFar] = 0;
            }
            prefixSum[sumSoFar]++;
        }
    }
    return count;
}


-----
function maxNonOverlapping(nums, target) 
    // Your code here
}


************************************
Question ID: 1652
function minOperations(target) {
    let operations = 0;
    let current_bit = '0';
    for (let bit of target) {
        if (bit !== current_bit) {
            operations++;
            current_bit = bit;
        }
    }
    return operations;
}


-----
function minOperations(target) 
    // Your code here
}


************************************
Question ID: 1653
function dfs(root, distance, depths) {
    if (!root) return 0;
    if (!root.left && !root.right) {
        depths.push(0);
        return 1;
    }
    let left = [], right = [];
    let count = dfs(root.left, distance, left) + dfs(root.right, distance, right);
    for (let l of left) {
        for (let r of right) {
            if (l + r + 2 <= distance) count++;
        }
    }
    depths.push(...left.map(l => l + 1), ...right.map(r => r + 1));
    return count;
}

function countPairs(root, distance) {
    let depths = [];
    return dfs(root, distance, depths);
}

-----
function dfs(root, distance, depths) 
    // Your code here
}

************************************
Question ID: 1654
function minimumJumps(forbidden, a, b, x) {
    const forbidden_positions = new Set(forbidden);
    const q = [[0, 0, 0]];
    const visited = new Set(['0,0']);
    while (q.length) {
        const [pos, steps, backward] = q.shift();
        if (pos === x) return steps;
        const forward_pos = pos + a;
        const backward_pos = pos - b;
        if (forward_pos <= 6000 && !forbidden_positions.has(forward_pos) && !visited.has(`${forward_pos},0`)) {
            visited.add(`${forward_pos},0`);
            q.push([forward_pos, steps + 1, 0]);
        }
        if (backward === 0 && backward_pos > 0 && !forbidden_positions.has(backward_pos) && !visited.has(`${backward_pos},1`)) {
            visited.add(`${backward_pos},1`);
            q.push([backward_pos, steps + 1, 1]);
        }
    }
    return -1;
}

-----
function minimumJumps(forbidden, a, b, x) 
    // Your code here
}

************************************
Question ID: 1655
function canDistribute(nums, quantity) {
    const counts = new Map();
    for (const num of nums) {
        counts.set(num, (counts.get(num) || 0) + 1);
    }

    const values = Array.from(counts.values());
    quantity.sort((a, b) => b - a);

    function dfs(index, values) {
        if (index === quantity.length) {
            return true;
        }
        for (let i = 0; i < values.length; i++) {
            if (values[i] >= quantity[index]) {
                values[i] -= quantity[index];
                if (dfs(index + 1, values)) return true;
                values[i] += quantity[index];
            }
        }
        return false;
    }

    return dfs(0, values);
}


-----
function canDistribute(nums, quantity) 
    // Your code here
}


************************************
Question ID: 1656
function countGoodTriplets(arr, a, b, c) {
    let count = 0;
    for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
            if (Math.abs(arr[i] - arr[j]) <= a) {
                for (let k = j + 1; k < arr.length; k++) {
                    if (Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[i] - arr[k]) <= c) {
                        count++;
                    }
                }
            }
        }
    }
    return count;
}


-----
function countGoodTriplets(arr, a, b, c) 
    // Your code here
}


************************************
Question ID: 1657
function getWinner(arr, k) {
    let winner = arr[0];
    let consecutiveWins = 0;

    for (let i = 1; i < arr.length; i++) {
        if (arr[i] > winner) {
            winner = arr[i];
            consecutiveWins = 0;
        }
        if (++consecutiveWins === k) {
            break;
        }
    }
    return winner;
}

-----
function getWinner(arr, k) 
    // Your code here
}

************************************
Question ID: 1658
function minSwaps(grid) {
    const n = grid.length;
    const row_zeros = new Array(n).fill(0);
    
    for (let i = 0; i < n; i++) {
        for (let j = n - 1; j >= 0; j--) {
            if (grid[i][j] === 0) {
                row_zeros[i]++;
            } else {
                break;
            }
        }
    }
    
    let steps = 0;
    for (let i = 0; i < n; i++) {
        const target = n - i - 1;
        let current_row = i;
        while (current_row < n && row_zeros[current_row] < target) {
            current_row++;
        }
        if (current_row === n) {
            return -1;
        }
        steps += current_row - i;
        row_zeros.splice(current_row, 1);
        row_zeros.splice(i, 0, target);
    }
    
    return steps;
}

-----
function minSwaps(grid) 
    // Your code here
}

************************************
Question ID: 1659
function maxSum(nums1, nums2) {
    const mod = 1e9 + 7;
    const m = nums1.length, n = nums2.length;
    const dp1 = new Array(m + 1).fill(0), dp2 = new Array(n + 1).fill(0);
    let i = m - 1, j = n - 1;
    while (i >= 0 || j >= 0) {
        const a = i >= 0 ? dp1[i] + nums1[i] : Number.MIN_SAFE_INTEGER;
        const b = j >= 0 ? dp2[j] + nums2[j] : Number.MIN_SAFE_INTEGER;
        const seen = new Set();
        if (a > b) {
            dp1[i--] = a % mod;
            seen.add(nums1[i + 1]);
        } else {
            dp2[j--] = b % mod;
            seen.add(nums2[j + 1]);
        }
    }
    return Math.max(dp1[0], dp2[0]) % mod;
}

-----
function maxSum(nums1, nums2) 
    // Your code here
}

************************************
Question ID: 1660
function thousandSeparator(n) {
    let result = String(n);
    let count = 0;
    for (let i = result.length - 1; i > 0; --i) {
        count++;
        if (count % 3 === 0) {
            result = result.slice(0, i) + '.' + result.slice(i);
        }
    }
    return result;
}

-----
function thousandSeparator(n) 
    // Your code here
}

************************************
Question ID: 1662
function minNumOperations(nums) {
    let result = 0;
    let highestBit = new Array(32).fill(0);
    for (let num of nums) {
        for (let j = 0; j < 32; ++j) {
            if (num & (1 << j)) {
                highestBit[j]++;
            }
        }
    }
    for (let count of highestBit) {
        result = Math.max(result, count);
    }
    return result + 31;
}

-----
function minNumOperations(nums) 
    // Your code here
}

************************************
Question ID: 1663
function containsCycle(grid) {
    function dfs(x, y, startX, startY, depth) {
        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] !== grid[startX][startY])
            return false;

        grid[x][y] = '*';

        const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        for (const [dx, dy] of directions) {
            const newX = x + dx;
            const newY = y + dy;

            if (newX === startX && newY === startY && depth >= 4) return true;

            if (dfs(newX, newY, startX, startY, depth + 1)) return true;
        }
      
        grid[x][y] = grid[startX][startY];

        return false;
    }

    for (let i = 0; i < grid.length; ++i) {
        for (let j = 0; j < grid[0].length; ++j) {
            if (dfs(i, j, i, j, 0)) return true;
        }
    }
    return false;
}

-----
function containsCycle(grid) 
    // Your code here
}

************************************
Question ID: 1664
function numberOfFairs(nums) {
    let even_sum = 0, odd_sum = 0, l_even = 0, l_odd = 0, count = 0;
    for (let i = 0; i < nums.length; ++i) {
        if (i % 2 === 0) even_sum += nums[i];
        else odd_sum += nums[i];
    }
    for (let i = 0; i < nums.length; ++i) {
        if (i % 2 === 0) {
            even_sum -= nums[i];
            if (l_even + odd_sum === l_odd + even_sum) ++count;
            l_even += nums[i];
        } else {
            odd_sum -= nums[i];
            if (l_even + odd_sum === l_odd + even_sum) ++count;
            l_odd += nums[i];
        }
    }
    return count;
}

-----
function numberOfFairs(nums) 
    // Your code here
}

************************************
Question ID: 1665
function minimumEffort(tasks) {
    tasks.sort((a, b) => (b[1] - b[0]) - (a[1] - a[0]));
    let ans = 0, sum = 0;
    for (const task of tasks) {
        ans = Math.max(ans, sum + task[1]);
        sum += task[0];
    }
    return ans;
}

-----
function minimumEffort(tasks) 
    // Your code here
}

************************************
Question ID: 1666
function makeGood(s) {
    let result = [];
    for (let c of s) {
        if (result.length > 0 && Math.abs(result[result.length - 1].charCodeAt(0) - c.charCodeAt(0)) === 32) {
            result.pop();
        } else {
            result.push(c);
        }
    }
    return result.join("");
}


-----
function makeGood(s) 
    // Your code here
}


************************************
Question ID: 1668
function longestAwesomeSubstring(s) {
    let n = s.length;
    let maxLen = 0;
    for (let i = 0; i < n; ++i) {
        for (let j = i + 1; j <= n; ++j) {
            let substr = s.substring(i, j);
            if (isAwesome(substr)) {
                maxLen = Math.max(maxLen, j - i);
            }
        }
    }
    return maxLen;
}

function isAwesome(s) {
    let odd_count = 0;
    let freq = new Array(26).fill(0);
    for (let c of s) {
        freq[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;
    }
    for (let i = 0; i < 26; i++) {
        if (freq[i] % 2 == 1) {
            odd_count++;
        }
    }
    return odd_count <= 1;
}

-----
function longestAwesomeSubstring(s) 
    // Your code here
}

************************************
Question ID: 1669
function minCost(n, cuts) {
    cuts.push(0);
    cuts.push(n);
    cuts.sort((a, b) => a - b);
    const size = cuts.length;
    const dp = Array.from({ length: size }, () => Array(size).fill(0));

    for (let len = 2; len < size; len++) {
        for (let i = 0; i < size - len; i++) {
            const j = i + len;
            dp[i][j] = Infinity;
            for (let k = i + 1; k < j; k++) {
                dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + cuts[j] - cuts[i]);
            }
        }
    }

    return dp[0][size - 1];
}

-----
function minCost(n, cuts) 
    // Your code here
}

************************************
Question ID: 1670
class FrontMiddleBackQueue {
    constructor() {
        this.first = [];
        this.second = [];
    }
    
    pushFront(val) {
        this.first.unshift(val);
        if (this.first.length > this.second.length + 1) {
            this.second.unshift(this.first.pop());
        }
    }
    
    pushMiddle(val) {
        if (this.first.length < this.second.length) {
            this.first.push(val);
        } else {
            this.second.unshift(val);
        }
    }
    
    pushBack(val) {
        this.second.push(val);
        if (this.second.length > this.first.length) {
            this.first.push(this.second.shift());
        }
    }
    
    popFront() {
        if (this.first.length === 0 && this.second.length === 0) return -1;
        let val = this.first.shift();
        if (this.first.length + 1 < this.second.length) {
            this.first.push(this.second.shift());
        }
        return val;
    }
    
    popMiddle() {
        if (this.first.length === 0 && this.second.length === 0) return -1;
        let val;
        if (this.first.length < this.second.length) {
            val = this.second.shift();
        } else {
            val = this.first.pop();
        }
        if (this.second.length > this.first.length) {
            this.first.push(this.second.shift());
        }
        return val;
    }
    
    popBack() {
        if (this.first.length === 0 && this.second.length === 0) return -1;
        let val = this.second.pop();
        if (this.first.length > this.second.length + 1) {
            this.second.unshift(this.first.pop());
        }
        return val;
    }
}


-----
class FrontMiddleBackQueue 
    // Your code here
}


************************************
Question ID: 1671
function minimumMountainRemovals(nums) {
    const n = nums.length;
    const left = new Array(n).fill(0);
    const right = new Array(n).fill(0);
    for (let i = 1; i < n; ++i) {
        left[i] = left[i - 1] + (nums[i] > nums[i - 1] ? 1 : 0);
        right[n - i - 1] = right[n - i] + (nums[n - i - 1] > nums[n - i] ? 1 : 0);
    }
    let ans = n - 3;
    for (let i = 1; i < n - 1; ++i) {
        ans = Math.min(ans, n - 1 - left[i] - right[i]);
    }
    return ans;
}

-----
function minimumMountainRemovals(nums) 
    // Your code here
}

************************************
Question ID: 1672
function maximumWealth(accounts) {
    let maxWealth = 0;
    for (let customer of accounts) {
        let wealth = 0;
        for (let account of customer) {
            wealth += account;
        }
        maxWealth = Math.max(maxWealth, wealth);
    }
    return maxWealth;
}

-----
function maximumWealth(accounts) 
    // Your code here
}

************************************
Question ID: 1673
function mostCompetitive(nums, k) {
    let stack = [];
    let n = nums.length;
    for (let i = 0; i < n; i++) {
        while (stack.length > 0 && stack[stack.length - 1] > nums[i] && stack.length + n - i > k) {
            stack.pop();
        }
        if (stack.length < k) {
            stack.push(nums[i]);
        }
    }
    return stack;
}


-----
function mostCompetitive(nums, k) 
    // Your code here
}


************************************
Question ID: 1674
function minOperations(n) {
    return n * (n - 1) / 2;
}


-----
function minOperations(n) 
    // Your code here
}


************************************
Question ID: 1675
function canPlaceBalls(force, position, m) {
    let last_position = position[0];
    let placed_balls = 1;

    for (let i = 1; i < position.length; i++) {
        if (position[i] - last_position >= force) {
            placed_balls++;
            last_position = position[i];

            if (placed_balls === m) {
                return true;
            }
        }
    }

    return false;
}

function maxDistance(position, m) {
    position.sort((a, b) => a - b);

    let left = 1;
    let right = position[position.length - 1] - position[0];
    let ans = 0;

    while (left <= right) {
        let mid = Math.floor((left + right) / 2);
        if (canPlaceBalls(mid, position, m)) {
            ans = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return ans;
}

-----
function canPlaceBalls(force, position, m) 
    // Your code here
}

************************************
Question ID: 1678
function numWays(s) {
  let numberOfOnes = s.split('').filter(c => c === '1').length;
  if (numberOfOnes % 3 !== 0) return 0;

  let target = numberOfOnes / 3;
  if (target === 0) {
    let n = s.length;
    return ((n - 1) * (n - 2) / 2) % 1000000007;
  }

  let onesSoFar1 = 0, onesSoFar2 = 0;
  let way1 = 0, way2 = 0;
  for (let c of s) {
    if (c === '1') {
      onesSoFar1++;
      if (onesSoFar1 === target) {
        way1++;
        onesSoFar1 = 0;
      }

      onesSoFar2++;
      if (onesSoFar2 === target * 2) {
        way2++;
        onesSoFar2 = 0;
      }
    }
  }

  return (way1 * way2) % 1000000007;
}


-----
function numWays(s) 
    // Your code here
}


************************************
Question ID: 1679
function findLengthOfShortestSubarray(arr) {
    const n = arr.length;
    let left = 0, right = n - 1;

    while (left < n - 1 && arr[left] <= arr[left + 1]) left++;
    if (left === n - 1) return 0;

    while (right > 0 && arr[right] >= arr[right - 1]) right--;

    let result = Math.min(right, n - left - 1);

    let i = 0, j = right;

    while (i <= left && j < n) {
        if (arr[i] <= arr[j]) {
            result = Math.min(result, j - i - 1);
            i++;
        } else {
            j++;
        }
    }

    return result;
}


-----
function findLengthOfShortestSubarray(arr) 
    // Your code here
}


************************************
Question ID: 1680
function countRoutes(locations, start, finish, fuel, curr = null, remainingFuel = null, memo = {}) {
    if (curr === null) {
        curr = start;
        remainingFuel = fuel;
    }

    if (remainingFuel < 0) {
        return 0;
    }

    const key = `${curr}:${remainingFuel}`;
    if (memo.hasOwnProperty(key)) {
        return memo[key];
    }

    let ans = (curr === finish) ? 1 : 0;
    for (let next = 0; next < locations.length; ++next) {
        if (next !== curr) {
            ans += countRoutes(locations, start, finish, fuel, next, remainingFuel - Math.abs(locations[curr] - locations[next]), memo);
            ans %= 1000000007;
        }
    }
    memo[key] = ans;
    return ans;
}

-----
function countRoutes(locations, start, finish, fuel, curr = null, remainingFuel = null, memo = 
    // Your code here
}

************************************
Question ID: 1682
function mostVisited(n, rounds) {
    const visited = new Array(n + 1).fill(0);
    
    for (let i = 1; i < rounds.length; ++i) {
        for (let start = rounds[i - 1], end = rounds[i]; start !== end; start = start % n + 1) {
            ++visited[start];
        }
    }
    ++visited[rounds[rounds.length - 1]];
    
    const maxVisits = Math.max(...visited);
    const result = [];
    
    for (let i = 1; i <= n; ++i) {
        if (visited[i] === maxVisits) {
            result.push(i);
        }
    }
    return result;
}

-----
function mostVisited(n, rounds) 
    // Your code here
}

************************************
Question ID: 1684
function findLatestStep(arr, m) {
    const n = arr.length;
    const lengthLeft = new Array(n + 2).fill(0);
    const lengthRight = new Array(n + 2).fill(0);
    let count = 0;
    let result = -1;
    
    for (let i = 0; i < n; ++i) {
        const pos = arr[i];
        const leftLength = lengthRight[pos - 1];
        const rightLength = lengthLeft[pos + 1];
        const newLength = leftLength + rightLength + 1;

        if (leftLength === m || rightLength === m) {
            count--;
        }

        if (newLength === m) {
            count++;
        }

        if (newLength > 0) {
            lengthLeft[pos - leftLength] = newLength;
            lengthRight[pos + rightLength] = newLength;
            result = i + 1;
        }
    }
    
    return count > 0 ? result : -1;
}


-----
function findLatestStep(arr, m) 
    // Your code here
}


************************************
Question ID: 1685
var stoneGameV = function(stoneValue) {
    const memo = new Array(stoneValue.length).fill(null).map(() => new Array(stoneValue.length).fill(-1));
    return maxScore(stoneValue, 0, stoneValue.length - 1, memo);
};

function maxScore(stoneValue, start, end, memo) {
    if (start === end) return 0;
    if (memo[start][end] !== -1) return memo[start][end];

    let leftSum = 0, rightSum = 0;
    for (let i = start; i < end; ++i) {
        leftSum += stoneValue[i];
        rightSum = 0;
        for (let j = i + 1; j <= end; ++j)
            rightSum += stoneValue[j];

        if (leftSum > rightSum)
            memo[start][end] = Math.max(memo[start][end], rightSum + maxScore(stoneValue, i + 1, end, memo));
        else if (leftSum < rightSum)
            memo[start][end] = Math.max(memo[start][end], leftSum + maxScore(stoneValue, start, i, memo));
        else
            memo[start][end] = Math.max(memo[start][end], leftSum + Math.max(maxScore(stoneValue, start, i, memo), maxScore(stoneValue, i + 1, end, memo)));
    }
    return memo[start][end];
}


-----
var stoneGameV = function(stoneValue) 
    // Your code here
}


************************************
Question ID: 1686
function stoneGameVI(aliceValues, bobValues) {
    const n = aliceValues.length;
    const diff = aliceValues.map((val, i) => [val + bobValues[i], i]).sort((a, b) => b[0] - a[0]);

    let aliceSum = 0, bobSum = 0;
    for (let i = 0; i < n; i++) {
        if (i % 2 === 0)
            aliceSum += aliceValues[diff[i][1]];
        else
            bobSum += bobValues[diff[i][1]];
    }

    return aliceSum === bobSum ? 0 : (aliceSum > bobSum ? 1 : -1);
}


-----
function stoneGameVI(aliceValues, bobValues) 
    // Your code here
}


************************************
Question ID: 1687
function min_trips(boxes, portsCount, maxBoxes, maxWeight) {
    let trips = 0, idx = 0, n = boxes.length;
    while (idx < n) {
        let curr_limit = maxWeight, prev_port = 0;
        for (let count = 0; count < maxBoxes && idx < n; ++idx) {
            if (boxes[idx][1] <= curr_limit) {
                if (prev_port !== boxes[idx][0]) {
                    prev_port = boxes[idx][0];
                    trips += 1;
                }
                curr_limit -= boxes[idx][1];
                count += 1;
            }
        }
        trips += 1;
    }
    return trips;
}

-----
function min_trips(boxes, portsCount, maxBoxes, maxWeight) 
    // Your code here
}

************************************
Question ID: 1688
function numberOfMatches(n) {
    let matches = 0;
    while (n > 1) {
        matches += Math.floor(n / 2);
        n = Math.floor((n + 1) / 2);
    }
    return matches;
}

-----
function numberOfMatches(n) 
    // Your code here
}

************************************
Question ID: 1689
function containsPattern(arr, m, k) {
    const n = arr.length;
    if (m * k > n) return false;

    for (let i = 0; i + m * k <= n; i++) {
        let patternFound = true;
        for (let j = 0; j < m; j++) {
            for (let l = 1; l < k; l++) {
                if (arr[i + j] !== arr[i + j + l * m]) {
                    patternFound = false;
                    break;
                }
            }
            if (!patternFound) break;
        }
        if (patternFound) return true;
    }
    return false;
}

-----
function containsPattern(arr, m, k) 
    // Your code here
}

************************************
Question ID: 1690
function getMaxLen(nums) {
    let maxLength = 0, currentLen = 0, currentNegLen = 0;
    
    for (const num of nums) {
        if (num > 0) {
            ++currentLen;
            if (currentNegLen > 0) ++currentNegLen;
        } else if (num < 0) {
            [currentLen, currentNegLen] = [currentNegLen, currentLen + 1];
        } else {
            currentLen = 0;
            currentNegLen = 0;
        }
        maxLength = Math.max(maxLength, currentLen);
    }
    
    return maxLength;
}

-----
function getMaxLen(nums) 
    // Your code here
}

************************************
Question ID: 1692
function numTrees(n) {
    const dp = Array(n + 1).fill(0);
    dp[0] = 1;
    dp[1] = 1;

    for (let i = 2; i <= n; i++) {
        for (let j = 0; j < i; j++) {
            dp[i] += dp[j] * dp[i - 1 - j];
            dp[i] %= 1000000007;
        }
    }

    return dp[n];
}

-----
function numTrees(n) 
    // Your code here
}

************************************
Question ID: 1694
function minSubarray(nums, p) {
    const n = nums.length;
    let need = 0, cur = 0, res = n;
    const last_seen = new Map();

    for (const num of nums)
        need = (need + num) % p;

    if (need === 0)
        return 0;

    last_seen.set(cur, -1);
    for (let i = 0; i < n; ++i) {
        cur = (cur + nums[i]) % p;
        last_seen.set(cur, i);
        const want = (cur - need + p) % p;
        if (last_seen.has(want))
            res = Math.min(res, i - last_seen.get(want));
    }

    return res === n ? -1 : res;
}


-----
function minSubarray(nums, p) 
    // Your code here
}


************************************
Question ID: 1695
function maxSumRangeQuery(nums, requests) {
    const n = nums.length;
    const cnt = new Array(n).fill(0);
    const mod = 1e9 + 7;

    for (const req of requests) {
        cnt[req[0]]++;
        if (req[1] + 1 < n) cnt[req[1] + 1]--;
    }

    for (let i = 1; i < n; i++) {
        cnt[i] += cnt[i - 1];
    }

    nums.sort((a, b) => a - b);
    cnt.sort((a, b) => a - b);

    let ans = 0;
    for (let i = 0; i < n; i++) {
        ans += (BigInt(nums[i]) * BigInt(cnt[i])) % mod;
    }

    return Number(ans % mod);
}

-----
function maxSumRangeQuery(nums, requests) 
    // Your code here
}

************************************
Question ID: 1696
var isPrintable = function(targetGrid) {
    const m = targetGrid.length, n = targetGrid[0].length;
    const top = Array(61).fill(m), bottom = Array(61).fill(-1), left = Array(61).fill(n), right = Array(61).fill(-1);
    const vis = Array.from({ length: m }, () => Array(n).fill(false));

    for (let i = 0; i < m; ++i) {
        for (let j = 0; j < n; ++j) {
            const c = targetGrid[i][j];
            top[c] = Math.min(top[c], i);
            bottom[c] = Math.max(bottom[c], i);
            left[c] = Math.min(left[c], j);
            right[c] = Math.max(right[c], j);
        }
    }

    const dfs = (x) => {
        const i = Math.floor(x / n), j = x % n;
        if (vis[i][j]) return true;
        const c = targetGrid[i][j];
        if (i < top[c] || i > bottom[c] || j < left[c] || j > right[c]) return false;
        vis[i][j] = true;
        for (let k = 1; k <= 60; ++k) {
            if (k === c) continue;
            if (i >= top[k] && i <= bottom[k] && j >= left[k] && j <= right[k]) return false;
            if (!dfs(((i-top[k])*(right[k]-left[k]+1)) + j - left[k])) return false;
        }
        return true;
    };

    for (let color = 1; color <= 60; ++color) {
        for (let i = top[color]; i <= bottom[color]; ++i) {
            for (let j = left[color]; j <= right[color]; ++j) {
                if (!vis[i][j] && !dfs(i * n + j)) return false;
            }
        }
    }
    
    return true;
};


-----
var isPrintable = function(targetGrid) 
    // Your code here
};


************************************
Question ID: 1697
function distanceLimitedPathsExist(n, edgeList, queries) {
    const graph = new Map();

    for (const [u, v, dis] of edgeList) {
        if (!graph.has(u)) graph.set(u, []);
        if (!graph.has(v)) graph.set(v, []);
        graph.get(u).push([v, dis]);
        graph.get(v).push([u, dis]);
    }

    const answer = new Array(queries.length).fill(false);
    for (let i = 0; i < queries.length; i++) {
        const [pj, qj, limitj] = queries[i];

        const q = [[pj, 0]];
        const visited = new Array(n).fill(false);
        visited[pj] = true;

        while (q.length > 0) {
            const [curr_node, curr_dist] = q.shift();

            for (const [next_node, next_dist] of graph.get(curr_node) || []) {
                if (curr_dist + next_dist < limitj) {
                    if (next_node === qj) {
                        answer[i] = true;
                        break;
                    }
                    if (!visited[next_node]) {
                        visited[next_node] = true;
                        q.push([next_node, curr_dist + next_dist]);
                    }
                }
            }
            if (answer[i]) break;
        }
    }
    return answer;
}

-----
function distanceLimitedPathsExist(n, edgeList, queries) 
    // Your code here
}

************************************
Question ID: 1698
function modifyString(s) {
    s = s.split('');
    for (let i = 0; i < s.length; i++) {
        if (s[i] === '?') {
            for (let c = 'a'.charCodeAt(0); c <= 'z'.charCodeAt(0); c++) {
                if ((i - 1 < 0 || s[i - 1] !== String.fromCharCode(c)) && (i + 1 >= s.length || s[i + 1] !== String.fromCharCode(c))) {
                    s[i] = String.fromCharCode(c);
                    break;
                }
            }
        }
    }
    return s.join('');
}


-----
function modifyString(s) 
    // Your code here
}


************************************
Question ID: 1700
function min_time_to_remove_balloons(colors, neededTime) {
    const n = colors.length;
    const INF = 1e9;
    let dp = Array.from({ length: n }, () => Array(26).fill(INF));

    for (let color = 0; color < 26; color++) {
        if (colors.charAt(0) !== String.fromCharCode('A'.charCodeAt(0) + color))
            dp[0][color] = neededTime[0];
    }

    for (let i = 1; i < n; i++) {
        for (let color1 = 0; color1 < 26; color1++) {
            for (let color2 = 0; color2 < 26; color2++) {
                if (color1 !== color2 && colors.charAt(i) !== String.fromCharCode('A'.charCodeAt(0) + color1)) {
                    dp[i][color1] = Math.min(dp[i][color1], dp[i - 1][color2] + neededTime[i]);
                }
            }
        }
    }

    let ans = INF;
    for (let color = 0; color < 26; color++) {
        ans = Math.min(ans, dp[n - 1][color]);
    }

    return ans;
}


-----
function min_time_to_remove_balloons(colors, neededTime) 
    // Your code here
}


************************************
Question ID: 1701
function maxNumEdgesToRemove(n, edges) {
    let parent = new Array(2 * n + 1).fill().map((_, i) => i);

    function find(u) {
        return parent[u] === u ? u : parent[u] = find(parent[u]);
    }

    function unite(u, v) {
        u = find(u);
        v = find(v);
        if (u !== v) {
            parent[u] = v;
            return true;
        }
        return false;
    }

    edges.sort((a, b) => b[0] - a[0]);
    let ct = [0, 0];
    let both = n - 1;
    for (let edge of edges) {
        if (edge[0] === 3 && unite(edge[1], edge[2] + n)) {
            both--;
        }
        if (both === 0) break;
    }

    for (let type = 1; type < 3; type++) {
        for (let edge of edges) {
            if (edge[0] === type && unite(edge[1], edge[2] + n)) {
                ct[type - 1]++;
            }
        }
        if (both + ct[type - 1] < n - 1) {
            return -1;
        }
    }

    return ct[0] + ct[1] - n + 1;
}


-----
function maxNumEdgesToRemove(n, edges) 
    // Your code here
}


************************************
Question ID: 1702
function maximumBinaryString(binary) {
    let zeroCount = 0;
    let oneCount = 0;
    
    for (const c of binary) {
        if (c === '0') {
            zeroCount++;
        } else {
            oneCount++;
        }
    }
    
    if (zeroCount <= 1) {
        return binary;
    }
    
    let result = "";
    for (let i = 0; i < oneCount; ++i) {
        result += '1';
    }
    for (let i = 0; i < zeroCount - 1; ++i) {
        result += '0';
    }
    result += "1####1";
    return result.substr(0, binary.length);
}

-----
function maximumBinaryString(binary) 
    // Your code here
}

************************************
Question ID: 1703
function minMoves(nums, k) {
    const ones_pos = [];
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] === 1) {
            ones_pos.push(i - ones_pos.length);
        }
    }
    let sum = 0;
    for (let i = 0; i < k; i++) {
        sum += ones_pos[i];
    }
    let min_sum = sum;
    for (let i = k; i < ones_pos.length; i++) {
        sum += ones_pos[i] - ones_pos[i - k];
        min_sum = Math.min(min_sum, sum);
    }
    return min_sum - (k - 1) * k / 2;
}


-----
function minMoves(nums, k) 
    // Your code here
}


************************************
Question ID: 1704
function numSpecial(mat) {
    let m = mat.length, n = mat[0].length;
    let row = new Array(m).fill(0), col = new Array(n).fill(0);

    for (let i = 0; i < m; ++i) {
        for (let j = 0; j < n; ++j) {
            if (mat[i][j] == 1) {
                ++row[i];
                ++col[j];
            }
        }
    }

    let special_positions = 0;
    for (let i = 0; i < m; ++i) {
        for (let j = 0; j < n; ++j) {
            if (mat[i][j] == 1 && row[i] == 1 && col[j] == 1) {
                ++special_positions;
            }
        }
    }

    return special_positions;
}

-----
function numSpecial(mat) 
    // Your code here
}

************************************
Question ID: 1705
function unhappyFriends(n, preferences, pairs) {
    const pairMapping = new Array(n);
    for (const pair of pairs) {
        pairMapping[pair[0]] = pair[1];
        pairMapping[pair[1]] = pair[0];
    }

    let unhappyCount = 0;
    for (let x = 0; x < n; x++) {
        const y = pairMapping[x];
        const prefX = preferences[x];
        const idxY = prefX.indexOf(y);

        for (let i = 0; i < idxY; i++) {
            const u = prefX[i];
            const v = pairMapping[u];
            const prefU = preferences[u];
            const idxV = prefU.indexOf(v);
            if (prefU.indexOf(x) < idxV) {
                unhappyCount++;
                break;
            }
        }
    }

    return Math.floor(unhappyCount / 2);
}


-----
function unhappyFriends(n, preferences, pairs) 
    // Your code here
}


************************************
Question ID: 1706
function minCostConnectPoints(points) {
    const n = points.length;
    const cost = new Array(n).fill(Infinity);
    const visited = new Array(n).fill(false);
    cost[0] = 0;

    let ans = 0;

    for (let i = 0; i < n; i++) {
        let min_cost = Infinity;
        let cur_point = -1;
        for (let j = 0; j < n; j++) {
            if (!visited[j] && cost[j] < min_cost) {
                min_cost = cost[j];
                cur_point = j;
            }
        }

        visited[cur_point] = true;
        ans += min_cost;

        for (let j = 0; j < n; j++) {
            if (!visited[j]) {
                const new_cost = Math.abs(points[cur_point][0] - points[j][0]) + Math.abs(points[cur_point][1] - points[j][1]);
                cost[j] = Math.min(cost[j], new_cost);
            }
        }
    }

    return ans;
}

-----
function minCostConnectPoints(points) 
    // Your code here
}

************************************
Question ID: 1707
function canTransform(s, t) {
    let i = 0, j = 0;
    while (i < s.length && j < t.length) {
        if (s[i] === t[j]) {
            i++;
            j++;
        } else {
            i++;
        }
    }
    return j === t.length;
}


-----
function canTransform(s, t) 
    // Your code here
}


************************************
Question ID: 1710
function busiestServers(k, arrival, load) {
    const serverRequests = new Array(k).fill(0);
    const pq = [];
    const availableServers = Array.from({ length: k }, (_, i) => i);

    for (let i = 0; i < arrival.length; i++) {
        while (pq.length && pq[0][0] <= arrival[i]) {
            const [, serverId] = pq.shift();
            availableServers.push(serverId);
        }

        if (availableServers.length) {
            const serverId = availableServers.shift();
            serverRequests[serverId]++;
            pq.push([arrival[i] + load[i], serverId]);
            pq.sort((a, b) => a[0] - b[0]);
        }
    }

    const maxRequests = Math.max(...serverRequests);
    return serverRequests.reduce((result, requests, i) => {
        if (requests === maxRequests) {
            result.push(i);
        }
        return result;
    }, []);
}


-----
function busiestServers(k, arrival, load) 
    // Your code here
}


************************************
Question ID: 1711
function restoreMatrix(rowSum, colSum) {
    let m = rowSum.length;
    let n = colSum.length;
    let result = Array.from({ length: m }, () => Array(n).fill(0));

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            let value = Math.min(rowSum[i], colSum[j]);
            result[i][j] = value;
            rowSum[i] -= value;
            colSum[j] -= value;
        }
    }

    return result;
}


-----
function restoreMatrix(rowSum, colSum) 
    // Your code here
}


************************************
Question ID: 1712
function waysToSplit(nums) {
    const MOD = BigInt(1e9 + 7);
    const n = nums.length;
    const prefixSum = new Array(n + 1).fill(BigInt(0));
    for (let i = 0; i < n; i++) {
        prefixSum[i + 1] = prefixSum[i] + BigInt(nums[i]);
    }
    let ans = BigInt(0);
    let left = 0, right = 0;
    for (let mid = 1; mid < n - 1; mid++) {
        while (left + 1 < mid && prefixSum[left + 1] * BigInt(2) <= prefixSum[mid]) {
            left++;
        }
        while (right < mid || (right + 1 < n && prefixSum[right + 1] - prefixSum[mid] <= prefixSum[n] - prefixSum[right + 1])) {
            right++;
        }
        if (right >= mid && prefixSum[mid] - prefixSum[left] <= prefixSum[right] - prefixSum[mid]) {
            ans = (ans + BigInt(right - mid + 1)) % MOD;
        }
    }
    return Number(ans);
}

-----
function waysToSplit(nums) 
    // Your code here
}

************************************
Question ID: 1713
function minOperations(target, arr) {
    const pos = new Map();
    for (let i = 0; i < target.length; ++i) {
        pos.set(target[i], i);
    }

    const dp = [];
    for (const a of arr) {
        if (pos.has(a)) {
            const idx = dp.findIndex(x => x >= pos.get(a));
            if (idx === -1) {
                dp.push(pos.get(a));
            } else {
                dp[idx] = pos.get(a);
            }
        }
    }
    return target.length - dp.length;
}

-----
function minOperations(target, arr) 
    // Your code here
}

************************************
Question ID: 1714
function reorderSpaces(text) {
    const spaces = text.split('').filter(char => char === ' ').length;
    const words = text.trim().split(/\s+/);
    
    if (words.length === 1) {
        return words[0] + ' '.repeat(spaces);
    }

    const spaceBetweenWords = Math.floor(spaces / (words.length - 1));
    const extraSpaces = spaces % (words.length - 1);
    let result = '';
    
    for (let i = 0; i < words.length; i++) {
        result += words[i];
        if (i < words.length - 1) {
            result += ' '.repeat(spaceBetweenWords);
        }
    }
    
    result += ' '.repeat(extraSpaces);

    return result;
}

-----
function reorderSpaces(text) 
    // Your code here
}

************************************
Question ID: 1716
function maxProductPath(grid) {
    const m = grid.length;
    const n = grid[0].length;
    const mod = 1e9 + 7;
    const dp = new Array(m).fill(0).map(() => new Array(n).fill(0).map(() => [0, 0]));

    dp[0][0] = [grid[0][0], grid[0][0]];

    for(let i = 1; i < m; i++) {
        dp[i][0] = [dp[i - 1][0][0] * grid[i][0], dp[i - 1][0][0] * grid[i][0]];
    }
    for(let j = 1; j < n; j++) {
        dp[0][j] = [dp[0][j - 1][0] * grid[0][j], dp[0][j - 1][0] * grid[0][j]];
    }

    for(let i = 1; i < m; i++) {
        for(let j = 1; j < n; j++) {
            if(grid[i][j] < 0) {
                dp[i][j][0] = Math.min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j];
                dp[i][j][1] = Math.max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j];
            } else {
                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j];
                dp[i][j][1] = Math.min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j];
            }
        }
    }
    
    return dp[m - 1][n - 1][0] >= 0 ? dp[m - 1][n - 1][0] % mod : -1;
}


-----
function maxProductPath(grid) 
    // Your code here
}


************************************
Question ID: 1717
function minCost(cost, size1, size2) {
    let dp = new Array(size2 + 1).fill(Infinity);
    dp[0] = 0;

    for (let i = 0; i < size1; i++) {
        for (let j = size2; j >= 0; j--) {
            let minCost = Infinity;
            for (let k = 0; k < size2; k++) {
                if (((1 << k) & j) === 0) {
                    minCost = Math.min(minCost, cost[i][k] + dp[j | (1 << k)]);
                }
            }
            dp[j] = Math.min(dp[j], minCost);
        }
    }

    return dp[(1 << size2) - 1];
}

-----
function minCost(cost, size1, size2) 
    // Your code here
}

************************************
Question ID: 1719
function checkWays(pairs) {
    const candidates = {};
    for (const [x, y] of pairs) {
        candidates[x] = (candidates[x] || 0) + 1;
        candidates[y] = (candidates[y] || 0) + 1;
    }

    let rootCount = 0;
    for (const candidate in candidates) {
        if (candidates[candidate] == 1) {
            rootCount++;
            if (rootCount > 1) {
                return 2;
            }
        }
    }

    return rootCount;
}

-----
function checkWays(pairs) 
    // Your code here
}

************************************
Question ID: 1720
function minOperations(logs) {
    let depth = 0;
    for (const log of logs) {
        if (log === "../") {
            if (depth > 0) {
                depth--;
            }
        } else if (log !== "./") {
            depth++;
        }
    }
    return depth;
}


-----
function minOperations(logs) 
    // Your code here
}


************************************
Question ID: 1721
function minOperationsMaxProfit(customers, boardingCost, runningCost) {
    let rotations = 0, waiting = 0, onBoard = 0, profit = 0, maxProfit = 0, maxRotations = 0;
    while (customers.length > 0 || waiting > 0) {
        if (customers.length > 0) {
            waiting += customers.shift();
        }
        
        onBoard = Math.min(waiting, 4);
        waiting -= onBoard;
        profit += onBoard * boardingCost - runningCost;
        rotations++;
        
        if (profit > maxProfit) {
            maxProfit = profit;
            maxRotations = rotations;
        }
    }
    return maxProfit > 0 ? maxRotations : -1;
}


-----
function minOperationsMaxProfit(customers, boardingCost, runningCost) 
    // Your code here
}


************************************
Question ID: 1723
function maxAchievableRequests(n, requests, idx = 0, counts = null) {
    if (counts === null) {
        counts = new Array(n).fill(0);
    }
    if (idx === requests.length) {
        if (counts.every(count => count === 0)) return 0;
        return 0;
    }
    let ignored = maxAchievableRequests(n, requests, idx + 1, [...counts]);
    counts[requests[idx][0]]++;
    counts[requests[idx][1]]--;

    let accepted = 1 + maxAchievableRequests(n, requests, idx + 1, counts);

    return Math.max(ignored, accepted);
}

-----
function maxAchievableRequests(n, requests, idx = 0, counts = null) 
    // Your code here
}

************************************
Question ID: 1725
function numberOfSets(n, k) {
    const mod = 1e9 + 7;
    const dp = Array.from({ length: n }, () => Array(k + 1).fill(0));
    const presum = Array(n).fill(1);
    
    for (let j = 1; j <= k; ++j) {
        for (let i = 0; i < n; ++i) {
            dp[i][j] = presum[i];
            if (i > 0) {
                dp[i][j] += dp[i - 1][j];
            }
            dp[i][j] %= mod;
            presum[i] = (presum[i] + dp[i][j - 1]) % mod;
        }
    }

    return dp[n - 1][k];
}

-----
function numberOfSets(n, k) 
    // Your code here
}

************************************
Question ID: 1726
function bestCoordinate(towers, radius) {
    let max_quality = 0, best_x = 0, best_y = 0;

    for (let x = 0; x <= 50; ++x) {
        for (let y = 0; y <= 50; ++y) {
            let sum_quality = 0;
            for (const tower of towers) {
                const dist = Math.sqrt(Math.pow(x - tower[0], 2) + Math.pow(y - tower[1], 2));
                if (dist <= radius) {
                    sum_quality += Math.floor(tower[2] / (1 + dist));
                }
            }
            if (sum_quality > max_quality) {
                max_quality = sum_quality;
                best_x = x;
                best_y = y;
            }
        }
    }

    return [best_x, best_y];
}

-----
function bestCoordinate(towers, radius) 
    // Your code here
}

************************************
Question ID: 1727
function canMouseWin(grid, catJump, mouseJump) {
    const rows = grid.length;
    const cols = grid[0].length;
    let cat_r, cat_c, mouse_r, mouse_c;

    for (let r = 0; r < rows; ++r)
        for (let c = 0; c < cols; ++c) {
            if (grid[r][c] === 'C') {
                cat_r = r;
                cat_c = c;
            } else if (grid[r][c] === 'M') {
                mouse_r = r;
                mouse_c = c;
            }
        }

    const dirs = [-1, 0, 1, 0, -1];

    function dfs(r_m, c_m, r_c, c_c, cnt, dst_m_c) {
        if (cnt >= 100)
            return false;
        if (r_m < 0 || r_m >= rows || c_m < 0 || c_m >= cols)
            return false;
        if (r_c < 0 || r_c >= rows || c_c < 0 || c_c >= cols)
            return true;
        if (grid[r_m][c_m] === 'F' || cnt !== dst_m_c) {
            return true;
        } else if (grid[r_m][c_m] === '#' || cnt + 1 === dst_m_c) {
            return false;
        }

        let res = false;
        for(let i = 0; i < 4; i++){
            let jump = (dst_m_c === cnt) ? catJump : mouseJump;
            res |= !dfs(r_m + jump * dirs[i], c_m + jump * dirs[i+1], r_c + dirs[i] * dirs[(i + 2) % 4], c_c + dirs[i+1] * dirs[(i + 3) % 4], cnt + 1, dst_m_c);
            if(jump === 1) break;
        }

        return res;
    }

    return dfs(mouse_r, mouse_c, cat_r, cat_c, 0, Math.abs(cat_r - mouse_r) + Math.abs(cat_c - mouse_c));
}

-----
function canMouseWin(grid, catJump, mouseJump) 
    // Your code here
}

************************************
Question ID: 1730
function findSpecialInteger(nums) {
    for (let x = 1; x <= nums.length; ++x) {
        let count = 0;
        for (let num of nums) {
            if (num >= x) {
                ++count;
            }
        }
        if (count === x) {
            return x;
        }
    }
    return -1;
}

-----
function findSpecialInteger(nums) 
    // Your code here
}

************************************
Question ID: 1732
function minOperations(n) {
    let operations = 0;
    while (n > 0) {
        if (n % 2 === 0) {
            n /= 2;
        } else {
            n--;
        }
        operations++;
    }
    return operations;
}

-----
function minOperations(n) 
    // Your code here
}

************************************
Question ID: 1733
function visiblePoints(points, angle, location) {
    const angles = points.filter(point => point[0] !== location[0] || point[1] !== location[1])
        .map(point => Math.atan2(point[1] - location[1], point[0] - location[0]) * 180 / Math.PI)
        .sort((a, b) => a - b);
    angles.push(...angles.map(a => a + 360));
    let max_points = 0;
    let j = 0;
    const n = angles.length;
    for (let i = 0; i < 2 * n; i++) {
        while (angles[i] - angles[j] > angle) {
            j += 1;
        }
        max_points = Math.max(max_points, i - j + 1);
    }
    const locationsAtPoint = points.filter(point => point[0] === location[0] && point[1] === location[1]).length;
    return max_points + locationsAtPoint;
}


-----
function visiblePoints(points, angle, location) 
    // Your code here
}


************************************
Question ID: 1734
function decode(encoded) {
    const n = encoded.length + 1;
    let totalXor = 0;
    
    for (let i = 1; i <= n; i++) {
        totalXor ^= i;
    }

    let nonFirstXor = 0;
    for (let i = 1; i < n - 1; i += 2) {
        nonFirstXor ^= encoded[i];
    }
    
    const perm = new Array(n);
    perm[0] = totalXor ^ nonFirstXor;

    for (let i = 1; i < n; i++) {
        perm[i] = perm[i - 1] ^ encoded[i - 1];
    }
    
    return perm;
}


-----
function decode(encoded) 
    // Your code here
}


************************************
Question ID: 1735
const MOD = 1e9 + 7;

function mul(a, b) {
  return (BigInt(a) * BigInt(b)) % MOD;
}

function ways(n, k, mem) {
  if (n === 1) return k;
  const key = n + ',' + k;
  if (mem[key]) return mem[key];

  if (k === 1) {
    mem[key] = 1;
    return 1;
  }
  if (n > k) {
    mem[key] = 0;
    return 0;
  }

  let res = mul(ways(n, k - 1, mem), n);
  res = (res - mul(n - 1, ways(n - 1, k - 1, mem)) + MOD) % MOD;
  
  mem[key] = Number(res);
  return mem[key];
}

function waysToFillArray(queries) {
  const mem = {};
  const ans = [];
  for (let i = 0; i < queries.length; i++) {
    ans.push(ways(queries[i][0], queries[i][1], mem));
  }
  return ans;
}

-----
const MOD = 1e9 + 7;

function mul(a, b) 
    // Your code here
}

************************************
Question ID: 1736
function maximumTime(time) {
    let res = time.split('');
    if (res[0] === "?") {
        res[0] = (res[1] <= "3" || res[1] === "?") ? "2" : "1";
    }
    if (res[1] === "?") {
        res[1] = (res[0] === "2") ? "3" : "9";
    }
    if (res[3] === "?") {
        res[3] = "5";
    }
    if (res[4] === "?") {
        res[4] = "9";
    }
    return res.join('');
}

-----
function maximumTime(time) 
    // Your code here
}

************************************
Question ID: 1737
function maxDepth(s) {
    let depth = 0, maxDepth = 0;
    for (const ch of s) {
        if (ch === '(') depth++;
        else if (ch === ')') depth--;
        maxDepth = Math.max(maxDepth, depth);
    }
    return maxDepth;
}

-----
function maxDepth(s) 
    // Your code here
}

************************************
Question ID: 1738
function maximalNetworkRank(n, roads) {
    let degree = new Array(n).fill(0);
    let s = new Set();
    
    for (let road of roads) {
        degree[road[0]]++;
        degree[road[1]]++;
        s.add([Math.min(road[0], road[1]), Math.max(road[0], road[1])].toString());
    }
    
    let ans = 0;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            ans = Math.max(ans, degree[i] + degree[j] - (s.has([i, j].toString()) ? 1 : 0));
        }
    }
    return ans;
}


-----
function maximalNetworkRank(n, roads) 
    // Your code here
}


************************************
Question ID: 1739
function checkPalindromeFormation(a, b) {
    function isPalindrome(s, left, right) {
        while (left < right) {
            if (s.charAt(left++) !== s.charAt(right--)) return false;
        }
        return true;
    }

    for (let i = 0, j = a.length - 1; i < j; ++i, --j) {
        if (a.charAt(i) !== b.charAt(j))
            return isPalindrome(a, i, j) || isPalindrome(b, i, j);
    }
    return true;
}

-----
function checkPalindromeFormation(a, b) 
    // Your code here
}

************************************
Question ID: 1740
function countSubgraphsForEachD(n, edges) {
    const tree = Array.from({ length: n + 1 }, () => []);
    for (const [u, v] of edges) {
        tree[u].push(v);
        tree[v].push(u);
    }

    function dfs(node, parent) {
        let depth = 0;
        for (const child of tree[node]) {
            if (child !== parent) depth = Math.max(depth, 1 + dfs(child, node));
        }
        return depth;
    }

    const ans = new Array(n - 1).fill(0);
    for (let i = 1; i <= n; i++) {
        const maxD = dfs(i, 0);
        if (maxD > 0) ans[maxD - 1]++;
    }
    return ans;
}

-----
function countSubgraphsForEachD(n, edges) 
    // Your code here
}

************************************
Question ID: 1742
function maxWidthOfVerticalArea(points) {
    const xs = points.map(point => point[0]).sort((a, b) => a - b);
    let max_width = 0;
    for (let i = 1; i < xs.length; i++) {
        max_width = Math.max(max_width, xs[i] - xs[i - 1]);
    }
    return max_width;
}


-----
function maxWidthOfVerticalArea(points) 
    // Your code here
}


************************************
Question ID: 1743
function countSubstringsWithOneDifference(s, t) {
    let count = 0;
    for (let i = 0; i < s.length; i++) {
        for (let j = 0; j < t.length; j++) {
            let differences = 0;
            for (let k = 0; i + k < s.length && j + k < t.length; k++) {
                if (s[i + k] !== t[j + k]) {
                    differences++;
                }
                if (differences === 2) {
                    break;
                }
                if (differences === 1) {
                    count++;
                }
            }
        }
    }
    return count;
}

-----
function countSubstringsWithOneDifference(s, t) 
    // Your code here
}

************************************
Question ID: 1744
function numWays(words, target) {
    let n = words.length, m = target.length;
    const MOD = 1e9 + 7;
    let cnt = Array(26).fill(0);
    for (let word of words) {
        for (let ch of word) {
            cnt[ch.charCodeAt(0) - 'a'.charCodeAt(0)]++;
        }
    }
    let dp = Array(m + 1).fill(0);
    dp[0] = 1;
    for (let ch of target) {
        for (let i = m - 1; i >= 0; i--) {
            dp[i + 1] += dp[i] * cnt[ch.charCodeAt(0) - 'a'.charCodeAt(0)];
            dp[i + 1] %= MOD;
        }
    }
    return dp[m];
}

-----
function numWays(words, target) 
    // Your code here
}

************************************
Question ID: 1745
function isPalindrome(s, start, end) {
    while (start < end) {
        if (s[start] !== s[end]) return false;
        start++;
        end--;
    }
    return true;
}

function checkPartitioning(s) {
    const n = s.length;
    for (let i = 0; i < n - 2; ++i) {
        if (isPalindrome(s, 0, i)) {
            for (let j = i + 1; j < n - 1; ++j) {
                if (isPalindrome(s, i + 1, j) && isPalindrome(s, j + 1, n - 1)) return true;
            }
        }
    }
    return false;
}

-----
function isPalindrome(s, start, end) 
    // Your code here
}

************************************
Question ID: 1746
function maxLengthBetweenEqualCharacters(s) {
    let maxLength = -1;
    let charIndexMap = new Map();

    for (let i = 0; i < s.length; i++) {
        if (charIndexMap.has(s[i])) {
            maxLength = Math.max(maxLength, i - charIndexMap.get(s[i]) - 1);
        } else {
            charIndexMap.set(s[i], i);
        }
    }

    return maxLength;
}

-----
function maxLengthBetweenEqualCharacters(s) 
    // Your code here
}

************************************
Question ID: 1748
function bestTeamScore(scores, ages) {
    const players = ages.map((age, index) => [age, scores[index]]);
    players.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
    
    const n = players.length;
    const dp = Array(n).fill(0);
    let bestScore = 0;
    
    for (let i = 0; i < n; i++) {
        dp[i] = players[i][1];
        for (let j = 0; j < i; j++) {
            if (players[i][1] >= players[j][1]) {
                dp[i] = Math.max(dp[i], dp[j] + players[i][1]);
            }
        }
        bestScore = Math.max(bestScore, dp[i]);
    }
    
    return bestScore;
}


-----
function bestTeamScore(scores, ages) 
    // Your code here
}


************************************
Question ID: 1749
function maxAbsoluteSum(nums) {
    let max_sum = 0, min_sum = 0, max_end = 0, min_end = 0;
    for (let num of nums) {
        max_end = Math.max(max_end + num, num);
        min_end = Math.min(min_end + num, num);
        max_sum = Math.max(max_sum, max_end);
        min_sum = Math.min(min_sum, min_end);
    }
    return Math.max(max_sum, -min_sum);
}

-----
function maxAbsoluteSum(nums) 
    // Your code here
}

************************************
Question ID: 1750
function minimumLength(s) {
    if(s.isEmpty()) return 0;
    let i = 0, j = s.length - 1;
    while(i < j){
        if(s[i] != s[j]) break;
        let remove_char = s[i];
        while(i < s.length && s[i] == remove_char) i++;
        while(j >= 0 && s[j] == remove_char) j--;
    }
    return Math.max(0, j - i + 1);
}

-----
function minimumLength(s) 
    // Your code here
}

************************************
Question ID: 1751
function slowestKey(releaseTimes, keysPressed) {
    let max_key = keysPressed[0];
    let max_duration = releaseTimes[0];

    for (let i = 1; i < releaseTimes.length; i++) {
        let duration = releaseTimes[i] - releaseTimes[i - 1];
        if (duration > max_duration || (duration === max_duration && keysPressed[i] > max_key)) {
            max_key = keysPressed[i];
            max_duration = duration;
        }
    }
    return max_key;
}


-----
function slowestKey(releaseTimes, keysPressed) 
    // Your code here
}


************************************
Question ID: 1752
function checkArithmeticSubarrays(nums, l, r) {
    const results = [];
    for(let i = 0; i < l.length; i++) {
        const subarray = nums.slice(l[i], r[i] + 1).sort((a, b) => a - b);
        let is_arithmetic = true;
        const diff = subarray[1] - subarray[0];
        for(let j = 1; j < subarray.length - 1; j++) {
            if(subarray[j + 1] - subarray[j] !== diff) {
                is_arithmetic = false;
                break;
            }
        }
        results.push(is_arithmetic);
    }
    return results;
}


-----
function checkArithmeticSubarrays(nums, l, r) 
    // Your code here
}


************************************
Question ID: 1753
function minimumEffortPath(heights) {
    const directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];
    const rows = heights.length;
    const cols = heights[0].length;
    const efforts = Array.from({ length: rows }, () => Array(cols).fill(Infinity));
    const pq = new PriorityQueue((a, b) => a[0] - b[0]);

    efforts[0][0] = 0;
    pq.offer([0, 0, 0]);

    while (!pq.isEmpty()) {
        const [effort, x, y] = pq.poll();

        if (x === rows - 1 && y === cols - 1) {
            return effort;
        }

        for (const [dx, dy] of directions) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols) {
                const newEffort = Math.max(effort, Math.abs(heights[nx][ny] - heights[x][y]));
                if (newEffort < efforts[nx][ny]) {
                    efforts[nx][ny] = newEffort;
                    pq.offer([newEffort, nx, ny]);
                }
            }
        }
    }

    return -1;
}

class PriorityQueue {
    constructor(comparator) {
        this.comparator = comparator;
        this.data = [];
    }

    offer(elem) {
        let i = this.data.length;
        this.data.push(elem);

        while (i > 0) {
            const parent = Math.floor((i - 1) / 2);
            if (this.comparator(this.data[i], this.data[parent]) >= 0) {
                break;
            }
            [this.data[i], this.data[parent]] = [this.data[parent], this.data[i]];
            i = parent;
        }
    }

    poll() {
        if (this.isEmpty()) return null;

        const result = this.data[0];
        const last = this.data.pop();

        if (!this.isEmpty()) {
            this.data[0] = last;
            let i = 0;

            while (true) {
                const left = 2 * i + 1;
                const right = 2 * i + 2;
                let smallest = i;

                if (left < this.data.length && this.comparator(this.data[left], this.data[smallest]) < 0) {
                    smallest = left;
                }

                if (right < this.data.length && this.comparator(this.data[right], this.data[smallest]) < 0) {
                    smallest = right;
                }

                if (smallest === i) break;

                [this.data[i], this.data[smallest]] = [this.data[smallest], this.data[i]];
                i = smallest;
            }
        }

        return result;
    }

    isEmpty() {
        return this.data.length === 0;
    }
}


-----
function minimumEffortPath(heights) 
    // Your code here
}


************************************
Question ID: 1754
function largestMerge(word1, word2) {
    let result = '';
    while (word1.length > 0 || word2.length > 0) {
        if (word1 > word2) {
            result += word1[0];
            word1 = word1.slice(1);
        } else {
            result += word2[0];
            word2 = word2.slice(1);
        }
    }
    return result;
}

-----
function largestMerge(word1, word2) 
    // Your code here
}

************************************
Question ID: 1755
function decrypt(code, k) {
    const n = code.length;
    const result = new Array(n).fill(0);
    if (k === 0) return result;
    
    for (let i = 0; i < n; i++) {
        let sum = 0;
        for (let j = 1; j <= Math.abs(k); j++) {
            sum += k > 0 ? code[(i + j) % n] : code[(i - j + n) % n];
        }
        result[i] = sum;
    }
    return result;
}

-----
function decrypt(code, k) 
    // Your code here
}

************************************
Question ID: 1756
function minDeletions(s) {
    let aCount = 0, deletions = 0;
    for (let c of s) {
        if (c === 'a') {
            aCount++;
        } else {
            if (aCount > 0) {
                aCount--;
            } else {
                deletions++;
            }
        }
    }
    return deletions;
}

-----
function minDeletions(s) 
    // Your code here
}

************************************
Question ID: 1758
function canDistribute(nums, quantity) {
    const counts = new Array(51).fill(0);
    for (const num of nums) {
        counts[num]++;
    }

    quantity.sort((a, b) => b - a);

    function dfs(idx) {
        if (idx === quantity.length) {
            return true;
        }
        for (let i = 1; i <= 50; ++i) {
            if (counts[i] >= quantity[idx]) {
                counts[i] -= quantity[idx];
                if (dfs(idx + 1)) {
                    return true;
                }
                counts[i] += quantity[idx];
            }
        }
        return false;
    }

    return dfs(0);
}


-----
function canDistribute(nums, quantity) 
    // Your code here
}


************************************
Question ID: 1759
function countHomogenous(s) {
    const MOD = 1000000007;
    let count = 1;
    let total = 0;
    for (let i = 1; i < s.length; ++i) {
        count = (s[i] === s[i - 1]) ? count + 1 : 1;
        total = (total + count) % MOD;
    }
    return (total + count) % MOD;
}

-----
function countHomogenous(s) 
    // Your code here
}

************************************
Question ID: 1760
function canFormArray(arr, pieces) {
    const pieceMap = new Map(pieces.map(piece => [piece[0], piece]));
    
    let i = 0;
    while (i < arr.length) {
        if (!pieceMap.has(arr[i]))
            return false;
        
        for (const num of pieceMap.get(arr[i])) {
            if (arr[i++] !== num)
                return false;
        }
    }
    
    return true;
}

-----
function canFormArray(arr, pieces) 
    // Your code here
}

************************************
Question ID: 1761
function countVowelStrings(n) {
    const dp = [1, 1, 1, 1, 1];

    for (let i = 1; i < n; i++) {
        for (let j = 3; j >= 0; j--) {
            dp[j] += dp[j + 1];
        }
    }

    return dp.reduce((a, b) => a + b, 0);
}

-----
function countVowelStrings(n) 
    // Your code here
}

************************************
Question ID: 1762
function furthestBuilding(heights, bricks, ladders) {
    const minHeap = [];
    for (let i = 0; i < heights.length - 1; ++i) {
        const diff = heights[i + 1] - heights[i];
        if (diff > 0) {
            minHeap.push(diff);
            minHeap.sort((a, b) => a - b);
            if (minHeap.length > ladders) {
                bricks -= minHeap.shift();
                if (bricks < 0) {
                    return i;
                }
            }
        }
    }
    return heights.length - 1;
}


-----
function furthestBuilding(heights, bricks, ladders) 
    // Your code here
}


************************************
Question ID: 1763
function longestNiceSubstring(s) {
    let n = s.length;
    let result = "";
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; ++j) {
            let isNice = true;
            for (let ch = 'A'.charCodeAt(0); ch <= 'Z'.charCodeAt(0); ++ch) {
                let upper = false, lower = false;
                for (let k = i; k <= j; ++k) {
                    if (s.charCodeAt(k) == ch) upper = true;
                    if (s.charCodeAt(k) == (ch + 32)) lower = true;
                }
                if ((upper && !lower) || (!upper && lower)) {
                    isNice = false;
                    break;
                }
            }
            if (isNice && j - i + 1 > result.length) {
                result = s.substring(i, j + 1);
            }
        }
    }
    return result;
}

-----
function longestNiceSubstring(s) 
    // Your code here
}

************************************
Question ID: 1764
function maxKRepeating(sequence, word) {
    let maxK = 0;
    const seqLength = sequence.length;
    const wordLength = word.length;
    for (let i = 0; i <= seqLength - wordLength; i++) {
        let k = 0;
        while (sequence.substr(i, wordLength * (k + 1)) === word.repeat(k + 1)) {
            k++;
        }
        if (k > maxK) {
            maxK = k;
        }
    }
    return maxK;
}

-----
function maxKRepeating(sequence, word) 
    // Your code here
}

************************************
Question ID: 1766
function minimumMountainRemovals(nums) {
    const n = nums.length;
    const left = new Array(n), right = new Array(n);
    for (let i = 0; i < n; ++i) {
        left[i] = lowerBound(left.slice(0, i), nums[i]);
        right[n - 1 - i] = lowerBound(right.slice(n - 1 - i, n).reverse(), nums[n - 1 - i]);
    }
    let result = n;
    for (let i = 1; i < n - 1; ++i)
        result = Math.min(result, n - (left[i] + 1) - (right[i] + 1));

    return result;
}

-----
function minimumMountainRemovals(nums) 
    // Your code here
}

************************************
Question ID: 1768
function mergeAlternately(word1, word2) {
    let result = "";
    let i = 0, j = 0;
    while (i < word1.length && j < word2.length) {
        result += word1[i++];
        result += word2[j++];
    }
    while (i < word1.length) result += word1[i++];
    while (j < word2.length) result += word2[j++];
    return result;
}

-----
function mergeAlternately(word1, word2) 
    // Your code here
}

************************************
Question ID: 1769
function maximumGenerated(n) {
    if (n === 0) {
        return 0;
    }
    let nums = new Array(n + 1).fill(0);
    nums[1] = 1;
    let maxVal = 1;
    for (let i = 2; i <= n; i++) {
        nums[i] = i % 2 === 0 ? nums[i / 2] : nums[Math.floor(i / 2)] + nums[Math.floor(i / 2) + 1];
        maxVal = Math.max(maxVal, nums[i]);
    }
    return maxVal;
}

-----
function maximumGenerated(n) 
    // Your code here
}

************************************
Question ID: 1770
function minDeletions(s) {
    const freq = {};
    const used = new Set();
    let deletions = 0;

    for (const c of s) {
        freq[c] = (freq[c] || 0) + 1;
    }

    for (const count in freq) {
        let num = freq[count];
        while (used.has(num) && num > 0) {
            deletions++;
            num--;
        }
        used.add(num);
    }

    return deletions;
}

-----
function minDeletions(s) 
    // Your code here
}

************************************
Question ID: 1771
function maxProfit(inventory, orders) {
    const mod = 1e9 + 7;
    inventory.sort((a, b) => b - a).push(0);
    let n = inventory.length, ans = 0n, count = 1n;
    for (let i = 0; i < n - 1; ++i, ++count) {
        const diff = BigInt(inventory[i] - inventory[i + 1]);
        if (count * diff < orders) {
            orders -= count * diff;
            ans = (ans + (((BigInt(inventory[i]) + BigInt(inventory[i + 1]) + 1n) * diff) / 2n) % mod * count) % mod;
        } else {
            const q = BigInt(orders / count);
            const r = BigInt(orders % count);
            ans = (ans + (((BigInt(inventory[i]) + BigInt(inventory[i]) - q + 1n) * q) / 2n) % mod * count) % mod;
            ans = (ans + r * (BigInt(inventory[i]) - q)) % mod;
            break;
        }
    }
    return parseInt(ans);
}

-----
function maxProfit(inventory, orders) 
    // Your code here
}

************************************
Question ID: 1772
const MOD = 1e9 + 7

function createSortedArray(instructions) {
    let nums = new Set();
    let cost = 0;

    for (let i of instructions) {
        nums.add(i);
        let sortedNums = Array.from(nums).sort((a, b) => a - b);
        let less_than = sortedNums.filter(x => x < i).length;
        let greater_than = sortedNums.filter(x => x > i).length;
        cost = (cost + Math.min(less_than, greater_than)) % MOD;
        nums = new Set(sortedNums);
    }

    return cost;
}

-----
const MOD = 1e9 + 7

function createSortedArray(instructions) 
    // Your code here
}

************************************
Question ID: 1773
function countMatches(items, ruleKey, ruleValue) {
    let count = 0;
    let index = ruleKey === "type" ? 0 : (ruleKey === "color" ? 1 : 2);
    for (let item of items) {
        if (item[index] === ruleValue)
            count++;
    }
    return count;
}

-----
function countMatches(items, ruleKey, ruleValue) 
    // Your code here
}

************************************
Question ID: 1774
function closestCost(baseCosts, toppingCosts, target) {
    let closest = Infinity;

    function dfs(index, cost) {
        if (index === toppingCosts.length || cost >= target + closest) {
            closest = Math.min(closest, Math.abs(cost - target));
            return;
        }
        
        dfs(index + 1, cost);
        dfs(index + 1, cost + toppingCosts[index]);
        dfs(index + 1, cost + 2 * toppingCosts[index]);
    }

    for (const base of baseCosts) {
        dfs(0, base);
    }

    return target - (closest > target ? -closest : closest);
}

-----
function closestCost(baseCosts, toppingCosts, target) 
    // Your code here
}

************************************
Question ID: 1776
function minOperations(nums, x) {
    const total = nums.reduce((accumulator, currentValue) => accumulator + currentValue);
    const target = total - x;
    if (target < 0) return -1;

    let maxLength = -1;
    let left = 0, sum = 0;

    for (let right = 0; right < nums.length; ++right) {
        sum += nums[right];

        while (sum > target) {
            sum -= nums[left++];
        }

        if (sum == target) {
            maxLength = Math.max(maxLength, right - left + 1);
        }
    }

    return maxLength == -1 ? -1 : nums.length - maxLength;
}


-----
function minOperations(nums, x) 
    // Your code here
}


************************************
Question ID: 1778
function getMaxGridHappiness(m, n, introvertsCount, extrovertsCount) {
    const dp = Array.from({ length: 6 }, () => Array.from({ length: 6 }, () => Array.from({ length: 37 }, () => Array(64).fill(0))));
    const seen = Array.from({ length: 6 }, () => Array.from({ length: 6 }, () => Array.from({ length: 37 }, () => Array(64).fill(false))));

    function maxHappy(y, mask) {
        if (y == n)
            return 0;

        if (seen[m][n][introvertsCount][mask])
            return dp[m][n][introvertsCount][mask];
        seen[m][n][introvertsCount][mask] = true;

        let ans = 0;
        for (let x = 0; x <= m; ++x) {
            let happiness = 0;
            if (mask >> x & 1) {
                happiness -= 30;
                if (x > 0 && mask & 1)
                    happiness -= 30;
                else
                    happiness += 20;
            }
            ans = Math.max(ans, happiness + maxHappy(y + 1, (mask | (1 << x)) >> 1));
        }

        return dp[m][n][introvertsCount][mask] = ans;
    }

    return maxHappy(0, 0);
}


-----
function getMaxGridHappiness(m, n, introvertsCount, extrovertsCount) 
    // Your code here
}


************************************
Question ID: 1779
function nearestValidPoint(x, y, points) {
    let min_distance = Number.MAX_VALUE, index = -1;
    for (let i = 0; i < points.length; i++) {
        if (x === points[i][0] || y === points[i][1]) {
            const distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
            if (distance < min_distance) {
                min_distance = distance;
                index = i;
            }
        }
    }
    return index;
}

-----
function nearestValidPoint(x, y, points) 
    // Your code here
}

************************************
Question ID: 1780
function checkPowersOfThree(n) {
    while (n > 0) {
        if (n % 3 === 2) return false;
        n = Math.floor(n / 3);
    }
    return true;
}

-----
function checkPowersOfThree(n) 
    // Your code here
}

************************************
Question ID: 1781
function arrayStringsAreEqual(word1, word2) {
    return word1.join("") === word2.join("");
}

-----
function arrayStringsAreEqual(word1, word2) 
    // Your code here
}

************************************
Question ID: 1782
function getSmallestString(n, k) {
    const result = Array(n).fill('a');
    k -= n;
    for (let i = n - 1; i >= 0; --i) {
        const value = Math.min(k, 25);
        result[i] = String.fromCharCode(result[i].charCodeAt(0) + value);
        k -= value;
        if (k === 0) break;
    }
    return result.join('');
}

-----
function getSmallestString(n, k) 
    // Your code here
}

************************************
Question ID: 1784
function minimumEnergy(tasks) {
    tasks.sort((a, b) => (b[1] - b[0]) - (a[1] - a[0]));

    let energy = 0;
    for (let task of tasks) {
        energy = Math.max(energy + task[0], task[1]);
    }
    return energy;
}

-----
function minimumEnergy(tasks) 
    // Your code here
}

************************************
Question ID: 1785
function minElements(nums, limit, goal) {
    let sum = nums.reduce((a, b) => a + b, 0);
    let diff = Math.abs(goal - sum);
    
    return Math.ceil(diff / limit);
}


-----
function minElements(nums, limit, goal) 
    // Your code here
}


************************************
Question ID: 1786
function countConsistentStrings(allowed, words) {
    const allowedSet = new Set(allowed);
    let count = 0;
    for (const word of words) {
        let isValid = true;
        for (const c of word) {
            if (!allowedSet.has(c)) {
                isValid = false;
                break;
            }
        }
        if (isValid) {
            count++;
        }
    }
    return count;
}

-----
function countConsistentStrings(allowed, words) 
    // Your code here
}

************************************
Question ID: 1787
function calculateSummationOfAbsoluteDifferences(nums) {
    let n = nums.length;
    let result = new Array(n).fill(0);

    for(let i = 0; i < n; i++) {
        for(let j = 0; j < n; j++) {
            if(i !== j) {
                result[i] += Math.abs(nums[i] - nums[j]);
            }
        }
    }

    return result;
}

-----
function calculateSummationOfAbsoluteDifferences(nums) 
    // Your code here
}

************************************
Question ID: 1788
function stoneGameVI(aliceValues, bobValues) {
    const n = aliceValues.length;
    const sums = aliceValues.map((v, i) => [v + bobValues[i], i]).sort((a, b) => b[0] - a[0]);

    let aliceScore = 0, bobScore = 0;
    for (let i = 0; i < n; ++i) {
        if (i % 2 === 0) aliceScore += aliceValues[sums[i][1]];
        else bobScore += bobValues[sums[i][1]];
    }

    return aliceScore === bobScore ? 0 : aliceScore > bobScore ? 1 : -1;
}

-----
function stoneGameVI(aliceValues, bobValues) 
    // Your code here
}

************************************
Question ID: 1790
function areAlmostEqual(s1, s2) {
    if(s1 === s2) return true;
    let diff = [];
    for(let i = 0; i < s1.length; i++) {
        if(s1.charAt(i) !== s2.charAt(i)) {
            diff.push(i);
        }
    }
    return diff.length === 2 && s1.charAt(diff[0]) === s2.charAt(diff[1]) && s1.charAt(diff[1]) === s2.charAt(diff[0]);
}

-----
function areAlmostEqual(s1, s2) 
    // Your code here
}

************************************
Question ID: 1791
function maximumWealth(accounts) {
    return accounts.reduce((maxWealth, customer) =>
        Math.max(maxWealth, customer.reduce((wealth, account) => wealth + account, 0)), 0);
}


-----
function maximumWealth(accounts) 
    // Your code here
}


************************************
Question ID: 1792
function mostCompetitive(nums, k) {
    const stack = [];
    const n = nums.length;

    for (let i = 0; i < n; i++) {
        while (stack.length > 0 && nums[i] < stack[stack.length - 1] && stack.length + n - i > k) {
            stack.pop();
        }
        if (stack.length < k) {
            stack.push(nums[i]);
        }
    }

    return stack;
}

-----
function mostCompetitive(nums, k) 
    // Your code here
}

************************************
Question ID: 1793
function minMoves(nums, limit) {
    const n = nums.length;
    const delta = new Array(2 * limit + 2).fill(0);

    for (let i = 0; i < n / 2; i++) {
        const lo = Math.min(nums[i], nums[n - 1 - i]) + 1;
        const hi = Math.max(nums[i], nums[n - 1 - i]) + limit;
        delta[lo]--;
        delta[nums[i] + nums[n - 1 - i]]--;
        delta[hi + 1]++;
    }
    let moves = n, current = n;
    for (let i = 2; i <= 2 * limit; i++) {
        current += delta[i];
        moves = Math.min(moves, current);
    }
    return moves;
}


-----
function minMoves(nums, limit) 
    // Your code here
}


************************************
Question ID: 1794
function minimumDeviation(nums) {
    const pq = new MaxPriorityQueue();
    let min_val = Infinity;

    for (const num of nums) {
        if (num % 2 === 0) {
            pq.enqueue(num);
        } else {
            pq.enqueue(num * 2);
        }
        min_val = Math.min(min_val, num);
    }

    let result = Infinity;
    while (true) {
        const top = pq.dequeue().element;
        result = Math.min(result, top - min_val);

        if (top % 2 === 1) break;
        pq.enqueue(Math.floor(top / 2));
        min_val = Math.min(min_val, Math.floor(top / 2));
    }
    return result;
}


-----
function minimumDeviation(nums) 
    // Your code here
}


************************************
Question ID: 1796
function secondHighest(s) {
    let largest = -1, second_largest = -1;
    for (let c of s) {
        if (!isNaN(c)) {
            let d = parseInt(c);
            if (d > largest) {
                second_largest = largest;
                largest = d;
            } else if (d < largest && d > second_largest) {
                second_largest = d;
            }
        }
    }
    return second_largest;
}

-----
function secondHighest(s) 
    // Your code here
}

************************************
Question ID: 1797
function interpret(command) {
    let result = "";
    for (let i = 0; i < command.length; ++i) {
        if (command[i] === 'G') result += 'G';
        else if (command[i] === '(' && command[i+1] === ')') {
            result += 'o';
            i++;
        } else {
            result += "al";
            i+=3;
        }
    }
    return result;
}


-----
function interpret(command) 
    // Your code here
}


************************************
Question ID: 1798
function maxOperations(nums, k) {
    let count = {};
    let operations = 0;

    for (let num of nums) {
        if (count[k - num] > 0) {
            count[k - num]--;
            operations++;
        }
        else {
            count[num] = (count[num] || 0) + 1;
        }
    }

    return operations;
}


-----
function maxOperations(nums, k) 
    // Your code here
}


************************************
Question ID: 1799
function minimumIncompatibility(nums, k) {
    let n = nums.length;
    if (n % k !== 0) return -1;
    
    nums.sort((a, b) => a - b);
    let diffs = [];
    for (let i = 0; i < k; ++i) {
        diffs.push(nums[(i + 1) * (n / k) - 1] - nums[i * (n / k)]);
    }
    
    return diffs.reduce((acc, curr) => acc + curr, 0);
}

-----
function minimumIncompatibility(nums, k) 
    // Your code here
}

************************************
Question ID: 1800
function concatenatedBinary(n) {
    let result = 0;
    const mod = 1000000007;
    for (let i = 1; i <= n; ++i) {
        const length = Math.floor(Math.log2(i)) + 1;
        result = ((result << length) % mod + i) % mod;
    }
    return result;
}


-----
function concatenatedBinary(n) 
    // Your code here
}


************************************
Question ID: 1801
function getNumberOfBacklogOrders(orders) {
  const buyOrders = new PriorityQueue([], (a, b) => b[0] - a[0]);
  const sellOrders = new PriorityQueue([], (a, b) => a[0] - b[0]);
  let numOrders = 0, mod = 1e9 + 7;

  for (const [price, amount, orderType] of orders) {
    let curAmount = amount;

    if (orderType === 0) { // buy order
      while (curAmount > 0 && !sellOrders.isEmpty() && sellOrders.peek()[0] <= price) {
        let x = Math.min(curAmount, sellOrders.peek()[1]);
        curAmount -= x;
        sellOrders.peek()[1] -= x;
        if (sellOrders.peek()[1] === 0) {
          sellOrders.pop();
        }
      }
      if (curAmount > 0) {
          buyOrders.push([price, curAmount]);
      }
    } else { // sell order
      while (curAmount > 0 && !buyOrders.isEmpty() && buyOrders.peek()[0] >= price) {
        let x = Math.min(curAmount, buyOrders.peek()[1]);
        curAmount -= x;
        buyOrders.peek()[1] -= x;
        if (buyOrders.peek()[1] === 0) {
          buyOrders.pop();
        }
      }
      if (curAmount > 0) {
          sellOrders.push([price, curAmount]);
      }
    }
  }

  while (!buyOrders.isEmpty()) {
    numOrders = (numOrders + buyOrders.pop()[1]) % mod;
  }

  while (!sellOrders.isEmpty()) {
    numOrders = (numOrders + sellOrders.pop()[1]) % mod;
  }

  return numOrders;
}

// Helper class for JavaScript PriorityQueue
class PriorityQueue {
  constructor(items = [], compareFn = (a, b) => a - b) {
    this._compareFn = compareFn;
    this._heap = items;
    this.heapify();
  }

  parent(i) { return Math.floor((i - 1) / 2); }
  left(i) { return 2 * i + 1; }
  right(i) { return 2 * i + 2; }

  isEmpty() {
    return this._heap.length === 0;
  }

  peek() {
    return this._heap[0];
  }

  size() {
    return this._heap.length;
  }

  push(value) {
    this._heap.push(value);
    this._siftUp(this._heap.length - 1);
  }

  pop() {
    const removed = this._heap[0];
    const last = this._heap.pop();
    if (!this.isEmpty()) {
      this._heap[0] = last;
      this._siftDown(0);
    }
    return removed;
  }

  heapify() {
    for (let i = Math.floor((this._heap.length - 1) / 2); i >= 0; i--) {
      this._siftDown(i);
    }
  }

  _greater(i, j) {
    return this._compareFn(this._heap[i], this._heap[j]) > 0;
  }

  _swap(i, j) {
    [this._heap[i], this._heap[j]] = [this._heap[j], this._heap[i]];
  }

  _siftUp(i) {
    while (i > 0 && this._greater(i, this.parent(i))) {
      this._swap(i, this.parent(i));
      i = this.parent(i);
    }
  }

  _siftDown(i) {
    let maxIndex = i;
    const l = this.left(i);
    const r = this.right(i);

    if (l < this._heap.length && this._greater(l, maxIndex)) {
      maxIndex = l;
    }
    if (r < this._heap.length && this._greater(r, maxIndex)) {
      maxIndex = r;
    }
    if (i !== maxIndex) {
      this._swap(i, maxIndex);
      this._siftDown(maxIndex);
    }
  }
}

-----
function getNumberOfBacklogOrders(orders) 
    // Your code here
}

************************************
Question ID: 1802
function countStudents(students, sandwiches) {
    let queue = [...students];
    let index = 0, attempts = 0;

    while (queue.length) {
        let student = queue[0];
        if (student === sandwiches[index]) {
            queue.shift();
            index++;
            attempts = 0;
        } else {
            queue.push(queue.shift());
            attempts++;
        }
        if (attempts === queue.length) break;
    }

    return queue.length;
}

-----
function countStudents(students, sandwiches) 
    // Your code here
}

************************************
Question ID: 1803
function averageWaitingTime(customers) {
    let waitTime = 0;
    let currTime = 0;
    
    for (const customer of customers) {
        currTime = Math.max(currTime, customer[0]) + customer[1];
        waitTime += currTime - customer[0];
    }
    
    return waitTime / customers.length;
}


-----
function averageWaitingTime(customers) 
    // Your code here
}


************************************
Question ID: 1805
function minMoves(nums, k) {
    const n = nums.length;
    const ones = [];
    
    for(let i = 0; i < n; ++i){
        if(nums[i] === 1){
            ones.push(i - ones.length);
        }
    }

    let moves = 0;
    for(let i = 0; i < k; ++i){
        moves += (ones[i] - ones[k / 2]);
    }

    let min_moves = moves;
    for(let i = k; i < ones.length; ++i){
        moves += ones[i] - ones[i - k] - k;
        min_moves = Math.min(min_moves, moves);
    }

    return min_moves;
}


-----
function minMoves(nums, k) 
    // Your code here
}


************************************
Question ID: 1806
function numberOfMatches(n) {
    return n - 1;
}


-----
function numberOfMatches(n) 
    // Your code here
}


************************************
Question ID: 1807
function minPartitions(n) {
    let max_digit = 0;
    for (const c of n) {
        max_digit = Math.max(max_digit, parseInt(c));
        if (max_digit === 9) break;
    }
    return max_digit;
}

-----
function minPartitions(n) 
    // Your code here
}

************************************
Question ID: 1808
function stoneGame(stones) {
    const n = stones.length;
    const dp = Array.from({length:n}, () => Array(n).fill(0));
    
    for (let i = n - 1; i >= 0; i--) {
        for (let j = i + 1; j < n; j++) {
            dp[i][j] = Math.max(stones[j] - dp[i][j - 1], stones[i] - dp[i + 1][j]);
        }
    }
    
    return dp[0][n - 1];
}

-----
function stoneGame(stones) 
    // Your code here
}

************************************
Question ID: 1812
function reformatNumber(number) {
    const cleanedNumber = number.replace(/\D/g, '');

    const blocks = [];
    let n = cleanedNumber.length;
    for (let i = 0; i < n;) {
        if (n - i === 2 || n - i === 4) {
            blocks.push(cleanedNumber.substr(i, 2));
            i += 2;
        } else {
            blocks.push(cleanedNumber.substr(i, 3));
            i += 3;
        }
    }

    return blocks.join('-');
}

-----
function reformatNumber(number) 
    // Your code here
}

************************************
Question ID: 1813
function maximumUniqueSubarray(nums) {
    let maxSum = 0, currentSum = 0, left = 0;
    const elements = new Set();
    
    for (let right = 0; right < nums.length; right++) {
        while (elements.has(nums[right])) {
            elements.delete(nums[left]);
            currentSum -= nums[left++];
        }
        
        elements.add(nums[right]);
        currentSum += nums[right];
        maxSum = Math.max(maxSum, currentSum);
    }
    
    return maxSum;
}


-----
function maximumUniqueSubarray(nums) 
    // Your code here
}


************************************
Question ID: 1814
function maxResult(nums, k) {
    const n = nums.length;
    const dq = [];
    const dp = new Array(n).fill(0);
    
    dp[0] = nums[0];
    dq.push(0);
    
    for (let i = 1; i < n; i++) {
        while (dq.length && dq[0] < i - k) {
            dq.shift();
        }
        
        dp[i] = nums[i] + dp[dq[0]];
        
        while (dq.length && dp[i] >= dp[dq[dq.length - 1]]) {
            dq.pop();
        }
        
        dq.push(i);
    }
    
    return dp[n - 1];
}

-----
function maxResult(nums, k) 
    // Your code here
}

************************************
Question ID: 1815
function distanceLimitedPathsExist(n, edgeList, queries) {
    edgeList.sort((a, b) => a[2] - b[2]);
    queries = queries.map((query, idx) => [...query, idx]).sort((a, b) => a[2] - b[2]);

    function find(x, parent) {
        if (x !== parent[x]) {
            parent[x] = find(parent[x], parent);
        }
        return parent[x];
    }

    const parent = Array.from({ length: n }, (_, idx) => idx);
    const res = new Array(queries.length).fill(false);
    let idx = 0;

    for (const query of queries) {
        const [p, q, limit, queryId] = query;
        while (idx < edgeList.length && edgeList[idx][2] < limit) {
            const [u, v] = edgeList[idx];
            const [ru, rv] = [find(u, parent), find(v, parent)];
            if (ru !== rv) {
                parent[ru] = rv;
            }
            idx++;
        }
        res[queryId] = find(p, parent) === find(q, parent);
    }

    return res;
}

-----
function distanceLimitedPathsExist(n, edgeList, queries) 
    // Your code here
}

************************************
Question ID: 1816
function truncateSentence(s, k) {
    let words = s.split(" ");
    return words.slice(0, k).join(" ");
}


-----
function truncateSentence(s, k) 
    // Your code here
}


************************************
Question ID: 1817
function totalMoney(n) {
    let weeks = Math.floor(n / 7);
    let days_remaining = n % 7;
    return 28 * weeks + 7 * weeks * (weeks - 1) / 2 + (weeks + 1) * days_remaining + days_remaining * (days_remaining - 1) / 2;
}


-----
function totalMoney(n) 
    // Your code here
}


************************************
Question ID: 1818
function maxPoints(s, x, y) {
    let points = 0;
    for (let i = 1; i < s.length; ++i) {
        if (s[i] === s[i - 1]) {
            points += Math.max(x, y);
            s = s.substring(0, i) + '#' + s.substring(i + 1);
        }
    }
    return points;
}

-----
function maxPoints(s, x, y) 
    // Your code here
}

************************************
Question ID: 1819
function largestLexSequence(n) {
    let res = new Array(n);
    for (let i = 0; i < n; ++i) {
        res[i] = i % 2;
    }
    return res;
}

-----
function largestLexSequence(n) 
    // Your code here
}

************************************
Question ID: 1820
function countTrees(pairs) {
    const nodes = pairs.length + 1;
    const in_degrees = new Array(nodes).fill(0);
    
    for (const [x, y] of pairs) {
        in_degrees[y]++;
    }
    
    let res = 1;
    for (let i = 1; i < nodes; i++) {
        res *= in_degrees[i];
    }
    
    return res;
}

-----
function countTrees(pairs) 
    // Your code here
}

************************************
Question ID: 1822
function signFunc(x) {
    if(x > 0) return 1;
    if(x < 0) return -1;
    return 0;
}

function arraySign(nums) {
    let product = 1;
    for(let i = 0; i < nums.length; i++) {
        product *= signFunc(nums[i]);
    }
    return product;
}

-----
function signFunc(x) 
    // Your code here
}

************************************
Question ID: 1823
function halvesAreAlike(s) {
    let halfLength = s.length / 2;
    let countA = 0, countB = 0;

    for (let i = 0; i < halfLength; i++) {
        if ("aeiouAEIOU".includes(s.charAt(i))) countA++;
    }

    for (let i = halfLength; i < s.length; i++) {
        if ("aeiouAEIOU".includes(s.charAt(i))) countB++;
    }

    return countA === countB;
}

-----
function halvesAreAlike(s) 
    // Your code here
}

************************************
Question ID: 1824
function eatenApples(apples, days) {
    const n = apples.length;
    const pq = new PriorityQueue();
    let ans = 0;

    for (let i = 0; i < n || !pq.isEmpty(); ++i) {
        if (i < n && apples[i] > 0) {
            pq.enqueue([i + days[i], apples[i]]);
        }

        while (!pq.isEmpty() && pq.peek()[0] <= i) {
            pq.dequeue();
        }

        if (!pq.isEmpty()) {
            ans++;
            let curr_apple = pq.dequeue();
            if (curr_apple[1] > 1) {
                curr_apple[1]--;
                pq.enqueue(curr_apple);
            }
        }
    }

    return ans;
}

class PriorityQueue {
    constructor(comparator = (a, b) => a[0] - b[0]) {
        this._comparator = comparator;
        this._queue = [];
    }

    // Additional methods and details omitted ...
}


-----
function eatenApples(apples, days) 
    // Your code here
}


************************************
Question ID: 1825
function minimumWorkingTime(jobs, k) {
    let max_job = Math.max(...jobs);
    let sum_jobs = jobs.reduce((a, b) => a + b, 0);
    
    let left = max_job, right = sum_jobs;
    while (left < right) {
        let mid = left + Math.floor((right - left) / 2);
        let count = 1, current_sum = 0;

        for (let job of jobs) {
            if (current_sum + job > mid) {
                count++;
                current_sum = 0;
            }
            current_sum += job;
        }

        if (count <= k) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}


-----
function minimumWorkingTime(jobs, k) 
    // Your code here
}


************************************
Question ID: 1826
function maximizeXor(nums, queries) {
    nums.sort((a, b) => a - b);
    const newQueries = queries.map((q, idx) => [q[0], q[1], idx]).sort((a, b) => a[1] - b[1]);

    const trie = new Array(200010).fill(null).map(() => new Array(2).fill(0));
    const sum = new Array(200010).fill(0);
    sum[0] = 1;

    let idx = 0, cnt = 0;
    const ans = new Array(queries.length).fill(0);

    for (const q of newQueries) {
        const [x, m, k] = q;
        let p = 0;
        while (idx < nums.length && nums[idx] <= m) {
            let cur = 0, t = nums[idx++];
            for (let i = 31; i >= 0; --i) {
                const bit = ((t >> i) & 1);
                if (!trie[cur][bit]) {
                    trie[cur][bit] = ++cnt;
                }
                cur = trie[cur][bit];
            }
            sum[cur]++;
        }
        if (!cnt) { 
            ans[k] = -1; 
            continue; 
        }
        let cur = 0, ans2 = 0;
        for (let i = 31; i >= 0; --i) {
            const bit = ((x >> i) & 1);
            if (trie[cur][bit ^ 1]) {
                cur = trie[cur][bit ^ 1];
                ans2 |= (1 << i);
            } else {
                cur = trie[cur][bit];
            }
        }
        ans[k] = ans2;
    }

    return ans;
}


-----
function maximizeXor(nums, queries) 
    // Your code here
}


************************************
Question ID: 1827
function minOperations(nums) {
    let operations = 0;
    for (let i = 1; i < nums.length; i++) {
        if (nums[i] <= nums[i - 1]) {
            operations += (nums[i - 1] - nums[i]) + 1;
            nums[i] = nums[i - 1] + 1;
        }
    }
    return operations;
}

-----
function minOperations(nums) 
    // Your code here
}

************************************
Question ID: 1828
function countPoints(points, queries) {
    const answer = [];
    for (const query of queries) {
        let inside = 0;
        for (const point of points) {
            const dx = point[0] - query[0];
            const dy = point[1] - query[1];
            if (dx * dx + dy * dy <= query[2] * query[2]) {
                inside++;
            }
        }
        answer.push(inside);
    }
    return answer;
}


-----
function countPoints(points, queries) 
    // Your code here
}


************************************
Question ID: 1829
function maximumUnits(boxTypes, truckSize) {
    boxTypes.sort((a, b) => b[1] - a[1]);

    let totalUnits = 0;
    for (const box of boxTypes) {
        const boxCount = Math.min(truckSize, box[0]);
        totalUnits += boxCount * box[1];
        truckSize -= boxCount;
        if (truckSize === 0) {
            break;
        }
    }

    return totalUnits;
}

-----
function maximumUnits(boxTypes, truckSize) 
    // Your code here
}

************************************
Question ID: 1830
function countPairs(deliciousness) {
    const MOD = 1e9 + 7;
    const hashMap = new Map();
    let maxVal = 0;
    for (const val of deliciousness) {
        maxVal = Math.max(maxVal, val);
    }
    const maxSum = maxVal * 2;

    let count = 0;
    for (const val of deliciousness) {
        for (let sum = 1; sum <= maxSum; sum <<= 1) {
            count = (count + (hashMap.get(sum - val) || 0)) % MOD;
        }
        hashMap.set(val, (hashMap.get(val) || 0) + 1);
    }

    return count;
}

-----
function countPairs(deliciousness) 
    // Your code here
}

************************************
Question ID: 1832
function minOperations(target, arr) {
    const indexMap = new Map();
    
    for (let i = 0; i < target.length; ++i) {
        indexMap.set(target[i], i);
    }

    const lis = [];
    for (const num of arr) {
        if (indexMap.has(num)) {
            const pos = lowerBound(lis, indexMap.get(num));
            if (pos === lis.length) {
                lis.push(indexMap.get(num));
            } else {
                lis[pos] = indexMap.get(num);
            }
        }
    }

    return target.length - lis.length;
}

function lowerBound(arr, target) {
    let low = 0;
    let high = arr.length;

    while (low < high) {
        const mid = Math.floor((low + high) / 2);
        if (arr[mid] < target) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }

    return low;
}

-----
function minOperations(target, arr) 
    // Your code here
}

************************************
Question ID: 1833
function largestAltitude(gain) {
    let max_altitude = 0, current_altitude = 0;
    for (let i = 0; i < gain.length; i++) {
        current_altitude += gain[i];
        max_altitude = Math.max(max_altitude, current_altitude);
    }
    return max_altitude;
}

-----
function largestAltitude(gain) 
    // Your code here
}

************************************
Question ID: 1834
function minimumTeachings(n, languages, friendships) {
    const languageUsers = {};
    const unconnectedUsers = new Set();

    friendsLoop: for (const [u, v] of friendships) {
        canCommunicate = false;

        for (const lang of languages[u - 1]) {
            if (languages[v - 1].includes(lang)) {
                canCommunicate = true;
                continue friendsLoop;
            }
        }

        if (!canCommunicate) {
            unconnectedUsers.add(u);
            unconnectedUsers.add(v);
        }
    }

    let res = unconnectedUsers.size;
    for (let i = 1; i <= n; ++i) {
        let cnt = 0;
        for (const user of unconnectedUsers) {
            if (!languages[user - 1].includes(i)) {
                cnt++;
            }
        }
        res = Math.min(res, cnt);
    }

    return res;
}

-----
function minimumTeachings(n, languages, friendships) 
    // Your code here
}

************************************
Question ID: 1835
function decode(encoded) {
    const n = encoded.length + 1;
    let total_xor = 0;
    for (let i = 1; i <= n; ++i) {
        total_xor ^= i;
    }
    let encoded_xor = 0;
    for (let i = 1; i < n - 1; i += 2) {
        encoded_xor ^= encoded[i];
    }
    const perm = [total_xor ^ encoded_xor];
    for (let i = 1; i < n; ++i) {
        perm.push(perm[i - 1] ^ encoded[i - 1]);
    }
    return perm;
}


-----
function decode(encoded) 
    // Your code here
}


************************************
Question ID: 1836
const MOD = 1e9 + 7;

function productWays(queries) {
    const res = [];
    for (const [n, k] of queries) {
        const pf = [];
        const pm = {};

        for (let i = 2; i * i <= k; i++) {
            let cnt = 0;
            let kMutable = k;
            while (kMutable % i === 0) {
                cnt++;
                kMutable /= i;
            }
            if (cnt !== 0) {
                pf.push(cnt);
                if (!pm[cnt]) pm[cnt] = 0;
                pm[cnt]++;
            }
        }

        if (k > 1) {
            if (!pm[k]) pm[k] = 0;
            pm[k]++;
            pf.push(1);
        }

        let ans = 1;
        for (const p of pf) {
            ans = (ans * (p * (n - 1) + 1)) % MOD;
        }

        res.push(ans);
    }
    return res;
}

-----
const MOD = 1e9 + 7;

function productWays(queries) 
    // Your code here
}

************************************
Question ID: 1837
function sumBase(n, k) {
    let sum = 0;
    while (n > 0) {
        sum += n % k;
        n = Math.floor(n / k);
    }
    return sum;
}


-----
function sumBase(n, k) 
    // Your code here
}


************************************
Question ID: 1838
function maxFrequency(nums, k) {
    nums.sort((a, b) => a - b);
    let n = nums.length, i = 0;
    let sum = 0;
    let max_freq = 0;

    for (let j = 0; j < n; j++) {
        sum += nums[j];
        while (sum + k < nums[j] * (j - i + 1)) {
            sum -= nums[i++];
        }
        max_freq = Math.max(max_freq, j - i + 1);
    }

    return max_freq;
}

-----
function maxFrequency(nums, k) 
    // Your code here
}

************************************
Question ID: 1839
function decode(encoded, first) {
    const arr = [first];
    for (let i = 0; i < encoded.length; i++) {
        arr.push(arr[i] ^ encoded[i]);
    }
    return arr;
}


-----
function decode(encoded, first) 
    // Your code here
}


************************************
Question ID: 1840
function minimumHammingDistance(source, target, allowedSwaps) {
    const n = source.length;
    const graph = new Map();

    for (const [a, b] of allowedSwaps) {
        if (!graph.has(a)) graph.set(a, []);
        if (!graph.has(b)) graph.set(b, []);
        graph.get(a).push(b);
        graph.get(b).push(a);
    }

    function dfs(node, visited, group) {
        if (visited[node]) return;
        visited[node] = 1;
        group.push(node);
        for (const neighbor of (graph.get(node) || [])) dfs(neighbor, visited, group);
    }

    let res = 0;
    const visited = new Array(n).fill(0);
    for (let i = 0; i < n; ++i) {
        if (!visited[i]) {
            const group = [];
            dfs(i, visited, group);
            const count = new Map();

            for (const node of group) count.set(source[node], (count.get(source[node]) || 0) + 1);
            for (const node of group) {
                if (count.get(target[node]) > 0) {
                    res++;
                    count.set(target[node], count.get(target[node]) - 1);
                }
            }
        }
    }

    return n - res;
}


-----
function minimumHammingDistance(source, target, allowedSwaps) 
    // Your code here
}


************************************
Question ID: 1842
function nextPermutation(array) {
    let n = array.length;
    let k = n - 2;
    while (k >= 0 && array[k] >= array[k + 1]) k--;

    if (k === -1) return false;

    let l = n - 1;
    while (array[l] <= array[k]) l--;

    [array[k], array[l]] = [array[l], array[k]];

    let left = k + 1, right = n - 1;
    while (left < right) {
        [array[left], array[right]] = [array[right], array[left]];
        left++;
        right--;
    }

    return true;
}

function nextPalindrome(num) {
    let n = num.length;
    let firstHalf = num.slice(0, (n + 1) / 2).split('');
    if (!nextPermutation(firstHalf)) return "";

    let secondHalf = firstHalf.slice().reverse();
    if (n % 2 === 1) secondHalf.shift();
    return firstHalf.join('') + secondHalf.join('');
}

-----
function nextPermutation(array) 
    // Your code here
}

************************************
Question ID: 1844
function countBalls(lowLimit, highLimit) {
    const boxCounts = new Array(46).fill(0);
    for(let i = lowLimit; i <= highLimit; i++) {
        let boxNumber = 0;
        let num = i;
        while(num) {
            boxNumber += num % 10;
            num = Math.floor(num / 10);
        }
        boxCounts[boxNumber]++;
    }
    return Math.max(...boxCounts);
}

-----
function countBalls(lowLimit, highLimit) 
    // Your code here
}

************************************
Question ID: 1845
function largestSubmatrix(matrix) {
    const m = matrix.length, n = matrix[0].length;
    const height = Array(n).fill(0);
    let max_area = 0;

    for (let i = 0; i < m; ++i) {
        for (let j = 0; j < n; ++j) {
            if (matrix[i][j] === 1) height[j]++;
            else height[j] = 0;
        }
        const sorted_height = [...height].sort((a, b) => a - b);
        for (let j = 0; j < n; ++j) {
            max_area = Math.max(max_area, sorted_height[j] * (n - j));
        }
    }
    return max_area;
}


-----
function largestSubmatrix(matrix) 
    // Your code here
}


************************************
Question ID: 1846
function maximumElementAfterDecrementingAndRearranging(arr) {
    arr.sort((a, b) => a - b);
    arr[0] = 1;
    for (let i = 1; i < arr.length; i++) {
        arr[i] = Math.min(arr[i], arr[i - 1] + 1);
    }
    return arr[arr.length - 1];
}

-----
function maximumElementAfterDecrementingAndRearranging(arr) 
    // Your code here
}

************************************
Question ID: 1847

```python
from typing import List
import bisect

class Solution:
    def closestRoom(self, rooms: List[List[int]], queries: List[List[int]]) -> List[int]:
        rooms.sort(key=lambda x: -x[1])
        ans = [0] * len(queries)

        for idx, q in enumerate(queries):
            q.append(idx)
        queries.sort(key=lambda x: -x[1])

        ids = []
        j = 0
        for q in queries:
            while j < len(rooms) and rooms[j][1] >= q[1]:
                bisect.insort(ids, rooms[j][0])
                j += 1
            if not ids:
                ans[q[2]] = -1
            else:
                k = bisect.bisect_left(ids, q[0])
                choices = [k-1, k] if k > 0 else [k]
                closest_idx = min(choices, key=lambda x: abs(ids[x]-q[0]))
                ans[q[2]] = ids[closest_idx]

        return ans
```


-----

```python
from typing import List
import bisect

class Solution:
    def closestRoom(self, rooms: List[List[int]], queries: List[List[int]]) -> List[int]:
        rooms.sort(key=lambda x: -x[1])
        ans = [0] * len(queries)

        for idx, q in enumerate(queries):
            q.append(idx)
        queries.sort(key=lambda x: -x[1])

        ids = []
        j = 0
        for q in queries:
            while j < len(rooms) and rooms[j][1] >= q[1]:
                bisect.insort(ids, rooms[j][0])
                j += 1
            if not ids:
                ans[q[2]] = -1
            else:
                k = bisect.bisect_left(ids, q[0])
                choices = [k-1, k] if k > 0 else [k]
                closest_idx = min(choices, key=lambda x: abs(ids[x]-q[0]))
                ans[q[2]] = ids[closest_idx]

        return ans
```

    // Your code here


************************************
Question ID: 1848
function sumOfUniqueElements(nums) {
    const elemCount = {};
    for (const num of nums) {
        elemCount[num] = (elemCount[num] || 0) + 1;
    }
    let sum = 0;
    for (const [elem, count] of Object.entries(elemCount)) {
        if (count === 1) {
            sum += parseInt(elem);
        }
    }
    return sum;
}


-----
function sumOfUniqueElements(nums) 
    // Your code here
}


************************************
Question ID: 1849
function maxAbsoluteSum(nums) {
    let maxSum = 0, minSum = 0, maxSoFar = 0, minSoFar = 0;
    for (let num of nums) {
        maxSoFar = Math.max(num, maxSoFar + num);
        maxSum = Math.max(maxSum, maxSoFar);

        minSoFar = Math.min(num, minSoFar + num);
        minSum = Math.min(minSum, minSoFar);
    }
    return Math.max(maxSum, Math.abs(minSum));
}

-----
function maxAbsoluteSum(nums) 
    // Your code here
}

************************************
Question ID: 1850
function minLengthAfterOperations(s) {
    const aCount = s.split('a').length - 1;
    const bCount = s.split('b').length - 1;
    const cCount = s.split('c').length - 1;

    if (aCount % 2 === bCount % 2 && bCount % 2 === cCount % 2) {
        return s.length % 2;
    }
    return (s.length + 1) % 2;
}

-----
function minLengthAfterOperations(s) 
    // Your code here
}

************************************
Question ID: 1851
function maxValue(events, k) {
  events.sort((a, b) => a[1] - b[1]);
  const n = events.length;
  const dp = Array.from({ length: n + 1 }, () => new Array(k + 1).fill(0));

  for (let i = 1; i <= n; i++) {
    let start = -1;
    for (let j = i - 1; j >= 1; j--) {
      if (events[j - 1][1] < events[i - 1][0]) {
        start = j;
        break;
      }
    }

    for (let j = 1; j <= k; j++) {
      if (start === -1) {
        dp[i][j] = Math.max(dp[i - 1][j], events[i - 1][2]);
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[start][j - 1] + events[i - 1][2]);
      }
    }
  }

  return dp[n][k];
}


-----
function maxValue(events, k) 
    // Your code here
}


************************************
Question ID: 1852
function distinctNumbersInSubarrays(nums, k) {
    let counts = new Map();
    let ans = [];
    for (let i = 0; i < nums.length; i++) {
        counts.set(nums[i], (counts.get(nums[i]) || 0) + 1);
        if (i >= k) {
            counts.set(nums[i - k], counts.get(nums[i - k]) - 1);
            if (counts.get(nums[i - k]) === 0) {
                counts.delete(nums[i - k]);
            }
        }
        if (i >= k - 1) {
            ans.push(counts.size);
        }
    }
    return ans;
}

-----
function distinctNumbersInSubarrays(nums, k) 
    // Your code here
}

************************************
Question ID: 1854
function maxAliveYear(logs) {
    let years = new Array(101).fill(0);
    for (let log of logs) {
        years[log[0] - 1950]++;
        years[log[1] - 1950]--;
    }
    let max_population = years[0];
    let max_year = 1950;
    for (let i = 1; i < 101; i++) {
        years[i] += years[i - 1];
        if (years[i] > max_population) {
            max_population = years[i];
            max_year = i + 1950;
        }
    }
    return max_year;
}

-----
function maxAliveYear(logs) 
    // Your code here
}

************************************
Question ID: 1855
function maxDistance(nums1, nums2) {
    let i = 0, j = 0, maxDist = 0;
    while (i < nums1.length && j < nums2.length) {
        if (nums1[i] > nums2[j]) {
            ++i;
        } else {
            maxDist = Math.max(maxDist, j - i);
            ++j;
        }
    }
    return maxDist;
}

-----
function maxDistance(nums1, nums2) 
    // Your code here
}

************************************
Question ID: 1856
var maxSumMinProduct = function(nums) {
    const MOD = BigInt(1000000007);
    let max_product = BigInt(0);
    let stk = [];
    let prefix_sum = new BigInt64Array(nums.length + 1);

    for (let i = 0; i < nums.length; i++) {
        prefix_sum[i + 1] = prefix_sum[i] + BigInt(nums[i]);
    }

    for (let i = 0; i < nums.length; i++) {
        while (stk.length > 0 && nums[stk[stk.length - 1]] > nums[i]) {
            let min_val = nums[stk.pop()];
            max_product = BigInt(Math.max(Number(max_product), Number(min_val * (prefix_sum[i] - prefix_sum[stk.length === 0 ? 0 : stk[stk.length - 1] + 1]))));
        }
        stk.push(i);
    }

    while (stk.length > 0) {
        let min_val = nums[stk.pop()];
        max_product = BigInt(Math.max(Number(max_product), Number(min_val * (prefix_sum[nums.length] - prefix_sum[stk.length === 0 ? 0 : stk[stk.length - 1] + 1]))));
    }

    return Number(max_product % MOD);
};


-----
var maxSumMinProduct = function(nums) 
    // Your code here
};


************************************
Question ID: 1857
function largestPathValue(colors, edges) {
    const n = colors.length;
    const adj = Array.from({ length: n }, () => []);
    const inDegrees = Array(n).fill(0);

    for (const e of edges) {
        adj[e[0]].push(e[1]);
        inDegrees[e[1]]++;
    }

    const colorCounts = Array.from({ length: n }, () => Array(26).fill(0));
    const queue = [];

    for (let i = 0; i < n; i++) {
        if (inDegrees[i] === 0) {
            queue.push(i);
        }
    }

    let visitedNodes = 0;
    let maxColorValue = 0;

    while (queue.length > 0) {
        const node = queue.pop();
        const color = colors.charCodeAt(node) - 'a'.charCodeAt();
        visitedNodes++;

        for (const neighbor of adj[node]) {
            for (let c = 0; c < 26; c++) {
                const count = colorCounts[node][c] + (c === color ? 1 : 0);
                colorCounts[neighbor][c] = Math.max(colorCounts[neighbor][c], count);
                maxColorValue = Math.max(maxColorValue, count);
            }
            if (--inDegrees[neighbor] === 0) {
                queue.push(neighbor);
            }
        }
    }

    return visitedNodes === n ? maxColorValue : -1;
}


-----
function largestPathValue(colors, edges) 
    // Your code here
}


************************************
Question ID: 1858
function maximumTime(time) {
    let result = time.split('');
    if (result[0] === '?') {
        result[0] = (result[1] === '?' || parseInt(result[1]) < 4) ? '2' : '1';
    }
    if (result[1] === '?') {
        result[1] = (result[0] === '2') ? '3' : '9';
    }
    if (result[3] === '?') {
        result[3] = '5';
    }
    if (result[4] === '?') {
        result[4] = '9';
    }
    return result.join('');
}

-----
function maximumTime(time) 
    // Your code here
}

************************************
Question ID: 1859
function minOperationsToSatisfyConditions(a, b) {
    let same = 0, less = 0, greater = 0;

    for (let i = 0; i < a.length; i++) {
        if (a[i] === b[i]) same++;
        else if (a[i] < b[i]) less++;
        else greater++;
    }

    return Math.min(same + Math.max(less, greater), Math.min(less, greater));
}

-----
function minOperationsToSatisfyConditions(a, b) 
    // Your code here
}

************************************
Question ID: 1860
function kthLargestValue(matrix, k) {
  let m = matrix.length;
  let n = matrix[0].length;
  let prefixXOR = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
  let pq = new PriorityQueue(k);

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      prefixXOR[i][j] = matrix[i - 1][j - 1] ^ prefixXOR[i - 1][j] ^ prefixXOR[i][j - 1] ^ prefixXOR[i - 1][j - 1];
      pq.offer(prefixXOR[i][j]);
      if (pq.size() > k) {
        pq.poll();
      }
    }
  }
  return pq.peek();
}

class PriorityQueue {
  constructor(k) {
    this.queue = [];
    this.k = k;
  }

  offer(element) {
    this.queue.push(element);
    this.queue.sort((a, b) => a - b);
  }

  poll() {
    return this.queue.shift();
  }

  size() {
    return this.queue.length;
  }

  peek() {
    return this.queue[0];
  }
}


-----
function kthLargestValue(matrix, k) 
    // Your code here
}


************************************
Question ID: 1861
function minBoxesTouchingFloor(n) {
    return Math.floor((n + 1) / 2);
}

-----
function minBoxesTouchingFloor(n) 
    // Your code here
}

************************************
Question ID: 1862
function sumOfFlooredPairs(nums) {
    const MOD = 1e9 + 7;
    const n = nums.length;
    const maxElement = Math.max(...nums);
    const cnt = new Array(maxElement + 1).fill(0);
    for (const num of nums)
        cnt[num]++;
    for (let i = 1; i <= maxElement; i++)
        cnt[i] += cnt[i - 1];
    
    let res = 0;
    for (const num of nums) {
        for (let j = 1, k = 1; k <= maxElement; j++, k += num) {
            res += j * (cnt[Math.min(k + num - 1, maxElement)] - cnt[k - 1]);
            res %= MOD;
        }
    }
    
    return res;
}

-----
function sumOfFlooredPairs(nums) 
    // Your code here
}

************************************
Question ID: 1863
function subsetXORSum(nums) {
    let ans = 0, n = nums.length, max_val = 1 << n;
    for (let i = 1; i < max_val; i++) {
        let xor_total = 0;
        for (let j = 0; j < n; j++) {
            if (i & (1 << j)) {
                xor_total ^= nums[j];
            }
        }
        ans += xor_total;
    }
    return ans;
}

-----
function subsetXORSum(nums) 
    // Your code here
}

************************************
Question ID: 1864
function minSwaps(s) {
    let zeroCount = 0, oneCount = 0;
    for (const c of s) {
        (c === '0') ? zeroCount++ : oneCount++;
    }

    if (Math.abs(zeroCount - oneCount) > 1) {
        return -1;
    }

    let swaps1 = 0, swaps2 = 0;
    for (let i = 0; i < s.length; i++) {
        if (i % 2 === 0 && s[i] !== '0') {
            swaps1++;
        }
        if (i % 2 === 1 && s[i] !== '1') {
            swaps1++;
        }
    }
    swaps1 = swaps1 / 2;

    for (let i = 0; i < s.length; i++) {
        if (i % 2 === 0 && s[i] !== '1') {
            swaps2++;
        }
        if (i % 2 === 1 && s[i] !== '0') {
            swaps2++;
        }
    }
    swaps2 = swaps2 / 2;

    if (zeroCount === oneCount) {
        return Math.min(swaps1, swaps2);
    }
    return (zeroCount > oneCount) ? swaps2 : swaps1;
}

-----
function minSwaps(s) 
    // Your code here
}

************************************
Question ID: 1865
class FindSumPairs {
    constructor(nums1, nums2) {
        this.nums1 = nums1;
        this.nums2 = nums2;
        this.nums2Map = new Map();

        for (const num of nums2) {
            this.nums2Map.set(num, (this.nums2Map.get(num) || 0) + 1);
        }
    }

    add(index, val) {
        this.nums2Map.set(this.nums2[index], this.nums2Map.get(this.nums2[index]) - 1);
        this.nums2[index] += val;
        this.nums2Map.set(this.nums2[index], (this.nums2Map.get(this.nums2[index]) || 0) + 1);
    }

    count(tot) {
        let count = 0;
        for (const num of this.nums1) {
            count += (this.nums2Map.get(tot - num) || 0);
        }
        return count;
    }
}


-----
class FindSumPairs 
    // Your code here
}


************************************
Question ID: 1866
function restoreArray(adjacentPairs) {
    const graph = new Map();
    for (const pair of adjacentPairs) {
        if (!graph.has(pair[0])) {
            graph.set(pair[0], []);
        }
        if (!graph.has(pair[1])) {
            graph.set(pair[1], []);
        }
        graph.get(pair[0]).push(pair[1]);
        graph.get(pair[1]).push(pair[0]);
    }
    const n = graph.size;
    const nums = Array(n);
    for (const [key, nodes] of graph.entries()) {
        if (nodes.length === 1) {
            nums[0] = key;
            break;
        }
    }

    nums[1] = graph.get(nums[0])[0];
    for (let i = 2; i < n; i++) {
        const nodes = graph.get(nums[i - 1]);
        nums[i] = nums[i-2] === nodes[0] ? nodes[1] : nodes[0];
    }
    return nums;
}

-----
function restoreArray(adjacentPairs) 
    // Your code here
}

************************************
Question ID: 1868
function findRLEProduct(encoded1, encoded2) {
    const result = [];
    let i = 0, j = 0, count1 = 0, count2 = 0;

    while (i < encoded1.length && j < encoded2.length) {
        const product = encoded1[i][0] * encoded2[j][0];
        const count = Math.min(encoded1[i][1] - count1, encoded2[j][1] - count2);
        count1 += count;
        count2 += count;
        
        if (result.length > 0 && result[result.length - 1][0] === product) {
            result[result.length - 1][1] += count;
        } else {
            result.push([product, count]);
        }

        if (count1 === encoded1[i][1]) {
            i++;
            count1 = 0;
        }

        if (count2 === encoded2[j][1]) {
            j++;
            count2 = 0;
        }
    }

    return result;
}

-----
function findRLEProduct(encoded1, encoded2) 
    // Your code here
}

************************************
Question ID: 1869
function checkZeroOnes(s) {
    let max_ones = 0, max_zeros = 0, current_ones = 0, current_zeros = 0;
    for (const c of s) {
        if (c === '1') {
            current_ones++;
            current_zeros = 0;
        } else {
            current_zeros++;
            current_ones = 0;
        }
        max_ones = Math.max(max_ones, current_ones);
        max_zeros = Math.max(max_zeros, current_zeros);
    }
    return max_ones > max_zeros;
}

-----
function checkZeroOnes(s) 
    // Your code here
}

************************************
Question ID: 1870
function minSpeedOnTime(dist, hour) {
    let max_time = hour - dist.length + 1;
    let lower = 1.0, upper = 1e7;
    while (upper - lower >= 1e-9) {
        let mid = (lower + upper) / 2;
        let time_taken = 0.0;
        for (let i = 0; i < dist.length; ++i) {
            time_taken += Math.ceil(dist[i] / mid) - (i == dist.length - 1 ? 0 : 1);
        }
        if (time_taken <= max_time) {
            upper = mid;
        } else {
            lower = mid;
        }
    }
    return (lower <= 1e7) ? Math.ceil(lower) : -1;
}

-----
function minSpeedOnTime(dist, hour) 
    // Your code here
}

************************************
Question ID: 1871
function isPalindrome(s, l, r) {
    while (l < r) {
        if (s[l++] !== s[r--]) return false;
    }
    return true;
}

function checkPartitioning(s) {
    const n = s.length;
    for (let i = 0; i < n - 2; i++) {
        if (isPalindrome(s, 0, i)) {
            for (let j = i + 1; j < n - 1; j++) {
                if (isPalindrome(s, i + 1, j) && isPalindrome(s, j + 1, n - 1)) {
                    return true;
                }
            }
        }
    }
    return false;
}


-----
function isPalindrome(s, l, r) 
    // Your code here
}


************************************
Question ID: 1872
function canEat(candiesCount, queries) {
    const prefixSum = new Array(candiesCount.length + 1).fill(0);
    for (let i = 0; i < candiesCount.length; ++i) {
        prefixSum[i + 1] = prefixSum[i] + candiesCount[i];
    }

    const result = new Array(queries.length);
    for (let i = 0; i < queries.length; ++i) {
        const [favoriteType, favoriteDay, dailyCap] = queries[i];
        const x1 = favoriteDay + 1;
        const y1 = (favoriteDay + 1) * dailyCap;

        const x2 = prefixSum[favoriteType] + 1;
        const y2 = prefixSum[favoriteType + 1];

        result[i] = !(x1 > y2 || y1 < x2);
    }

    return result;
}

-----
function canEat(candiesCount, queries) 
    // Your code here
}

************************************
Question ID: 1874
function canChoose(groups, nums) {
    let g_i = 0, n_i = 0;
    while (g_i < groups.length && n_i + groups[g_i].length <= nums.length) {
        const match = groups[g_i].every((val, i) => val === nums[n_i + i]);
        if (match) {
            n_i += groups[g_i].length;
            g_i++;
        } else {
            n_i++;
        }
    }
    return g_i === groups.length;
}


-----
function canChoose(groups, nums) 
    // Your code here
}


************************************
Question ID: 1876
function highestIsland(isWater) {
    const m = isWater.length;
    const n = isWater[0].length;
    const height = Array.from({ length: m }, () => Array(n).fill(-1));
    const q = [];

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (isWater[i][j] === 1) {
                height[i][j] = 0;
                q.push([i, j]);
            }
        }
    }

    const dx = [-1, 0, 1, 0];
    const dy = [0, 1, 0, -1];

    while (q.length) {
        const [x, y] = q.shift();

        for (let i = 0; i < 4; i++) {
            const newX = x + dx[i];
            const newY = y + dy[i];

            if (newX >= 0 && newX < m && newY >= 0 && newY < n && height[newX][newY] === -1) {
                height[newX][newY] = height[x][y] + 1;
                q.push([newX, newY]);
            }
        }
    }

    return height;
}

-----
function highestIsland(isWater) 
    // Your code here
}

************************************
Question ID: 1877
function minPairSum(nums) {
    nums.sort((a, b) => a - b);
    let maxSum = 0;
    for (let i = 0; i < nums.length / 2; i++)
        maxSum = Math.max(maxSum, nums[i] + nums[nums.length - 1 - i]);
    return maxSum;
}

-----
function minPairSum(nums) 
    // Your code here
}

************************************
Question ID: 1878
function check(nums) {
    let count = 0;
    for (let i = 1; i < nums.length; ++i) {
        if (nums[i] < nums[i - 1]) {
            ++count;
        }
        if (count > 1) {
            return false;
        }
    }
    return count === 1 || nums[0] >= nums[nums.length - 1];
}

-----
function check(nums) 
    // Your code here
}

************************************
Question ID: 1879
function maxScore(a, b, c) {
    return (a + b + c - Math.max(a, Math.max(b, c))) / 2;
}


-----
function maxScore(a, b, c) 
    // Your code here
}


************************************
Question ID: 1880
function largestMerge(word1, word2) {
    let merge = "";
    while (word1.length > 0 || word2.length > 0) {
        if (word1.localeCompare(word2) > 0) {
            merge += word1[0];
            word1 = word1.slice(1);
        } else {
            merge += word2[0];
            word2 = word2.slice(1);
        }
    }
    return merge;
}

-----
function largestMerge(word1, word2) 
    // Your code here
}

************************************
Question ID: 1881
function minAbsDifference(nums, goal) {
    const n = nums.length;
    const left = nums.slice(0, n / 2);
    const right = nums.slice(n / 2);
    const sums = new Set();

    for (let mask = 0; mask < (1 << left.length); ++mask) {
        let sum = 0;
        for (let i = 0; i < left.length; ++i) {
            if (mask & (1 << i)) {
                sum += left[i];
            }
        }
        sums.add(sum);
    }

    let ans = Math.abs(goal);

    for (let mask = 0; mask < (1 << right.length); ++mask) {
        let sum = 0;
        for (let i = 0; i < right.length; ++i) {
            if (mask & (1 << i)) {
                sum += right[i];
            }
        }
        const target = goal - sum;
        const candidate = [...sums].reduce((a, b) => Math.abs(b - target) < Math.abs(a - target) ? b : a);

        ans = Math.min(ans, Math.abs(candidate + sum - goal));
    }

    return ans;
}

-----
function minAbsDifference(nums, goal) 
    // Your code here
}

************************************
Question ID: 1882
function assignTasks(servers, tasks) {
    const result = new Array(tasks.length);
    const freeServers = [];
    for (let i = 0; i < servers.length; i++) {
        freeServers.push([servers[i], i]);
    }
    freeServers.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
    const busyServers = [];

    let time = 0;
    let taskIndex = 0;

    while (taskIndex < tasks.length) {
        while (busyServers.length && busyServers[0][0] <= time) {
            const server = busyServers.shift()[1];
            freeServers.push(server);
            freeServers.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
        }

        while (freeServers.length && taskIndex <= time && taskIndex < tasks.length) {
            const server = freeServers.shift();
            result[taskIndex] = server[1];
            busyServers.push([time + tasks[taskIndex], server]);
            busyServers.sort((a, b) => a[0] - b[0] || a[1][1] - b[1][1]);
            taskIndex++;
        }

        time++;
    }

    return result;
}


-----
function assignTasks(servers, tasks) 
    // Your code here
}


************************************
Question ID: 1883
function minSkips(dist, speed, hoursBefore) {
    const n = dist.length;
    const dp = Array.from({ length: n + 1 }, () => Array(n + 1).fill(1e9));
    dp[0][0] = 0;
    
    for (let i = 0; i < n; i++) {
        for (let j = -1; j < i; j++) {
            const t = dist[i] / speed + (j != -1 ? 1 : 0);
            dp[i + 1][j + 1] = Math.min(dp[i + 1][j + 1], dp[i][j] + t);
            const skipped_t = Math.ceil(dp[i][j] + dist[i] / speed) - dp[i][j];
            dp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j] + skipped_t);
        }
    }
    
    for (let i = 0; i <= n; i++) {
        if (dp[n][i] <= hoursBefore) {
            return i;
        }
    }
    return -1;
}


-----
function minSkips(dist, speed, hoursBefore) 
    // Your code here
}


************************************
Question ID: 1884
function minOperationsToAlternate(s) {
    let countA = 0, countB = 0;
    for (let i = 0; i < s.length; i++) {
        if (i % 2 === 0) {
            if (s[i] === '0') countA++;
            else countB++;
        } else {
            if (s[i] === '0') countB++;
            else countA++;
        }
    }
    return Math.min(countA, countB);
}

-----
function minOperationsToAlternate(s) 
    // Your code here
}

************************************
Question ID: 1885
function countHomogenous(s) {
    let res = 0, count = 1, mod = 1e9 + 7;
    for (let i = 1; i < s.length; ++i) {
        count = (s[i] === s[i - 1]) ? count + 1 : 1;
        res = (res + count) % mod;
    }
    return res;
}

-----
function countHomogenous(s) 
    // Your code here
}

************************************
Question ID: 1886
function minimumSize(nums, maxOperations) {
    const pq = new PriorityQueue((a, b) => b - a);
    for (const num of nums) {
        pq.offer(num);
    }
    while (maxOperations > 0) {
        const maxBalls = pq.poll();
        pq.offer(Math.floor(maxBalls / 2));
        pq.offer(maxBalls - Math.floor(maxBalls / 2));
        maxOperations--;
    }
    return pq.peek();
}

class PriorityQueue {
    constructor(comparator = (a, b) => a - b) {
        this._heap = [];
        this._comparator = comparator;
    }
    size() {
        return this._heap.length;
    }
    isEmpty() {
        return this.size() == 0;
    }
    peek() {
        return this._heap[0];
    }
    // Rest of the PriorityQueue implementation
}

-----
function minimumSize(nums, maxOperations) 
    // Your code here
}

************************************
Question ID: 1887
function minTrioDegree(n, edges) {
    const graph = {};
    const degree = new Array(n + 1).fill(0);

    for (const [u, v] of edges) {
        if (!graph[u]) graph[u] = {};
        if (!graph[v]) graph[v] = {};
        graph[u][v] = graph[v][u] = true;
        degree[u]++;
        degree[v]++;
    }

    let minDegree = Infinity;
    for (const [u, v] of edges) {
        for (let w = 1; w <= n; ++w) {
            if (graph[u][w] && graph[v][w]) {
                minDegree = Math.min(minDegree, degree[u] + degree[v] + degree[w] - 6);
            }
        }
    }

    return minDegree === Infinity ? -1 : minDegree;
}


-----
function minTrioDegree(n, edges) 
    // Your code here
}


************************************
Question ID: 1888
function nearestValidPoint(x, y, points) {
    let minDistance = Infinity;
    let minIndex = -1;

    for (let i = 0; i < points.length; i++) {
        if (x === points[i][0] || y === points[i][1]) {
            let distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
            if (distance < minDistance) {
                minDistance = distance;
                minIndex = i;
            }
        }
    }

    return minIndex;
}

-----
function nearestValidPoint(x, y, points) 
    // Your code here
}

************************************
Question ID: 1889
function checkPowersOfThree(n) {
    while (n > 0) {
        if (n % 3 === 2) return false;
        n = Math.floor(n / 3);
    }
    return true;
}


-----
function checkPowersOfThree(n) 
    // Your code here
}


************************************
Question ID: 1893
function isCovered(ranges, left, right) {
    for (let i = left; i <= right; i++) {
        let found = false;
        for (const range of ranges) {
            if (i >= range[0] && i <= range[1]) {
                found = true;
                break;
            }
        }
        if (!found) return false;
    }
    return true;
}

-----
function isCovered(ranges, left, right) 
    // Your code here
}

************************************
Question ID: 1894
function mergeAlternately(word1, word2) {
    let merged = "";
    let i = 0, j = 0;
    while (i < word1.length || j < word2.length) {
        if (i < word1.length) merged += word1[i++];
        if (j < word2.length) merged += word2[j++];
    }
    return merged;
}

-----
function mergeAlternately(word1, word2) 
    // Your code here
}

************************************
Question ID: 1895
function minOperations(boxes) {
    const result = new Array(boxes.length).fill(0);
    let count = 0, total = 0;
    
    for (let i = 0; i < boxes.length; i++) {
        total += count;
        result[i] = total;
        if (boxes[i] === '1') count++;
    }

    count = 0;
    total = 0;
    for (let i = boxes.length - 1; i >= 0; i--) {
        total += count;
        result[i] += total;
        if (boxes[i] === '1') count++;
    }

    return result;
}

-----
function minOperations(boxes) 
    // Your code here
}

************************************
Question ID: 1896
function maximumScore(nums, multipliers) {
    const n = nums.length, m = multipliers.length;
    const dp = Array.from({ length: m + 1 }, () => Array(m + 1).fill(0));
    let maxScore = Number.MIN_SAFE_INTEGER;

    for (let i = 0; i <= m; i++) {
        for (let j = 0; i + j <= m; j++) {
            if (i === 0 && j === 0) continue;
            let score = 0;
            if (i === 0) {
                score = dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1];
            } else if (j === 0) {
                score = dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1];
            } else {
                score = Math.max(dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1],
                                dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1]);
            }
            dp[i][j] = score;
            if (i + j === m) {
                maxScore = Math.max(maxScore, score);
            }
        }
    }

    return maxScore;
}

-----
function maximumScore(nums, multipliers) 
    // Your code here
}

************************************
Question ID: 1897
function longestPalindromeSubseq(word1, word2) {
    const n = word1.length;
    const m = word2.length;

    const dp = Array.from({ length: n + 1 }, () => new Array(m + 1).fill(0));

    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            if (word1[i] === word2[j]) {
                dp[i + 1][j + 1] = dp[i][j] + 1;
            } else {
                dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);
            }
        }
    }

    return dp[n][m];
}

-----
function longestPalindromeSubseq(word1, word2) 
    // Your code here
}

************************************
Question ID: 1898
function maximumRemovals(s, p, removable) {
    let low = 0, high = removable.length;
    while (low < high) {
        let mid = Math.floor((low + high + 1) / 2);
        let temp_s = s.split('');
        for (let i = 0; i < mid; i++) {
            temp_s[removable[i]] = '-';
        }
        let i = 0, j = 0;
        while (i < temp_s.length && j < p.length) {
            if (temp_s[i] === p[j]) {
                j++;
            }
            i++;
        }
        if (j === p.length) {
            low = mid;
        } else {
            high = mid - 1;
        }
    }
    return low;
}


-----
function maximumRemovals(s, p, removable) 
    // Your code here
}


************************************
Question ID: 1899
function countMatches(items, ruleKey, ruleValue) {
    const rule = {"type": 0, "color": 1, "name": 2};
    let count = 0;

    for (const item of items) {
        if (item[rule[ruleKey]] === ruleValue) {
            count++;
        }
    }

    return count;
}

-----
function countMatches(items, ruleKey, ruleValue) 
    // Your code here
}

************************************
Question ID: 1900
function closestCost(baseCosts, toppingCosts, target) {
    let closest = baseCosts[0];

    for (const base of baseCosts) {
        let cost = base;
        for (let i = 0; i < (1 << (toppingCosts.length * 2)); ++i) {
            let bitMask = i;
            for (let j = 0; j < toppingCosts.length; ++j, bitMask >>= 2) {
                cost += (bitMask & 3) * toppingCosts[j];
            }

            if (Math.abs(target - cost) < Math.abs(target - closest)) {
                closest = cost;
            } else if (Math.abs(target - cost) === Math.abs(target - closest) && cost < closest) {
                closest = cost;
            }

            cost = base;
        }
    }

    return closest;
}


-----
function closestCost(baseCosts, toppingCosts, target) 
    // Your code here
}


************************************
Question ID: 1901
function minOperations(nums1, nums2) {
    const sum1 = nums1.reduce((a, b) => a + b, 0);
    const sum2 = nums2.reduce((a, b) => a + b, 0);
    if (sum1 === sum2) return 0;
    if (sum1 < sum2) [nums1, nums2] = [nums2, nums1];
    nums1.sort((a, b) => b - a);
    nums2.sort((a, b) => a - b);
    let diff = Math.abs(sum1 - sum2), operations = 0;
    let i = 0, j = 0;
    while (diff > 0 && (i < nums1.length || j < nums2.length)) {
        const option1 = i < nums1.length ? nums1[i] - 1 : 0;
        const option2 = j < nums2.length ? 6 - nums2[j] : 0;
        if (option1 > option2) {
            diff -= option1;
            i++;
        } else {
            diff -= option2;
            j++;
        }
        operations++;
    }
    return diff === 0 ? operations : -1;
}


-----
function minOperations(nums1, nums2) 
    // Your code here
}


************************************
Question ID: 1902
function getCollisionTimes(cars) {
    const n = cars.length;
    const collisions = new Array(n).fill(-1);
    for (let i = n - 1; i >= 0; --i) {
        let time_to_collision = 1e9;
        for (let j = i + 1; j < n; ++j) {
            if (cars[j][1] > cars[i][1]) continue;
            let current_collision = (cars[j][0] - cars[i][0]) / (cars[i][1] - cars[j][1]);
            if(current_collision < time_to_collision) {
                time_to_collision = Math.min(time_to_collision, Math.min(collisions[j], current_collision));
            }
        }
        collisions[i] = time_to_collision === 1e9 ? -1.0 : time_to_collision;
    }
    return collisions;
}

-----
function getCollisionTimes(cars) 
    // Your code here
}

************************************
Question ID: 1903
function largestOddNumber(num) {
    for (let i = num.length - 1; i >= 0; i--) {
        if ((num.charCodeAt(i) - '0'.charCodeAt(0)) % 2 !== 0) {
            return num.slice(0, i + 1);
        }
    }
    return "";
}

-----
function largestOddNumber(num) 
    // Your code here
}

************************************
Question ID: 1904
function secondLargestDigit(s) {
    let largest = -1, secondLargest = -1;
    for (const c of s) {
        if (!isNaN(c)) {
            let digit = parseInt(c);
            if (digit > largest) {
                secondLargest = largest;
                largest = digit;
            } else if (digit !== largest && digit > secondLargest) {
                secondLargest = digit;
            }
        }
    }
    return secondLargest;
}

-----
function secondLargestDigit(s) 
    // Your code here
}

************************************
Question ID: 1906
function maxScore(nums) {
    const n = nums.length;
    const dp = new Array(n + 1).fill(null).map(() => new Array(n * 2 + 1).fill(-1));

    function gcd(x, y) {
        if (y === 0) return x;
        return gcd(y, x % y);
    }

    function dfs(i, j) {
        if (i > n) return 0;
        if (dp[i][j] !== -1) return dp[i][j];
        let ans = 0;
        for (let k = j + 1; k < n * 2; k++) {
            ans = Math.max(ans, dfs(i + 1, k) + i * gcd(nums[j], nums[k]));
        }
        return dp[i][j] = ans;
    }

    return dfs(1, 0);
}

-----
function maxScore(nums) 
    // Your code here
}

************************************
Question ID: 1908
function aliceWins(piles) {
    let xorSum = 0;
    for (let pile of piles) {
        xorSum ^= pile;
    }
    return xorSum !== 0;
}


-----
function aliceWins(piles) 
    // Your code here
}


************************************
Question ID: 1909
function canBeIncreasing(nums) {
    let count = 0;
    for (let i = 1; i < nums.length; ++i) {
        if (nums[i - 1] >= nums[i]) {
            count++;
            if (count > 1) return false;
            if (i > 1 && nums[i - 2] >= nums[i] && i < nums.length - 1 && nums[i - 1] >= nums[i + 1]) return false;
        }
    }
    return true;
}

-----
function canBeIncreasing(nums) 
    // Your code here
}

************************************
Question ID: 1910
function checkOnesSegment(s) {
    let count = 0;
    for (let i = 0; i < s.length; i++) {
        if (s[i] === '1') {
            if (i > 0 && s[i - 1] === '0') {
                count++;
            }
        }
    }
    return count <= 1;
}

-----
function checkOnesSegment(s) 
    // Your code here
}

************************************
Question ID: 1911
function minElements(nums, limit, goal) {
    let sum = nums.reduce((a, b) => a + b, 0);
    let diff = Math.abs(goal - sum);
    return Math.ceil(diff / limit);
}


-----
function minElements(nums, limit, goal) 
    // Your code here
}


************************************
Question ID: 1912
const mod = 1e9 + 7;

function countRestrictedPaths(n, edges) {
    let graph = new Array(n + 1).fill(null).map(() => []);
    let dist = new Array(n + 1).fill(Number.MAX_VALUE);

    edges.forEach(([u, v, w]) => {
        graph[u].push([v, w]);
        graph[v].push([u, w]);
    });

    let pq = [[0, n]]; // [distance, node]
    dist[n] = 0;

    while (pq.length !== 0) {
        pq.sort((a, b) => a[0] - b[0]);
        let [d, u] = pq.pop();
        if (d !== dist[u]) continue;

        graph[u].forEach(([v, w]) => {
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push([dist[v], v]);
            }
        });
    }

    let dp = new Array(n + 1).fill(-1);

    function dfs(u) {
        if (u === n) return 1;
        if (dp[u] !== -1) return dp[u];
        let ans = 0;
        graph[u].forEach(([v, _]) => {
            if (dist[v] < dist[u]) {
                ans = (ans + dfs(v)) % mod;
            }
        });
        dp[u] = ans;
        return ans;
    }

    return dfs(1);
}

-----
const mod = 1e9 + 7;

function countRestrictedPaths(n, edges) 
    // Your code here
}

************************************
Question ID: 1913
function minChanges(nums, k) {
    let n = nums.length;
    let xor_prefix = new Array(n + 1).fill(0);

    for (let i = 1; i <= n; i++) {
        xor_prefix[i] = xor_prefix[i - 1] ^ nums[i - 1];
    }

    let dp = Array.from({ length: k }, () => new Map());
    let min_dp = Array(k).fill(n);

    for (let i = 1; i <= n; i++) {
        let x = xor_prefix[i] ^ xor_prefix[i - k];

        if (i >= k) {
            dp[0].set(x, (dp[0].get(x) || 0) + 1);
        }

        for (let j = 1; i - j * k >= 0; j++) {
            dp[j].set(x, (dp[j].get(x) || 0) + 1);
            min_dp[j] = Math.min(min_dp[j], (dp[j - 1].get(x) || 0) - (dp[j].get(x) || 0));
        }
    }

    let answer = n;
    for (let j = 0; j < k; j++) {
        answer = Math.min(answer, min_dp[j] + j);
    }
    return answer;
}

-----
function minChanges(nums, k) 
    // Your code here
}

************************************
Question ID: 1914
function rotateGrid(grid, k) {
    if (!grid || grid.length === 0) return grid;
    
    let m = grid.length; // number of rows
    let n = grid[0].length; // number of columns
    let numLayers = Math.min(m, n) / 2;

    for (let layer = 0; layer < numLayers; ++layer) {
        let numToRotate = (m - 2 * layer) * 2 + (n - 2 * layer - 2) * 2; // number of elements in the outer ring
        let effective_k = k % numToRotate; // effective number of rotations
        
        while (effective_k--) {
            let temp = grid[layer][layer];
            for (let i = layer + 1; i < m - layer; ++i) [temp, grid[i][layer]] = [grid[i][layer], temp];
            for (let j = layer + 1; j < n - layer; ++j) [temp, grid[m - layer - 1][j]] = [grid[m - layer - 1][j], temp];
            for (let i = m - layer - 2; i >= layer; --i) [temp, grid[i][n - layer - 1]] = [grid[i][n - layer - 1], temp];
            for (let j = n - layer - 2; j > layer; --j) [temp, grid[layer][j]] = [grid[layer][j], temp];
        }
    }

    return grid;
}

-----
function rotateGrid(grid, k) 
    // Your code here
}

************************************
Question ID: 1915
function areAlmostEqual(s1, s2) {
    let diffCount = 0;
    let firstDiff = -1;
    let secondDiff = -1;
    for (let i = 0; i < s1.length; i++) {
        if (s1[i] !== s2[i]) {
            diffCount++;
            if (diffCount === 1)
                firstDiff = i;
            else if (diffCount === 2)
                secondDiff = i;
            else
                return false;
        }
    }
    return diffCount === 0 || (diffCount === 2 && s1[firstDiff] === s2[secondDiff] && s1[secondDiff] === s2[firstDiff]);
}

-----
function areAlmostEqual(s1, s2) 
    // Your code here
}

************************************
Question ID: 1916
function findCenter(edges) {
    if (edges[0][0] === edges[1][0] || edges[0][0] === edges[1][1]) {
        return edges[0][0];
    }
    return edges[0][1];
}

-----
function findCenter(edges) 
    // Your code here
}

************************************
Question ID: 1918
function maxScore(nums, k) {
    const n = nums.length;
    let result = 0;
    for (let i = k; i >= 0; i--) {
        for (let j = k; j < n; j++) {
            let minVal = nums[i];
            for (let x = i; x <= j; x++)
                minVal = Math.min(minVal, nums[x]);
            result = Math.max(result, minVal * (j - i + 1));
        }
    }
    return result;
}

-----
function maxScore(nums, k) 
    // Your code here
}

************************************
Question ID: 1920
function squareIsWhite(coordinates) {
    return (coordinates.charCodeAt(0) - 'a'.charCodeAt(0) + coordinates.charCodeAt(1) - '1'.charCodeAt(0)) % 2 === 0;
}

-----
function squareIsWhite(coordinates) 
    // Your code here
}

************************************
Question ID: 1921
function eliminateMaximum(dist, speed) {
    const n = dist.length;
    const timeToReachCity = dist.map((d, i) => Math.ceil(d / speed[i])).sort((a, b) => a - b);
    let eliminated = 0;
    for (let i = 0; i < n && timeToReachCity[i] > i; i++) {
        eliminated++;
    }
    return eliminated;
}

-----
function eliminateMaximum(dist, speed) 
    // Your code here
}

************************************
Question ID: 1922
function goodDigitStrings(n) {
    const mod = 1000000007;
    let evenCount = 1, primeCount = 1;
    for (let i = 0; i < n; ++i) {
        if (i % 2 === 0) evenCount = (evenCount * 5) % mod;
        else primeCount = (primeCount * 4) % mod;
    }
    return (evenCount * primeCount) % mod;
}

-----
function goodDigitStrings(n) 
    // Your code here
}

************************************
Question ID: 1923
function areSentencesSimilar(sentence1, sentence2) {
    let words1 = sentence1.split(" ");
    let words2 = sentence2.split(" ");
    
    while (
        words1.length && words2.length &&
        words1[0] === words2[0]
    ) {
        words1.shift();
        words2.shift();
    }
    
    while (
        words1.length && words2.length &&
        words1[words1.length - 1] === words2[words2.length - 1]
    ) {
        words1.pop();
        words2.pop();
    }
    
    return !words1.length || !words2.length;
}

-----
function areSentencesSimilar(sentence1, sentence2) 
    // Your code here
}

************************************
Question ID: 1924
function maxHappyGroups(batchSize, groups) {
    let remainders = new Array(batchSize).fill(0);
    for (let g of groups) {
        remainders[g % batchSize]++;
    }

    let result = remainders[0];
    let i = 1, j = batchSize - 1;

    while (i < j) {
        result += Math.min(remainders[i], remainders[j]);
        i++;
        j--;
    }
    if (i === j) {
        result += Math.floor(remainders[i] / 2);
    }

    return result;
}

-----
function maxHappyGroups(batchSize, groups) 
    // Your code here
}

************************************
Question ID: 1925
function reverse(x) {
    let rev = 0;
    while (x !== 0) {
        rev = rev * 10 + x % 10;
        x = Math.floor(x / 10);
    }
    return rev;
}

function countNicePairs(nums) {
    const MOD = 1_000_000_007;
    const count = new Map();
    let result = 0;

    for (const num of nums) {
        const diff = num - reverse(num);
        count.set(diff, (count.get(diff) || 0) + 1);
    }

    for (const val of count.values()) {
        result = (result + ((val * (val - 1)) / 2) % MOD) % MOD;
    }

    return result;
}

-----
function reverse(x) 
    // Your code here
}

************************************
Question ID: 1926
function nearestExit(maze, entrance) {
    const m = maze.length;
    const n = maze[0].length;
    const moves = [[-1, 0], [1, 0], [0, -1], [0, 1]];
    const q = [[entrance[0], entrance[1]]];

    let steps = -1;
    while (q.length) {
        steps++;
        const size = q.length;
        for (let i = 0; i < size; ++i) {
            const [r, c] = q.shift();
            if (maze[r][c] === '+') continue;
            if (r === 0 || r === m-1 || c === 0 || c === n-1) {
                if (r !== entrance[0] || c !== entrance[1]) return steps;
            }
            maze[r][c] = '+';
            for (const move of moves) {
                const nr = r + move[0];
                const nc = c + move[1];
                if (nr >= 0 && nr < m && nc >= 0 && nc < n) {
                    q.push([nr, nc]);
                }
            }
        }
    }
    return -1;
}

-----
function nearestExit(maze, entrance) 
    // Your code here
}

************************************
Question ID: 1927
function maxAscendingSum(nums) {
    let maxSum = 0, currentSum = nums[0];

    for (let i = 1; i < nums.length; ++i) {
        if (nums[i] > nums[i - 1]) {
            currentSum += nums[i];
        } else {
            maxSum = Math.max(maxSum, currentSum);
            currentSum = nums[i];
        }
    }

    return Math.max(maxSum, currentSum);
}

-----
function maxAscendingSum(nums) 
    // Your code here
}

************************************
Question ID: 1928
function getNumberOfBacklogOrders(orders) {
    const sell = new PriorityQueue((a, b) => a[0] - b[0]);
    const buy = new PriorityQueue((a, b) => b[0] - a[0]);

    for (const order of orders) {
        const [price, amount, orderType] = order;
        let currAmount = amount;
        if (orderType === 0) {
            while (currAmount > 0 && sell.size() > 0 && sell.peek()[0] <= price) {
                const executedAmount = Math.min(currAmount, sell.peek()[1]);
                currAmount -= executedAmount;
                sell.peek()[1] -= executedAmount;
                if (sell.peek()[1] === 0) sell.pop();
            }
            if (currAmount > 0) buy.push([price, currAmount]);
        } else {
            while (currAmount > 0 && buy.size() > 0 && buy.peek()[0] >= price) {
                const executedAmount = Math.min(currAmount, buy.peek()[1]);
                currAmount -= executedAmount;
                buy.peek()[1] -= executedAmount;
                if (buy.peek()[1] === 0) buy.pop();
            }
            if (currAmount > 0) sell.push([price, currAmount]);
        }
    }

    let res = 0;
    while (buy.size() > 0) res += buy.pop()[1];
    while (sell.size() > 0) res += sell.pop()[1];

    return res % 1000000007;
}


-----
function getNumberOfBacklogOrders(orders) 
    // Your code here
}


************************************
Question ID: 1929
function maxValue(n, index, maxSum) {
    maxSum -= n;
    let left = 0, right = maxSum, ans = 0;
    while (left <= right) {
        const mid = left + ((right - left) >> 1);
        let sum = Math.min(mid, index) * (Math.min(mid, index) + 1) / 2 + Math.min(mid, n - index - 1) * (Math.min(mid, n - index) + 1) / 2;
        if (mid > index) {
            sum += (mid - index - 1) * (mid - index) / 2;
        }
        if (mid > n - index) {
            sum += (mid - n + index) * (mid - n + index + 1) / 2;
        }
        if (sum <= maxSum) {
            ans = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return ans + 1;
}

-----
function maxValue(n, index, maxSum) 
    // Your code here
}

************************************
Question ID: 1930
function maxConsecutiveValues(coins) {
    coins.sort((a, b) => a - b);
    let maxValue = 0;
    for (let coin of coins) {
        if (coin <= maxValue + 1) {
            maxValue += coin;
        } else {
            break;
        }
    }
    return maxValue + 1;
}

-----
function maxConsecutiveValues(coins) 
    // Your code here
}

************************************
Question ID: 1931
function numOfWays(m, n) {
    let mod = 1e9 + 7;
    let a = 6, b = 6, c = 3, d = 3;
    while (--n) {
        let temp_a = a, temp_c = c;
        a = (a * 3 + b * 2) % mod;
        b = (temp_a * 2 + b * 2) % mod;
        c = (c * 3 + d * 2) % mod;
        d = (temp_c * 2 + d * 2) % mod;
    }
    return m === 1 ? b : (a + c) % mod;
}

-----
function numOfWays(m, n) 
    // Your code here
}

************************************
Question ID: 1933
function numDifferentIntegers(word) {
  word = word.replace(/\D/g, " ");
  let nums = word.split(/\s+/).filter(Boolean);
  let uniqueNums = new Set();
  for (let num of nums) {
    num = num.replace(/^0+/, "") || "0";
    uniqueNums.add(num);
  }
  return uniqueNums.size;
}

-----
function numDifferentIntegers(word) 
    // Your code here
}

************************************
Question ID: 1935
function min_operations(n) {
    let count = 1;
    let temp = 1;

    while (temp % n !== 0) {
        temp = (temp * 2) % n;
        count++;
    }

    return count;
}

-----
function min_operations(n) 
    // Your code here
}

************************************
Question ID: 1936
function numberOfNiceDivisors(primeFactors) {
    const MOD = 1000000007;
    let result = 1;
    for (let p = 2; p <= primeFactors; ++p) {
        if (primeFactors % p === 0) {
            let count = 0;
            while (primeFactors % p === 0) {
                primeFactors /= p;
                ++count;
            }
            result = (result * (count * 2 + 1)) % MOD;
        }
    }
    return result;
}

-----
function numberOfNiceDivisors(primeFactors) 
    // Your code here
}

************************************
Question ID: 1937
function maxPoints(points) {
    let m = points.length, n = points[0].length;
    let dp = new Array(n).fill(0);
    for (const row of points) {
        const next_dp = new Array(n).fill(0);
        for (let c1 = 0; c1 < n; ++c1) {
            const score = dp[c1] + row[c1] - c1;
            for (let c2 = 0; c2 < n; ++c2) {
                next_dp[c2] = Math.max(next_dp[c2], score - row[c1] + c2);
            }
        }
        dp = next_dp;
    }
    return Math.max(...dp);
}


-----
function maxPoints(points) 
    // Your code here
}


************************************
Question ID: 1938
function minOperations(nums) {
    let operations = 0;
    for (let i = 1; i < nums.length; ++i) {
        if (nums[i] <= nums[i - 1]) {
            operations += nums[i - 1] - nums[i] + 1;
            nums[i] = nums[i - 1] + 1;
        }
    }
    return operations;
}

-----
function minOperations(nums) 
    // Your code here
}

************************************
Question ID: 1942
function smallestChair(times, targetFriend) {
    const events = new Map();
    for (let i = 0; i < times.length; ++i) {
        events.set(times[i][0], i);
        events.set(times[i][1], ~i);
    }
    
    const availableChairs = new Set(Array.from({length: times.length}, (_, i) => i));

    const assignedChair = [];

    for (const [time, idx] of events) {
        if (idx >= 0) {
            const chair = Math.min(...availableChairs);
            availableChairs.delete(chair);
            assignedChair[idx] = chair;
            if (idx == targetFriend) return chair;
        } else {
            availableChairs.add(assignedChair[~idx]);
        }
    }

    return -1;
}

-----
function smallestChair(times, targetFriend) 
    // Your code here
}

************************************
