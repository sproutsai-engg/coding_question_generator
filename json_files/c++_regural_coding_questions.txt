Question ID: 1

#include <vector>
#include <unordered_map>

std::vector<int> twoSum(std::vector<int>& nums, int target) {
    std::unordered_map<int, int> map;
    for (int i = 0; i < nums.size(); i++) {
        int complement = target - nums[i];
        if (map.find(complement) != map.end()) {
            return {map[complement], i};
        }
        map[nums[i]] = i;
    }
    return {};
}

-----
#include <vector>
#include <unordered_map>

std::vector<int> twoSum(std::vector<int>& nums, int target) 
    // Your code here
}

************************************
Question ID: 3

#include <string>
#include <unordered_set>

int lengthOfLongestSubstring(std::string s) {
    int left = 0, right = 0, maxLength = 0;
    std::unordered_set<char> characters;

    while (right < s.size()) {
        if (characters.find(s[right]) == characters.end()) {
            characters.insert(s[right]);
            maxLength = std::max(maxLength, right - left + 1);
            right++;
        } else {
            characters.erase(s[left]);
            left++;
        }
    }

    return maxLength;
}

-----
#include <string>
#include <unordered_set>

int lengthOfLongestSubstring(std::string s) 
    // Your code here
}

************************************
Question ID: 4

double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    if (nums1.size() > nums2.size()) {
        return findMedianSortedArrays(nums2, nums1);
    }
    
    int x = nums1.size();
    int y = nums2.size();
    int low = 0;
    int high = x;
    
    while (low <= high) {
        int partitionX = (low + high) / 2;
        int partitionY = (x + y + 1) / 2 - partitionX;
        
        int maxLeftX = (partitionX == 0) ? INT_MIN : nums1[partitionX - 1];
        int minRightX = (partitionX == x) ? INT_MAX : nums1[partitionX];
        
        int maxLeftY = (partitionY == 0) ? INT_MIN : nums2[partitionY - 1];
        int minRightY = (partitionY == y) ? INT_MAX : nums2[partitionY];
        
        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {
            if ((x + y) % 2 == 0) {
                return (double(max(maxLeftX, maxLeftY) + min(minRightX, minRightY))) / 2;
            } else {
                return double(max(maxLeftX, maxLeftY));
            }
        } else if (maxLeftX > minRightY) {
            high = partitionX - 1;
        } else {
            low = partitionX + 1;
        }
    }    
    return 0;
}

-----
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) 
    // Your code here
}

************************************
Question ID: 5

#include <string>

std::string longestPalindromicSubstring(std::string s) {
  int n = s.size();
  if (n == 0) return "";
  int start = 0, maxLength = 1;

  for (int i = 0; i < n; ++i) {
    int l = i, r = i;

    while (r < n - 1 && s[r] == s[r + 1])
      r++;
    i = r;

    while (l > 0 && r < n - 1 && s[l - 1] == s[r + 1]) {
      l--;
      r++;
    }

    int length = r - l + 1;
    if (length > maxLength) {
      start = l;
      maxLength = length;
    }
  }

  return s.substr(start, maxLength);
}

-----
#include <string>

std::string longestPalindromicSubstring(std::string s) 
    // Your code here
}

************************************
Question ID: 6

#include <string>
#include <vector>

std::string convert(std::string s, int numRows) {
    if (numRows == 1 || numRows >= s.size()) return s;

    std::vector<std::string> rows(std::min(numRows, int(s.size())));
    int curRow = 0;
    bool goingDown = false;

    for (char c : s) {
        rows[curRow] += c;
        if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;
        curRow += goingDown ? 1 : -1;
    }

    std::string result;
    for (std::string row : rows) result += row;
    return result;
}

-----
#include <string>
#include <vector>

std::string convert(std::string s, int numRows) 
    // Your code here
}

************************************
Question ID: 7

int reverse(int x) {
    long long res = 0;
    while (x != 0) {
        res = res * 10 + x % 10;
        x /= 10;
    }
    return (res < INT_MIN || res > INT_MAX) ? 0 : res;
}

-----
int reverse(int x) 
    // Your code here
}

************************************
Question ID: 8

int myAtoi(string s) {
    long result = 0;
    int i = 0, sign = 1;
    while (s[i] == ' ') i++;
    if (s[i] == '-' || s[i] == '+') sign = (s[i++] == '+') ? 1 : -1;
    while (isdigit(s[i])) {
        result = result * 10 + (s[i++] - '0');
        if (result * sign > INT_MAX) return INT_MAX;
        if (result * sign < INT_MIN) return INT_MIN;
    }
    return result * sign;
}

-----
int myAtoi(string s) 
    // Your code here
}

************************************
Question ID: 9

bool isPalindrome(int x) {
    if (x < 0) return false;
    int original = x, reversed = 0;
    while (x > 0) {
        reversed = reversed * 10 + x % 10;
        x /= 10;
    }
    return original == reversed;
}


-----
bool isPalindrome(int x) 
    // Your code here
}


************************************
Question ID: 10

bool isMatch(std::string s, std::string p) {
    int m = s.length(), n = p.length();
    std::vector<std::vector<bool>> dp(m + 1, std::vector<bool>(n + 1, false));
    dp[0][0] = true;

    for (int j = 1; j <= n; j++) {
        if (p[j - 1] == '*' && dp[0][j - 2]) {
            dp[0][j] = true;
        }
    }

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (p[j - 1] == s[i - 1] || p[j - 1] == '.') {
                dp[i][j] = dp[i - 1][j - 1];
            } else if (p[j - 1] == '*') {
                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));
            }
        }
    }

    return dp[m][n];
}

-----
bool isMatch(std::string s, std::string p) 
    // Your code here
}

************************************
Question ID: 11

int maxArea(vector<int>& height) {
    int max_area = 0, left = 0, right = height.size() - 1;
    while (left < right) {
        max_area = max(max_area, min(height[left], height[right]) * (right - left));
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }
    return max_area;
}

-----
int maxArea(vector<int>& height) 
    // Your code here
}

************************************
Question ID: 12

#include <vector>
#include <string>

std::string intToRoman(int num) {
    std::vector<std::pair<int, std::string>> romans = {
        {1000, "M"},
        {900, "CM"},
        {500, "D"},
        {400, "CD"},
        {100, "C"},
        {90, "XC"},
        {50, "L"},
        {40, "XL"},
        {10, "X"},
        {9, "IX"},
        {5, "V"},
        {4, "IV"},
        {1, "I"}
    };
    std::string roman = "";
    for (const auto& p : romans) {
        while (num >= p.first) {
            roman += p.second;
            num -= p.first;
        }
    }
    return roman;
}

-----
#include <vector>
#include <string>

std::string intToRoman(int num) 
    // Your code here
}

************************************
Question ID: 13

int romanToInt(string s) {
    unordered_map<char, int> roman_values = { {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000} };
    int total = 0;
    int prev_value = 0;

    for (char c : s) {
        int current_value = roman_values[c];
        if (current_value > prev_value)
            total += current_value - (2 * prev_value);
        else
            total += current_value;
        prev_value = current_value;
    }

    return total;
}


-----
int romanToInt(string s) 
    // Your code here
}


************************************
Question ID: 14

#include <vector>
#include <string>
using namespace std;

string longestCommonPrefix(vector<string>& strs) {
    if (strs.empty()) return "";

    for (int i = 0; i < strs[0].size(); ++i) {
        char c = strs[0][i];
        for (int j = 1; j < strs.size(); ++j) {
            if (i == strs[j].size() || strs[j][i] != c) {
                return strs[0].substr(0, i);
            }
        }
    }
    return strs[0];
}

-----
#include <vector>
#include <string>
using namespace std;

string longestCommonPrefix(vector<string>& strs) 
    // Your code here
}

************************************
Question ID: 15

#include <vector>
#include <algorithm>

std::vector<std::vector<int>> threeSum(std::vector<int>& nums) {
    std::vector<std::vector<int>> result;
    std::sort(nums.begin(), nums.end());

    for (int i = 0; i < (int)nums.size() - 2; ++i) {
        if (i == 0 || nums[i] != nums[i - 1]) {
            int j = i + 1, k = nums.size() - 1;
            while (j < k) {
                int sum = nums[i] + nums[j] + nums[k];
                if (sum == 0) {
                    result.push_back({nums[i], nums[j], nums[k]});
                    while (j < k && nums[j] == nums[j + 1]) ++j;
                    while (j < k && nums[k] == nums[k - 1]) --k;
                    ++j;
                    --k;
                } else if (sum < 0) {
                    ++j;
                } else {
                    --k;
                }
            }
        }
    }

    return result;
}

-----
#include <vector>
#include <algorithm>

std::vector<std::vector<int>> threeSum(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 16

#include <algorithm>
#include <vector>

int threeSumClosest(std::vector<int>& nums, int target) {
    std::sort(nums.begin(), nums.end());
    int closest = nums[0] + nums[1] + nums[2];
    for (int i = 0; i < nums.size() - 2; ++i) {
        int left = i + 1;
        int right = nums.size() - 1;
        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];
            if (sum == target) {
                return sum;
            }
            if (abs(target - sum) < abs(target - closest)) {
                closest = sum;
            }
            if (sum < target) {
                left++;
            } else {
                right--;
            }
        }
    }
    return closest;
}

-----
#include <algorithm>
#include <vector>

int threeSumClosest(std::vector<int>& nums, int target) 
    // Your code here
}

************************************
Question ID: 17

#include <vector>
#include <string>
using namespace std;

vector<string> letterCombinations(string digits) {
    if(digits.empty()) return {};
    vector<string> phone = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    vector<string> result = {""};

    for (char d : digits) {
        vector<string> temp;
        for (const string &s : result) {
            for (char c : phone[d - '2']) {
                temp.push_back(s + c);
            }
        }
        result.swap(temp);
    }
    return result;
}

-----
#include <vector>
#include <string>
using namespace std;

vector<string> letterCombinations(string digits) 
    // Your code here
}

************************************
Question ID: 18

#include <vector>
#include <algorithm>
using namespace std;

vector<vector<int>> fourSum(vector<int>& nums, int target) {
    vector<vector<int>> result;
    int n = nums.size();
    if(n < 4)
        return result;

    sort(nums.begin(), nums.end());
    for(int i = 0; i < n - 3; i++) {
        if(i > 0 && nums[i] == nums[i-1])
            continue;

        for(int j = i + 1; j < n - 2; j++) {
            if(j > i + 1 && nums[j] == nums[j-1])
                continue;

            int left = j + 1;
            int right = n - 1;
            while(left < right) {
                int sum = nums[i] + nums[j] + nums[left] + nums[right];
                if(sum == target) {
                    result.push_back({nums[i], nums[j], nums[left], nums[right]});
                    ++left;
                    --right;
                    while(left < right && nums[left] == nums[left-1]) ++left;
                    while(left < right && nums[right] == nums[right+1]) --right;
                } else if(sum < target) {
                    ++left;
                } else {
                    --right;
                }
            }
        }
    }
    return result;
}


-----
#include <vector>
#include <algorithm>
using namespace std;

vector<vector<int>> fourSum(vector<int>& nums, int target) 
    // Your code here
}


************************************
Question ID: 20

bool isValid(std::string s) {
    std::stack<char> stack;

    for (char c : s) {
        if (c == '(' || c == '{' || c == '[') {
            stack.push(c);
        } else {
            if (stack.empty()) return false;
            if (c == ')' && stack.top() != '(') return false;
            if (c == '}' && stack.top() != '{') return false;
            if (c == ']' && stack.top() != '[') return false;
            stack.pop();
        }
    }

    return stack.empty();
}

-----
bool isValid(std::string s) 
    // Your code here
}

************************************
Question ID: 22

#include <vector>
#include <string>

void generateParenthesisHelper(int open, int close, std::string current, std::vector<std::string>& result) {
    if (open == 0 && close == 0) {
        result.push_back(current);
        return;
    }
    if (open > 0) {
        generateParenthesisHelper(open - 1, close + 1, current + '(', result);
    }
    if (close > 0) {
        generateParenthesisHelper(open, close - 1, current + ')', result);
    }
}

std::vector<std::string> generateParenthesis(int n) {
    std::vector<std::string> result;
    generateParenthesisHelper(n, 0, "", result);
    return result;
}


-----
#include <vector>
#include <string>

void generateParenthesisHelper(int open, int close, std::string current, std::vector<std::string>& result) 
    // Your code here
}


************************************
Question ID: 24

ListNode* swapPairs(ListNode* head) {
    if (!head || !head->next) return head;

    ListNode* second = head->next;
    head->next = swapPairs(second->next);
    second->next = head;
    
    return second;
}

-----
ListNode* swapPairs(ListNode* head) 
    // Your code here
}

************************************
Question ID: 26

int removeDuplicates(vector<int>& nums) {
    if (nums.empty()) return 0;
    int i = 0;
    for (int j = 1; j < nums.size(); j++) {
        if (nums[j] != nums[i]) {
            i++;
            nums[i] = nums[j];
        }
    }
    return i + 1;
}


-----
int removeDuplicates(vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 27

int removeElement(vector<int>& nums, int val) {
    int i = 0;
    for (int j = 0; j < nums.size(); j++) {
        if (nums[j] != val) {
            nums[i] = nums[j];
            i++;
        }
    }
    return i;
}

-----
int removeElement(vector<int>& nums, int val) 
    // Your code here
}

************************************
Question ID: 28

int strStr(string haystack, string needle) {
    if(needle.empty()) return 0;

    size_t pos = haystack.find(needle);
    if(pos != string::npos)
        return pos;
    return -1;
}

-----
int strStr(string haystack, string needle) 
    // Your code here
}

************************************
Question ID: 29

int divide(int dividend, int divisor) {
    if (dividend == INT_MIN && divisor == -1) {
        return INT_MAX;
    }

    int sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;

    long long dvd = labs(dividend);
    long long dvs = labs(divisor);
    int ans = 0;

    while (dvd >= dvs) {
        long long temp = dvs, multiple = 1;
        while (dvd >= (temp << 1)) {
            temp <<= 1;
            multiple <<= 1;
        }
        dvd -= temp;
        ans += multiple;
    }

    return ans * sign;
}

-----
int divide(int dividend, int divisor) 
    // Your code here
}

************************************
Question ID: 30

#include <vector>
#include <string>
#include <unordered_map>

std::vector<int> findSubstring(std::string s, std::vector<std::string>& words) {
    if (s.empty() || words.empty()) return {};
    
    std::unordered_map<std::string, int> word_count;
    for (const auto& word : words) {
        ++word_count[word];
    }
    
    int word_length = words[0].size();
    int total_words = words.size();
    int total_length = word_length * total_words;
    std::vector<int> result;
    
    for (int i = 0; i <= (int)s.size() - total_length; ++i) {
        std::unordered_map<std::string, int> temp_word_count;
        for (int j = 0; j < total_words; ++j) {
            std::string current_word = s.substr(i + j * word_length, word_length);
            if (word_count.find(current_word) == word_count.end()) break;
            ++temp_word_count[current_word];
            if (temp_word_count[current_word] > word_count[current_word]) break;
            if (j + 1 == total_words) result.push_back(i);
        }
    }
    
    return result;
}

-----
#include <vector>
#include <string>
#include <unordered_map>

std::vector<int> findSubstring(std::string s, std::vector<std::string>& words) 
    // Your code here
}

************************************
Question ID: 31

#include <algorithm>
void nextPermutation(vector<int>& nums) {
    int n = nums.size(), k, l;
    for (k = n - 2; k >= 0; k--) {
        if (nums[k] < nums[k + 1]) break;
    }
    if (k < 0) {
        reverse(nums.begin(), nums.end());
    } else {
        for (l = n - 1; l > k; l--) {
            if (nums[l] > nums[k]) break;
        }
        swap(nums[k], nums[l]);
        reverse(nums.begin() + k + 1, nums.end());
    }
}

-----
#include <algorithm>
void nextPermutation(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 32

#include <stack>

int longestValidParentheses(string s) {
    int n = s.length();
    int result = 0;
    std::stack<int> st;

    for (int i = 0; i < n; ++i) {
        if (s[i] == '(') {
            st.push(i);
        } else {
            if (!st.empty() && s[st.top()] == '(') {
                st.pop();
            } else {
                st.push(i);
            }
        }
    }

    if (st.empty()) {
        result = n;
    } else {
        int right = n, left = 0;
        while (!st.empty()) {
            left = st.top();
            st.pop();
            result = std::max(result, right - left - 1);
            right = left;
        }
        result = std::max(result, right);
    }

    return result;
}

-----
#include <stack>

int longestValidParentheses(string s) 
    // Your code here
}

************************************
Question ID: 33

int search(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        }
        if (nums[mid] >= nums[left]) {
            if (target >= nums[left] && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            if (target > nums[mid] && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    return -1;
}

-----
int search(vector<int>& nums, int target) 
    // Your code here
}

************************************
Question ID: 34

#include <vector>

std::vector<int> searchRange(std::vector<int>& nums, int target) {
    int start = -1, end = -1;
    int left = 0, right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
            if (nums[mid] == target) {
                start = mid;
            }
        }
    }
    
    left = 0, right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
            if (nums[mid] == target) {
                end = mid;
            }
        }
    }
    
    return {start, end};
}

-----
#include <vector>

std::vector<int> searchRange(std::vector<int>& nums, int target) 
    // Your code here
}

************************************
Question ID: 35

int searchInsert(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) return mid;
        if (nums[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return left;
}

-----
int searchInsert(vector<int>& nums, int target) 
    // Your code here
}

************************************
Question ID: 36

bool isValidSudoku(vector<vector<char>>& board) {
    unordered_set<string> seen;
    
    for(int i = 0; i < 9; i++) {
        for(int j = 0; j < 9; j++) {
            char current_val = board[i][j];
            if(current_val != '.') {
                string row = to_string(current_val) + " in row " + to_string(i);
                string col = to_string(current_val) + " in col " + to_string(j);
                string box = to_string(current_val) + " in box " + to_string(i/3) + "-" + to_string(j/3);
                if(seen.count(row) || seen.count(col) || seen.count(box)) {
                    return false;
                }
                seen.insert(row);
                seen.insert(col);
                seen.insert(box);
            }
        }
    }
    return true;
}


-----
bool isValidSudoku(vector<vector<char>>& board) 
    // Your code here
}


************************************
Question ID: 37

#include <vector>
#include <iostream>

using namespace std;

bool isValid(vector<vector<char>>& board, int row, int col, char c) {
    for (int i = 0; i < 9; i++) {
        if (board[i][col] == c) return false; 
        if (board[row][i] == c) return false; 
        if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false; 
    }
    return true;
}

bool solveSudokuHelper(vector<vector<char>>& board) {
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (board[i][j] == '.') {
                for (char c = '1'; c <= '9'; c++) {
                    if (isValid(board, i, j, c)) {
                        board[i][j] = c;

                        if (solveSudokuHelper(board))
                            return true;

                        board[i][j] = '.';
                    }
                }
                return false;
            }
        }
    }
    return true;
}

void solveSudoku(vector<vector<char>>& board) {
    solveSudokuHelper(board);
}

-----
#include <vector>
#include <iostream>

using namespace std;

bool isValid(vector<vector<char>>& board, int row, int col, char c) 
    // Your code here
}

************************************
Question ID: 38

#include <string>

std::string countAndSay(int n) {
    if (n == 1) return "1";
    std::string previous = countAndSay(n-1);
    std::string result = "";
    int count = 1;
    for (int i = 1; i < previous.length(); i++) {
        if (previous[i] == previous[i-1]) {
            count++;
        } else {
            result += std::to_string(count) + previous[i-1];
            count = 1;
        }
    }
    result += std::to_string(count) + previous.back();
    return result;
}

-----
#include <string>

std::string countAndSay(int n) 
    // Your code here
}

************************************
Question ID: 39

#include <vector>

void findCombinations(std::vector<int>& candidates, int target, int startIndex, std::vector<int>& current, std::vector<std::vector<int>>& result) {
    if (target == 0) {
        result.push_back(current);
        return;
    }
    if (startIndex == candidates.size() || target < 0) {
        return;
    }

    findCombinations(candidates, target, startIndex + 1, current, result);

    current.push_back(candidates[startIndex]);
    findCombinations(candidates, target - candidates[startIndex], startIndex, current, result);
    current.pop_back();
}

std::vector<std::vector<int>> combinationSum(std::vector<int>& candidates, int target) {
    std::vector<int> current;
    std::vector<std::vector<int>> result;
    findCombinations(candidates, target, 0, current, result);
    return result;
}


-----
#include <vector>

void findCombinations(std::vector<int>& candidates, int target, int startIndex, std::vector<int>& current, std::vector<std::vector<int>>& result) 
    // Your code here
}


************************************
Question ID: 40

#include <vector>
#include <algorithm>

void combine(std::vector<int>& candidates, int target, std::vector<std::vector<int>>& result, std::vector<int>& combination, int index) {
    if (target == 0) {
        result.push_back(combination);
        return;
    }

    for (int i = index; i < candidates.size() && target >= candidates[i]; ++i) {
        if (i == index || candidates[i] != candidates[i - 1]) {
            combination.push_back(candidates[i]);
            combine(candidates, target - candidates[i], result, combination, i + 1);
            combination.pop_back();
        }
    }
}

std::vector<std::vector<int>> combinationSum2(std::vector<int>& candidates, int target) {
    std::vector<std::vector<int>> result;
    std::vector<int> combination;
    std::sort(candidates.begin(), candidates.end());
    combine(candidates, target, result, combination, 0);
    return result;
}


-----
#include <vector>
#include <algorithm>

void combine(std::vector<int>& candidates, int target, std::vector<std::vector<int>>& result, std::vector<int>& combination, int index) 
    // Your code here
}


************************************
Question ID: 41

int firstMissingPositive(vector<int>& nums) {
    int n = nums.size();
    for(int i = 0; i < n; ++i)
        while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])
            swap(nums[i], nums[nums[i] - 1]);

    for(int i = 0; i < n; ++i)
        if(nums[i] != i + 1)
            return i + 1;
    return n + 1;
}

-----
int firstMissingPositive(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 42

#include <vector>
using namespace std;

int trap(vector<int>& height) {
    int n = height.size();
    int left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;

    while (left < right) {
        if (height[left] <= height[right]) {
            maxLeft = max(maxLeft, height[left]);
            water += maxLeft - height[left];
            left++;
        } else {
            maxRight = max(maxRight, height[right]);
            water += maxRight - height[right];
            right--;
        }
    }

    return water;
}

-----
#include <vector>
using namespace std;

int trap(vector<int>& height) 
    // Your code here
}

************************************
Question ID: 43

string multiply(string num1, string num2) {
    int m = num1.size(), n = num2.size();
    string res(m + n, '0');
    for (int i = m - 1; i >= 0; i--) {
        for (int j = n - 1; j >= 0; j--) {
            int p1 = i + j, p2 = i + j + 1;
            int mult = (num1[i] - '0') * (num2[j] - '0') + (res[p2] - '0');
            res[p1] += mult / 10;
            res[p2] = (mult % 10) + '0';
        }
    }
    while (res.size() > 1 && res[0] == '0')
        res.erase(res.begin());
    return res;
}

-----
string multiply(string num1, string num2) 
    // Your code here
}

************************************
Question ID: 44

bool isMatch(const std::string& s, const std::string& p) {
    int m = s.size(), n = p.size();
    int i = 0, j = 0, asterisk = -1, match;
    while (i < m) {
        if (j < n && (s[i] == p[j] || p[j] == '?')) {
            i++; j++;
        } else if (j < n && p[j] == '*') {
            match = i;
            asterisk = j++;
        } else if (asterisk >= 0) {
            i = ++match;
            j = asterisk + 1;
        } else {
            return false;
        }
    }
    while (j < n && p[j] == '*') j++;
    return j == n;
}

-----
bool isMatch(const std::string& s, const std::string& p) 
    // Your code here
}

************************************
Question ID: 45

int jump(vector<int>& nums) {
    int jumps = 0, current_end = 0, current_farthest = 0;
    
    for (int i = 0; i < nums.size() - 1; i++) {
        current_farthest = max(current_farthest, i + nums[i]);
        if (i == current_end) {
            jumps++;
            current_end = current_farthest;
        }
    }
    return jumps;
}

-----
int jump(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 46

#include <vector>

void helper(std::vector<int>& nums, int index, std::vector<std::vector<int>>& results) {
    if (index == nums.size() - 1) {
        results.push_back(nums);
        return;
    }

    for (int i = index; i < nums.size(); i++) {
        std::swap(nums[index], nums[i]);
        helper(nums, index + 1, results);
        std::swap(nums[index], nums[i]);
    }
}

std::vector<std::vector<int>> permute(std::vector<int>& nums) {
    std::vector<std::vector<int>> results;
    helper(nums, 0, results);
    return results;
}

-----
#include <vector>

void helper(std::vector<int>& nums, int index, std::vector<std::vector<int>>& results) 
    // Your code here
}

************************************
Question ID: 47

#include <vector>
#include <algorithm>

void backtrack(std::vector<std::vector<int>>& result, std::vector<int>& nums, int start) {
    if (start == nums.size()) {
        result.push_back(nums);
        return;
    }
    for (int i = start; i < nums.size(); i++) {
        if (i > start && nums[i] == nums[start]) continue;
        std::swap(nums[start], nums[i]);
        backtrack(result, nums, start + 1);
        std::swap(nums[start], nums[i]);
    }
}

std::vector<std::vector<int>> permuteUnique(std::vector<int>& nums) {
    std::sort(nums.begin(), nums.end());
    std::vector<std::vector<int>> result;
    backtrack(result, nums, 0);
    return result;
}


-----
#include <vector>
#include <algorithm>

void backtrack(std::vector<std::vector<int>>& result, std::vector<int>& nums, int start) 
    // Your code here
}


************************************
Question ID: 48

void rotate(vector<vector<int>>& matrix) {
    int n = matrix.size();
    for (int i = 0; i < n / 2; i++) {
        for (int j = i; j < n - i - 1; j++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[n - j - 1][i];
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
            matrix[j][n - i - 1] = temp;
        }
    }
}

-----
void rotate(vector<vector<int>>& matrix) 
    // Your code here
}

************************************
Question ID: 49

#include <vector>
#include <string>
#include <map>
#include <algorithm>

std::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) {
    std::map<std::string, std::vector<std::string>> anagramMap;

    for (std::string str : strs) {
        std::string key = str;
        std::sort(key.begin(), key.end());
        anagramMap[key].push_back(str);
    }

    std::vector<std::vector<std::string>> result;
    for (auto &entry : anagramMap) {
        result.push_back(entry.second);
    }

    return result;
}

-----
#include <vector>
#include <string>
#include <map>
#include <algorithm>

std::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) 
    // Your code here
}

************************************
Question ID: 50

double myPow(double x, int n) {
    if (n == 0) return 1;
    if (n < 0) {
        x = 1 / x;
        n = -n;
    }
    double result = 1;
    double currentProduct = x;
    for (long long i = n; i; i /= 2) {
        if ((i % 2) == 1) {
            result = result * currentProduct;
        }
        currentProduct = currentProduct * currentProduct;
    }
    return result;
}

-----
double myPow(double x, int n) 
    // Your code here
}

************************************
Question ID: 51

#include <vector>
#include <string>

bool isSafe(const std::vector<std::string>& board, int row, int col, int n) {
    for (int i = 0; i < col; ++i) {
        if (board[row][i] == 'Q') return false;
    }
    for (int i = row, j = col; i >= 0 && j >= 0; --i, --j) {
        if (board[i][j] == 'Q') return false;
    }
    for (int i = row, j = col; i < n && j >= 0; ++i, --j) {
        if (board[i][j] == 'Q') return false;
    }
    return true;
}

void solve(std::vector<std::vector<std::string>>& result, std::vector<std::string>& board, int n, int col) {
    if (col == n) {
        result.push_back(board);
        return;
    }
    for (int row = 0; row < n; ++row) {
        if (isSafe(board, row, col, n)) {
            board[row][col] = 'Q';
            solve(result, board, n, col + 1);
            board[row][col] = '.';
        }
    }
}

std::vector<std::vector<std::string>> solveNQueens(int n) {
    std::vector<std::vector<std::string>> result;
    std::vector<std::string> board(n, std::string(n, '.'));
    solve(result, board, n, 0);
    return result;
}

-----
#include <vector>
#include <string>

bool isSafe(const std::vector<std::string>& board, int row, int col, int n) 
    // Your code here
}

************************************
Question ID: 52

#include <vector>
using namespace std;

bool isSafe(vector<int> &cols, int row) {
    int col = cols.size();
    for (int i = 0; i < cols.size(); i++) {
        if (cols[i] == row || abs(i - col) == abs(cols[i] - row)) {
            return false;
        }
    }
    return true;
}

void backtrack(int n, vector<int> &cols, int &count) {
    if (cols.size() == n) {
        count++;
        return;
    }

    for (int i = 0; i < n; i++) {
        if (isSafe(cols, i)) {
            cols.push_back(i);
            backtrack(n, cols, count);
            cols.pop_back();
        }
    }
}

int totalNQueens(int n) {
    vector<int> cols;
    int count = 0;
    backtrack(n, cols, count);
    return count;
}


-----
#include <vector>
using namespace std;

bool isSafe(vector<int> &cols, int row) 
    // Your code here
}


************************************
Question ID: 53

int maxSubArray(vector<int>& nums) {
    int max_sum = nums[0];
    int current_sum = max_sum;
    
    for (int i = 1; i < nums.size(); i++) {
        current_sum = max(current_sum + nums[i], nums[i]);
        max_sum = max(max_sum, current_sum);
    }
    
    return max_sum;
}

-----
int maxSubArray(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 54

#include <vector>
using namespace std;

vector<int> spiralOrder(vector<vector<int>>& matrix) {
    vector<int> result;
    if (matrix.empty()) return result;
    int m = matrix.size(), n = matrix[0].size();
    int rowStart = 0, colStart = 0, rowEnd = m - 1, colEnd = n - 1;

    while (rowStart <= rowEnd && colStart <= colEnd) {
        for (int i = colStart; i <= colEnd; ++i) {
            result.push_back(matrix[rowStart][i]);
        }
        rowStart++;
        for (int i = rowStart; i <= rowEnd; ++i) {
            result.push_back(matrix[i][colEnd]);
        }
        colEnd--;
        if (rowStart <= rowEnd) {
            for (int i = colEnd; i >= colStart; --i) {
                result.push_back(matrix[rowEnd][i]);
            }
        }
        rowEnd--;
        if (colStart <= colEnd) {
            for (int i = rowEnd; i >= rowStart; --i) {
                result.push_back(matrix[i][colStart]);
            }
        }
        colStart++;
    }
    return result;
}

-----
#include <vector>
using namespace std;

vector<int> spiralOrder(vector<vector<int>>& matrix) 
    // Your code here
}

************************************
Question ID: 55

bool canJump(vector<int>& nums) {
    int maxReach = 0;
    for (int i = 0; i < nums.size(); ++i) {
        if (i > maxReach) return false;
        maxReach = max(maxReach, i + nums[i]);
    }
    return true;
}

-----
bool canJump(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 56

#include <vector>
#include <algorithm>

std::vector<std::vector<int>> merge(std::vector<std::vector<int>>& intervals) {
    if (intervals.empty()) return {};

    std::sort(intervals.begin(), intervals.end());
    std::vector<std::vector<int>> result;
    result.push_back(intervals[0]);

    for (int i = 1; i < intervals.size(); i++) {
        if (result.back()[1] >= intervals[i][0]) {
            result.back()[1] = std::max(result.back()[1], intervals[i][1]);
        } else {
            result.push_back(intervals[i]);
        }
    }

    return result;
}

-----
#include <vector>
#include <algorithm>

std::vector<std::vector<int>> merge(std::vector<std::vector<int>>& intervals) 
    // Your code here
}

************************************
Question ID: 57

#include <vector>
using namespace std;

vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
    vector<vector<int>> result;
    int start_pos = 0;

    while (start_pos < intervals.size() && intervals[start_pos][1] < newInterval[0]) {
        result.push_back(intervals[start_pos]);
        start_pos++;
    }

    while (start_pos < intervals.size() && intervals[start_pos][0] <= newInterval[1]) {
        newInterval[0] = min(newInterval[0], intervals[start_pos][0]);
        newInterval[1] = max(newInterval[1], intervals[start_pos][1]);
        start_pos++;
    }

    result.push_back(newInterval);

    while (start_pos < intervals.size()) {
        result.push_back(intervals[start_pos]);
        start_pos++;
    }

    return result;
}

-----
#include <vector>
using namespace std;

vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) 
    // Your code here
}

************************************
Question ID: 58

int lengthOfLastWord(string s) {
    int length = 0;
    int tail = s.length() - 1;
    while (tail >= 0 && s[tail] == ' ') tail--;
    while (tail >= 0 && s[tail] != ' ') {
        length++;
        tail--;
    }
    return length;
}

-----
int lengthOfLastWord(string s) 
    // Your code here
}

************************************
Question ID: 59

#include <vector>

std::vector<std::vector<int>> generateMatrix(int n) {
    std::vector<std::vector<int>> matrix(n, std::vector<int>(n));
    int value = 1, top = 0, bottom = n - 1, left = 0, right = n - 1;

    while (value <= n * n) {
        for (int i = left; i <= right; i++) {
            matrix[top][i] = value++;
        }

        for (int i = top + 1; i <= bottom; i++) {
            matrix[i][right] = value++;
        }

        if (top < bottom && left < right) {
            for (int i = right - 1; i >= left; i--) {
                matrix[bottom][i] = value++;
            }

            for (int i = bottom - 1; i > top; i--) {
                matrix[i][left] = value++;
            }
        }

        top++, bottom--, left++, right--;
    }

    return matrix;
}

-----
#include <vector>

std::vector<std::vector<int>> generateMatrix(int n) 
    // Your code here
}

************************************
Question ID: 60

#include <string>
#include <vector>

std::string getPermutation(int n, int k) {
    std::vector<int> factorials(n, 1);
    std::vector<char> nums(n, '1');
    std::string result;
    int index;

    for (int i = 1; i <= n; ++i) {
        nums[i - 1] += i - 1;
        factorials[i - 1] *= i;
    }

    k--;

    for (int i = n; i >= 1; --i) {
        index = k / factorials[i - 1];
        k %= factorials[i - 1];
        result.push_back(nums[index]);
        nums.erase(nums.begin() + index);
    }

    return result;
}

-----
#include <string>
#include <vector>

std::string getPermutation(int n, int k) 
    // Your code here
}

************************************
Question ID: 62

int uniquePaths(int m, int n) {
    vector<vector<int>> dp(m, vector<int>(n, 1));
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}

-----
int uniquePaths(int m, int n) 
    // Your code here
}

************************************
Question ID: 63

int uniquePathsWithObstacles(vector<vector<int>>& grid) {
    int m = grid.size();
    int n = grid[0].size();
    if (grid[0][0] == 1) return 0;
    
    grid[0][0] = 1;
    for (int i = 1; i < m; ++i)
        grid[i][0] = (grid[i][0] == 0 && grid[i - 1][0] == 1) ? 1 : 0;
    for (int i = 1; i < n; ++i)
        grid[0][i] = (grid[0][i] == 0 && grid[0][i - 1] == 1) ? 1 : 0;

    for (int i = 1; i < m; ++i)
        for (int j = 1; j < n; ++j)
            if (grid[i][j] == 0) 
                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];
            else 
                grid[i][j] = 0;

    return grid[m - 1][n - 1];
}

-----
int uniquePathsWithObstacles(vector<vector<int>>& grid) 
    // Your code here
}

************************************
Question ID: 64

int minPathSum(vector<vector<int>>& grid) {
    int m = grid.size(), n = grid[0].size();
        
    for(int i = 1; i < m; i++)
        grid[i][0] += grid[i - 1][0];
        
    for(int i = 1; i < n; i++)
        grid[0][i] += grid[0][i - 1];
        
    for(int i = 1; i < m; i++){
        for(int j = 1; j < n; j++){
            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]);
        }
    }
    return grid[m - 1][n - 1];
}

-----
int minPathSum(vector<vector<int>>& grid) 
    // Your code here
}

************************************
Question ID: 65

#include <regex>
#include <string>

bool isNumber(const std::string& s) {
    std::regex pattern("^[-+]?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(e[-+]?[0-9]+)?$");
    return std::regex_match(s, pattern);
}


-----
#include <regex>
#include <string>

bool isNumber(const std::string& s) 
    // Your code here
}


************************************
Question ID: 66

#include <vector>

std::vector<int> plusOne(std::vector<int>& digits) {
    int n = digits.size();

    for(int i = n - 1; i >= 0; i--) {
        if(digits[i] < 9) {
            digits[i]++;
            return digits;
        }
        digits[i] = 0;
    }

    digits.insert(digits.begin(), 1);
    return digits;
}


-----
#include <vector>

std::vector<int> plusOne(std::vector<int>& digits) 
    // Your code here
}


************************************
Question ID: 67

std::string addBinary(std::string a, std::string b) {
    std::string result = "";
    int i = a.size() - 1, j = b.size() - 1, carry = 0;
    while (i >= 0 || j >= 0 || carry) {
        if (i >= 0) carry += a[i--] - '0';
        if (j >= 0) carry += b[j--] - '0';
        result = char(carry % 2 + '0') + result;
        carry /= 2;
    }
    return result;
}

-----
std::string addBinary(std::string a, std::string b) 
    // Your code here
}

************************************
Question ID: 68

#include <vector>
#include <string>
using namespace std;

vector<string> fullJustify(vector<string>& words, int maxWidth) {
    vector<string> result;
    int idx = 0;
    while (idx < words.size()) {
        int totalChars = words[idx].size();
        int last = idx + 1;
        while (last < words.size()) {
            if (totalChars + 1 + words[last].length() > maxWidth) break;
            totalChars += 1 + words[last].length();
            last++;
        }
        int gaps = last - idx - 1;
        stringstream line;
        if (last == words.size() || gaps == 0) {
            for (int i = idx; i < last; i++) {
                line << words[i];
                if (i < last - 1) line << " ";
            }
            line << string(maxWidth - line.str().size(), ' ');
        } else {
            int evenSpaces = (maxWidth - totalChars) / gaps;
            int extraSpaces = (maxWidth - totalChars) % gaps;
            for (int i = idx; i < last; i++) {
                line << words[i];
                if (i < last - 1) {
                    line << string(evenSpaces + (i - idx < extraSpaces ? 1 : 0), ' ');
                }
            }
        }
        idx = last;
        result.push_back(line.str());
    }
    return result;
}

-----
#include <vector>
#include <string>
using namespace std;

vector<string> fullJustify(vector<string>& words, int maxWidth) 
    // Your code here
}

************************************
Question ID: 69

int mySqrt(int x) {
    if (x == 0 || x == 1) return x;
    int start = 1, end = x, ans;
    while (start <= end) {
        int mid = (start + end) / 2;
        if (mid * mid == x) return mid;
        if (mid * mid < x) {
            start = mid + 1;
            ans = mid;
        } else {
            end = mid - 1;
        }
    }
    return ans;
}

-----
int mySqrt(int x) 
    // Your code here
}

************************************
Question ID: 70

int climbStairs(int n) {
    if(n <= 2) return n;
    int a = 1, b = 2, c;
    for(int i = 3; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    return c;
}


-----
int climbStairs(int n) 
    // Your code here
}


************************************
Question ID: 71

#include <string>
#include <vector>
#include <sstream>

std::string simplifyPath(std::string path) {
    std::vector<std::string> stack;
    std::istringstream ss{path};
    std::string part;

    while (std::getline(ss, part, '/')) {
        if (part.empty() || part == ".") continue;
        if (part == "..") {
            if (!stack.empty()) stack.pop_back();
        } else {
            stack.push_back(part);
        }
    }

    std::string canonicalPath;
    for (const auto &piece : stack) {
        canonicalPath += '/' + piece;
    }
    return stack.empty() ? "/" : canonicalPath;
}

-----
#include <string>
#include <vector>
#include <sstream>

std::string simplifyPath(std::string path) 
    // Your code here
}

************************************
Question ID: 72

int minDistance(string word1, string word2) {
    int m = word1.size();
    int n = word2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    
    for (int i = 0; i <= m; i++) {
        for (int j = 0; j <= n; j++) {
            if (i == 0) {
                dp[i][j] = j;
            } else if (j == 0) {
                dp[i][j] = i;
            } else if (word1[i - 1] == word2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
            }
        }
    }
    
    return dp[m][n];
}

-----
int minDistance(string word1, string word2) 
    // Your code here
}

************************************
Question ID: 73

void setZeroes(vector<vector<int>>& matrix) {
    int rows = matrix.size();
    int cols = matrix[0].size();
    bool firstRow = false, firstCol = false;
    
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (matrix[i][j] == 0) {
                if (i == 0) firstRow = true;
                if (j == 0) firstCol = true;
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }

    for (int i = 1; i < rows; i++) {
        for (int j = 1; j < cols; j++) {
            if (matrix[i][0] == 0 || matrix[0][j] == 0)
                matrix[i][j] = 0;
        }
    }

    if (firstRow) {
        for (int j = 0; j < cols; j++)
            matrix[0][j] = 0;
    }

    if (firstCol) {
        for (int i = 0; i < rows; i++)
            matrix[i][0] = 0;
    }
}

-----
void setZeroes(vector<vector<int>>& matrix) 
    // Your code here
}

************************************
Question ID: 74

bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int m = matrix.size();
    int n = matrix[0].size();
    int l = 0, r = m * n - 1;
    
    while (l <= r) {
        int mid = l + (r - l) / 2;
        int midVal = matrix[mid / n][mid % n];
        
        if (midVal == target) {
            return true;
        } else if (midVal < target) {
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    
    return false;
}

-----
bool searchMatrix(vector<vector<int>>& matrix, int target) 
    // Your code here
}

************************************
Question ID: 75

void sortColors(vector<int>& nums) {
    int red = 0, white = 0, blue = nums.size() - 1;
    while (white <= blue) {
        if (nums[white] == 0) {
            swap(nums[red++], nums[white++]);
        } else if (nums[white] == 1) {
            white++;
        } else {
            swap(nums[white], nums[blue--]);
        }
    }
}

-----
void sortColors(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 76

#include <string>
#include <unordered_map>

std::string min_window(std::string s, std::string t) {
    std::unordered_map<char, int> need, window;
    for (char c : t) need[c]++;
    
    int left = 0, right = 0;
    int valid = 0;
    int start = 0, length = INT_MAX;

    while (right < s.length()) {
        char c = s[right];
        right++;
        if (need.count(c)) {
            window[c]++;
            if (window[c] <= need[c]) valid++;
        }

        while (valid == t.length()) {
            if (right - left < length) {
                start = left;
                length = right - left;
            }

            char d = s[left];
            left++;
            if (need.count(d)) {
                if (window[d] <= need[d]) valid--;
                window[d]--;
            }
        }
    }
    return length == INT_MAX ? "" : s.substr(start, length);
}


-----
#include <string>
#include <unordered_map>

std::string min_window(std::string s, std::string t) 
    // Your code here
}


************************************
Question ID: 77

#include <vector>

void backtrack(int n, int k, int start, std::vector<int>& current, std::vector<std::vector<int>>& result) {
    if (current.size() == k) {
        result.push_back(current);
        return;
    }

    for (int i = start; i <= n; ++i) {
        current.push_back(i);
        backtrack(n, k, i + 1, current, result);
        current.pop_back();
    }
}

std::vector<std::vector<int>> combine(int n, int k) {
    std::vector<std::vector<int>> result;
    std::vector<int> current;
    backtrack(n, k, 1, current, result);
    return result;
}

-----
#include <vector>

void backtrack(int n, int k, int start, std::vector<int>& current, std::vector<std::vector<int>>& result) 
    // Your code here
}

************************************
Question ID: 78

#include <vector>

std::vector<std::vector<int>> subsets(std::vector<int>& nums) {
    std::vector<std::vector<int>> result;
    int n = nums.size();
    int num_subsets = 1 << n;

    for (int i = 0; i < num_subsets; ++i) {
        std::vector<int> subset;
        for (int j = 0; j < n; ++j) {
            if (i & (1 << j)) {
                subset.push_back(nums[j]);
            }
        }
        result.push_back(subset);
    }
    return result;
}

-----
#include <vector>

std::vector<std::vector<int>> subsets(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 79

bool exist(vector<vector<char>>& board, string word) {
    int m = board.size();
    int n = board[0].size();
    
    function<bool(int, int, int)> dfs = [&](int i, int j, int k) {
        if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] != word[k])
            return false;
        if (k == word.length() - 1)
            return true;
        
        char temp = board[i][j];
        board[i][j] = '/';
        bool res = dfs(i + 1, j, k + 1) || dfs(i - 1, j, k + 1) || dfs(i, j + 1, k + 1) || dfs(i, j - 1, k + 1);
        board[i][j] = temp;
        return res;
    };
    
    for (int i = 0; i < m; i++)
        for (int j = 0; j < n; j++)
            if (dfs(i, j, 0))
                return true;
    return false;
}


-----
bool exist(vector<vector<char>>& board, string word) 
    // Your code here
}


************************************
Question ID: 80

int removeDuplicates(vector<int>& nums) {
    int i = 0;
    for (int num : nums) {
        if (i < 2 || num > nums[i - 2]) {
            nums[i++] = num;
        }
    }
    return i;
}

-----
int removeDuplicates(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 81

bool search(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) return true;

        if (nums[mid] == nums[left]) {
            left++;
        } else if (nums[mid] > nums[left]) {
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    return false;
}

-----
bool search(vector<int>& nums, int target) 
    // Your code here
}

************************************
Question ID: 84

int largestRectangleArea(vector<int>& heights) {
    heights.push_back(0);
    stack<int> s;
    int max_area = 0;
    for (int i = 0; i < heights.size(); i++) {
        while (!s.empty() && heights[s.top()] > heights[i]) {
            int height = heights[s.top()];
            s.pop();
            int width = s.empty() ? i : i - s.top() - 1;
            max_area = max(max_area, height * width);
        }
        s.push(i);
    }
    return max_area;
}

-----
int largestRectangleArea(vector<int>& heights) 
    // Your code here
}

************************************
Question ID: 85

#include <vector>
#include <stack>
using namespace std;

int maximalRectangle(vector<vector<char>>& matrix) {
    if (matrix.empty()) return 0;

    int m = matrix.size();
    int n = matrix[0].size();
    vector<int> height(n + 1, 0);
    int maxArea = 0;

    for (int i = 0; i < m; ++i) {
        stack<int> s;
        for (int j = 0; j <= n; ++j) {
            if (j < n) {
                height[j] = matrix[i][j] == '1' ? height[j] + 1 : 0;
            }
            while (!s.empty() && height[j] < height[s.top()]) {
                int h = height[s.top()];
                s.pop();
                int w = s.empty() ? j : j - s.top() - 1;
                maxArea = max(maxArea, h * w);
            }
            s.push(j);
        }
    }

    return maxArea;
}


-----
#include <vector>
#include <stack>
using namespace std;

int maximalRectangle(vector<vector<char>>& matrix) 
    // Your code here
}


************************************
Question ID: 87

bool isScramble(string s1, string s2) {
    if (s1 == s2) return true;
    if (s1.size() != s2.size() || sort(s1.begin(), s1.end()) != sort(s2.begin(), s2.end())) return false;

    for (int i = 1; i < s1.size(); i++) {
        if (isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i), s2.substr(i)))
            return true;
        if (isScramble(s1.substr(0, i), s2.substr(s2.size() - i)) && isScramble(s1.substr(i), s2.substr(0, s2.size() - i)))
            return true;
    }
    return false;
}

-----
bool isScramble(string s1, string s2) 
    // Your code here
}

************************************
Question ID: 88

void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
    int i = m - 1, j = n - 1, k = m + n - 1;
    while (i >= 0 && j >= 0) {
        if (nums1[i] > nums2[j])
            nums1[k--] = nums1[i--];
        else
            nums1[k--] = nums2[j--];
    }
    while (j >= 0) {
        nums1[k--] = nums2[j--];
    }
}

-----
void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) 
    // Your code here
}

************************************
Question ID: 89

#include <vector>

std::vector<int> grayCode(int n) {
    std::vector<int> result;
    for (int i = 0; i < (1 << n); i++) {
        result.push_back(i ^ (i >> 1));
    }
    return result;
}

-----
#include <vector>

std::vector<int> grayCode(int n) 
    // Your code here
}

************************************
Question ID: 90

#include <vector>
#include <set>
using namespace std;

vector<vector<int>> subsetsWithDup(vector<int>& nums) {
    set<vector<int>> result;
    vector<int> subset;
    sort(nums.begin(), nums.end());
    backtrack(nums, 0, subset, result);
    return vector<vector<int>>(result.begin(), result.end());
}

void backtrack(vector<int>& nums, int index, vector<int>& subset, set<vector<int>>& result) {
    result.insert(subset);
    for (int i = index; i < nums.size(); i++) {
        subset.push_back(nums[i]);
        backtrack(nums, i + 1, subset, result);
        subset.pop_back();
    }
}

-----
#include <vector>
#include <set>
using namespace std;

vector<vector<int>> subsetsWithDup(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 91

#include <string>
#include <vector>

int numDecodings(std::string s) {
    int n = s.size();
    std::vector<int> dp(n + 1, 0);
    dp[0] = 1;
    dp[1] = s[0] != '0' ? 1 : 0;

    for (int i = 2; i <= n; ++i) {
        int oneDigit = stoi(s.substr(i - 1, 1));
        int twoDigits = stoi(s.substr(i - 2, 2));

        if (oneDigit >= 1)
            dp[i] += dp[i - 1];
        if (twoDigits >= 10 && twoDigits <= 26)
            dp[i] += dp[i - 2];
    }
    return dp[n];
}


-----
#include <string>
#include <vector>

int numDecodings(std::string s) 
    // Your code here
}


************************************
Question ID: 92

ListNode* reverseBetween(ListNode* head, int left, int right) {
    if (!head || left == right) return head;
    ListNode dummy(0);
    dummy.next = head;
    ListNode* pre = &dummy;
    for (int i = 1; i < left; ++i) pre = pre->next;
    ListNode* cur = pre->next;
    for (int i = left; i < right; ++i) {
        ListNode* t = cur->next;
        cur->next = t->next;
        t->next = pre->next;
        pre->next = t;
    }
    return dummy.next;
}

-----
ListNode* reverseBetween(ListNode* head, int left, int right) 
    // Your code here
}

************************************
Question ID: 93

#include<vector>
#include<string>
using namespace std;

vector<string> restore_ip_address(string s) {
    vector<string> result;
    string ip;
    dfs(result, s, ip, 0, 0);
    return result;
}

void dfs(vector<string>& result, string s, string ip, int start, int part) {
    if (part == 4 && start == s.size()) {
        ip.pop_back();
        result.push_back(ip);
        return;
    }
    if (part == 4 || start == s.size()) return;

    int num = 0;
    for (int i = start; i < s.size(); i++) {
        num = num * 10 + (s[i] - '0');
        if (num > 255) break;
        ip += s[i];
        dfs(result, s, ip + '.', i + 1, part + 1);
        if (num == 0) break;
    }
}


-----
#include<vector>
#include<string>
using namespace std;

vector<string> restore_ip_address(string s) 
    // Your code here
}


************************************
Question ID: 96

int numTrees(int n) {
    vector<int> dp(n + 1, 0);
    dp[0] = dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        for (int j = 0; j < i; j++) {
            dp[i] += dp[j] * dp[i - j - 1];
        }
    }
    return dp[n];
}

-----
int numTrees(int n) 
    // Your code here
}

************************************
Question ID: 97

bool isInterleave(string s1, string s2, string s3) {
    int m = s1.length(), n = s2.length();
    if (m + n != s3.length()) return false;

    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));
    dp[0][0] = true;
    for (int i = 1; i <= m; i++)
        dp[i][0] = dp[i - 1][0] && s1[i - 1] == s3[i - 1];
    for (int j = 1; j <= n; j++)
        dp[0][j] = dp[0][j - 1] && s2[j - 1] == s3[j - 1];

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) ||
                       (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);
        }
    }

    return dp[m][n];
}

-----
bool isInterleave(string s1, string s2, string s3) 
    // Your code here
}

************************************
Question ID: 99

void inorder(TreeNode* node, TreeNode*& first, TreeNode*& second, TreeNode*& prev) {
    if (!node) return;
    inorder(node->left, first, second, prev);
    if (prev && prev->val > node->val) {
        if (!first) first = prev;
        second = node;
    }
    prev = node;
    inorder(node->right, first, second, prev);
}

void recoverTree(TreeNode* root) {
    TreeNode *first = nullptr, *second = nullptr, *prev = nullptr;
    inorder(root, first, second, prev);
    std::swap(first->val, second->val);
}

-----
void inorder(TreeNode* node, TreeNode*& first, TreeNode*& second, TreeNode*& prev) 
    // Your code here
}

************************************
Question ID: 101

bool isSymmetric(TreeNode* root) {
    return checkSymmetry(root, root);
}

bool checkSymmetry(TreeNode* node1, TreeNode* node2) {
    if (!node1 && !node2) return true;
    if (!node1 || !node2) return false;
    return (node1->val == node2->val) && checkSymmetry(node1->right, node2->left) && checkSymmetry(node1->left, node2->right);
}

-----
bool isSymmetric(TreeNode* root) 
    // Your code here
}

************************************
Question ID: 104

int maxDepth(TreeNode* root) {
    if (root == nullptr) {
        return 0;
    }
    return 1 + max(maxDepth(root->left), maxDepth(root->right));
}

-----
int maxDepth(TreeNode* root) 
    // Your code here
}

************************************
Question ID: 107

#include <vector>
#include <queue>

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

std::vector<std::vector<int>> levelOrderBottom(TreeNode* root) {
    std::vector<std::vector<int>> result;
    if (root == nullptr) return result;

    std::queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        std::vector<int> level;
        int size = q.size();

        for (int i = 0; i < size; i++) {
            TreeNode* current = q.front();
            q.pop();
            level.push_back(current->val);

            if (current->left) q.push(current->left);
            if (current->right) q.push(current->right);
        }
        result.insert(result.begin(), level);
    }

    return result;
}

-----
#include <vector>
#include <queue>

struct TreeNode 
    // Your code here
}

************************************
Question ID: 111

int minDepth(TreeNode* root) {
    if (!root) return 0;
    int left = minDepth(root->left);
    int right = minDepth(root->right);
    return (left == 0 || right == 0) ? left + right + 1 : min(left, right) + 1;
}

-----
int minDepth(TreeNode* root) 
    // Your code here
}

************************************
Question ID: 114

void flatten(TreeNode* root) {
    if (!root) return;
    flatten(root->left);
    flatten(root->right);
    if (root->left) {
        TreeNode* temp = root->right;
        root->right = root->left;
        root->left = nullptr;
        while (root->right) root = root->right;
        root->right = temp;
    }
}

-----
void flatten(TreeNode* root) 
    // Your code here
}

************************************
Question ID: 115

int numDistinct(string s, string t) {
    int m = s.size(), n = t.size();
    vector<vector<unsigned int>> dp(m + 1, vector<unsigned int>(n + 1, 0));

    for (int i = 0; i <= m; i++) {
        dp[i][0] = 1;
    }

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s[i - 1] == t[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }

    return dp[m][n];
}

-----
int numDistinct(string s, string t) 
    // Your code here
}

************************************
Question ID: 116

void connect(Node* root) {
    if (!root) return;
    if (root->left) {
        root->left->next = root->right;
        if (root->next) {
            root->right->next = root->next->left;
        }
    }
    connect(root->left);
    connect(root->right);
}


-----
void connect(Node* root) 
    // Your code here
}


************************************
Question ID: 118

vector<vector<int>> generate(int numRows) {
    vector<vector<int>> pascalsTriangle(numRows);
    for (int i = 0; i < numRows; i++) {
        pascalsTriangle[i].resize(i + 1);
        pascalsTriangle[i][0] = pascalsTriangle[i][i] = 1;
        for (int j = 1; j < i; j++) {
            pascalsTriangle[i][j] = pascalsTriangle[i - 1][j - 1] + pascalsTriangle[i - 1][j];
        }
    }
    return pascalsTriangle;
}

-----
vector<vector<int>> generate(int numRows) 
    // Your code here
}

************************************
Question ID: 119

#include <vector>
using namespace std;

vector<int> getRow(int rowIndex) {
    vector<int> row(rowIndex + 1, 1);
    for (int i = 1; i <= rowIndex; i++) {
        for (int j = i - 1; j > 0; j--) {
            row[j] += row[j - 1];
        }
    }
    return row;
}

-----
#include <vector>
using namespace std;

vector<int> getRow(int rowIndex) 
    // Your code here
}

************************************
Question ID: 120

int minimumTotal(vector<vector<int>>& triangle) {
    for (int row = triangle.size() - 2; row >= 0; row--) {
        for (int col = 0; col < triangle[row].size(); col++) {
            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1]);
        }
    }
    return triangle[0][0];
}

-----
int minimumTotal(vector<vector<int>>& triangle) 
    // Your code here
}

************************************
Question ID: 121

int maxProfit(vector<int>& prices) {
    int minPrice = INT_MAX;
    int maxProfit = 0;
    for (int price : prices) {
        minPrice = min(minPrice, price);
        maxProfit = max(maxProfit, price - minPrice);
    }
    return maxProfit;
}

-----
int maxProfit(vector<int>& prices) 
    // Your code here
}

************************************
Question ID: 122

int maxProfit(vector<int>& prices) {
    int max_profit = 0;
    for (int i = 1; i < prices.size(); i++) {
        if (prices[i] > prices[i - 1]) {
            max_profit += prices[i] - prices[i - 1];
        }
    }
    return max_profit;
}

-----
int maxProfit(vector<int>& prices) 
    // Your code here
}

************************************
Question ID: 123

int maxProfit(vector<int>& prices) {
    int buy1 = INT_MAX, buy2 = INT_MAX;
    int profit1 = 0, profit2 = 0;
    
    for (int price : prices) {
        buy1 = min(buy1, price);
        profit1 = max(profit1, price - buy1);
        buy2 = min(buy2, price - profit1);
        profit2 = max(profit2, price - buy2);
    }
    
    return profit2;
}

-----
int maxProfit(vector<int>& prices) 
    // Your code here
}

************************************
Question ID: 125

#include <cctype>
#include <algorithm>

bool isPalindrome(std::string s) {
    s.erase(std::remove_if(s.begin(), s.end(), [](char c) { return !std::isalnum(c); }), s.end());
    std::transform(s.begin(), s.end(), s.begin(), ::tolower);
    int left = 0, right = s.size() - 1;
    while (left < right) {
        if (s[left++] != s[right--]) return false;
    }
    return true;
}

-----
#include <cctype>
#include <algorithm>

bool isPalindrome(std::string s) 
    // Your code here
}

************************************
Question ID: 126

#include <vector>
#include <string>
#include <queue>
#include <unordered_set>
#include <unordered_map>

std::vector<std::vector<std::string>> findLadders(std::string beginWord, std::string endWord, std::vector<std::string>& wordList) {
    std::unordered_set<std::string> dict(wordList.begin(), wordList.end());
    if (dict.find(endWord) == dict.end()) {
        return {};
    }
    std::unordered_map<std::string, std::vector<std::string>> adjacent;
    std::unordered_map<std::string, int> distance;
    
    auto neighbors = [&](const std::string& word) {
        std::vector<std::string> result;
        std::string temp = word;
        for (char& ch : temp) {
            char original = ch;
            for (int i = 'a'; i <= 'z'; ++i) {
                ch = i;
                if (dict.count(temp) && temp != word) {
                    result.push_back(temp);
                }
            }
            ch = original;
        }
        return result;
    };
    
    std::queue<std::string> q;
    q.push(beginWord);
    distance[beginWord] = 0;
    
    while (!q.empty()) {
        std::string current = q.front();
        q.pop();
        if (current == endWord) {
            break;
        }
        for (const std::string& neighbor : neighbors(current)) {
            if (!distance.count(neighbor)) {
                distance[neighbor] = distance[current] + 1;
                q.push(neighbor);
            }
            if (distance[neighbor] == distance[current] + 1) {
                adjacent[current].push_back(neighbor);
            }
        }
    }
    
    std::vector<std::vector<std::string>> result;
    std::vector<std::string> path = {beginWord};
    std::function<void(const std::string&)> backtrack = [&](const std::string& word) {
        if (word == endWord) {
            result.push_back(path);
            return;
        }
        for (const std::string& next : adjacent[word]) {
            path.push_back(next);
            backtrack(next);
            path.pop_back();
        }
    };
    
    backtrack(beginWord);
    return result;
}


-----
#include <vector>
#include <string>
#include <queue>
#include <unordered_set>
#include <unordered_map>

std::vector<std::vector<std::string>> findLadders(std::string beginWord, std::string endWord, std::vector<std::string>& wordList) 
    // Your code here
}


************************************
Question ID: 127

#include <string>
#include <vector>
#include <queue>
#include <unordered_set>

int ladderLength(std::string beginWord, std::string endWord, std::vector<std::string>& wordList) {
    std::unordered_set<std::string> dict(wordList.begin(), wordList.end());
    if (!dict.count(endWord)) return 0;

    std::queue<std::string> q;
    q.push(beginWord);
    int steps = 1;

    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; ++i) {
            std::string currentWord = q.front();
            q.pop();
            if (currentWord == endWord) return steps;

            for (char& c : currentWord) {
                char originalChar = c;
                for (int j = 0; j < 26; ++j) {
                    c = 'a' + j;
                    if (dict.count(currentWord)) {
                        q.push(currentWord);
                        dict.erase(currentWord);
                    }
                }
                c = originalChar;
            }
        }
        ++steps;
    }
    return 0;
}

-----
#include <string>
#include <vector>
#include <queue>
#include <unordered_set>

int ladderLength(std::string beginWord, std::string endWord, std::vector<std::string>& wordList) 
    // Your code here
}

************************************
Question ID: 128

int longestConsecutive(vector<int>& nums) {
    unordered_set<int> elements(nums.begin(), nums.end());
    int longestSeq = 0;
    
    for (int num : nums) {
        if (elements.find(num - 1) == elements.end()) {
            int currentNum = num;
            int currentSeq = 1;
            
            while (elements.find(currentNum + 1) != elements.end()) {
                currentNum += 1;
                currentSeq += 1;
            }
            
            longestSeq = max(longestSeq, currentSeq);
        }
    }
    return longestSeq;
}

-----
int longestConsecutive(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 129

int sumNumbers(TreeNode* root, int cur = 0) {
    if (!root) return 0;
    cur = cur * 10 + root->val;
    if (!root->left && !root->right) return cur;
    return sumNumbers(root->left, cur) + sumNumbers(root->right, cur);
}


-----
int sumNumbers(TreeNode* root, int cur = 0) 
    // Your code here
}


************************************
Question ID: 131

#include <vector>
#include <string>

bool isPalindrome(const std::string& s, int start, int end) {
    while (start < end) {
        if (s[start++] != s[end--]) return false;
    }
    return true;
}

void dfs(const std::string& s, int start, std::vector<std::vector<std::string>>& results, std::vector<std::string> current) {
    if (start == s.length()) {
        results.push_back(current);
        return;
    }
    
    for (int end = start; end < s.length(); ++end) {
        if (isPalindrome(s, start, end)) {
            current.push_back(s.substr(start, end - start + 1));
            dfs(s, end + 1, results, current);
            current.pop_back();
        }
    }
}

std::vector<std::vector<std::string>> partition(std::string s) {
    std::vector<std::vector<std::string>> results;
    std::vector<std::string> current;
    dfs(s, 0, results, current);
    return results;
}

-----
#include <vector>
#include <string>

bool isPalindrome(const std::string& s, int start, int end) 
    // Your code here
}

************************************
Question ID: 132

#include <vector>
#include <string>

int minCut(std::string s) {
    int n = s.size();
    std::vector<int> dp(n + 1, 0);
    std::vector<std::vector<bool>> isPalindrome(n, std::vector<bool>(n, false));
    
    for (int i = 0; i <= n; i++) {
        dp[i] = i - 1;
    }
    
    for (int j = 1; j < n; j++) {
        for (int i = j; i >= 0; i--) {
            if (s[i] == s[j] && (j - i < 2 || isPalindrome[i + 1][j - 1])) {
                isPalindrome[i][j] = true;
                dp[j + 1] = std::min(dp[j + 1], dp[i] + 1);
            }
        }
    }
    
    return dp[n];
}

-----
#include <vector>
#include <string>

int minCut(std::string s) 
    // Your code here
}

************************************
Question ID: 134

int can_complete_circuit(vector<int>& gas, vector<int>& cost) {
    int total_gas = 0, total_cost = 0, start = 0, gas_tank = 0;
    for (int i = 0; i < gas.size(); ++i) {
        total_gas += gas[i];
        total_cost += cost[i];
        gas_tank += gas[i] - cost[i];
        if (gas_tank < 0) {
            start = i + 1;
            gas_tank = 0;
        }
    }
    return (total_gas < total_cost) ? -1 : start;
}

-----
int can_complete_circuit(vector<int>& gas, vector<int>& cost) 
    // Your code here
}

************************************
Question ID: 135

#include <vector>
using namespace std;

int minCandies(vector<int>& ratings) {
    int n = ratings.size();
    vector<int> candies(n, 1);

    for(int i = 1; i < n; i++) {
        if(ratings[i] > ratings[i-1]) candies[i] = candies[i-1] + 1;
    }
    for(int i = n - 2; i >= 0; i--) {
        if(ratings[i] > ratings[i+1]) candies[i] = max(candies[i], candies[i+1] + 1);
    }

    int sum = 0;
    for(int candy : candies) sum += candy;

    return sum;
}

-----
#include <vector>
using namespace std;

int minCandies(vector<int>& ratings) 
    // Your code here
}

************************************
Question ID: 136

int singleNumber(vector<int>& nums) {
    int result = 0;
    for (int num : nums) {
        result ^= num;
    }
    return result;
}

-----
int singleNumber(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 137

int singleNumber(vector<int>& nums) {
    int ones = 0, twos = 0;
    for (int n : nums) {
        ones = (ones ^ n) & ~twos;
        twos = (twos ^ n) & ~ones;
    }
    return ones;
}

-----
int singleNumber(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 139

#include <vector>
#include <string>
#include <unordered_set>

bool wordBreak(std::string s, std::vector<std::string>& wordDict) {
    std::unordered_set<std::string> dict(wordDict.begin(), wordDict.end());
    std::vector<bool> dp(s.size() + 1, false);
    dp[0] = true;
    for (size_t i = 1; i <= s.size(); ++i) {
        for (size_t j = 0; j < i; ++j) {
            if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {
                dp[i] = true;
                break;
            }
        }
    }
    return dp[s.size()];
}


-----
#include <vector>
#include <string>
#include <unordered_set>

bool wordBreak(std::string s, std::vector<std::string>& wordDict) 
    // Your code here
}


************************************
Question ID: 140

#include <vector>
#include <string>
#include <unordered_set>

std::vector<std::string> helper(const std::string& s, const std::unordered_set<std::string>& dict, std::unordered_map<std::string, std::vector<std::string>>& memo) {
    if (memo.count(s)) return memo[s];

    std::vector<std::string> res;
    if (dict.count(s)) res.push_back(s);

    for (int i = 1; i < s.size(); ++i) {
        std::string prefix = s.substr(0, i);
        if (!dict.count(prefix)) continue;
        std::string suffix = s.substr(i);
        auto temp = helper(suffix, dict, memo);
        for (const auto& t : temp) {
            res.push_back(prefix + " " + t);
        }
    }
    memo[s] = res;
    return res;
}

std::vector<std::string> wordBreak(std::string s, std::vector<std::string>& wordDict) {
    std::unordered_set<std::string> dict(wordDict.begin(), wordDict.end());
    std::unordered_map<std::string, std::vector<std::string>> memo;
    return helper(s, dict, memo);
}

-----
#include <vector>
#include <string>
#include <unordered_set>

std::vector<std::string> helper(const std::string& s, const std::unordered_set<std::string>& dict, std::unordered_map<std::string, std::vector<std::string>>& memo) 
    // Your code here
}

************************************
Question ID: 141

bool hasCycle(ListNode *head) {
    ListNode *slow = head, *fast = head;
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) {
            return true;
        }
    }
    return false;
}

-----
bool hasCycle(ListNode *head) 
    // Your code here
}

************************************
Question ID: 146

#include <unordered_map>
#include <list>
using namespace std;

class LRUCache {
    int capacity;
    list<pair<int, int>> lru_list;
    unordered_map<int, list<pair<int, int>>::iterator> cache;

public:
    LRUCache(int cap) : capacity(cap) {}

    int get(int key) {
        auto it = cache.find(key);
        if (it == cache.end()) {
            return -1;
        }
        lru_list.splice(lru_list.begin(), lru_list, it->second);
        return it->second->second;
    }

    void put(int key, int value) {
        auto it = cache.find(key);
        if (it != cache.end()) {
            lru_list.erase(it->second);
        } else if (lru_list.size() == (size_t)capacity) {
            cache.erase(lru_list.rbegin()->first);
            lru_list.pop_back();
        }
        lru_list.emplace_front(key, value);
        cache[key] = lru_list.begin();
    }
};


-----
#include <unordered_map>
#include <list>
using namespace std;

class LRUCache 
    // Your code here
};


************************************
Question ID: 149

#include <unordered_map>

int maxPoints(vector<vector<int>>& points) {
    int n = points.size();
    if (n <= 2) return n;
    int max_count = 0;

    for (int i = 0; i < n; i++) {
        std::unordered_map<string, int> slope_map;
        int duplicates = 0, local_max = 0;

        for (int j = i + 1; j < n; j++) {
            int deltaX = points[j][0] - points[i][0];
            int deltaY = points[j][1] - points[i][1];

            if (deltaX == 0 && deltaY == 0) {
                duplicates++;
                continue;
            }

            int gcd = std::gcd(deltaX, deltaY);
            deltaX /= gcd;
            deltaY /= gcd;

            string key = to_string(deltaX) + "_" + to_string(deltaY);
            slope_map[key]++;
            local_max = max(local_max, slope_map[key]);
        }
        max_count = max(max_count, local_max + duplicates + 1);
    }

    return max_count;
}


-----
#include <unordered_map>

int maxPoints(vector<vector<int>>& points) 
    // Your code here
}


************************************
Question ID: 150

#include <vector>
#include <string>
#include <stack>

int evalRPN(vector<string>& tokens) {
    stack<int> s;
    for (const string& token : tokens) {
        if(token == "+" || token == "-" || token == "*" || token == "/") {
            int b = s.top(); s.pop();
            int a = s.top(); s.pop();
            if (token == "+") s.push(a + b);
            else if (token == "-") s.push(a - b);
            else if (token == "*") s.push(a * b);
            else s.push(a / b);
        } else {
            s.push(stoi(token));
        }
    }
    return s.top();
}

-----
#include <vector>
#include <string>
#include <stack>

int evalRPN(vector<string>& tokens) 
    // Your code here
}

************************************
Question ID: 151

#include <string>
#include <sstream>
#include <vector>
#include <algorithm>

std::string reverseWords(std::string s) {
    std::stringstream ss(s);
    std::vector<std::string> words;
    std::string temp;

    while (ss >> temp) {
        words.push_back(temp);
    }

    std::reverse(words.begin(), words.end());

    std::string result;
    for (size_t i = 0; i < words.size(); ++i) {
        result += words[i] + (i < words.size() - 1 ? " " : "");
    }

    return result;
}

-----
#include <string>
#include <sstream>
#include <vector>
#include <algorithm>

std::string reverseWords(std::string s) 
    // Your code here
}

************************************
Question ID: 152

int maxProduct(vector<int>& nums) {
    int max_so_far = nums[0];
    int min_so_far = nums[0];
    int result = nums[0];
    
    for (int i = 1; i < nums.size(); i++) {
        if (nums[i] < 0)
            swap(max_so_far, min_so_far);
        
        max_so_far = max(nums[i], max_so_far * nums[i]);
        min_so_far = min(nums[i], min_so_far * nums[i]);
        result = max(result, max_so_far);
    }
    return result;
}


-----
int maxProduct(vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 153

```c++
int findMin(vector<int>& nums) {
    int left = 0, right = nums.size() - 1;

    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] > nums[right]) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return nums[left];
}

-----
```c++
int findMin(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 154

int findMin(vector<int>& nums) {
    int low = 0, high = nums.size() - 1;
    
    while (low < high) {
        int mid = low + (high - low) / 2;
        if (nums[mid] > nums[high]) {
            low = mid + 1;
        } else if (nums[mid] < nums[high]) {
            high = mid;
        } else {
            high--;
        }
    }
    return nums[low];
}

-----
int findMin(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 157

int read4(char *buf4);

int read(char *buf, int n) {
    int totalRead = 0;
    char buf4[4];

    while (totalRead < n) {
        int read4Count = read4(buf4);
        for (int i = 0; i < read4Count && totalRead < n; ++i) {
            buf[totalRead++] = buf4[i];
        }
        if (read4Count < 4) break;
    }

    return totalRead;
}

-----
int read4(char *buf4);

int read(char *buf, int n) 
    // Your code here
}

************************************
Question ID: 159

int lengthOfLongestSubstringTwoDistinct(string s) {
    int l = 0, r = 0, max_len = 0, cur_len = 0;
    unordered_map<char, int> char_count;

    while (r < s.length()) {
        char_count[s[r]]++;
        if (char_count.size() <= 2) {
            cur_len++;
        } else {
            while (char_count.size() > 2 && l <= r) {
                char_count[s[l]]--;
                if (char_count[s[l]] == 0) {
                    char_count.erase(s[l]);
                }
                l++;
                cur_len--;
            }
            cur_len++;
        }
        max_len = max(max_len, cur_len);
        r++;
    }
    return max_len;
}

-----
int lengthOfLongestSubstringTwoDistinct(string s) 
    // Your code here
}

************************************
Question ID: 161

bool isOneEditDistance(string s, string t) {
    int m = s.length(), n = t.length();
    if (m > n) {
        return isOneEditDistance(t, s);
    }
    if (n - m > 1) {
        return false;
    }
    bool flag = false;
    for (int i = 0; i < m; ++i) {
      if (s[i] != t[i]) {
          if (m < n) {
              return s.substr(i) == t.substr(i + 1);
          } else {
              return s.substr(i + 1) == t.substr(i + 1);
          }
      }
    }
    return m + 1 == n;
}

-----
bool isOneEditDistance(string s, string t) 
    // Your code here
}

************************************
Question ID: 162

int findPeakElement(vector<int>& nums) {
    int left = 0, right = nums.size() - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < nums[mid + 1]) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}

-----
int findPeakElement(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 163

#include <vector>
#include <string>

std::vector<std::string> findMissingRanges(std::vector<int>& nums, int lower, int upper) {
    std::vector<std::string> result;
    long prev = (long)lower - 1;

    for (int i = 0; i <= nums.size(); ++i) {
        long cur = (i == nums.size()) ? (long)upper + 1 : nums[i];
        if (cur - prev >= 2) {
            result.push_back(std::to_string(prev + 1) + (cur - prev == 2 ? "" : "->") + std::to_string(cur - 1));
        }
        prev = cur;
    }

    return result;
}

-----
#include <vector>
#include <string>

std::vector<std::string> findMissingRanges(std::vector<int>& nums, int lower, int upper) 
    // Your code here
}

************************************
Question ID: 164

int maximumGap(vector<int>& nums) {
    if (nums.size() < 2) return 0;
    
    int min_val = *min_element(nums.begin(), nums.end());
    int max_val = *max_element(nums.begin(), nums.end());
    int len = nums.size();
    int bucket_size = max(1, (max_val - min_val) / (len - 1));
    int bucket_num = (max_val - min_val) / bucket_size + 1;
    vector<pair<int, int>> buckets(bucket_num, {INT_MAX, INT_MIN});

    for (int num : nums) {
        int idx = (num - min_val) / bucket_size;
        buckets[idx].first = min(buckets[idx].first, num);
        buckets[idx].second = max(buckets[idx].second, num);
    }

    int max_gap = 0, prev_max = min_val;
    for (auto& bucket : buckets) {
        if (bucket.first == INT_MAX) continue;
        max_gap = max(max_gap, bucket.first - prev_max);
        prev_max = bucket.second;
    }
    return max_gap;
}

-----
int maximumGap(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 165

int compareVersion(string version1, string version2) {
    int i = 0, j = 0;
    while (i < version1.size() || j < version2.size()) {
        int num1 = 0, num2 = 0;
        while (i < version1.size() && version1[i] != '.') {
            num1 = num1 * 10 + (version1[i++] - '0');
        }
        while (j < version2.size() && version2[j] != '.') {
            num2 = num2 * 10 + (version2[j++] - '0');
        }
        if (num1 < num2) return -1;
        if (num1 > num2) return 1;
        i++; j++;
    }
    return 0;
}

-----
int compareVersion(string version1, string version2) 
    // Your code here
}

************************************
Question ID: 166

#include <unordered_map>
std::string fractionToDecimal(int numerator, int denominator) {
    if (numerator == 0) return "0";
    std::string res;
    if ((numerator > 0) ^ (denominator > 0)) res += '-';
    long num = std::abs((long)numerator), den = std::abs((long)denominator);
    res += std::to_string(num / den);
    num %= den;
    if (num == 0) return res;
    res += '.';
    std::unordered_map<int, int> map;
    while (num) {
        if (map.find(num) != map.end()) {
            res.insert(map[num], "(");
            res += ")";
            break;
        }
        map[num] = res.size();
        num *= 10;
        res += std::to_string(num / den);
        num %= den;
    }
    return res;
}


-----
#include <unordered_map>
std::string fractionToDecimal(int numerator, int denominator) 
    // Your code here
}


************************************
Question ID: 167

#include <vector>
using namespace std;

vector<int> twoSum(vector<int>& numbers, int target) {
    int left = 0, right = numbers.size() - 1;
    while (left < right) {
        int current_sum = numbers[left] + numbers[right];
        if (current_sum == target) {
            return {left + 1, right + 1};
        } else if (current_sum < target) {
            left++;
        } else {
            right--;
        }
    }
    return {};
}

-----
#include <vector>
using namespace std;

vector<int> twoSum(vector<int>& numbers, int target) 
    // Your code here
}

************************************
Question ID: 168

#include <string>

std::string convertToTitle(int columnNumber) {
    std::string result = "";
    while (columnNumber) {
        columnNumber--;
        result = (char)(columnNumber % 26 + 'A') + result;
        columnNumber /= 26;
    }
    return result;
}


-----
#include <string>

std::string convertToTitle(int columnNumber) 
    // Your code here
}


************************************
Question ID: 169

int majorityElement(vector<int>& nums) {
    int count = 0;
    int candidate;

    for (int num : nums) {
        if (count == 0) {
            candidate = num;
        }
        count += (num == candidate) ? 1 : -1;
    }

    return candidate;
}

-----
int majorityElement(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 171

int titleToNumber(string columnTitle) {
    int result = 0;
    for (char c : columnTitle) {
        result = result * 26 + (c - 'A' + 1);
    }
    return result;
}

-----
int titleToNumber(string columnTitle) 
    // Your code here
}

************************************
Question ID: 172

int trailingZeroes(int n) {
    int count = 0;
    while (n > 0) {
        n /= 5;
        count += n;
    }
    return count;
}


-----
int trailingZeroes(int n) 
    // Your code here
}


************************************
Question ID: 174

#include<vector>
using namespace std;

int calculateMinimumHP(vector<vector<int>>& dungeon) {
    int m = dungeon.size(), n = dungeon[0].size();
    vector<vector<int>> dp(m, vector<int>(n));

    for (int i = m - 1; i >= 0; i--) {
        for (int j = n - 1; j >= 0; j--) {
            if(i == m-1 && j == n-1){
                dp[i][j] = min(0, dungeon[i][j]);
            }
            else if (i == m - 1) {
                dp[i][j] = min(0, dp[i][j + 1] + dungeon[i][j]);
            }
            else if (j == n - 1) {
                dp[i][j] = min(0, dp[i + 1][j] + dungeon[i][j]);
            }
            else {
                dp[i][j] = min(0, max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);
            }
        }
    }

    return abs(dp[0][0]) + 1;
}

-----
#include<vector>
using namespace std;

int calculateMinimumHP(vector<vector<int>>& dungeon) 
    // Your code here
}

************************************
Question ID: 179

#include <algorithm>
#include <string>
#include <vector>

bool compare(std::string a, std::string b) {
    return a+b > b+a;
}

std::string largestNumber(std::vector<int>& nums) {
    std::vector<std::string> asStrs;
    for (int num : nums) asStrs.push_back(std::to_string(num));
    std::sort(asStrs.begin(), asStrs.end(), compare);
    std::string res;
    for (std::string s: asStrs) res += s;
    return res[0] == '0' ? "0" : res;
}

-----
#include <algorithm>
#include <string>
#include <vector>

bool compare(std::string a, std::string b) 
    // Your code here
}

************************************
Question ID: 186

void reverseWords(vector<char>& s) {
    reverse(s.begin(), s.end());
    int start = 0, end;
    while ((end = find(s.begin() + start, s.end(), ' ') - s.begin()) < s.size()) {
        reverse(s.begin() + start, s.begin() + end);
        start = end + 1;
    }
    reverse(s.begin() + start, s.end());
}

-----
void reverseWords(vector<char>& s) 
    // Your code here
}

************************************
Question ID: 187

#include <vector>
#include <string>
#include <unordered_map>

std::vector<std::string> findRepeatedDnaSequences(std::string s) {
    std::vector<std::string> result;
    std::unordered_map<std::string, int> dna_counter;

    for (size_t i = 0; i <= s.length() - 10; ++i) {
        std::string sequence = s.substr(i, 10);
        dna_counter[sequence]++;
        if (dna_counter[sequence] == 2) {
            result.push_back(sequence);
        }
    }

    return result;
}

-----
#include <vector>
#include <string>
#include <unordered_map>

std::vector<std::string> findRepeatedDnaSequences(std::string s) 
    // Your code here
}

************************************
Question ID: 188

#include <vector>
#include <algorithm>
int maxProfit(int k, std::vector<int>& prices) {
    int n = prices.size();
    if (k > n / 2) {
        int max_profit = 0;
        for (int i = 1; i < n; ++i)
            max_profit += std::max(prices[i] - prices[i - 1], 0);
        return max_profit;  
    }

    std::vector<std::vector<int>> dp(k + 1, std::vector<int>(n, 0));
    for (int i = 1; i <= k; ++i) {
        int max_diff = -prices[0];
        for (int j = 1; j < n; ++j) {
            dp[i][j] = std::max(dp[i][j - 1], prices[j] + max_diff);
            max_diff = std::max(max_diff, dp[i - 1][j] - prices[j]);
        }
    }
    return dp[k][n - 1];
}

-----
#include <vector>
#include <algorithm>
int maxProfit(int k, std::vector<int>& prices) 
    // Your code here
}

************************************
Question ID: 189

#include <vector>
using namespace std;

void rotate(vector<int>& nums, int k) {
    int n = nums.size();
    k %= n;
    reverse(nums.begin(), nums.end());
    reverse(nums.begin(), nums.begin() + k);
    reverse(nums.begin() + k, nums.end());
}

-----
#include <vector>
using namespace std;

void rotate(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 190

unsigned int reverseBits(unsigned int n) {
    unsigned int res = 0;
    for (int i = 0; i < 32; ++i) {
        res <<= 1;
        res |= n & 1;
        n >>= 1;
    }
    return res;
}

-----
unsigned int reverseBits(unsigned int n) 
    // Your code here
}

************************************
Question ID: 191

int hammingWeight(uint32_t n) {
    int count = 0;
    while (n != 0) {
        count += n & 1;
        n >>= 1;
    }
    return count;
}

-----
int hammingWeight(uint32_t n) 
    // Your code here
}

************************************
Question ID: 194

#include <vector>
#include <string>
#include <sstream>

std::vector<std::string> transpose(std::vector<std::string> &content)
{
    std::vector<std::vector<std::string>> data;
    for (const std::string &line : content)
    {
        std::vector<std::string> row;
        std::stringstream ss(line);
        std::string word;
        while (ss >> word)
            row.push_back(word);
        data.push_back(row);
    }

    std::vector<std::string> result(data[0].size(), "");
    for (size_t i = 0; i < data[0].size(); ++i)
    {
        for (size_t j = 0; j < data.size(); ++j)
        {
            result[i] += data[j][i];
            if (j < data.size() - 1)
                result[i] += " ";
        }
    }

    return result;
}


-----
#include <vector>
#include <string>
#include <sstream>

std::vector<std::string> transpose(std::vector<std::string> &content)

    // Your code here
}


************************************
Question ID: 198

int rob(vector<int>& nums) {
    int prev1 = 0, prev2 = 0;
    for (const auto& num : nums) {
        int tmp = prev1;
        prev1 = max(prev2 + num, prev1);
        prev2 = tmp;
    }
    return prev1;
}

-----
int rob(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 200

void dfs(vector<vector<char>>& grid, int i, int j) {
    if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == '0')
        return;

    grid[i][j] = '0';
    dfs(grid, i + 1, j);
    dfs(grid, i - 1, j);
    dfs(grid, i, j + 1);
    dfs(grid, i, j - 1);
}

int numIslands(vector<vector<char>>& grid) {
    int count = 0;
    for(int i = 0; i < grid.size(); i++) {
        for(int j = 0; j < grid[0].size(); j++) {
            if(grid[i][j] == '1') {
                count++;
                dfs(grid, i, j);
            }
        }
    }
    return count;
}

-----
void dfs(vector<vector<char>>& grid, int i, int j) 
    // Your code here
}

************************************
Question ID: 201

int rangeBitwiseAnd(int left, int right) {
    int shift = 0;
    while (left != right) {
        left >>= 1;
        right >>= 1;
        ++shift;
    }
    return left << shift;
}

-----
int rangeBitwiseAnd(int left, int right) 
    // Your code here
}

************************************
Question ID: 202

int getNext(int n) {
    int sum = 0;
    while (n > 0) {
        int digit = n % 10;
        sum += digit * digit;
        n /= 10;
    }
    return sum;
}

bool isHappy(int n) {
    int slow = n, fast = getNext(n);
    while (fast != 1 && slow != fast) {
        slow = getNext(slow);
        fast = getNext(getNext(fast));
    }
    return fast == 1;
}

-----
int getNext(int n) 
    // Your code here
}

************************************
Question ID: 204

int countPrimes(int n) {
    if (n <= 2) return 0;
    vector<bool> isPrime(n, true);
    isPrime[0] = isPrime[1] = false;
    for (int i = 2; i * i < n; ++i) {
        if (isPrime[i]) {
            for (int j = i * i; j < n; j += i) {
                isPrime[j] = false;
            }
        }
    }
    return count(isPrime.begin(), isPrime.end(), true);
}

-----
int countPrimes(int n) 
    // Your code here
}

************************************
Question ID: 205

#include <unordered_map>

bool isIsomorphic(std::string s, std::string t) {
    std::unordered_map<char, char> map1, map2;
    for (size_t i = 0; i < s.size(); ++i) {
        if (map1.find(s[i]) == map1.end()) {
            map1[s[i]] = t[i];
        }
        if (map2.find(t[i]) == map2.end()) {
            map2[t[i]] = s[i];
        }
        if (map1[s[i]] != t[i] || map2[t[i]] != s[i]) {
            return false;
        }
    }
    return true;
}

-----
#include <unordered_map>

bool isIsomorphic(std::string s, std::string t) 
    // Your code here
}

************************************
Question ID: 207

#include <vector>
#include <queue>

bool canFinish(int numCourses, std::vector<std::vector<int>>& prerequisites) {
    std::vector<std::vector<int>> adj(numCourses);
    std::vector<int> inDegree(numCourses, 0);
    
    for (auto& p : prerequisites) {
        adj[p[1]].push_back(p[0]);
        inDegree[p[0]]++;
    }
    
    std::queue<int> q;
    for (int i = 0; i < numCourses; i++) {
        if (inDegree[i] == 0) q.push(i);
    }
    
    while (!q.empty()) {
        int currCourse = q.front();
        q.pop();
        numCourses--;
        
        for (int nextCourse : adj[currCourse]) {
            inDegree[nextCourse]--;
            if (inDegree[nextCourse] == 0) q.push(nextCourse);
        }
    }
    
    return numCourses == 0;
}


-----
#include <vector>
#include <queue>

bool canFinish(int numCourses, std::vector<std::vector<int>>& prerequisites) 
    // Your code here
}


************************************
Question ID: 209

#include <climits>
int minSubArrayLen(int target, vector<int>& nums) {
    int left = 0, cur_sum = 0, min_len = INT_MAX;
    for (int right = 0; right < nums.size(); right++) {
        cur_sum += nums[right];
        while (cur_sum >= target) {
            min_len = min(min_len, right - left + 1);
            cur_sum -= nums[left++];
        }
    }
    return min_len == INT_MAX ? 0 : min_len;
}

-----
#include <climits>
int minSubArrayLen(int target, vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 210

#include <vector>
#include <queue>
using namespace std;

vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
    vector<int> inDegree(numCourses, 0);
    vector<vector<int>> adjList(numCourses);
    
    for (auto& p : prerequisites) {
        adjList[p[1]].push_back(p[0]);
        inDegree[p[0]]++;
    }
    
    queue<int> q;
    for (int i = 0; i < numCourses; i++) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }
    
    vector<int> order;
    
    while (!q.empty()) {
        int curr = q.front();
        q.pop();
        order.push_back(curr);
        for (auto next : adjList[curr]) {
            if (--inDegree[next] == 0) {
                q.push(next);
            }
        }
    }
    
    return (order.size() == numCourses) ? order : vector<int>();
}


-----
#include <vector>
#include <queue>
using namespace std;

vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) 
    // Your code here
}


************************************
Question ID: 212

#include <vector>
#include <string>

void dfs(const std::vector<std::vector<char>>& board, const std::string& word, int index, int i, int j, std::vector<std::vector<bool>>& visited, bool& found){
    if (index == word.length()) {
        found = true;
        return;
    }
    if (i < 0 || j < 0 || i >= board.size() || j >= board[0].size() || visited[i][j] || board[i][j] != word[index]){
        return;
    }
    visited[i][j] = true;
    dfs(board, word, index + 1, i - 1, j, visited, found);
    dfs(board, word, index + 1, i + 1, j, visited, found);
    dfs(board, word, index + 1, i, j - 1, visited, found);
    dfs(board, word, index + 1, i, j + 1, visited, found);
    visited[i][j] = false;
}

std::vector<std::string> findWords(std::vector<std::vector<char>>& board, std::vector<std::string>& words) {
    std::vector<std::string> result;
    for (const auto& word : words) {
        bool found = false;
        std::vector<std::vector<bool>> visited(board.size(), std::vector<bool>(board[0].size(), false));
        for (int i = 0; i < board.size() && !found; ++i) {
            for (int j = 0; j < board[0].size() && !found; ++j) {
                dfs(board, word, 0, i, j, visited, found);
            }
        }
        if (found) {
            result.push_back(word);
        }
    }
    return result;
}


-----
#include <vector>
#include <string>

void dfs(const std::vector<std::vector<char>>& board, const std::string& word, int index, int i, int j, std::vector<std::vector<bool>>& visited, bool& found)
    // Your code here
}


************************************
Question ID: 213

int rob(vector<int>& nums) {
    if (nums.size() == 1) return nums[0];
    int prev = 0, curr = 0;
    for (int i = 0; i < nums.size() - 1; i++) {
        int temp = max(curr, prev + nums[i]);
        prev = curr;
        curr = temp;
    }
    int res = curr;
    prev = 0;
    curr = 0;
    for (int i = 1; i < nums.size(); i++) {
        int temp = max(curr, prev + nums[i]);
        prev = curr;
        curr = temp;
    }
    return max(res, curr);
}

-----
int rob(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 214

#include <string>

std::string shortestPalindrome(std::string s) {
    int n = s.size();
    std::string rev_s = s;
    std::reverse(rev_s.begin(), rev_s.end());
    
    for (int i = 0; i < n; ++i) {
        if(s.substr(0, n - i) == rev_s.substr(i))
            return rev_s.substr(0, i) + s;
    }
    return "";
}


-----
#include <string>

std::string shortestPalindrome(std::string s) 
    // Your code here
}


************************************
Question ID: 215

#include <algorithm>
#include <vector>

int findKthLargest(std::vector<int>& nums, int k) {
    std::sort(nums.begin(), nums.end(), std::greater<int>());
    return nums[k-1];
}

-----
#include <algorithm>
#include <vector>

int findKthLargest(std::vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 216

#include <vector>

void helper(int k, int n, int current, std::vector<int>& current_comb, std::vector<std::vector<int>>& result) {
    if (k == 0 && n == 0) {
        result.push_back(current_comb);
    } else if (k > 0 && n > 0) {
        for (int i = current + 1; i <= 9; ++i) {
            current_comb.push_back(i);
            helper(k - 1, n - i, i, current_comb, result);
            current_comb.pop_back();
        }
    }
}

std::vector<std::vector<int>> combinationSum3(int k, int n) {
    std::vector<std::vector<int>> result;
    std::vector<int> current_comb;
    helper(k, n, 0, current_comb, result);
    return result;
}


-----
#include <vector>

void helper(int k, int n, int current, std::vector<int>& current_comb, std::vector<std::vector<int>>& result) 
    // Your code here
}


************************************
Question ID: 217

bool containsDuplicate(vector<int>& nums) {
    unordered_set<int> s;
    for (int num : nums) {
        if (s.find(num) != s.end()) {
            return true;
        }
        s.insert(num);
    }
    return false;
}


-----
bool containsDuplicate(vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 218

#include <vector>
#include <set>
#include <algorithm>
using namespace std;

vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {
    vector<pair<int, int>> points;
    for (const auto &b : buildings) {
        points.emplace_back(b[0], -b[2]);
        points.emplace_back(b[1], b[2]);
    }
    sort(points.begin(), points.end());
    multiset<int> heights = {0};
    int prev = 0;
    vector<vector<int>> skyline;
    for (const auto &[x, h] : points) {
        if (h < 0)
            heights.insert(-h);
        else
            heights.erase(heights.find(h));
        int cur = *heights.rbegin();
        if (cur != prev) {
            skyline.push_back({x, cur});
            prev = cur;
        }
    }
    return skyline;
}

-----
#include <vector>
#include <set>
#include <algorithm>
using namespace std;

vector<vector<int>> getSkyline(vector<vector<int>>& buildings) 
    // Your code here
}

************************************
Question ID: 219

bool containsNearbyDuplicate(vector<int>& nums, int k) {
    unordered_map<int, int> valueIndexMap;
    for (int i = 0; i < nums.size(); i++) {
        if (valueIndexMap.find(nums[i]) != valueIndexMap.end() && i - valueIndexMap[nums[i]] <= k) {
            return true;
        }
        valueIndexMap[nums[i]] = i;
    }
    return false;
}

-----
bool containsNearbyDuplicate(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 220

#include <vector>
#include <set>
using namespace std;

bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
    set<long> window;
    for (int i = 0; i < nums.size(); i++) {
        if (i > k) {
            window.erase(nums[i - k - 1]);
        }
        auto pos = window.lower_bound((long)nums[i] - t);
        if (pos != window.end() && *pos - nums[i] <= t) {
            return true;
        }
        window.insert(nums[i]);
    }
    return false;
}

-----
#include <vector>
#include <set>
using namespace std;

bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) 
    // Your code here
}

************************************
Question ID: 221

int maximalSquare(vector<vector<char>>& matrix) {
    int m = matrix.size();
    int n = matrix[0].size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    int maxSize = 0;

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (matrix[i - 1][j - 1] == '1') {
                dp[i][j] = min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}) + 1;
                maxSize = max(maxSize, dp[i][j]);
            }
        }
    }
    
    return maxSize * maxSize;
}

-----
int maximalSquare(vector<vector<char>>& matrix) 
    // Your code here
}

************************************
Question ID: 223

int totalArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {
    int area1 = (ax2 - ax1) * (ay2 - ay1);
    int area2 = (bx2 - bx1) * (by2 - by1);

    int overlapWidth = min(ax2, bx2) - max(ax1, bx1);
    int overlapHeight = min(ay2, by2) - max(ay1, by1);

    int overlapArea = max(overlapWidth, 0) * max(overlapHeight, 0);

    return area1 + area2 - overlapArea;
}


-----
int totalArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) 
    // Your code here
}


************************************
Question ID: 224

int calculate(string s) {
    int result = 0, sign = 1, num = 0;
    stack<int> st;
    for (char c : s) {
        if (isdigit(c)) {
            num = num * 10 + (c - '0');
        } else {
            result += sign * num;
            num = 0;
            if (c == '+') {
                sign = 1;
            } else if (c == '-') {
                sign = -1;
            } else if (c == '(') {
                st.push(result);
                st.push(sign);
                result = 0;
                sign = 1;
            } else if (c == ')') {
                int prev_sign = st.top();
                st.pop();
                int prev_result = st.top();
                st.pop();
                result = prev_result + prev_sign * result;
            }
        }
    }
    result += sign * num;
    return result;
}

-----
int calculate(string s) 
    // Your code here
}

************************************
Question ID: 225

#include <queue>

class MyStack {
public:
    std::queue<int> q1, q2;

    void push(int x) {
        q2.push(x);
        while (!q1.empty()) {
            q2.push(q1.front());
            q1.pop();
        }
        std::swap(q1, q2);
    }

    int pop() {
        int top = q1.front();
        q1.pop();
        return top;
    }

    int top() {
        return q1.front();
    }

    bool empty() {
        return q1.empty();
    }
};

-----
#include <queue>

class MyStack 
    // Your code here
};

************************************
Question ID: 227

int calculate(string s) {
    int result = 0, num = 0, sign = 1;
    stack<int> st;
    
    for (char c : s) {
        if (isdigit(c)) {
            num = num * 10 + (c - '0');
        } else if (c == '+') {
            result += sign * num;
            num = 0;
            sign = 1;
        } else if (c == '-') {
            result += sign * num;
            num = 0;
            sign = -1;
        } else if (c == '(') {
            st.push(result);
            st.push(sign);
            result = 0;
            sign = 1;
        } else if (c == ')') {
            result += sign * num;
            num = 0;
            result *= st.top(); st.pop();
            result += st.top(); st.pop();
        }
    }
    if (num) result += sign * num;
    return result;
}

-----
int calculate(string s) 
    // Your code here
}

************************************
Question ID: 228

#include <vector>
#include <string>

std::vector<std::string> find_ranges(std::vector<int>& nums) {
    std::vector<std::string> result;
    int n = nums.size();
    if (n == 0) return result;

    int start = nums[0];
    for (int i = 1; i < n; ++i) {
        if (nums[i] > nums[i-1] + 1) {
            if (start == nums[i-1])
                result.push_back(std::to_string(start));
            else
                result.push_back(std::to_string(start) + "->" + std::to_string(nums[i-1]));
            start = nums[i];
        }
    }

    if (start == nums[n-1])
        result.push_back(std::to_string(start));
    else
        result.push_back(std::to_string(start) + "->" + std::to_string(nums[n-1]));

    return result;
}

-----
#include <vector>
#include <string>

std::vector<std::string> find_ranges(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 229

#include <vector>
#include <unordered_map>
using namespace std;

vector<int> majorityElement(vector<int>& nums) {
    int n = nums.size();
    unordered_map<int, int> count;
    vector<int> result;

    for (int num : nums) {
        if (count.find(num) == count.end()) {
            count[num] = 1;
        } else {
            count[num]++;
        }
        if (count[num] > n / 3 && find(result.begin(), result.end(), num) == result.end()) {
            result.push_back(num);
        }
    }
    return result;
}

-----
#include <vector>
#include <unordered_map>
using namespace std;

vector<int> majorityElement(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 231

bool isPowerOfTwo(int n) {
    if (n <= 0) {
        return false;
    }
    return (n & (n - 1)) == 0;
}

-----
bool isPowerOfTwo(int n) 
    // Your code here
}

************************************
Question ID: 233

int countDigitOne(int n) {
    int count = 0;
    for(long long i = 1; i <= n; i *= 10){
        int divider = i * 10;
        count += (n / divider) * i + min(max(n % divider - i + 1, 0LL), i);
    }
    return count;
}

-----
int countDigitOne(int n) 
    // Your code here
}

************************************
Question ID: 237

void deleteNode(ListNode* node) {
    ListNode* nextNode = node->next;
    *node = *nextNode;
    delete nextNode;
}

-----
void deleteNode(ListNode* node) 
    // Your code here
}

************************************
Question ID: 238

vector<int> productExceptSelf(vector<int>& nums) {
    int n = nums.size();
    vector<int> answer(n, 1);
    
    int left = 1;
    for (int i = 0; i < n; i++) {
        answer[i] *= left;
        left *= nums[i];
    }
    
    int right = 1;
    for (int i = n - 1; i >= 0; i--) {
        answer[i] *= right;
        right *= nums[i];
    }
    
    return answer;
}

-----
vector<int> productExceptSelf(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 239

#include <vector>
#include <deque>

std::vector<int> maxSlidingWindow(std::vector<int>& nums, int k) {
    std::vector<int> result;
    std::deque<int> dq;

    for (int i = 0; i < nums.size(); i++) {
        while (!dq.empty() && dq.front() < i - k + 1) {
            dq.pop_front();
        }

        while (!dq.empty() && nums[dq.back()] < nums[i]) {
            dq.pop_back();
        }

        dq.push_back(i);

        if (i >= k - 1) {
            result.push_back(nums[dq.front()]);
        }
    }

    return result;
}


-----
#include <vector>
#include <deque>

std::vector<int> maxSlidingWindow(std::vector<int>& nums, int k) 
    // Your code here
}


************************************
Question ID: 240

bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int row = matrix.size() - 1, col = 0;
    while (row >= 0 && col < matrix[0].size()) {
        if (matrix[row][col] > target) {
            row--;
        } else if (matrix[row][col] < target) {
            col++;
        } else {
            return true;
        }
    }
    return false;
}

-----
bool searchMatrix(vector<vector<int>>& matrix, int target) 
    // Your code here
}

************************************
Question ID: 241

#include<vector>
#include<string>

using namespace std;

vector<int> diffWaysToCompute(string input) {
    vector<int> result;
    for (int i = 0; i < input.size(); i++) {
        char c = input[i];
        if (c == '+' || c == '-' || c == '*') {
            auto left = diffWaysToCompute(input.substr(0, i));
            auto right = diffWaysToCompute(input.substr(i + 1));
            for (int l : left) {
                for (int r : right) {
                    if (c == '+') result.push_back(l + r);
                    else if (c == '-') result.push_back(l - r);
                    else if (c == '*') result.push_back(l * r);
                }
            }
        }
    }
    if (result.empty()) result.push_back(stoi(input));
    return result;
}

-----
#include<vector>
#include<string>

using namespace std;

vector<int> diffWaysToCompute(string input) 
    // Your code here
}

************************************
Question ID: 242

bool isAnagram(std::string s, std::string t) {
    if(s.size() != t.size())
        return false;
    
    std::unordered_map<char, int> counts;
    for(char c : s)
        counts[c]++;
        
    for(char c : t) {
        if(counts[c] == 0)
            return false;
        counts[c]--;
    }
    
    return true;
}

-----
bool isAnagram(std::string s, std::string t) 
    // Your code here
}

************************************
Question ID: 243

#include <vector>
#include <string>
#include <climits>

int shortestDistance(std::vector<std::string> wordsDict, std::string word1, std::string word2) {
    int idx1 = -1, idx2 = -1, minDistance = INT_MAX;
    for (int i = 0; i < wordsDict.size(); i++) {
        if (wordsDict[i] == word1) idx1 = i;
        if (wordsDict[i] == word2) idx2 = i;
        if (idx1 != -1 && idx2 != -1)
            minDistance = std::min(minDistance, std::abs(idx1 - idx2));
    }
    return minDistance;
}

-----
#include <vector>
#include <string>
#include <climits>

int shortestDistance(std::vector<std::string> wordsDict, std::string word1, std::string word2) 
    // Your code here
}

************************************
Question ID: 245

#include <vector>
#include <string>
#include <limits>

int shortestDistance(std::vector<std::string>& wordsDict, std::string word1, std::string word2) {
    int index1 = -1, index2 = -1, minDistance = std::numeric_limits<int>::max();
    for (int i = 0; i < wordsDict.size(); ++i) {
        if (wordsDict[i] == word1) { index1 = i; }
        if (wordsDict[i] == word2) { index2 = i; }
        if (index1 != -1 && index2 != -1) {
            minDistance = std::min(minDistance, std::abs(index1 - index2));
        }
    }
    return minDistance;
}

-----
#include <vector>
#include <string>
#include <limits>

int shortestDistance(std::vector<std::string>& wordsDict, std::string word1, std::string word2) 
    // Your code here
}

************************************
Question ID: 246

bool isStrobogrammatic(string num) {
    unordered_map<char, char> lookup {{'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}};
    int left = 0, right = num.size() - 1;
    while(left <= right) {
        if(lookup[num[left]] != num[right]) return false;
        left++;
        right--;
    }
    return true;
}

-----
bool isStrobogrammatic(string num) 
    // Your code here
}

************************************
Question ID: 247

#include <vector>
#include <string>

std::vector<std::string> findStrobogrammatic(int n) {
    return helper(n, n);
}

std::vector<std::string> helper(int n, int m) {
    if (n == 0) return {""};
    if (n == 1) return {"0", "1", "8"};
    
    std::vector<std::string> list = helper(n - 2, m);
    std::vector<std::string> res;

    for (int i = 0; i < list.size(); i++) {
        std::string s = list[i];
        
        if (n != m) res.push_back("0" + s + "0");

        res.push_back("1" + s + "1");
        res.push_back("6" + s + "9");
        res.push_back("8" + s + "8");
        res.push_back("9" + s + "6");
    }

    return res;
}

-----
#include <vector>
#include <string>

std::vector<std::string> findStrobogrammatic(int n) 
    // Your code here
}

************************************
Question ID: 248

int strobogrammaticInRange(string low, string high) {
    int count = 0;
    for(int len = low.size(); len <= high.size(); ++len)
        count += helper(len, len) <= high ? helper(len, len) >= low ? 1 : 0 : 0;
    return count;
}

string helper(int m, int n) {
    if(m == 0) return "";
    if(m == 1) return "0 1 8";
    if(n == 0) return "11 69 88 96";
    string res = "";
    for(auto a : helper(m - 2, n)) {
        if(m != n) res += a + "0" + a;
        res += a + "1" + a;
        res += a + "6" + a;
        res += a + "8" + a;
        res += a + "9" + a;
    }
    return res;
}


-----
int strobogrammaticInRange(string low, string high) 
    // Your code here
}


************************************
Question ID: 249

#include <vector>
#include <string>
#include <unordered_map>

std::vector<std::vector<std::string>> groupStrings(std::vector<std::string>& strings) {
    std::unordered_map<std::string, std::vector<std::string>> map;
    
    for (const auto& s : strings) {
        std::string key;
        for (char c : s) {
            key += std::to_string((c - s[0] + 26) % 26) + ",";
        }
        map[key].push_back(s);
    }
    
    std::vector<std::vector<std::string>> result;
    for (auto& kv : map) {
        result.push_back(kv.second);
    }
    
    return result;
}

-----
#include <vector>
#include <string>
#include <unordered_map>

std::vector<std::vector<std::string>> groupStrings(std::vector<std::string>& strings) 
    // Your code here
}

************************************
Question ID: 252

#include <vector>
#include <algorithm>

bool canAttendMeetings(std::vector<std::vector<int>>& intervals) {
    std::sort(intervals.begin(), intervals.end());
    
    for (int i = 1; i < intervals.size(); ++i) {
        if (intervals[i][0] < intervals[i - 1][1])
            return false;
    }
    
    return true;
}

-----
#include <vector>
#include <algorithm>

bool canAttendMeetings(std::vector<std::vector<int>>& intervals) 
    // Your code here
}

************************************
Question ID: 253

#include <vector>
#include <queue>
#include <algorithm>

int minMeetingRooms(std::vector<std::vector<int>>& intervals) {
    if (intervals.empty()) return 0;

    std::sort(intervals.begin(), intervals.end(),
              [](const std::vector<int>& a, const std::vector<int>& b) { return a[0] < b[0]; });

    std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;
    min_heap.push(intervals[0][1]);

    for (int i = 1; i < intervals.size(); i++) {
        if (intervals[i][0] >= min_heap.top()) {
            min_heap.pop();
        }
        min_heap.push(intervals[i][1]);
    }

    return min_heap.size();
}

-----
#include <vector>
#include <queue>
#include <algorithm>

int minMeetingRooms(std::vector<std::vector<int>>& intervals) 
    // Your code here
}

************************************
Question ID: 254

#include <vector>

void helper(int n, int start, std::vector<int>& path, std::vector<std::vector<int>>& result) {
    if (n == 1) {
        if (path.size() > 1) {
            result.push_back(path);
        }
        return;
    }

    for (int i = start; i <= n; ++i) {
        if (n % i == 0) {
            path.push_back(i);
            helper(n / i, i, path, result);
            path.pop_back();
        }
    }
}

std::vector<std::vector<int>> getFactors(int n) {
    std::vector<std::vector<int>> result;
    std::vector<int> path;
    helper(n, 2, path, result);
    return result;
}

-----
#include <vector>

void helper(int n, int start, std::vector<int>& path, std::vector<std::vector<int>>& result) 
    // Your code here
}

************************************
Question ID: 255

bool isValidPreorder(vector<int>& preorder) {
    stack<int> stk;
    int lower_bound = INT_MIN;
    for (int num : preorder) {
        if (num < lower_bound) return false;
        while (!stk.empty() && num > stk.top()) {
            lower_bound = stk.top();
            stk.pop();
        }
        stk.push(num);
    }
    return true;
}

-----
bool isValidPreorder(vector<int>& preorder) 
    // Your code here
}

************************************
Question ID: 256

int minCost(vector<vector<int>>& costs) {
    if (costs.empty()) return 0;
    for (int i = 1; i < costs.size(); ++i) {
        costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);
        costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);
        costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);
    }
    return min(costs.back()[0], min(costs.back()[1], costs.back()[2]));
}

-----
int minCost(vector<vector<int>>& costs) 
    // Your code here
}

************************************
Question ID: 258

int addDigits(int num) {
    return 1 + (num - 1) % 9;
}

-----
int addDigits(int num) 
    // Your code here
}

************************************
Question ID: 259

int threeSumSmaller(vector<int>& nums, int target) {
    int count = 0;
    sort(nums.begin(), nums.end());
    for (int i = 0; i < nums.size(); ++i) {
        int j = i + 1, k = nums.size() - 1;
        while (j < k) {
            if (nums[i] + nums[j] + nums[k] < target) {
                count += k - j;
                ++j;
            } else {
                --k;
            }
        }
    }
    return count;
}

-----
int threeSumSmaller(vector<int>& nums, int target) 
    // Your code here
}

************************************
Question ID: 260

#include <vector>
using namespace std;

vector<int> singleNumber(vector<int>& nums) {
    int xor_all = 0;
    for (int num : nums) {
        xor_all ^= num;
    }

    int bit = xor_all & (-xor_all);
    int n1 = 0;
    int n2 = 0;
    for (int num : nums) {
        if (num & bit) {
            n1 ^= num;
        } else {
            n2 ^= num;
        }
    }

    return vector<int>{n1, n2};
}

-----
#include <vector>
using namespace std;

vector<int> singleNumber(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 261

#include <vector>

bool isTree(int n, std::vector<std::vector<int>>& edges) {
    std::vector<std::vector<int>> neighbors(n);
    for (const auto& edge : edges) {
        neighbors[edge[0]].push_back(edge[1]);
        neighbors[edge[1]].push_back(edge[0]);
    }
    std::vector<bool> visited(n, false);
    if(hasCycle(neighbors, visited, -1, 0)) return false;
    for (const auto& visit : visited)
        if (!visit) return false;
    return true;
}

bool hasCycle(const std::vector<std::vector<int>>& neighbors, std::vector<bool>& visited, int parent, int node) {
    visited[node] = true;
    for (const auto& neighbor : neighbors[node])
        if ((neighbor != parent && visited[neighbor]) || (!visited[neighbor] && hasCycle(neighbors, visited, node, neighbor))) return true;
    return false;
}

-----
#include <vector>

bool isTree(int n, std::vector<std::vector<int>>& edges) 
    // Your code here
}

************************************
Question ID: 263

bool isUgly(int n) {
    if (n <= 0) return false;
    while (n % 2 == 0) n /= 2;
    while (n % 3 == 0) n /= 3;
    while (n % 5 == 0) n /= 5;
    return n == 1;
}

-----
bool isUgly(int n) 
    // Your code here
}

************************************
Question ID: 264

int nthUglyNumber(int n) {
    vector<int> uglyNumbers(n);
    uglyNumbers[0] = 1;
    int i2 = 0, i3 = 0, i5 = 0;

    for (int i = 1; i < n; i++) {
        uglyNumbers[i] = min({uglyNumbers[i2] * 2, uglyNumbers[i3] * 3, uglyNumbers[i5] * 5});
        if (uglyNumbers[i] == uglyNumbers[i2] * 2) i2++;
        if (uglyNumbers[i] == uglyNumbers[i3] * 3) i3++;
        if (uglyNumbers[i] == uglyNumbers[i5] * 5) i5++;
    }

    return uglyNumbers[n - 1];
}


-----
int nthUglyNumber(int n) 
    // Your code here
}


************************************
Question ID: 265

int minCost(vector<vector<int>>& costs) {
    if (costs.empty()) return 0;

    int n = costs.size();
    int k = costs[0].size();

    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < k; ++j) {
            int minCost = INT_MAX;
            for (int l = 0; l < k; ++l) {
                if (l == j) continue;
                minCost = min(minCost, costs[i - 1][l]);
            }
            costs[i][j] += minCost;
        }
    }
    return *min_element(costs[n - 1].begin(), costs[n - 1].end());
}


-----
int minCost(vector<vector<int>>& costs) 
    // Your code here
}


************************************
Question ID: 266

bool canPermutePalindrome(string s) {
    unordered_map<char, int> count;
    for (char c : s) {
        count[c]++;
    }
    int odd_count = 0;
    for (auto it = count.begin(); it != count.end(); ++it) {
        if (it->second % 2) {
            odd_count++;
        }
    }
    return odd_count <= 1;
}

-----
bool canPermutePalindrome(string s) 
    // Your code here
}

************************************
Question ID: 267

#include <vector>
#include <string>
#include <unordered_map>

using namespace std;

vector<string> generatePalindromes(string s) {
    unordered_map<char, int> charCount;
    for (const char &c : s) {
        charCount[c]++;
    }
    
    int numOdds = 0;
    string halfStr = "", midChar = "";
    for (const auto &entry : charCount) {
        if (entry.second % 2 == 1) {
            numOdds++;
            midChar = entry.first;
        }
        halfStr += string(entry.second / 2, entry.first);
        
        if (numOdds > 1) {
            return {};
        }
    }
    
    vector<string> result;
    sort(halfStr.begin(), halfStr.end());
    do {
        string palindrome = halfStr + midChar + string(halfStr.rbegin(), halfStr.rend());
        result.push_back(palindrome);
    } while (next_permutation(halfStr.begin(), halfStr.end()));
    
    return result;
}

-----
#include <vector>
#include <string>
#include <unordered_map>

using namespace std;

vector<string> generatePalindromes(string s) 
    // Your code here
}

************************************
Question ID: 268

int missingNumber(vector<int>& nums) {
    int n = nums.size();
    int expected_sum = (n * (n + 1)) / 2;
    int actual_sum = 0;
    for (int num : nums) {
        actual_sum += num;
    }
    return expected_sum - actual_sum;
}

-----
int missingNumber(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 269

#include <vector>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <queue>

std::string alienOrder(std::vector<std::string> &words) {
    std::unordered_map<char, std::unordered_set<char>> graph;
    std::unordered_map<char, int> inDegree;
    
    for (const std::string &word : words)
        for (char c : word)
            inDegree[c] = 0;
    
    for (int i = 0; i < words.size() - 1; i++) {
        std::string word1 = words[i], word2 = words[i + 1];
        
        bool found = false;
        for (int j = 0; j < std::min(word1.size(), word2.size()); j++) {
            char c1 = word1[j], c2 = word2[j];
            if (c1 != c2) {
                if (!graph[c1].count(c2)) {
                    graph[c1].insert(c2);
                    inDegree[c2]++;
                }
                found = true;
                break;
            }
        }
        
        if (!found && word1.size() > word2.size())
            return "";
    }

    std::queue<char> q;
    for (auto &[c, deg] : inDegree)
        if (deg == 0)
            q.push(c);
    
    std::string result;
    while (!q.empty()) {
        char c = q.front();
        q.pop();
        result += c;
        
        for (char neigh : graph[c]) {
            inDegree[neigh]--;
            if (inDegree[neigh] == 0)
                q.push(neigh);
        }
    }
    
    if (result.size() < inDegree.size())
        return "";
    
    return result;
}

-----
#include <vector>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <queue>

std::string alienOrder(std::vector<std::string> &words) 
    // Your code here
}

************************************
Question ID: 271

#include <vector>
#include <string>

std::string encode(const std::vector<std::string>& strs) {
    std::string encoded_string;
    for (const auto& s : strs) {
        encoded_string += std::to_string(s.length()) + "#" + s;
    }
    return encoded_string;
}

std::vector<std::string> decode(const std::string& s) {
    std::vector<std::string> strs;
    int i = 0;
    while (i < s.length()) {
        int delimiter_pos = s.find('#', i);
        int length = std::stoi(s.substr(i, delimiter_pos - i));
        strs.push_back(s.substr(delimiter_pos + 1, length));
        i = delimiter_pos + length + 1;
    }
    return strs;
}


-----
#include <vector>
#include <string>

std::string encode(const std::vector<std::string>& strs) 
    // Your code here
}


************************************
Question ID: 272

#include <vector>
#include <queue>
#include <cmath>
#include <cstdlib>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
};

vector<int> closestKValues(TreeNode* root, double target, int k) {
    vector<int> values;
    priority_queue<pair<double, int>> maxHeap;

    function<void(TreeNode*)> inorderTraverse = [&](TreeNode* node) {
        if (!node) return;
        inorderTraverse(node->left);
        maxHeap.push(make_pair(fabs(node->val - target), node->val));
        if (maxHeap.size() > k) maxHeap.pop();
        inorderTraverse(node->right);
    };

    inorderTraverse(root);
    while (!maxHeap.empty()) {
        values.push_back(maxHeap.top().second);
        maxHeap.pop();
    }
    return values;
}

-----
#include <vector>
#include <queue>
#include <cmath>
#include <cstdlib>
using namespace std;

struct TreeNode 
    // Your code here
}

************************************
Question ID: 274

int hIndex(vector<int>& citations) {
    sort(citations.begin(), citations.end(), greater<int>());
    int h = 0;
    for (int i = 0; i < citations.size(); ++i) {
        if (citations[i] >= i + 1) {
            h = i + 1;
        } else {
            break;
        }
    }
    return h;
}

-----
int hIndex(vector<int>& citations) 
    // Your code here
}

************************************
Question ID: 275

int hIndex(vector<int>& citations) {
    int n = citations.size();
    int left = 0, right = n - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (citations[mid] == n - mid) {
            return n - mid;
        } else if (citations[mid] < n - mid) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return n - left;
}

-----
int hIndex(vector<int>& citations) 
    // Your code here
}

************************************
Question ID: 276

int numWays(int n, int k) {
    if (n == 0) return 0;
    if (n == 1) return k;
    int same = k;
    int different = k * (k - 1);
    for (int i = 2; i < n; ++i) {
        int temp = different;
        different = (same + different) * (k - 1);
        same = temp;
    }
    return same + different;
}

-----
int numWays(int n, int k) 
    // Your code here
}

************************************
Question ID: 277

bool knows(int a, int b);

int findCelebrity(int n) {
    int candidate = 0;
    for (int i = 1; i < n; i++) {
        if (knows(candidate, i)) {
            candidate = i;
        }
    }
    
    for (int i = 0; i < n; i++) {
        if (i != candidate && (knows(candidate, i) || !knows(i, candidate))) {
            return -1;
        }
    }
    return candidate;
}

-----
bool knows(int a, int b);

int findCelebrity(int n) 
    // Your code here
}

************************************
Question ID: 278

int firstBadVersion(int n) {
    int left = 1;
    int right = n;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (isBadVersion(mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}


-----
int firstBadVersion(int n) 
    // Your code here
}


************************************
Question ID: 279

#include <vector>
#include <limits>
#include <cmath>

int numSquares(int n) {
    std::vector<int> dp(n + 1, std::numeric_limits<int>::max());
    dp[0] = 0;
    
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j * j <= i; j++) {
            dp[i] = std::min(dp[i], dp[i - j * j] + 1);
        }
    }
    
    return dp[n];
}

-----
#include <vector>
#include <limits>
#include <cmath>

int numSquares(int n) 
    // Your code here
}

************************************
Question ID: 280

void wiggleSort(vector<int>& nums) {
    for (int i = 1; i < nums.size(); i++) {
        if (i%2 == 0 && nums[i] > nums[i-1] || i%2 == 1 && nums[i] < nums[i-1]) {
            swap(nums[i], nums[i-1]);
        }
    }
}

-----
void wiggleSort(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 282

#include <string>
#include <vector>

void helper(const std::string &num, int target, int pos, long long currVal, long long prevVal, std::string currExpr, std::vector<std::string> &res) {
    if (pos == num.size()) {
        if (currVal == target) {
            res.push_back(currExpr);
        }
        return;
    }

    for (int i = pos; i < num.size(); ++i) {
        if (i != pos && num[pos] == '0') break;
        long long val = std::stoll(num.substr(pos, i - pos + 1));
        if (pos == 0) {
            helper(num, target, i + 1, val, val, currExpr + num.substr(pos, i - pos + 1), res);
        } else {
            helper(num, target, i + 1, currVal + val, val, currExpr + "+" + num.substr(pos, i - pos + 1), res);
            helper(num, target, i + 1, currVal - val, -val, currExpr + "-" + num.substr(pos, i - pos + 1), res);
            helper(num, target, i + 1, currVal - prevVal + prevVal * val, prevVal * val, currExpr + "*" + num.substr(pos, i - pos + 1), res);
        }
    }
}

std::vector<std::string> addOperators(std::string num, int target) {
    std::vector<std::string> res;
    helper(num, target, 0, 0, 0, "", res);
    return res;
}


-----
#include <string>
#include <vector>

void helper(const std::string &num, int target, int pos, long long currVal, long long prevVal, std::string currExpr, std::vector<std::string> &res) 
    // Your code here
}


************************************
Question ID: 283

void moveZeroes(vector<int>& nums) {
    int index = 0;
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] != 0) {
            nums[index++] = nums[i];
        }
    }
    for (int i = index; i < nums.size(); i++) {
        nums[i] = 0;
    }
}

-----
void moveZeroes(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 286

#include <vector>
#include <queue>
using namespace std;

void wallsAndGates(vector<vector<int>>& rooms) {
    const int INF = 2147483647;
    int m = rooms.size();
    int n = rooms[0].size();
    queue<pair<int, int>> q;

    for(int i = 0; i < m; i++) {
        for(int j = 0; j < n; j++) {
            if(rooms[i][j] == 0) {
                q.push(make_pair(i, j));
            }
        }
    }

    int directions[][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    while(!q.empty()) {
        int i = q.front().first;
        int j = q.front().second;
        q.pop();

        for(auto d : directions) {
            int ni = i + d[0];
            int nj = j + d[1];

            if(ni >= 0 && ni < m && nj >= 0 && nj < n && rooms[ni][nj] == INF) {
                rooms[ni][nj] = rooms[i][j] + 1;
                q.push(make_pair(ni, nj));
            }
        }
    }
}

-----
#include <vector>
#include <queue>
using namespace std;

void wallsAndGates(vector<vector<int>>& rooms) 
    // Your code here
}

************************************
Question ID: 287

int findDuplicate(vector<int>& nums) {
    int slow = nums[0];
    int fast = nums[0];

    do {
        slow = nums[slow];
        fast = nums[nums[fast]];
    } while (slow != fast);

    slow = nums[0];

    while (slow != fast) {
        slow = nums[slow];
        fast = nums[fast];
    }

    return slow;
}


-----
int findDuplicate(vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 289

#include <vector>

std::vector<std::vector<int>> gameOfLife(std::vector<std::vector<int>>& board) {
    int m = board.size();
    int n = board[0].size();
    std::vector<std::vector<int>> result(m, std::vector<int>(n, 0));
    
    std::vector<std::vector<int>> dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};
    
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            int liveNeighbors = 0;
            
            for (std::vector<int> dir : dirs) {
                int newRow = i + dir[0];
                int newCol = j + dir[1];
                
                if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && board[newRow][newCol] == 1) {
                    liveNeighbors++;
                }
            }
            
            if (board[i][j] == 1 && (liveNeighbors == 2 || liveNeighbors == 3)) {
                result[i][j] = 1;
            } else if (board[i][j] == 0 && liveNeighbors == 3) {
                result[i][j] = 1;
            }
        }
    }
    
    return result;
}

-----
#include <vector>

std::vector<std::vector<int>> gameOfLife(std::vector<std::vector<int>>& board) 
    // Your code here
}

************************************
Question ID: 290

#include <string>
#include <unordered_map>
#include <sstream>
using namespace std;

bool wordPattern(string pattern, string s) {
    unordered_map<char, string> char_map;
    unordered_map<string, char> word_map;
    stringstream ss(s);

    int i = 0;
    for (string word; ss >> word; ++i) {
        if (i == pattern.size()) return false;
        char c = pattern[i];
        if (char_map.count(c) == 0 && word_map.count(word) == 0) {
            char_map[c] = word;
            word_map[word] = c;
        } else {
            if (char_map[c] != word || word_map[word] != c) return false;
        }
    }

    return i == pattern.size();
}


-----
#include <string>
#include <unordered_map>
#include <sstream>
using namespace std;

bool wordPattern(string pattern, string s) 
    // Your code here
}


************************************
Question ID: 291

bool wordPatternMatch(string pattern, string s) {
    unordered_map<char, string> pattern_map;
    unordered_set<string> words;
    return backtrack(pattern, 0, s, 0, pattern_map, words);
}

bool backtrack(string& pattern, int p_index, string& s, int s_index, unordered_map<char, string>& pattern_map, unordered_set<string>& words) {
    if (p_index == pattern.size() && s_index == s.size()) return true;
    if (p_index == pattern.size() || s_index == s.size()) return false;

    char p = pattern[p_index];
    if (pattern_map.count(p)) {
        string word = pattern_map[p];
        if (s.substr(s_index, word.size()) != word) return false;
        return backtrack(pattern, p_index + 1, s, s_index + word.size(), pattern_map, words);
    } else {
        for (int length = 1; length <= s.size() - s_index; length++) {
            string word = s.substr(s_index, length);
            if (words.count(word)) continue;
            pattern_map[p] = word;
            words.insert(word);
            if (backtrack(pattern, p_index + 1, s, s_index + length, pattern_map, words)) return true;
            pattern_map.erase(p);
            words.erase(word);
        }
    }
    return false;
}

-----
bool wordPatternMatch(string pattern, string s) 
    // Your code here
}

************************************
Question ID: 292

bool canWinNim(int n) {
    return n % 4 != 0;
}

-----
bool canWinNim(int n) 
    // Your code here
}

************************************
Question ID: 293

#include <vector>
#include <string>

std::vector<std::string> generatePossibleNextMoves(std::string currentState) {
    std::vector<std::string> result;
    for (int i = 1; i < currentState.size(); ++i) {
        if (currentState[i] == '+' && currentState[i - 1] == '+') {
            currentState[i] = currentState[i - 1] = '-';
            result.push_back(currentState);
            currentState[i] = currentState[i - 1] = '+';
        }
    }
    return result;
}

-----
#include <vector>
#include <string>

std::vector<std::string> generatePossibleNextMoves(std::string currentState) 
    // Your code here
}

************************************
Question ID: 294

bool canWin(string currentState) {
    for (int i = 0; i < currentState.size() - 1; ++i) {
        if (currentState[i] == '+' && currentState[i + 1] == '+') {
            currentState[i] = '-';
            currentState[i + 1] = '-';
            bool opponentWins = canWin(currentState);
            currentState[i] = '+';
            currentState[i + 1] = '+';
            if (!opponentWins) return true;
        }
    }
    return false;
}

-----
bool canWin(string currentState) 
    // Your code here
}

************************************
Question ID: 295

#include <queue>
using namespace std;

class MedianFinder {
public:
    /** initialize your data structure here. */
    priority_queue<int> left;
    priority_queue<int, vector<int>, greater<int> > right;
    
    MedianFinder() {}
    
    void addNum(int num) {
        if (left.empty() || num <= left.top()) {
            left.push(num);
        } else {
            right.push(num);
        }
        
        if (left.size() < right.size()) {
            left.push(right.top());
            right.pop();
        } else if (left.size() > right.size() + 1) {
            right.push(left.top());
            left.pop();
        }
    }
    
    double findMedian() {
        if(left.size() == right.size()){
            return ((double)left.top() + (double)right.top()) / 2;
        }
        else{
            return left.top();
        }
    }
};


-----
#include <queue>
using namespace std;

class MedianFinder 
    // Your code here
};


************************************
Question ID: 296

int minTotalDistance(vector<vector<int>>& grid) {
    vector<int> rows, cols;
    int m = grid.size(), n = grid[0].size();
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (grid[i][j]) {
                rows.push_back(i);
                cols.push_back(j);
            }
        }
    }
    sort(cols.begin(), cols.end());
    int row_median = rows[rows.size() / 2], col_median = cols[cols.size() / 2];
    int distance = 0;
    for (int i : rows) distance += abs(i - row_median);
    for (int j : cols) distance += abs(j - col_median);
    return distance;
}

-----
int minTotalDistance(vector<vector<int>>& grid) 
    // Your code here
}

************************************
Question ID: 299

std::string getHint(std::string secret, std::string guess) {
    int bulls = 0, cows = 0;
    std::vector<int> secret_count(10, 0);
    std::vector<int> guess_count(10, 0);

    for (size_t i = 0; i < secret.length(); i++) {
        if (secret[i] == guess[i]) {
            bulls++;
        } else {
            secret_count[secret[i] - '0']++;
            guess_count[guess[i] - '0']++;
        }
    }

    for (size_t i = 0; i < 10; i++) {
        cows += std::min(secret_count[i], guess_count[i]);
    }

    return std::to_string(bulls) + "A" + std::to_string(cows) + "B";
}


-----
std::string getHint(std::string secret, std::string guess) 
    // Your code here
}


************************************
Question ID: 300

int lengthOfLIS(vector<int>& nums) {
    vector<int> dp(nums.size(), 1);
    int max_length = 1;
    for (int i = 1; i < nums.size(); i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
        max_length = max(max_length, dp[i]);
    }
    return max_length;
}

-----
int lengthOfLIS(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 301

#include <vector>
#include <string>
#include <set>
#include <queue>

using namespace std;

class Solution {
public:
    vector<string> removeInvalidParentheses(string s) {
        set<string> visited;
        queue<string> q;
        vector<string> result;
        bool found = false;

        visited.insert(s);
        q.push(s);

        while (!q.empty()) {
            string cur = q.front();
            q.pop();

            if (isValid(cur)) {
                found = true;
                result.push_back(cur);
            }

            if (found) continue;

            for (int i = 0; i < cur.length(); ++i) {
                if (cur[i] == '(' || cur[i] == ')') {
                    string next = cur.substr(0, i) + cur.substr(i+1);
                    if (visited.find(next) == visited.end()) {
                        visited.insert(next);
                        q.push(next);
                    }
                }
            }
        }
        return result;
    }

    bool isValid(const string &s) {
        int count = 0;
        for (char c : s) {
            if (c == '(') count++;
            if (c == ')') count--;
            if (count < 0) return false;
        }
        return count == 0;
    }
};


-----
#include <vector>
#include <string>
#include <set>
#include <queue>

using namespace std;

class Solution 
    // Your code here
};


************************************
Question ID: 302

int minArea(vector<vector<char>>& image, int x, int y) {
    int top = x, bottom = x, left = y, right = y;
    for (int i = 0; i < image.size(); ++i) {
        for (int j = 0; j < image[i].size(); ++j) {
            if (image[i][j] == '1') {
                top = min(top, i);
                bottom = max(bottom, i);
                left = min(left, j);
                right = max(right, j);
            }
        }
    }
    return (bottom - top + 1) * (right - left + 1);
}

-----
int minArea(vector<vector<char>>& image, int x, int y) 
    // Your code here
}

************************************
Question ID: 305

#include <vector>

using namespace std;

vector<int> numIslands2(int m, int n, vector<vector<int>>& positions) {
    vector<int> roots(m * n, -1);
    vector<vector<int>> dirs{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};
    int islandCount = 0;
    vector<int> result;
    
    auto getIndex = [&](int i, int j){
        return i * n + j;
    };        
    
    function<int(int)> findRoot = [&](int x) {
        if (roots[x] != x) {
            roots[x] = findRoot(roots[x]);
        }
        return roots[x];
    };
    
    for(const auto& position : positions) {
        int i = position[0], j = position[1], index = getIndex(i, j);
        if (roots[index] != -1) {
            result.push_back(islandCount);
            continue;
        }
        islandCount++;
        roots[index] = index;
        for (const auto& dir : dirs) {
            int ni = i + dir[0], nj = j + dir[1], neighbor = getIndex(ni, nj);
            if (ni >= 0 && ni < m && nj >= 0 && nj < n && roots[neighbor] != -1) {
                int rootNb = findRoot(neighbor);
                if (index != rootNb) {
                    roots[rootNb] = index;
                    islandCount--;
                }
            }
        }
        result.push_back(islandCount);
    }
    return result;
}


-----
#include <vector>

using namespace std;

vector<int> numIslands2(int m, int n, vector<vector<int>>& positions) 
    // Your code here
}


************************************
Question ID: 306

bool isAdditiveNumber(std::string num) {
    for (int i = 1; i <= num.length() / 2; i++) {
        for (int j = 1; j <= (num.length() - i) / 2; j++) {
            if (check(num.substr(0, i), num.substr(i, j), num.substr(i + j))) {
                return true;
            }
        }
    }
    return false;
}

bool check(std::string num1, std::string num2, std::string remaining) {
    if ((num1.size() > 1 && num1[0] == '0') || (num2.size() > 1 && num2[0] == '0')) {
        return false;
    }
    std::string sum = add(num1, num2);
    if (remaining == sum) {
        return true;
    }
    if (remaining.substr(0, sum.size()) != sum) {
        return false;
    }
    return check(num2, sum, remaining.substr(sum.size()));
}

std::string add(std::string num1, std::string num2) {
    int carry = 0;
    std::string result;
    for (int i = num1.size() - 1, j = num2.size() - 1;
         i >= 0 || j >= 0 || carry > 0; i--, j--) {
        int n1 = i >= 0 ? num1[i] - '0' : 0;
        int n2 = j >= 0 ? num2[j] - '0' : 0;
        int sum = n1 + n2 + carry;
        carry = sum / 10;
        result.push_back('0' + sum % 10);
    }
    std::reverse(result.begin(), result.end());
    return result;
}

-----
bool isAdditiveNumber(std::string num) 
    // Your code here
}

************************************
Question ID: 309

int maxProfit(vector<int>& prices) {
    int profit = 0;
    for (int i = 1; i < prices.size(); ++i) {
        profit += max(prices[i] - prices[i - 1], 0);
    }
    return profit;
}

-----
int maxProfit(vector<int>& prices) 
    // Your code here
}

************************************
Question ID: 310

#include <vector>
#include <queue>
using namespace std;

vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {
    if (n == 1) return {0};

    vector<int> degrees(n, 0);
    vector<vector<int>> adjList(n);
    for (const auto &edge : edges) {
        adjList[edge[0]].push_back(edge[1]);
        adjList[edge[1]].push_back(edge[0]);
        degrees[edge[0]]++;
        degrees[edge[1]]++;
    }

    queue<int> q;
    for (int i = 0; i < n; ++i) {
        if (degrees[i] == 1) q.push(i);
    }

    while (n > 2) {
        int leaves_size = q.size();
        n -= leaves_size;
        for (int i = 0; i < leaves_size; i++) {
            int leaf = q.front(); q.pop();
            for (int neighbor : adjList[leaf]) {
                if (--degrees[neighbor] == 1) q.push(neighbor);
            }
        }
    }

    vector<int> result;
    while (!q.empty()) {
        result.push_back(q.front());
        q.pop();
    }

    return result;
}

-----
#include <vector>
#include <queue>
using namespace std;

vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) 
    // Your code here
}

************************************
Question ID: 311

#include <vector>
using namespace std;

vector<vector<int>> multiply(vector<vector<int>>& mat1, vector<vector<int>>& mat2) {
    int m = mat1.size();
    int k = mat1[0].size();
    int n = mat2[0].size();
    vector<vector<int>> result(m, vector<int>(n, 0));
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < k; j++) {
            if (mat1[i][j] != 0) {
                for (int l = 0; l < n; l++) {
                    result[i][l] += mat1[i][j] * mat2[j][l];
                }
            }
        }
    }
    return result;
}

-----
#include <vector>
using namespace std;

vector<vector<int>> multiply(vector<vector<int>>& mat1, vector<vector<int>>& mat2) 
    // Your code here
}

************************************
Question ID: 312

int maxCoins(vector<int>& nums) {
    int n = nums.size();
    nums.insert(nums.begin(), 1);
    nums.push_back(1);

    vector<vector<int>> dp(n + 2, vector<int>(n + 2, 0));
    for (int len = 1; len <= n; len++) {
        for (int left = 1; left <= n - len + 1; left++) {
            int right = left + len - 1;
            for (int i = left; i <= right; i++) {
                dp[left][right] = max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);
            }
        }
    }

    return dp[1][n];
}

-----
int maxCoins(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 313

int nthSuperUglyNumber(int n, vector<int>& primes) {
    vector<int> ugly(n);
    ugly[0] = 1;
    vector<int> indices(primes.size(), 0);
    
    for (int i = 1; i < n; i++) {
        int min_val = INT_MAX;
        
        for (int j = 0; j < primes.size(); j++)
            min_val = min(min_val, ugly[indices[j]] * primes[j]);
        
        ugly[i] = min_val;
        
        for (int j = 0; j < primes.size(); j++)
            if (ugly[i] == ugly[indices[j]] * primes[j])
                indices[j]++;
    }
    
    return ugly.back();
}

-----
int nthSuperUglyNumber(int n, vector<int>& primes) 
    // Your code here
}

************************************
Question ID: 314

#include <vector>
#include <map>
#include <queue>

class TreeNode {
public:
    int val;
    TreeNode* left;
    TreeNode* right;

    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};

std::vector<std::vector<int>> verticalOrder(TreeNode* root) {
    if (!root) return {};

    std::map<int, std::vector<int>> columnTable;
    std::queue<std::pair<TreeNode*, int>> q;
    q.push({root, 0});

    while (!q.empty()) {
        TreeNode* curNode = q.front().first;
        int column = q.front().second;
        q.pop();

        if (curNode) {
            columnTable[column].push_back(curNode->val);
            q.push({curNode->left, column - 1});
            q.push({curNode->right, column + 1});
        }
    }

    std::vector<std::vector<int>> result;
    for (auto& [_, values] : columnTable) {
        result.push_back(std::move(values));
    }

    return result;
}

-----
#include <vector>
#include <map>
#include <queue>

class TreeNode 
    // Your code here
}

************************************
Question ID: 315

#include <vector>
#include <iostream>

using namespace std;

vector<int> countSmaller(vector<int>& nums) {
    vector<int> result(nums.size(), 0);
    vector<int> indices(nums.size(), 0);

    for (int i = 0; i < nums.size(); ++i) {
        indices[i] = i;
    }

    mergeSort(nums, indices, result, 0, nums.size() - 1);
    return result;
}

void mergeSort(vector<int>& nums, vector<int>& indices, vector<int>& result, int left, int right) {
    if (left >= right) {
        return;
    }

    int mid = left + (right - left) / 2;
    mergeSort(nums, indices, result, left, mid);
    mergeSort(nums, indices, result, mid + 1, right);


    int I = left;
    int J = mid + 1;
    int K = 0;
    vector<int> temp(right - left + 1);
    while (I <= mid && J <= right) {
        if (nums[indices[I]] <= nums[indices[J]]) {
            result[indices[I]] += (J - mid - 1);
            temp[K++] = indices[I++];
        } else {
            temp[K++] = indices[J++];
        }
    }

    while (I <= mid) {
        result[indices[I]] += (J - mid - 1);
        temp[K++] = indices[I++];
    }

    while (J <= right) {
        temp[K++] = indices[J++];
    }

    for (int i = left, k = 0; i <= right; ++i, ++k) {
        indices[i] = temp[k];
    }
}

-----
#include <vector>
#include <iostream>

using namespace std;

vector<int> countSmaller(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 316

#include <string>
#include <vector>
#include <stack>
using namespace std;

string removeDuplicateLetters(string s) {
    vector<int> count(256, 0);
    vector<bool> visited(256, false);
    stack<char> st;
    
    for (char ch : s) {
        count[ch]++;
    }
    
    for (char ch : s) {
        count[ch]--;
        if (visited[ch]) continue;
        while (!st.empty() && ch < st.top() && count[st.top()] > 0) {
            visited[st.top()] = false;
            st.pop();
        }
        st.push(ch);
        visited[ch] = true;
    }
    
    string result = "";
    while (!st.empty()) {
        result = st.top() + result;
        st.pop();
    }
    return result;
}

-----
#include <string>
#include <vector>
#include <stack>
using namespace std;

string removeDuplicateLetters(string s) 
    // Your code here
}

************************************
Question ID: 317

#include <vector>
#include <queue>

using namespace std;

int shortestDistance(vector<vector<int>>& grid) {
    int m = grid.size();
    int n = grid[0].size();
    
    vector<vector<int>> total_count(m, vector<int>(n, 0));
    vector<vector<int>> dist_sum(m, vector<int>(n, 0));
    int house_count = 0;
    
    int dirs[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 1) {
                house_count++;
                queue<pair<int, int>> q;
                q.push({i, j});
                vector<vector<bool>> visited(m, vector<bool>(n, false));
                int level = 1;
                while (!q.empty()) {
                    int sz = q.size();
                    for (int q_i = 0; q_i < sz; q_i++) {
                        int x = q.front().first;
                        int y = q.front().second;
                        q.pop();
                        for (auto &dir : dirs) {
                            int x_new = x + dir[0];
                            int y_new = y + dir[1];
                            if (x_new >= 0 && x_new < m && y_new >= 0 && y_new < n && !visited[x_new][y_new] && grid[x_new][y_new] == 0) {
                                visited[x_new][y_new] = true;
                                q.push({x_new, y_new});
                                dist_sum[x_new][y_new] += level;
                                total_count[x_new][y_new]++;
                            }
                        }
                    }
                    level++;
                }
            }
        }
    }
                                         
    int min_dist = INT_MAX;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (total_count[i][j] == house_count) {
                min_dist = min(min_dist, dist_sum[i][j]);
            }
        }
    }
    
    return min_dist == INT_MAX ? -1 : min_dist;
}


-----
#include <vector>
#include <queue>

using namespace std;

int shortestDistance(vector<vector<int>>& grid) 
    // Your code here
}


************************************
Question ID: 318

#include <vector>
#include <string>

int maxProduct(std::vector<std::string>& words) {
    int n = words.size();
    std::vector<int> mask(n, 0);
    for (int i = 0; i < n; ++i) {
        for (char c : words[i]) {
            mask[i] |= (1 << (c - 'a'));
        }
    }

    int max_product = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            if ((mask[i] & mask[j]) == 0) {
                max_product = std::max(max_product, int(words[i].length() * words[j].length()));
            }
        }
    }

    return max_product;
}


-----
#include <vector>
#include <string>

int maxProduct(std::vector<std::string>& words) 
    // Your code here
}


************************************
Question ID: 319

int bulbSwitch(int n) {
    return sqrt(n);
}

-----
int bulbSwitch(int n) 
    // Your code here
}

************************************
Question ID: 320

#include <vector>
#include <string>

std::vector<std::string> generateAbbreviations(std::string word) {
    std::vector<std::string> res;
    res.push_back(word.empty() ? "" : std::to_string(word.size()));
    for (size_t i = 0; i < word.size(); ++i)
        for (const std::string &abbr : generateAbbreviations(word.substr(i + 1))) {
            size_t num;
            if (abbr.empty() || (num = abbr.find_first_not_of('123456789')) > 0)
                res.push_back(word.substr(0, i) + '1' + abbr);
            if (i == 0 || abbr.empty() || abbr[0] > '9')
                res.push_back(word.substr(0, i + 1) + abbr);
        }
    return res;
}

-----
#include <vector>
#include <string>

std::vector<std::string> generateAbbreviations(std::string word) 
    // Your code here
}

************************************
Question ID: 321


```cpp
#include <vector>
#include <algorithm>

std::vector<int> maxNumber(std::vector<int>& nums1, std::vector<int>& nums2, int k) {
    int m = nums1.size(), n = nums2.size();
    std::vector<int> ans(k, 0);
    for (int i = std::max(0, k - n); i <= k && i <= m; ++i) {
        std::vector<int> candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);
        if (greater(candidate, 0, ans, 0)) ans = candidate;
    }
    return ans;
}

std::vector<int> maxArray(std::vector<int>& nums, int k) {
    int n = nums.size();
    std::vector<int> ans(k, 0);
    for (int i = 0, j = 0; i < n; ++i) {
        while (n - i > k - j && j > 0 && ans[j - 1] < nums[i]) j--;
        if (j < k) ans[j++] = nums[i];
    }
    return ans;
}

std::vector<int> merge(std::vector<int>& nums1, std::vector<int>& nums2, int k) {
    std::vector<int> ans(k, 0);
    for (int i = 0, j = 0, r = 0; r < k; ++r)
        ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];
    return ans;
}

bool greater(std::vector<int>& nums1, int i, std::vector<int>& nums2, int j) {
    while (i < nums1.size() && j < nums2.size() && nums1[i] == nums2[j]) {
        i++;
        j++;
    }
    return j == nums2.size() || (i < nums1.size() && nums1[i] > nums2[j]);
}
```


-----

```cpp
#include <vector>
#include <algorithm>

std::vector<int> maxNumber(std::vector<int>& nums1, std::vector<int>& nums2, int k) 
    // Your code here
}
```


************************************
Question ID: 322

#include <vector>
#include <algorithm>

int coinChange(std::vector<int>& coins, int amount) {
    std::vector<int> dp(amount + 1, amount + 1);
    dp[0] = 0;
    
    for (int i = 0; i < coins.size(); i++) {
        for (int j = coins[i]; j <= amount; j++) {
            dp[j] = std::min(dp[j], dp[j - coins[i]] + 1);
        }
    }

    return dp[amount] <= amount ? dp[amount] : -1;
}

-----
#include <vector>
#include <algorithm>

int coinChange(std::vector<int>& coins, int amount) 
    // Your code here
}

************************************
Question ID: 323

#include <vector>

int countComponents(int n, std::vector<std::vector<int>>& edges) {
    std::vector<std::vector<int>> adjList(n);
    for (const auto& edge : edges) {
        adjList[edge[0]].push_back(edge[1]);
        adjList[edge[1]].push_back(edge[0]);
    }
    
    std::vector<bool> visited(n, false);
    int connectedComponents = 0;

    for (int i = 0; i < n; ++i) {
        if (!visited[i]) {
            std::function<void(int)> dfs = [&](int node) {
                visited[node] = true;
                for (int neighbor : adjList[node]) {
                    if (!visited[neighbor]) {
                        dfs(neighbor);
                    }
                }
            };
            dfs(i);
            connectedComponents++;
        }
    }
    return connectedComponents;
}


-----
#include <vector>

int countComponents(int n, std::vector<std::vector<int>>& edges) 
    // Your code here
}


************************************
Question ID: 324

#include <algorithm>
void wiggleSort(vector<int>& nums) {
    sort(nums.begin(), nums.end());
    for (int i = 1; i < nums.size() - 1; i += 2) {
        swap(nums[i], nums[i + 1]);
    }
}


-----
#include <algorithm>
void wiggleSort(vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 325

int maxSubArrayLen(vector<int>& nums, int k) {
    unordered_map<int, int> sumIndex;
    int maxLength = 0, sum = 0;
    for(int i = 0; i < nums.size(); i++) {
        sum += nums[i];
        if(sum == k) maxLength = i + 1;
        if(sumIndex.count(sum - k)) maxLength = max(maxLength, i - sumIndex[sum - k]);
        if(!sumIndex.count(sum)) sumIndex[sum] = i;
    }
    return maxLength;
}


-----
int maxSubArrayLen(vector<int>& nums, int k) 
    // Your code here
}


************************************
Question ID: 326

bool isPowerOfThree(int n) {
    if (n < 1) {
        return false;
    }
    
    while (n % 3 == 0) {
        n /= 3;
    }
    
    return n == 1;
}

-----
bool isPowerOfThree(int n) 
    // Your code here
}

************************************
Question ID: 327

int countRangeSum(vector<int>& nums, int lower, int upper) {
    int n = nums.size();
    vector<long> sums(n + 1, 0);
    for (int i = 0; i < n; ++i)
        sums[i + 1] = sums[i] + nums[i];

    function<int(int, int)> mergeSort = [&](int start, int end) {
        if (start == end)
            return 0;
        int mid = start + (end - start) / 2;
        int count = mergeSort(start, mid) + mergeSort(mid + 1, end);

        int j = mid + 1, k = mid + 1;
        for (int i = start; i <= mid; ++i) {
            while (j <= end && sums[j] - sums[i] < lower) ++j;
            while (k <= end && sums[k] - sums[i] <= upper) ++k;
            count += k - j;
        }

        inplace_merge(sums.begin() + start, sums.begin() + mid + 1, sums.begin() + end + 1);
        return count;
    };

    return mergeSort(0, n);
}

-----
int countRangeSum(vector<int>& nums, int lower, int upper) 
    // Your code here
}

************************************
Question ID: 329

int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};

int dfs(vector<vector<int>>& matrix, vector<vector<int>>& memo, int i, int j) {
    if (memo[i][j] != 0) return memo[i][j];
    
    int max_len = 0;
    for (int k = 0; k < 4; ++k) {
        int ni = i + dx[k], nj = j + dy[k];
        if (ni >= 0 && ni < matrix.size() && nj >= 0 && nj < matrix[0].size() && matrix[ni][nj] > matrix[i][j]) {
            max_len = max(max_len, dfs(matrix, memo, ni, nj));
        }
    }
    
    memo[i][j] = max_len + 1;
    return memo[i][j];
}

int longestIncreasingPath(vector<vector<int>>& matrix) {
    int m = matrix.size(), n = matrix[0].size();
    
    vector<vector<int>> memo(m, vector<int>(n, 0));
    
    int ans = 0;
    for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j)
            ans = max(ans, dfs(matrix, memo, i, j));
    
    return ans;
}


-----
int dx[] = 
    // Your code here
}


************************************
Question ID: 330

int minPatches(vector<int>& nums, int n) {
    long long maxSum = 0;
    int patches = 0, i = 0;
    
    while (maxSum < n) {
        if (i < nums.size() && nums[i] <= maxSum + 1) {
            maxSum += nums[i];
            i++;
        } else {
            maxSum += maxSum + 1;
            patches++;
        }
    }
    return patches;
}

-----
int minPatches(vector<int>& nums, int n) 
    // Your code here
}

************************************
Question ID: 331

#include <string>
#include <sstream>
#include <vector>

bool isValidSerialization(const std::string &preorder) {
    std::istringstream iss(preorder);
    std::string token;
    int node_count = 1;

    while (std::getline(iss, token, ',')) {
        --node_count;
        if (node_count < 0) return false;
        if (token != "#") node_count += 2;
    }

    return node_count == 0;
}

-----
#include <string>
#include <sstream>
#include <vector>

bool isValidSerialization(const std::string &preorder) 
    // Your code here
}

************************************
Question ID: 332

#include <vector>
#include <string>
#include <unordered_map>
#include <set>

using namespace std;

vector<string> findItinerary(vector<vector<string>>& tickets) {
    unordered_map<string, multiset<string>> flights;
    vector<string> itinerary;
    
    for (const auto& ticket : tickets)
        flights[ticket[0]].insert(ticket[1]);
    
    stack<string> dfs;
    dfs.push("JFK");
    
    while (!dfs.empty()) {
        string next_airport = dfs.top();
        if (flights[next_airport].empty()) {
            itinerary.push_back(next_airport);
            dfs.pop();
        } else {
            dfs.push(*flights[next_airport].begin());
            flights[next_airport].erase(flights[next_airport].begin());
        }
    }
    
    reverse(itinerary.begin(), itinerary.end());
    return itinerary;
}

-----
#include <vector>
#include <string>
#include <unordered_map>
#include <set>

using namespace std;

vector<string> findItinerary(vector<vector<string>>& tickets) 
    // Your code here
}

************************************
Question ID: 334

bool findTriplets(vector<int>& nums) {
    int first = INT_MAX, second = INT_MAX;

    for (int num : nums) {
        if (num <= first) {
            first = num;
        } else if (num <= second) {
            second = num;
        } else {
            return true;
        }
    }
    return false;
}

-----
bool findTriplets(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 335

bool isPathCrossing(const std::vector<int>& distance) {
    std::unordered_set<std::pair<int, int>, pair_hash> visited;
    int x = 0, y = 0;
    visited.insert({x, y});
    int dx[] = {0, -1, 0, 1};
    int dy[] = {1, 0, -1, 0};
    
    for (int i = 0; i < distance.size(); ++i) {
        int direction = i % 4;
        for (int j = 0; j < distance[i]; ++j) {
            x += dx[direction];
            y += dy[direction];
            if (!visited.insert({x, y}).second) {
                return true;
            }
        }
    }
    return false;
}


-----
bool isPathCrossing(const std::vector<int>& distance) 
    // Your code here
}


************************************
Question ID: 336

#include <vector>
#include <string>

std::vector<std::pair<int, int>> palindromePairs(const std::vector<std::string> &words) {
    std::vector<std::pair<int, int>> result;

    for (size_t i = 0; i < words.size(); i++) {
        for (size_t j = 0; j < words.size(); j++) {
            if (i == j) continue;
            std::string concat = words[i] + words[j];

            bool is_palindrome = true;
            for (size_t left = 0, right = concat.size() - 1; left < right; left++, right--) {
                if (concat[left] != concat[right]) {
                    is_palindrome = false;
                    break;
                }
            }

            if (is_palindrome) {
                result.push_back(std::make_pair(i, j));
            }
        }
    }

    return result;
}

-----
#include <vector>
#include <string>

std::vector<std::pair<int, int>> palindromePairs(const std::vector<std::string> &words) 
    // Your code here
}

************************************
Question ID: 337

int robHelper(TreeNode* node, int& includeNode, int& excludeNode) {
    if (!node) return 0;

    int left_include, left_exclude, right_include, right_exclude;

    robHelper(node->left, left_include, left_exclude);
    robHelper(node->right, right_include, right_exclude);

    includeNode = node->val + left_exclude + right_exclude;
    excludeNode = max(left_include, left_exclude) + max(right_include, right_exclude);
    return max(includeNode, excludeNode);
}

int rob(TreeNode* root) {
    int includeNode = 0, excludeNode = 0;
    return robHelper(root, includeNode, excludeNode);
}

-----
int robHelper(TreeNode* node, int& includeNode, int& excludeNode) 
    // Your code here
}

************************************
Question ID: 338

#include <vector>
using namespace std;

vector<int> countBits(int n) {
    vector<int> ans(n + 1, 0);
    for (int i = 1; i <= n; ++i) {
        ans[i] = ans[i & (i - 1)] + 1;
    }
    return ans;
}

-----
#include <vector>
using namespace std;

vector<int> countBits(int n) 
    // Your code here
}

************************************
Question ID: 339

#include <vector>
#include <variant>

using NestedList = std::vector<std::variant<int, std::vector<std::variant<int, std::vector<int>>>>>;

int depthSumHelper(NestedList nestedList, int depth) {
    int sum = 0;
    for (auto& element : nestedList) {
        if (std::holds_alternative<int>(element)) {
            sum += std::get<int>(element) * depth;
        } else {
            sum += depthSumHelper(std::get<std::vector<std::variant<int, std::vector<int>>>>(element), depth + 1);
        }
    }
    return sum;
}

int depthSum(NestedList nestedList) {
    return depthSumHelper(nestedList, 1);
}


-----
#include <vector>
#include <variant>

using NestedList = std::vector<std::variant<int, std::vector<std::variant<int, std::vector<int>>>>>;

int depthSumHelper(NestedList nestedList, int depth) 
    // Your code here
}


************************************
Question ID: 340

#include <unordered_map>
#include <algorithm>

int lengthOfLongestSubstringKDistinct(std::string s, int k) {
    std::unordered_map<char, int> charCount;
    int left = 0, maxLength = 0;

    for (int right = 0; right < s.size(); ++right) {
        charCount[s[right]]++;

        while (charCount.size() > k) {
            charCount[s[left]]--;
            if (charCount[s[left]] == 0) {
                charCount.erase(s[left]);
            }
            left++;
        }

        maxLength = std::max(maxLength, right - left + 1);
    }
    return maxLength;
}

-----
#include <unordered_map>
#include <algorithm>

int lengthOfLongestSubstringKDistinct(std::string s, int k) 
    // Your code here
}

************************************
Question ID: 342

bool isPowerOfFour(int n) {
    if (n <= 0) return false;
    while (n % 4 == 0) {
        n /= 4;
    }
    return n == 1;
}

-----
bool isPowerOfFour(int n) 
    // Your code here
}

************************************
Question ID: 343

int integerBreak(int n) {
    if (n <= 3) return n - 1;
    int product = 1;
    while (n > 4) {
        product *= 3;
        n -= 3;
    }
    return product * n;
}

-----
int integerBreak(int n) 
    // Your code here
}

************************************
Question ID: 344

void reverseString(vector<char>& s) {
    int left = 0, right = s.size() - 1;
    while (left < right) {
        swap(s[left++], s[right--]);
    }
}

-----
void reverseString(vector<char>& s) 
    // Your code here
}

************************************
Question ID: 345

#include <algorithm>
#include <string>

std::string reverseVowels(std::string s) {
    int i = 0, j = s.size() - 1;
    while (i < j) {
        if (!isVowel(s[i])) {
            i++;
        } else if (!isVowel(s[j])) {
            j--;
        } else {
            std::swap(s[i], s[j]);
            i++;
            j--;
        }
    }
    return s;
}

bool isVowel(char c) {
    c = std::tolower(c);
    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
}

-----
#include <algorithm>
#include <string>

std::string reverseVowels(std::string s) 
    // Your code here
}

************************************
Question ID: 346

#include <queue>
using namespace std;

class MovingAverage {
public:
    queue<int> q;
    int maxSize;
    double sum;

    MovingAverage(int size) {
        maxSize = size;
        sum = 0;
    }

    double next(int val) {
        if (q.size() == maxSize) {
            sum -= q.front();
            q.pop();
        }
        q.push(val);
        sum += val;
        return sum / q.size();
    }
};

-----
#include <queue>
using namespace std;

class MovingAverage 
    // Your code here
};

************************************
Question ID: 347

#include <vector>
#include <unordered_map>
#include <queue>
using namespace std;

vector<int> kMostFrequent(vector<int>& nums, int k) {
    unordered_map<int, int> frequency;
    for (int num : nums) {
        frequency[num]++;
    }

    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> min_heap;
    for (const auto& entry : frequency) {
        min_heap.push({entry.second, entry.first});
        if (min_heap.size() > k) {
            min_heap.pop();
        }
    }

    vector<int> result;
    while (!min_heap.empty()) {
        result.push_back(min_heap.top().second);
        min_heap.pop();
    }

    return result;
}


-----
#include <vector>
#include <unordered_map>
#include <queue>
using namespace std;

vector<int> kMostFrequent(vector<int>& nums, int k) 
    // Your code here
}


************************************
Question ID: 349

#include <vector>
#include <set>

std::vector<int> intersection(std::vector<int>& nums1, std::vector<int>& nums2) {
    std::set<int> set1(nums1.begin(), nums1.end());
    std::set<int> result;
    for (int num : nums2) {
        if (set1.count(num)) {
            result.insert(num);
        }
    }
    return std::vector<int>(result.begin(), result.end());
}

-----
#include <vector>
#include <set>

std::vector<int> intersection(std::vector<int>& nums1, std::vector<int>& nums2) 
    // Your code here
}

************************************
Question ID: 350

#include <vector>
#include <unordered_map>

std::vector<int> intersect(std::vector<int>& nums1, std::vector<int>& nums2) {
    std::unordered_map<int, int> count_map;
    std::vector<int> result;
    
    for (int num : nums1) {
        count_map[num]++;
    }
    
    for (int num : nums2) {
        if (count_map[num] > 0) {
            result.push_back(num);
            count_map[num]--;
        }
    }

    return result;
}


-----
#include <vector>
#include <unordered_map>

std::vector<int> intersect(std::vector<int>& nums1, std::vector<int>& nums2) 
    // Your code here
}


************************************
Question ID: 351

int numberOfPatterns(int m, int n) {
    const vector<vector<int>> jumps(10, vector<int>(10, 0));
    jumps[1][3] = jumps[3][1] = 2;
    jumps[1][7] = jumps[7][1] = 4;
    jumps[3][9] = jumps[9][3] = 6;
    jumps[7][9] = jumps[9][7] = 8;
    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5;

    vector<bool> visited(10, false);

    int cnt = 0;
    for (int i = m; i <= n; ++i) {
        cnt += dfs(jumps, visited, 1, i - 1) * 4; // 1, 3, 7, 9
        cnt += dfs(jumps, visited, 2, i - 1) * 4; // 2, 4, 6, 8
        cnt += dfs(jumps, visited, 5, i - 1);     // 5
    }

    return cnt;
}

int dfs(const vector<vector<int>>& jumps, vector<bool>& visited, int curr, int remaining) {
    if (remaining < 0) return 0;
    if (remaining == 0) return 1;

    visited[curr] = true;
    int cnt = 0;
    for (int next = 1; next <= 9; ++next) {
        if (!visited[next] && (jumps[curr][next] == 0 || visited[jumps[curr][next]])) {
            cnt += dfs(jumps, visited, next, remaining - 1);
        }
    }
    visited[curr] = false;

    return cnt;
}


-----
int numberOfPatterns(int m, int n) 
    // Your code here
}


************************************
Question ID: 352

#include <map>

class SummaryRanges {
public:
    void addNum(int val) {
        if (intervals.empty() || intervals.begin()->first > val + 1) {
            intervals[val] = val;
        } else {
            auto it = intervals.lower_bound(val);
            auto left = prev(it), right = it;
            
            if (left != intervals.end() && left->second + 1 == val) {
                left->second++;
                if (right != intervals.end() && val + 1 == right->first) {
                    left->second = right->second;
                    intervals.erase(right);
                }
            } else if (right != intervals.end() && val + 1 == right->first) {
                intervals[val] = right->second;
                intervals.erase(right);
            } else {
                intervals[val] = val;
            }
        }
    }

    vector<vector<int>> getIntervals() {
        vector<vector<int>> result;
        for (const auto& interval : intervals) {
            result.push_back({interval.first, interval.second});
        }
        return result;
    }

private:
    map<int, int> intervals;
};


-----
#include <map>

class SummaryRanges 
    // Your code here
};


************************************
Question ID: 353

#include <list>
#include <unordered_set>
#include <vector>

class SnakeGame {
public:
    SnakeGame(int width, int height, std::vector<std::vector<int>>& food)
        : width(width), height(height), food(food), pos(0), score(0) {
        snake.push_back({0, 0});
        occupied.insert(0);
    }

    int move(std::string direction) {
        int new_x = snake.back().first + dx[direction];
        int new_y = snake.back().second + dy[direction];

        if (new_x < 0 || new_x >= height || new_y < 0 || new_y >= width) {
            return -1;
        }

        std::pair<int, int> new_head = std::make_pair(new_x, new_y);
        std::pair<int, int> tail = snake.front();

        if (pos < food.size() && food[pos][0] == new_x && food[pos][1] == new_y) {
            score++;
            pos++;
        } else {
            snake.pop_front();
            occupied.erase(tail.first * width + tail.second);
        }

        if (occupied.count(new_head.first * width + new_head.second)) {
            return -1;
        }

        snake.push_back(new_head);
        occupied.insert(new_head.first * width + new_head.second);
        return score;
    }

private:
    int width;
    int height;
    std::vector<std::vector<int>> food;
    int pos;
    int score;
    std::list<std::pair<int, int>> snake;
    std::unordered_set<int> occupied;
    std::unordered_map<std::string, int> dx = {{"U", -1}, {"D", 1}, {"L", 0}, {"R", 0}};
    std::unordered_map<std::string, int> dy = {{"U", 0}, {"D", 0}, {"L", -1}, {"R", 1}};
};

-----
#include <list>
#include <unordered_set>
#include <vector>

class SnakeGame 
    // Your code here
};

************************************
Question ID: 354

#include <vector>
#include <algorithm>

int maxEnvelopes(std::vector<std::vector<int>>& envelopes) {
    std::sort(envelopes.begin(), envelopes.end(), [](const std::vector<int>& a, const std::vector<int>& b) {
        return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];
    });
    
    std::vector<int> dp;
    for (const auto& envelope : envelopes) {
        auto it = std::lower_bound(dp.begin(), dp.end(), envelope[1]);
        if (it == dp.end()) {
            dp.push_back(envelope[1]);
        } else {
            *it = envelope[1];
        }
    }
    
    return dp.size();
}

-----
#include <vector>
#include <algorithm>

int maxEnvelopes(std::vector<std::vector<int>>& envelopes) 
    // Your code here
}

************************************
Question ID: 355

#include <list>
#include <unordered_map>
#include <vector>
#include <algorithm>
using namespace std;

class Twitter {
public:
    class Tweet {
    public:
        int time;
        int tweetId;
        Tweet(int t, int id) : time(t), tweetId(id) {}
    };

    unordered_map<int, vector<Tweet>> tweets;
    unordered_map<int, unordered_set<int>> following;
    int timeStamp;

    Twitter() {
        timeStamp = 0;
    }

    void postTweet(int userId, int tweetId) {
        tweets[userId].emplace_back(timeStamp++, tweetId);
    }

    vector<int> getNewsFeed(int userId) {
        vector<Tweet*> feed;
        for (Tweet& t : tweets[userId]) {
            feed.push_back(&t);
        }
        for (int user : following[userId]) {
            for (Tweet& t : tweets[user]) {
                feed.push_back(&t);
            }
        }
        
        sort(feed.begin(), feed.end(), [](Tweet* a, Tweet* b) {
            return a->time > b->time;
        });

        vector<int> result;
        for (int i = 0; i < feed.size() && i < 10; ++i) {
            result.push_back(feed[i]->tweetId);
        }
        return result;
    }

    void follow(int followerId, int followeeId) {
        if (followerId != followeeId) {
            following[followerId].insert(followeeId);
        }
    }

    void unfollow(int followerId, int followeeId) {
        following[followerId].erase(followeeId);
    }
};


-----
#include <list>
#include <unordered_map>
#include <vector>
#include <algorithm>
using namespace std;

class Twitter 
    // Your code here
};


************************************
Question ID: 356

bool isReflected(vector<vector<int>>& points) {
    int minX = INT_MAX;
    int maxX = INT_MIN;

    unordered_set<string> pointSet;
    for(const auto& point : points) {
        minX = min(minX, point[0]);
        maxX = max(maxX, point[0]);
        pointSet.insert(to_string(point[0]) + "," + to_string(point[1]));
    }

    int sum = minX + maxX;
    for(const auto& point : points) {
        if(!pointSet.count(to_string(sum - point[0]) + "," + to_string(point[1]))) {
            return false;
        }
    }

    return true;
}

-----
bool isReflected(vector<vector<int>>& points) 
    // Your code here
}

************************************
Question ID: 357

int countNumbersWithUniqueDigits(int n) {
    if (n == 0) return 1;
    
    int total = 10;
    int uniqueDigits = 9;
    int currentAvailableDigits = 9;
    
    while(n-- > 1 && currentAvailableDigits > 0) {
        uniqueDigits *= currentAvailableDigits;
        total += uniqueDigits;
        currentAvailableDigits--;
    }
    
    return total;
}


-----
int countNumbersWithUniqueDigits(int n) 
    // Your code here
}


************************************
Question ID: 358

#include <queue>
#include <unordered_map>
#include <string>
using namespace std;

string rearrangeString(string s, int k) {
    if (k == 0) return s;
    
    unordered_map<char, int> freq;
    for (char c : s) {
        freq[c]++;
    }
    
    priority_queue<pair<int, char>> max_heap;
    for (const auto& kv : freq) {
        max_heap.emplace(kv.second, kv.first);
    }
    
    string result;
    while (!max_heap.empty()) {
        vector<pair<int, char>> temp;
        
        for (int i = 0; i < k && !max_heap.empty(); ++i) {
            auto curr = max_heap.top();
            max_heap.pop();
            
            result += curr.second;
            if (--curr.first > 0) {
                temp.push_back(curr);
            }
        }
        
        for (const auto& entry : temp) {
            max_heap.push(entry);
        }
        
        if (max_heap.empty()) break;
        if (result.length() < s.length()) result.append(k - temp.size(), ' ');
    }
    
    if (result.length() < s.length()) return "";
    return result;
}


-----
#include <queue>
#include <unordered_map>
#include <string>
using namespace std;

string rearrangeString(string s, int k) 
    // Your code here
}


************************************
Question ID: 360

vector<int> sortTransformedArray(vector<int>& nums, int a, int b, int c) {
    vector<int> result(nums.size());
    int i = 0, j = nums.size() - 1, index = (a >= 0) ? nums.size() - 1 : 0;
    
    while (i <= j) {
        int left = nums[i] * nums[i] * a + nums[i] * b + c;
        int right = nums[j] * nums[j] * a + nums[j] * b + c;
        
        if (a >= 0) {
            if (left >= right) {
                result[index--] = left;
                i++;
            } else {
                result[index--] = right;
                j--;
            }
        } else {
            if (left <= right) {
                result[index++] = left;
                i++;
            } else {
                result[index++] = right;
                j--;
            }
        }
    }
    return result;
}

-----
vector<int> sortTransformedArray(vector<int>& nums, int a, int b, int c) 
    // Your code here
}

************************************
Question ID: 361

int maxKilledEnemies(vector<vector<char>>& grid) {
    if (grid.empty()) return 0;
    int m = grid.size(), n = grid[0].size(), result = 0, rowhits = 0;
    vector<int> colhits(n, 0);
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (j == 0 || grid[i][j - 1] == 'W') {
                rowhits = 0;
                for (int k = j; k < n && grid[i][k] != 'W'; k++)
                    rowhits += grid[i][k] == 'E';
            }
            if (i == 0 || grid[i - 1][j] == 'W') {
                colhits[j] = 0;
                for (int k = i; k < m && grid[k][j] != 'W'; k++)
                    colhits[j] += grid[k][j] == 'E';
            }
            if (grid[i][j] == '0') result = max(result, rowhits + colhits[j]);
        }
    }
    return result;
}

-----
int maxKilledEnemies(vector<vector<char>>& grid) 
    // Your code here
}

************************************
Question ID: 362

#include <queue>

class HitCounter {
public:
    HitCounter() {}

    void hit(int timestamp) {
        q.push(timestamp);
    }

    int getHits(int timestamp) {
        while (!q.empty() && q.front() <= (timestamp - 300)) {
            q.pop();
        }
        return q.size();
    }

private:
    std::queue<int> q;
};

-----
#include <queue>

class HitCounter 
    // Your code here
};

************************************
Question ID: 363

#include <vector>
#include <set>

int maxSumSubmatrix(std::vector<std::vector<int>>& matrix, int k) {
    int rows = matrix.size();
    int cols = matrix[0].size();
    int maxSum = INT_MIN;

    for (int l = 0; l < cols; ++l) {
        std::vector<int> sums(rows, 0);
        for (int r = l; r < cols; ++r) {
            for (int i = 0; i < rows; ++i) {
                sums[i] += matrix[i][r];
            }

            std::set<int> sortedSums;
            sortedSums.insert(0);
            int currSum = 0;
            for (int sum : sums) {
                currSum += sum;
                auto it = sortedSums.lower_bound(currSum - k);
                if (it != sortedSums.end())
                    maxSum = std::max(maxSum, currSum - *it);
                sortedSums.insert(currSum);
            }
        }
    }

    return maxSum;
}


-----
#include <vector>
#include <set>

int maxSumSubmatrix(std::vector<std::vector<int>>& matrix, int k) 
    // Your code here
}


************************************
Question ID: 364

#include <variant>
#include <vector>

using NestedInteger = std::variant<int, std::vector<std::variant<int, std::vector<NestedInteger>>>>;

int sumHelper(NestedInteger& nested, int depth) {
    int sum = 0;
    if (auto pInt = std::get_if<int>(&nested)) {
        sum += depth * (*pInt);
    } else {
        auto& list = std::get<std::vector<NestedInteger>>(nested);
        for (auto& element : list) {
            sum += sumHelper(element, depth - 1);
        }
    }
    return sum;
}

int maxDepth(NestedInteger& nested) {
    if (std::holds_alternative<int>(nested)) return 0;
    int depth = 1;
    for (auto& element : std::get<std::vector<NestedInteger>>(nested)) {
        depth = std::max(depth, 1 + maxDepth(element));
    }
    return depth;
}

int depthSumInverse(std::vector<NestedInteger>& nestedList) {
    int max_depth = 1;
    for (auto& nested : nestedList) {
        max_depth = std::max(max_depth, 1 + maxDepth(nested));
    }
    int sum = 0;
    for (auto& nested : nestedList) {
        sum += sumHelper(nested, max_depth);
    }
    return sum;
}

-----
#include <variant>
#include <vector>

using NestedInteger = std::variant<int, std::vector<std::variant<int, std::vector<NestedInteger>>>>;

int sumHelper(NestedInteger& nested, int depth) 
    // Your code here
}

************************************
Question ID: 365

bool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {
    if (targetCapacity > jug1Capacity + jug2Capacity) return false;
    if (jug1Capacity == targetCapacity || jug2Capacity == targetCapacity 
        || jug1Capacity + jug2Capacity == targetCapacity) return true;
    return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0;
}

int gcd(int a, int b) {
    while (b) {
        int tmp = a % b;
        a = b;
        b = tmp;
    }
    return a;
}


-----
bool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) 
    // Your code here
}


************************************
Question ID: 367

bool isPerfectSquare(int num) {
    if (num < 2) return true;
    long long left = 2, right = num / 2, mid, square;
    while (left <= right) {
        mid = left + (right - left) / 2;
        square = mid * mid;
        if (square == num) return true;
        if (square > num) right = mid - 1;
        else left = mid + 1;
    }
    return false;
}

-----
bool isPerfectSquare(int num) 
    // Your code here
}

************************************
Question ID: 368

#include <vector>
#include <algorithm>
using namespace std;

vector<int> largestDivisibleSubset(vector<int>& nums) {
    sort(nums.begin(), nums.end());
    int n = nums.size();
    vector<int> count(n, 1), prev(n, -1), res;
    int max_idx = 0;

    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (nums[i] % nums[j] == 0 && count[i] < count[j] + 1) {
                count[i] = count[j] + 1;
                prev[i] = j;
            }
        }
        if (count[max_idx] < count[i]) max_idx = i;
    }

    for (int i = max_idx; i >= 0; i = prev[i]) {
        res.push_back(nums[i]);
    }

    return res;
}

-----
#include <vector>
#include <algorithm>
using namespace std;

vector<int> largestDivisibleSubset(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 370

#include <vector>
using namespace std;

vector<int> getUpdatedArray(int length, vector<vector<int>>& updates) {
    vector<int> arr(length, 0);

    for (const auto& update : updates) {
        arr[update[0]] += update[2];
        if (update[1] + 1 < length) {
            arr[update[1] + 1] -= update[2];
        }
    }
    
    for (int i = 1; i < length; i++) {
        arr[i] += arr[i - 1];
    }
    
    return arr;
}

-----
#include <vector>
using namespace std;

vector<int> getUpdatedArray(int length, vector<vector<int>>& updates) 
    // Your code here
}

************************************
Question ID: 371

int add(int a, int b) {
    while (b != 0) {
        int carry = a & b;
        a = a ^ b;
        b = carry << 1;
    }
    return a;
}

-----
int add(int a, int b) 
    // Your code here
}

************************************
Question ID: 372

int powmod(int a, int b) {
    if (b == 0) return 1;
    int res = powmod(a, b / 2);
    if (b % 2 == 0) return res * res % 1337;
    return res * res % 1337 * a % 1337;
}

int superPow(int a, vector<int>& b) {
    int n = 0;
    for (int bi : b) n = (n * 10 + bi) % 1140;
    return powmod(a % 1337, n + 1140);
}

-----
int powmod(int a, int b) 
    // Your code here
}

************************************
Question ID: 373

vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {
    auto comp = [&nums1, &nums2](pair<int, int> a, pair<int, int> b) {
        return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];
    };
    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> min_heap(comp);
    vector<vector<int>> result;

    if (nums1.empty() || nums2.empty()) return result;

    for (int i = 0; i < nums1.size(); ++i) {
        min_heap.emplace(i, 0);
    }

    while (k-- && !min_heap.empty()) {
        auto curr = min_heap.top();
        min_heap.pop();
        result.push_back({nums1[curr.first], nums2[curr.second]});
        if (curr.second + 1 < nums2.size()) {
            min_heap.emplace(curr.first, curr.second + 1);
        }
    }
    return result;
}

-----
vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) 
    // Your code here
}

************************************
Question ID: 374

int guessNumber(int n) {
    int low = 1, high = n;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        int result = guess(mid);
        if (result == 0) {
            return mid;
        } else if (result < 0) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return -1;
}

-----
int guessNumber(int n) 
    // Your code here
}

************************************
Question ID: 375

int getMoneyAmount(int n) {
    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));
    for (int i = n - 1; i >= 1; i--) {
        for (int j = i + 1; j <= n; j++) {
            int min_cost = INT_MAX;
            for (int k = i; k < j; k++) {
                int cost = k + max(dp[i][k - 1], dp[k + 1][j]);
                min_cost = min(min_cost, cost);
            }
            dp[i][j] = min_cost;
        }
    }
    return dp[1][n];
}

-----
int getMoneyAmount(int n) 
    // Your code here
}

************************************
Question ID: 376

int wiggleMaxLength(vector<int>& nums) {
    int len = nums.size();
    if (len < 2) return len;

    int up = 1, down = 1;
    for (int i = 1; i < len; ++i) {
        if (nums[i] > nums[i - 1])
            up = down + 1;
        else if (nums[i] < nums[i - 1])
            down = up + 1;
    }
    return max(up, down);
}

-----
int wiggleMaxLength(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 377

#include <vector>
using namespace std;

int combinationSum(vector<int>& nums, int target) {
    vector<int> dp(target + 1, 0);
    dp[0] = 1;
    
    for(int num : nums) {
        for(int i = num; i <= target; i++) {
            dp[i] += dp[i - num];
        }
    }
    
    return dp[target];
}


-----
#include <vector>
using namespace std;

int combinationSum(vector<int>& nums, int target) 
    // Your code here
}


************************************
Question ID: 378

#include <queue>
#include <vector>

int kthSmallest(std::vector<std::vector<int>>& matrix, int k) {
    int n = matrix.size();
    std::priority_queue<std::pair<int, std::pair<int, int>>, std::vector<std::pair<int, std::pair<int, int>>>, std::greater<>> min_heap;

    for (int i = 0; i < n; ++i) {
        min_heap.emplace(matrix[i][0], std::make_pair(i, 0));
    }

    while (--k) {
        auto [val, pos] = min_heap.top();
        min_heap.pop();

        if (++pos.second < n) {
            min_heap.emplace(matrix[pos.first][pos.second], pos);
        }
    }

    return min_heap.top().first;
}

-----
#include <queue>
#include <vector>

int kthSmallest(std::vector<std::vector<int>>& matrix, int k) 
    // Your code here
}

************************************
Question ID: 379

class PhoneDirectory {
    vector<bool> available;
    queue<int> released;
public:
    PhoneDirectory(int maxNumbers): available(maxNumbers, true) {}
    
    int get() {
        if(!released.empty()) {
            int number = released.front();
            released.pop();
            available[number] = false;
            return number;
        }
        for(int i = 0; i < available.size(); i++) {
            if(available[i]) {
                available[i] = false;
                return i;
            }
        }
        return -1;
    }
    
    bool check(int number) {
        return available[number];
    }
    
    void release(int number) {
        if(!available[number]) {
            available[number] = true;
            released.push(number);
        }
    }
};


-----
class PhoneDirectory 
    // Your code here
};


************************************
Question ID: 380

#include <unordered_map>
#include <vector>
#include <random>

class RandomizedSet {
    std::unordered_map<int, int> index_map;
    std::vector<int> nums;
public:
    bool insert(int val) {
        if (index_map.count(val)) return false;

        index_map[val] = nums.size();
        nums.push_back(val);
        return true;
    }

    bool remove(int val) {
        if (!index_map.count(val)) return false;

        int last = nums.back();
        index_map[last] = index_map[val];
        nums[index_map[val]] = last;

        nums.pop_back();
        index_map.erase(val);
        return true;
    }

    int getRandom() {
        return nums[rand() % nums.size()];
    }
};

-----
#include <unordered_map>
#include <vector>
#include <random>

class RandomizedSet 
    // Your code here
};

************************************
Question ID: 381

#include <unordered_map>
#include <vector>
#include <random>

class RandomizedCollection {
public:
    unordered_map<int, unordered_set<int>> indices;
    vector<int> nums;
    
    bool insert(int val) {
        nums.push_back(val);
        indices[val].insert(nums.size() - 1);
        return indices[val].size() == 1;
    }
    
    bool remove(int val) {
        if (!indices[val].size()) return false;
        int idx = *indices[val].begin();
        indices[val].erase(idx);
        if (idx < nums.size() - 1) {
            int last = nums.back();
            nums[idx] = last;
            indices[last].erase(nums.size() - 1);
            indices[last].insert(idx);
        }
        nums.pop_back();
        return true;
    }
    
    int getRandom() {
        return nums[rand() % nums.size()];
    }
};


-----
#include <unordered_map>
#include <vector>
#include <random>

class RandomizedCollection 
    // Your code here
};


************************************
Question ID: 382

#include <cstdlib>
#include <ctime>

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* head;

    Solution(ListNode* _head) {
        head = _head;
        srand(time(0));
    }

    int getRandom() {
        int result;
        ListNode* current = head;
        for (int i = 1; current; ++i) {
            if (rand() % i == 0) {
                result = current->val;
            }
            current = current->next;
        }
        return result;
    }
};

-----
#include <cstdlib>
#include <ctime>

struct ListNode 
    // Your code here
};

************************************
Question ID: 383

#include <string>
#include <unordered_map>

bool canConstruct(std::string ransomNote, std::string magazine) {
    std::unordered_map<char, int> letterCount;
    for (char c : magazine) {
        letterCount[c]++;
    }
    
    for (char c : ransomNote) {
        if (letterCount[c] == 0) {
            return false;
        }
        letterCount[c]--;
    }

    return true;
}

-----
#include <string>
#include <unordered_map>

bool canConstruct(std::string ransomNote, std::string magazine) 
    // Your code here
}

************************************
Question ID: 384

#include <algorithm>
#include <vector>
#include <ctime>

class Solution {
public:
    Solution(std::vector<int>& nums) {
        original = nums;
        srand(time(0));
    }
    
    std::vector<int> reset() {
        return original;
    }
    
    std::vector<int> shuffle() {
        std::vector<int> shuffled = original;
        for (int i = shuffled.size() - 1; i > 0; i--) {
            int j = rand() % (i + 1);
            std::swap(shuffled[i], shuffled[j]);
        }
        return shuffled;
    }
private:
    std::vector<int> original;
};


-----
#include <algorithm>
#include <vector>
#include <ctime>

class Solution 
    // Your code here
};


************************************
Question ID: 386

#include <vector>
#include <string>

void lexicographicalOrderHelper(int current, int n, std::vector<int>& result) {
    if (current > n) return;

    result.push_back(current);
    for (int i = 0; i <= 9; ++i) {
        lexicographicalOrderHelper(current * 10 + i, n, result);
    }
}

std::vector<int> lexicalOrder(int n) {
    std::vector<int> result;
    for (int i = 1; i <= 9; ++i) {
        lexicographicalOrderHelper(i, n, result);
    }
    return result;
}

-----
#include <vector>
#include <string>

void lexicographicalOrderHelper(int current, int n, std::vector<int>& result) 
    // Your code here
}

************************************
Question ID: 387

int firstUniqChar(std::string s) {
    std::unordered_map<char, int> charCount;
    for (char c : s)
        charCount[c]++;
    for (int i = 0; i < s.length(); i++)
        if (charCount[s[i]] == 1)
            return i;
    return -1;
}


-----
int firstUniqChar(std::string s) 
    // Your code here
}


************************************
Question ID: 388

#include <string>
#include <sstream>
#include <vector>
#include <algorithm>

int lengthLongestPath(std::string input) {
    std::istringstream ss(input);
    std::vector<int> dir_length_stack;
    std::string line;
    int max_file_length = 0;

    while (std::getline(ss, line, '\n')) {
        int level = 0;
        while (line.find('\t') != std::string::npos) {
            line.erase(0, 1);
            level++;
        }

        while (dir_length_stack.size() > level)
            dir_length_stack.pop_back();

        int length;
        if (dir_length_stack.empty()) {
            length = line.length();
        } else {
            length = dir_length_stack.back() + line.length() + 1;
        }
        dir_length_stack.push_back(length);

        if (line.find('.') != std::string::npos) {
            max_file_length = std::max(max_file_length, length);
        }
    }

    return max_file_length;
}


-----
#include <string>
#include <sstream>
#include <vector>
#include <algorithm>

int lengthLongestPath(std::string input) 
    // Your code here
}


************************************
Question ID: 389

char findTheDifference(std::string s, std::string t) {
    int sum_s = 0, sum_t = 0;
    for(char c : s) sum_s += c;
    for(char c : t) sum_t += c;
    return sum_t - sum_s;
}

-----
char findTheDifference(std::string s, std::string t) 
    // Your code here
}

************************************
Question ID: 390

int lastRemaining(int n) {
    bool direction = true;
    int head = 1, remaining = n, step = 1;

    while (remaining > 1) {
        if (direction || remaining % 2 == 1) {
            head += step;
        }
        remaining /= 2;
        step *= 2;
        direction = !direction;
    }

    return head;
}

-----
int lastRemaining(int n) 
    // Your code here
}

************************************
Question ID: 391

#include <vector>
#include <set>

bool isRectangleCover(std::vector<std::vector<int>>& rectangles) {
    int area = 0;
    std::set<std::pair<int, int>> points;
    int lx = INT_MAX, ly = INT_MAX, rx = INT_MIN, ry = INT_MIN;

    for (auto& rect : rectangles) {
        lx = std::min(lx, rect[0]);
        ly = std::min(ly, rect[1]);
        rx = std::max(rx, rect[2]);
        ry = std::max(ry, rect[3]);

        area += (rect[2] - rect[0]) * (rect[3] - rect[1]);

        std::pair<int, int> p1(rect[0], rect[1]);
        std::pair<int, int> p2(rect[0], rect[3]);
        std::pair<int, int> p3(rect[2], rect[1]);
        std::pair<int, int> p4(rect[2], rect[3]);

        if (!points.erase(p1)) points.insert(p1);
        if (!points.erase(p2)) points.insert(p2);
        if (!points.erase(p3)) points.insert(p3);
        if (!points.erase(p4)) points.insert(p4);
    }

    if (points.count({lx, ly}) && points.count({lx, ry}) &&
        points.count({rx, ly}) && points.count({rx, ry}) &&
        points.size() == 4)
        return area == (rx - lx) * (ry - ly);

    return false;
}

-----
#include <vector>
#include <set>

bool isRectangleCover(std::vector<std::vector<int>>& rectangles) 
    // Your code here
}

************************************
Question ID: 392

bool isSubsequence(std::string s, std::string t) {
    int si = 0, ti = 0;

    while (si < s.size() && ti < t.size()) {
        if (s[si] == t[ti])
            si++;
        ti++;
    }

    return si == s.size();
}


-----
bool isSubsequence(std::string s, std::string t) 
    // Your code here
}


************************************
Question ID: 393

bool validUtf8(vector<int>& data) {
    int count = 0;
    for (int byte : data) {
        if (count == 0) { 
            if ((byte >> 5) == 0b110) count = 1;
            else if ((byte >> 4) == 0b1110) count = 2;
            else if ((byte >> 3) == 0b11110) count = 3;
            else if ((byte >> 7)) return false; 
        } else { 
            if ((byte >> 6) != 0b10) return false;
            count--;
        }
    }
    return count == 0;
}

-----
bool validUtf8(vector<int>& data) 
    // Your code here
}

************************************
Question ID: 394

#include <string>
#include <stack>

std::string decodeString(const std::string &s) {
    std::stack<int> counts;
    std::stack<std::string> results;
    std::string current;
    int ptr = 0;

    while (ptr < s.size()) {
        if (isdigit(s[ptr])) {
            int count = 0;
            while (isdigit(s[ptr])) {
                count = count * 10 + (s[ptr] - '0');
                ptr++;
            }
            counts.push(count);
        } else if (s[ptr] == '[') {
            results.push(current);
            current = "";
            ptr++;
        } else if (s[ptr] == ']') {
            std::string prev = results.top();
            results.pop();
            int count = counts.top();
            counts.pop();
            for (int i = 0; i < count; i++) {
                prev += current;
            }
            current = prev;
            ptr++;
        } else {
            current += s[ptr];
            ptr++;
        }
    }

    return current;
}

-----
#include <string>
#include <stack>

std::string decodeString(const std::string &s) 
    // Your code here
}

************************************
Question ID: 395

#include <string>
#include <unordered_map>
#include <algorithm>

int longestSubstring(const std::string& s, int k) {
    if (s.empty() || k <= 0) return 0;

    std::unordered_map<char, int> char_count;
    for (char ch : s)
        char_count[ch]++;

    for (const auto& item : char_count) {
        if (item.second < k) {
            int res = 0;
            for (const std::string& str : split(s, item.first))
                res = std::max(res, longestSubstring(str, k));
            return res;
        }
    }
    return s.length();
}

std::vector<std::string> split(const std::string& s, char delimiter) {
    std::vector<std::string> subs;
    size_t start = 0;
    size_t end = s.find(delimiter);
    while (end != std::string::npos) {
        subs.push_back(s.substr(start, end - start));
        start = end + 1;
        end = s.find(delimiter, start);
    }
    subs.push_back(s.substr(start));
    return subs;
}

-----
#include <string>
#include <unordered_map>
#include <algorithm>

int longestSubstring(const std::string& s, int k) 
    // Your code here
}

************************************
Question ID: 396

int maxRotateFunction(vector<int>& nums) {
    int n = nums.size();
    int total_sum = 0;
    int f = 0;

    for (int i = 0; i < n; i++) {
        total_sum += nums[i];
        f += i * nums[i];
    }

    int max_f = f;
    for (int i = 1; i < n; i++) {
        f += total_sum - n * nums[n - i];
        max_f = max(max_f, f);
    }

    return max_f;
}


-----
int maxRotateFunction(vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 397

int minOperations(int n) {
    int steps = 0;
    while(n > 1) {
        n = (n % 2 == 0) ? n / 2 : n - 1;
        steps++;
    }
    return steps;
}

-----
int minOperations(int n) 
    // Your code here
}

************************************
Question ID: 398

#include <vector>
#include <cstdlib>

class Solution {
public:
    std::vector<int> nums;
    
    Solution(std::vector<int>& nums) {
        this->nums = nums;
    }
    
    int pick(int target) {
        int count = 0, res = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == target) {
                count++;
                if (std::rand() % count == 0) {
                    res = i;
                }
            }
        }
        return res;
    }
};

-----
#include <vector>
#include <cstdlib>

class Solution 
    // Your code here
};

************************************
Question ID: 399

#include <vector>
#include <unordered_map>
#include <string>

using namespace std;
  
double dfs(const string& s1, const string& s2, unordered_map<string, vector<pair<string, double>>>& graph) {
    if (!graph.count(s1) || !graph.count(s2)) return -1.0;
    if (s1 == s2) return 1.0;
  
    for (auto& p : graph[s1]) {
        double temp = dfs(p.first, s2, graph);
        if (temp > 0) return p.second * temp;
    }
    return -1.0;
}
  
vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
    unordered_map<string, vector<pair<string, double>>> graph;
    for (int i = 0; i < equations.size(); i++) {
        graph[equations[i][0]].push_back({equations[i][1], values[i]});
        graph[equations[i][1]].push_back({equations[i][0], 1 / values[i]});
    }
  
    vector<double> ans;
    for (const auto& q : queries) {
        ans.push_back(dfs(q[0], q[1], graph));
    }
    return ans;
}

-----
#include <vector>
#include <unordered_map>
#include <string>

using namespace std;
  
double dfs(const string& s1, const string& s2, unordered_map<string, vector<pair<string, double>>>& graph) 
    // Your code here
}

************************************
Question ID: 400

int findNthDigit(int n) {
    int size = 1;
    long length = 9;
    int start = 1;

    while (n > length * size) {
        n -= length * size;
        size++;
        length *= 10;
        start *= 10;
    }

    start += (n - 1) / size;
    string s = to_string(start);
    return s[(n - 1) % size] - '0';
}

-----
int findNthDigit(int n) 
    // Your code here
}

************************************
Question ID: 401

#include <vector>
#include <string>
using namespace std;

vector<string> readBinaryWatch(int turnedOn) {
    vector<string> times;
    for (int h = 0; h < 12; h++) {
        for (int m = 0; m < 60; m++) {
            if (__builtin_popcount(h) + __builtin_popcount(m) == turnedOn) {
                times.push_back(to_string(h) + (m < 10 ? ":0" : ":") + to_string(m));
            }
        }
    }
    return times;
}

-----
#include <vector>
#include <string>
using namespace std;

vector<string> readBinaryWatch(int turnedOn) 
    // Your code here
}

************************************
Question ID: 402

#include <string>
using namespace std;

string removeKDigits(string num, int k) {
    string result = "";
    for (char c : num) {
        while (k > 0 && !result.empty() && result.back() > c) {
            result.pop_back();
            k--;
        }
        result.push_back(c);
    }
    result.resize(result.length() - k);
    while (!result.empty() && result[0] == '0') {
        result.erase(result.begin());
    }
    return result.empty() ? "0" : result;
}

-----
#include <string>
using namespace std;

string removeKDigits(string num, int k) 
    // Your code here
}

************************************
Question ID: 403

#include <unordered_map>
#include <vector>
using namespace std;

bool canCross(vector<int>& stones) {
    unordered_map<int, unordered_set<int>> dp;
    int n = stones.size();
    for (int stone : stones)
        dp[stone] = unordered_set<int>();
    dp[0].insert(0);

    for (int stone : stones) {
        for (int k : dp[stone]) {
            for (int jump : {k - 1, k, k + 1}) {
                if (jump > 0 && dp.count(stone + jump))
                    dp[stone + jump].insert(jump);
            }
        }
    }
    return !dp[stones.back()].empty();
}


-----
#include <unordered_map>
#include <vector>
using namespace std;

bool canCross(vector<int>& stones) 
    // Your code here
}


************************************
Question ID: 405

std::string toHex(int num) {
    if (num == 0) return "0";
    std::string hex = "";
    unsigned int n = num;
    char hexDigits[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
    while (n) {
        hex = hexDigits[n & 15] + hex;
        n >>= 4;
    }
    return hex;
}

-----
std::string toHex(int num) 
    // Your code here
}

************************************
Question ID: 406

#include <vector>
#include <algorithm>

std::vector<std::vector<int>> reconstructQueue(std::vector<std::vector<int>>& people) {
    std::sort(people.begin(), people.end(), [](const std::vector<int>& a, const std::vector<int>& b) {
        return a[0] > b[0] || (a[0] == b[0] && a[1] < b[1]);
    });

    std::vector<std::vector<int>> result;
    for (const std::vector<int>& p : people) {
        result.insert(result.begin() + p[1], p);
    }
    return result;
}


-----
#include <vector>
#include <algorithm>

std::vector<std::vector<int>> reconstructQueue(std::vector<std::vector<int>>& people) 
    // Your code here
}


************************************
Question ID: 407

#include <queue>
#include <vector>

using namespace std;

int trapRainWater(vector<vector<int>>& heightMap) {
    int m = heightMap.size(), n = heightMap[0].size();
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    vector<vector<int>> visited(m, vector<int>(n, 0));

    for (int i = 0; i < m; i++) {
        pq.push({heightMap[i][0], i * n});
        pq.push({heightMap[i][n - 1], i * n + n - 1});
        visited[i][0] = visited[i][n - 1] = 1;
    }

    for (int i = 1; i < n - 1; i++) {
        pq.push({heightMap[0][i], i});
        pq.push({heightMap[m - 1][i], (m - 1) * n + i});
        visited[0][i] = visited[m - 1][i] = 1;
    }

    int water = 0, maxHeight = 0;
    vector<vector<int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    while (!pq.empty()) {
        auto t = pq.top(); pq.pop();
        int h = t.first, r = t.second / n, c = t.second % n;
        maxHeight = max(maxHeight, h);
        for (auto dir : dirs) {
            int x = r + dir[0], y = c + dir[1];
            if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) continue;
            if (heightMap[x][y] < maxHeight) water += maxHeight - heightMap[x][y];
            pq.push({heightMap[x][y], x * n + y});
            visited[x][y] = 1;
        }
    }

    return water;
}

-----
#include <queue>
#include <vector>

using namespace std;

int trapRainWater(vector<vector<int>>& heightMap) 
    // Your code here
}

************************************
Question ID: 408

bool validWordAbbreviation(string word, string abbr) {
    int i = 0, j = 0;
    while (i < word.size() && j < abbr.size()) {
        if (isdigit(abbr[j])) {
            if (abbr[j] == '0') return false; // leading zero
            int num = 0;
            while (j < abbr.size() && isdigit(abbr[j]))
                num = num * 10 + (abbr[j++] - '0');
            i += num;
        } else {
            if (word[i++] != abbr[j++]) return false;
        }
    }
    return i == word.size() && j == abbr.size();
}

-----
bool validWordAbbreviation(string word, string abbr) 
    // Your code here
}

************************************
Question ID: 409

int longestPalindrome(string s) {
    int charCount[128] = {0};
    int result = 0;
    for (char c : s)
        charCount[c]++;
    for (int count : charCount) {
        result += count / 2 * 2;
        if (result % 2 == 0 && count % 2 == 1)
            result++;
    }
    return result;
}

-----
int longestPalindrome(string s) 
    // Your code here
}

************************************
Question ID: 410

int splitArray(vector<int>& nums, int m) {
    long long left = 0, right = 0;
    for (int num : nums) {
        left = max(left, (long long)num);
        right += num;
    }

    while (left < right) {
        long long mid = (left + right) / 2;
        int count = 1;
        long long curSum = 0;
        for (int num : nums) {
            curSum += num;
            if (curSum > mid) {
                curSum = num;
                count++;
            }
        }

        if (count > m) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return (int)left;
}

-----
int splitArray(vector<int>& nums, int m) 
    // Your code here
}

************************************
Question ID: 411

#include <string>
#include <vector>

std::string abbreviate(const std::string& s, int k, int i) {
    if (i == s.length()) {
        return (k > 0) ? std::to_string(k) : "";
    }
    if (k == 0) {
        return s.substr(i) + (i + 1 < s.length() ? abbreviate(s, 1, i + 1) : "");
    }
    return std::to_string(k) + s[i] + (i + 1 < s.length() ? abbreviate(s, 1, i + 1) : "");
}

bool isAbbreviation(const std::string& target, const std::string& word) {
    int i = 0, j = 0;
    while (i < target.length() && j < word.length()) {
        if (target[i] == word[j]) {
            i++; j++;
        } else if (isdigit(target[i])) {
            int k = 0;
            while (i < target.length() && isdigit(target[i])) {
                k = k * 10 + target[i++] - '0';
            }
            j += k;
        } else {
            return false;
        }
    }
    return (i == target.length() && j == word.length());
}

std::string minAbbreviation(std::string target, std::vector<std::string>& dictionary) {
    std::string ans = target;
    for (int k = 0; k <= target.length(); k++) {
        for (int i = 0; i <= target.length() - k; i++) {
            std::string current = abbreviate(target, k, i);
            if (current.length() < ans.length()) {
                bool valid = true;
                for (const std::string& word : dictionary) {
                    if (isAbbreviation(current, word)) {
                        valid = false;
                        break;
                    }
                }
                if (valid) {
                    ans = current;
                }
            }
        }
    }
    return ans;
}


-----
#include <string>
#include <vector>

std::string abbreviate(const std::string& s, int k, int i) 
    // Your code here
}


************************************
Question ID: 412

#include <vector>
#include <string>

std::vector<std::string> fizzBuzz(int n) {
    std::vector<std::string> result(n);
    for(int i = 1; i <= n; ++i) {
        if (i % 15 == 0) result[i - 1] = "FizzBuzz";
        else if (i % 3 == 0) result[i - 1] = "Fizz";
        else if (i % 5 == 0) result[i - 1] = "Buzz";
        else result[i - 1] = std::to_string(i);
    }
    return result;
}

-----
#include <vector>
#include <string>

std::vector<std::string> fizzBuzz(int n) 
    // Your code here
}

************************************
Question ID: 413

int numberOfArithmeticSlices(vector<int>& nums) {
    int n = nums.size(), count = 0, cur = 0;
    for (int i = 2; i < n; ++i) {
        if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {
            cur++;
            count += cur;
        } else {
            cur = 0;
        }
    }
    return count;
}

-----
int numberOfArithmeticSlices(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 414

#include <set>

int thirdMax(vector<int>& nums) {
    set<int> top3;
    for (int num : nums) {
        top3.insert(num);
        if (top3.size() > 3) {
            top3.erase(top3.begin());
        }
    }
    return top3.size() == 3 ? *top3.begin() : *top3.rbegin();
}

-----
#include <set>

int thirdMax(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 415

std::string addStrings(std::string num1, std::string num2) {
    int i = num1.size() - 1, j = num2.size() - 1, carry = 0;
    std::string result;

    while (i >= 0 || j >= 0 || carry) {
        int sum = carry;

        if (i >= 0) {
            sum += num1[i] - '0';
            --i;
        }
        if (j >= 0) {
            sum += num2[j] - '0';
            --j;
        }

        carry = sum / 10;
        result.push_back(sum % 10 + '0');
    }

    std::reverse(result.begin(), result.end());
    return result;
}


-----
std::string addStrings(std::string num1, std::string num2) 
    // Your code here
}


************************************
Question ID: 416

#include <vector>
using namespace std;

bool canPartition(vector<int>& nums) {
    int sum = 0;
    for (int num : nums) sum += num;
    
    if (sum % 2 != 0) return false;
    
    int target = sum / 2;
    vector<bool> dp(target + 1, false);
    dp[0] = true;
    
    for (int num : nums) {
        for (int i = target; i >= num; i--) {
            dp[i] = dp[i] || dp[i - num];
        }
    }
    return dp[target];
}

-----
#include <vector>
using namespace std;

bool canPartition(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 417

#include <vector>

using namespace std;

void dfs(const vector<vector<int>>& heights, int r, int c, int prevHeight, vector<vector<bool>>& visited) {
    if (r < 0 || r >= heights.size() || c < 0 || c >= heights[0].size())
        return;
    if (heights[r][c] >= prevHeight && !visited[r][c]) {
        visited[r][c] = true;
        dfs(heights, r - 1, c, heights[r][c], visited);
        dfs(heights, r + 1, c, heights[r][c], visited);
        dfs(heights, r, c - 1, heights[r][c], visited);
        dfs(heights, r, c + 1, heights[r][c], visited);
    }
}

vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
    int m = heights.size();
    int n = heights[0].size();
    vector<vector<bool>> pacific(m, vector<bool>(n, false));
    vector<vector<bool>> atlantic(m, vector<bool>(n, false));

    for (int r = 0; r < m; ++r) {
        dfs(heights, r, 0, -1, pacific);
        dfs(heights, r, n - 1, -1, atlantic);
    }
    for (int c = 0; c < n; ++c) {
        dfs(heights, 0, c, -1, pacific);
        dfs(heights, m - 1, c, -1, atlantic);
    }
    vector<vector<int>> result;
    for (int r = 0; r < m; ++r) {
        for (int c = 0; c < n; ++c) {
            if (pacific[r][c] && atlantic[r][c]) {
                result.push_back({r, c});
            }
        }
    }
    return result;
}


-----
#include <vector>

using namespace std;

void dfs(const vector<vector<int>>& heights, int r, int c, int prevHeight, vector<vector<bool>>& visited) 
    // Your code here
}


************************************
Question ID: 418

int wordsTyping(vector<string>& sentence, int rows, int cols) {
    int total_chars = 0;
    for (const auto& word : sentence) {
        total_chars += word.size() + 1;
    }

    int result = 0;
    int index = 0;
    for (int r = 0; r < rows; ++r) {
        int remaining_cols = cols;
        while (true) {
            int word_len = sentence[index].size();
            if (remaining_cols >= word_len) {
                remaining_cols -= word_len + 1;
                index = (index + 1) % sentence.size();
                if (index == 0) result++;
            } else {
                break;
            }
        }
    }

    return result;
}

-----
int wordsTyping(vector<string>& sentence, int rows, int cols) 
    // Your code here
}

************************************
Question ID: 419

int countBattleships(vector<vector<char>>& board) {
    int count = 0;
    for (int i = 0; i < board.size(); i++) {
        for (int j = 0; j < board[i].size(); j++) {
            if (board[i][j] == 'X' &&
                (i == 0 || board[i - 1][j] == '.') &&
                (j == 0 || board[i][j - 1] == '.')) {
                count++;
            }
        }
    }
    return count;
}

-----
int countBattleships(vector<vector<char>>& board) 
    // Your code here
}

************************************
Question ID: 420

#include <cctype>
#include <algorithm>
int strongPassword(string password) {
    int missingLower = 1, missingUpper = 1, missingDigit = 1;
    int total = (int)password.size();
    for (char c : password) {
        if (islower(c)) missingLower = 0;
        if (isupper(c)) missingUpper = 0;
        if (isdigit(c)) missingDigit = 0;
    }
    int missing = missingLower + missingUpper + missingDigit;
    if (total < 6) return max(missing, 6 - total);
    if (total > 20) return missing + total - 20;
    return missing;
}

-----
#include <cctype>
#include <algorithm>
int strongPassword(string password) 
    // Your code here
}

************************************
Question ID: 421

int findMaximumXOR(vector<int>& nums) {
    int max_xor = 0;
    int mask = 0;

    for (int i = 31; i >= 0; i--) {
        mask |= (1 << i);
        unordered_set<int> prefixes;

        for (int num : nums) {
            prefixes.insert(num & mask);
        }

        int possible_max = max_xor | (1 << i);

        for (int prefix : prefixes) {
            if (prefixes.count(prefix ^ possible_max)) {
                max_xor = possible_max;
                break;
            }
        }
    }

    return max_xor;
}

-----
int findMaximumXOR(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 422

bool validWordSquare(vector<string>& words) {
    for (int i = 0; i < words.size(); ++i) {
        for (int j = 0; j < words[i].size(); ++j) {
            if (j >= words.size() || i >= words[j].size() || words[i][j] != words[j][i]) {
                return false;
            }
        }
    }
    return true;
}


-----
bool validWordSquare(vector<string>& words) 
    // Your code here
}


************************************
Question ID: 423

#include <vector>
#include <string>
#include <algorithm>
using namespace std;

string find_digits_in_ascending_order(string s) {
    vector<int> count(10, 0);
    for (char c : s) {
        if (c == 'z') count[0]++;
        if (c == 'w') count[2]++;
        if (c == 'u') count[4]++;
        if (c == 'x') count[6]++;
        if (c == 'g') count[8]++;
        if (c == 'o') count[1]++;  // o = one + two + four
        if (c == 'h') count[3]++;  // h = three + eight
        if (c == 'f') count[5]++;  // f = five + seven
        if (c == 's') count[7]++;  // s = six + seven
        if (c == 'i') count[9]++;  // i = five + six + eight + nine
    }
    count[1] -= count[0] + count[2] + count[4];
    count[3] -= count[8];
    count[5] -= count[4];
    count[7] -= count[6];
    count[9] -= count[5] + count[6] + count[8];
    
    string res;
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < count[i]; j++) {
            res += to_string(i);
        }
    }
    return res;
}


-----
#include <vector>
#include <string>
#include <algorithm>
using namespace std;

string find_digits_in_ascending_order(string s) 
    // Your code here
}


************************************
Question ID: 424

#include <string>
#include <algorithm>
using namespace std;

int characterReplacement(string s, int k) {
    int n = s.length();
    int left = 0, right = 0, maxFreq = 0, result = 0;
    int freq[26] = {0};
    
    for (right = 0; right < n; right++) {
        freq[s[right] - 'A']++;
        maxFreq = max(maxFreq, freq[s[right] - 'A']);
        
        if (right - left + 1 - maxFreq > k) {
            freq[s[left] - 'A']--;
            left++;
        }
        
        result = max(result, right - left + 1);
    }
    
    return result;
}


-----
#include <string>
#include <algorithm>
using namespace std;

int characterReplacement(string s, int k) 
    // Your code here
}


************************************
Question ID: 425

#include <vector>
#include <string>
#include <unordered_map>

void build(int r, const std::vector<std::string>& words, std::vector<std::string>& sq, std::unordered_map<std::string, std::vector<std::string>>& mapping, std::vector<std::vector<std::string>>& res){
    if(r == sq.size()){
        res.push_back(sq);
        return;
    }
    std::string prefix;
    for(int i=0; i<r; i++){
        prefix.push_back(sq[i][r]);
    }
    for(auto& word: mapping[prefix]){
        sq[r] = word;
        build(r+1, words, sq, mapping, res);
    }
}

std::vector<std::vector<std::string>> wordSquares(std::vector<std::string>& words){
    std::vector<std::vector<std::string>> res;
    if(words.empty()) return res;
    std::unordered_map<std::string, std::vector<std::string>> mapping;
    for(const auto& w: words){
        for(int i=0; i<=w.size(); i++){
            mapping[w.substr(0, i)].push_back(w);
        }
    }
    for(const auto& w: words){
        std::vector<std::string> sq(words[0].size(), "");
        sq[0] = w;
        build(1, words, sq, mapping, res);
    }
    return res;
}

-----
#include <vector>
#include <string>
#include <unordered_map>

void build(int r, const std::vector<std::string>& words, std::vector<std::string>& sq, std::unordered_map<std::string, std::vector<std::string>>& mapping, std::vector<std::vector<std::string>>& res)
    // Your code here
}

************************************
Question ID: 433

#include <vector>
#include <string>
#include <queue>
#include <unordered_set>

int minMutation(std::string start, std::string end, std::vector<std::string>& bank) {
    std::queue<std::string> q;
    q.push(start);
    std::unordered_set<std::string> visited;
    visited.insert(start);
    int depth = 0;

    while (!q.empty()) {
        int levelSize = q.size();
        for (int i = 0; i < levelSize; ++i) {
            std::string current = q.front();
            q.pop();
            if (current == end) return depth;

            for (const auto& gene : bank) {
                if (!visited.count(gene)) {
                    int diff = 0;
                    for (int j = 0; j < 8; ++j) {
                        if (current[j] != gene[j]) ++diff;
                        if (diff > 1) break;
                    }

                    if (diff == 1) {
                        q.push(gene);
                        visited.insert(gene);
                    }
                }
            }
        }
        depth++;
    }
    return -1;
}


-----
#include <vector>
#include <string>
#include <queue>
#include <unordered_set>

int minMutation(std::string start, std::string end, std::vector<std::string>& bank) 
    // Your code here
}


************************************
Question ID: 434

#include <string>
#include <sstream>

int countSegments(const std::string& s) {
    std::stringstream ss(s);
    int count = 0;
    std::string temp;

    while (ss >> temp) {
        ++count;
    }

    return count;
}

-----
#include <string>
#include <sstream>

int countSegments(const std::string& s) 
    // Your code here
}

************************************
Question ID: 435

#include <vector>
#include <algorithm>

bool compare(const std::vector<int>& a, const std::vector<int>& b) {
    return a[1] < b[1];
}

int eraseOverlapIntervals(std::vector<std::vector<int>>& intervals) {
    if (intervals.empty()) return 0;
    
    std::sort(intervals.begin(), intervals.end(), compare);
    
    int count = 0;
    int prev_end = intervals[0][1];
    
    for (size_t i = 1; i < intervals.size(); i++) {
        if (intervals[i][0] < prev_end) {
            count++;
        } else {
            prev_end = intervals[i][1];
        }
    }
    
    return count;
}

-----
#include <vector>
#include <algorithm>

bool compare(const std::vector<int>& a, const std::vector<int>& b) 
    // Your code here
}

************************************
Question ID: 436

#include <vector>
#include <map>

std::vector<int> findRightInterval(std::vector<std::vector<int>>& intervals) {
    std::vector<int> res(intervals.size(), -1);
    std::map<int, int> starts;
    for(int i = 0; i < intervals.size(); ++i) {
        starts[intervals[i][0]] = i;
    }

    for(int i = 0; i < intervals.size(); ++i) {
        auto it = starts.lower_bound(intervals[i][1]);
        if(it != starts.end()) {
            res[i] = it->second;
        }
    }

    return res;
}

-----
#include <vector>
#include <map>

std::vector<int> findRightInterval(std::vector<std::vector<int>>& intervals) 
    // Your code here
}

************************************
Question ID: 437

int pathSumHelper(TreeNode* node, int targetSum, int currentSum) {
    if (node == nullptr) {
        return 0;
    }
    
    currentSum += node->val;
    int totalPaths = currentSum == targetSum;
    totalPaths += pathSumHelper(node->left, targetSum, currentSum);
    totalPaths += pathSumHelper(node->right, targetSum, currentSum);
    return totalPaths;
}

int pathSum(TreeNode* root, int targetSum) {
    if (root == nullptr) {
        return 0;
    }

    return pathSumHelper(root, targetSum, 0) + pathSum(root->left, targetSum) + pathSum(root->right, targetSum);
}


-----
int pathSumHelper(TreeNode* node, int targetSum, int currentSum) 
    // Your code here
}


************************************
Question ID: 438

#include <vector>
#include <string>

std::vector<int> findAnagrams(std::string s, std::string p) {
    std::vector<int> result;
    if (s.size() < p.size()) return result;

    std::vector<int> s_count(26, 0), p_count(26, 0);
    for (char c : p) p_count[c - 'a']++;

    for (int i = 0; i < s.size(); i++) {
        s_count[s[i] - 'a']++;
        if (i >= p.size()) s_count[s[i - p.size()] - 'a']--;
        if (s_count == p_count) result.push_back(i - p.size() + 1);
    }

    return result;
}

-----
#include <vector>
#include <string>

std::vector<int> findAnagrams(std::string s, std::string p) 
    // Your code here
}

************************************
Question ID: 439

#include <string>
#include <stack>

std::string parseTernary(std::string expression) {
    std::stack<char> stk;
    for (int i = expression.size() - 1; i >= 0; --i) {
        char c = expression[i];
        if (!stk.empty() && stk.top() == '?') {
            stk.pop(); // Pop '?'
            char first = stk.top();
            stk.pop();
            stk.pop(); // Pop ':'
            char second = stk.top();
            stk.pop();
            stk.push(c == 'T' ? first : second);
        } else {
            stk.push(c);
        }
    }
    return std::string(1, stk.top());
}


-----
#include <string>
#include <stack>

std::string parseTernary(std::string expression) 
    // Your code here
}


************************************
Question ID: 440

#include <algorithm>
#include <vector>
using namespace std;

int findKthNumber(int n, int k) {
    vector<int> nums;
    for (int i = 1; i <= n; ++i) {
        nums.push_back(i);
    }
    sort(nums.begin(), nums.end(), [](int a, int b) {
        return to_string(a) < to_string(b);
    });
    return nums[k - 1];
}


-----
#include <algorithm>
#include <vector>
using namespace std;

int findKthNumber(int n, int k) 
    // Your code here
}


************************************
Question ID: 441

int arrangeCoins(int n) {
    int k = 0;
    while (n > k) {
        k++;
        n -= k;
    }
    return k;
}

-----
int arrangeCoins(int n) 
    // Your code here
}

************************************
Question ID: 442

#include <vector>
#include <cmath>

std::vector<int> findDuplicates(std::vector<int>& nums) {
    std::vector<int> duplicates;
    for (int i = 0; i < nums.size(); i++) {
        int index = abs(nums[i]) - 1;
        if (nums[index] < 0) {
            duplicates.push_back(abs(nums[i]));
        } else {
            nums[index] *= -1;
        }
    }
    return duplicates;
}

-----
#include <vector>
#include <cmath>

std::vector<int> findDuplicates(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 443

int compress(vector<char>& chars) {
    int index = 0, count;
    for(int i = 0; i < chars.size(); i += count) {
        count = 1;
        while(i + count < chars.size() && chars[i] == chars[i + count]) {
            count++;
        }
        chars[index++] = chars[i];
        if(count > 1) {
            for(char c : to_string(count)) {
                chars[index++] = c;
            }
        }
    }
    return index;
}

-----
int compress(vector<char>& chars) 
    // Your code here
}

************************************
Question ID: 444

bool isShortestAndUniqueSupersequence(vector<int>& nums, vector<vector<int>>& sequences) {
    unordered_map<int, int> pos;
    for (int i = 0; i < nums.size(); ++i) {
        pos[nums[i]] = i;
    }

    for (const auto& seq : sequences) {
        if (pos[seq[0]] > pos[seq.back()]) {
            return false;
        }
    }
    return true;
}

-----
bool isShortestAndUniqueSupersequence(vector<int>& nums, vector<vector<int>>& sequences) 
    // Your code here
}

************************************
Question ID: 446

#include <vector>
#include <unordered_map>

int numberOfArithmeticSlices(std::vector<int>& nums) {
    int res = 0;
    int n = nums.size();
    std::vector<std::unordered_map<int, int>> dp(n);

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            long diff = (long)nums[i] - (long)nums[j];
            if (diff <= INT_MIN || diff > INT_MAX) continue;

            int delta = (int)diff;
            dp[i][delta] += 1;

            if (dp[j].count(delta)) {
                res += dp[j][delta];
                dp[i][delta] += dp[j][delta];
            }
        }
    }
    return res;
}


-----
#include <vector>
#include <unordered_map>

int numberOfArithmeticSlices(std::vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 447

#include <unordered_map>

int numberOfBoomerangs(vector<vector<int>>& points) {
    int count = 0;

    for (auto& i : points) {
        unordered_map<int, int> group_count;
        for (auto& j : points) {
            int dx = i[0] - j[0], dy = i[1] - j[1];
            int dist = dx * dx + dy * dy;
            group_count[dist]++;
        }

        for (auto& g : group_count) {
            count += g.second * (g.second - 1);
        }
    }

    return count;
}

-----
#include <unordered_map>

int numberOfBoomerangs(vector<vector<int>>& points) 
    // Your code here
}

************************************
Question ID: 448

#include <vector>
using namespace std;

vector<int> findDisappearedNumbers(vector<int> &nums) {
    vector<int> result;
    
    for (int i = 0; i < nums.size(); ++i) {
        int index = abs(nums[i]) - 1;
        nums[index] = -abs(nums[index]);
    }
    
    for (int i = 0; i < nums.size(); ++i) {
        if (nums[i] > 0) {
            result.push_back(i + 1);
        }
    }
    
    return result;
}

-----
#include <vector>
using namespace std;

vector<int> findDisappearedNumbers(vector<int> &nums) 
    // Your code here
}

************************************
Question ID: 451

#include <unordered_map>
#include <vector>
#include <algorithm>

std::string sortByFrequency(std::string s) {
    std::unordered_map<char, int> freq;
    std::vector<char> chars(s.begin(), s.end());
    
    for (char c : s)
        freq[c]++;
        
    std::sort(chars.begin(), chars.end(), 
              [&](char a, char b) { return freq[a] > freq[b]; });
              
    return std::string(chars.begin(), chars.end());
}

-----
#include <unordered_map>
#include <vector>
#include <algorithm>

std::string sortByFrequency(std::string s) 
    // Your code here
}

************************************
Question ID: 452

#include <vector>
#include <algorithm>

int findMinArrowShots(std::vector<std::vector<int>>& points) {
    if (points.empty()) return 0;
    std::sort(points.begin(), points.end(), [](const std::vector<int>& a, const std::vector<int>& b) {
        return a[1] < b[1];
    });

    int arrows = 1;
    int end = points[0][1];

    for (int i = 1; i < points.size(); ++i) {
        if (points[i][0] > end) {
            arrows++;
            end = points[i][1];
        }
    }

    return arrows;
}

-----
#include <vector>
#include <algorithm>

int findMinArrowShots(std::vector<std::vector<int>>& points) 
    // Your code here
}

************************************
Question ID: 453

int minMoves(vector<int>& nums) {
    int min_element = *min_element(nums.begin(), nums.end());
    int moves = 0;
    for (int num : nums) {
        moves += (num - min_element);
    }
    return moves;
}


-----
int minMoves(vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 454

#include <unordered_map>

int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
    unordered_map<int, int> hashMap;
    int count = 0;
    
    for (auto i : nums1) {
        for (auto j : nums2) {
            hashMap[i + j]++;
        }
    }
    
    for (auto k : nums3) {
        for (auto l : nums4) {
            count += hashMap[-(k + l)];
        }
    }
    
    return count;
}

-----
#include <unordered_map>

int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) 
    // Your code here
}

************************************
Question ID: 455

#include <vector>
#include <algorithm>

int findContentChildren(std::vector<int>& g, std::vector<int>& s) {
    std::sort(g.begin(), g.end());
    std::sort(s.begin(), s.end());
    int i = 0, j = 0;

    while (i < g.size() && j < s.size()) {
      if (s[j] >= g[i]) {
        i++;
      }

      j++;
    }

    return i;
}


-----
#include <vector>
#include <algorithm>

int findContentChildren(std::vector<int>& g, std::vector<int>& s) 
    // Your code here
}


************************************
Question ID: 456

bool find132pattern(vector<int>& nums) {
    int n = nums.size(), third = INT_MIN;
    stack<int> st;
    for (int i = n - 1; i >= 0; --i) {
        if (nums[i] < third) return true;
        while (!st.empty() && st.top() < nums[i]) {
            third = st.top(); st.pop();
        }
        st.push(nums[i]);
    }
    return false;
}

-----
bool find132pattern(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 457

bool circularArrayLoop(vector<int>& nums) {
    int N = nums.size();
    for (int i = 0; i < N; i++) {
        int slow = i, fast = i;
        do {
            slow = getNextIndex(slow, nums);
            fast = getNextIndex(getNextIndex(fast, nums), nums);
        } while (slow != fast && nums[slow] * nums[fast] > 0);

        if (slow != fast) continue;
        bool cycle = false;
        int start = slow;
        do {
            cycle |= getNextIndex(start, nums) == start;
            start = getNextIndex(start, nums);
        } while (start != slow);
        if (!cycle) return true;
    }
    return false;
}

int getNextIndex(int idx, vector<int>& nums) {
    int N = nums.size();
    return ((idx + nums[idx]) % N + N) % N;
}


-----
bool circularArrayLoop(vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 458

int poorPigs(int buckets, int minutesToDie, int minutesToTest) {
    int pigs = 0;
    while (pow((minutesToTest / minutesToDie) + 1, pigs) < buckets) {
        pigs++;
    }
    return pigs;
}


-----
int poorPigs(int buckets, int minutesToDie, int minutesToTest) 
    // Your code here
}


************************************
Question ID: 459

bool can_construct(string s) {
    int n = s.size();
    for (int i = n / 2; i > 0; --i) {
        if (n % i == 0) {
            string substr = s.substr(0, i);
            bool flag = true;
            for (int j = i; j < n; j += i) {
                if (s.substr(j, i) != substr) {
                    flag = false;
                    break;
                }
            }

            if (flag) return true;
        }
    }
    return false;
}


-----
bool can_construct(string s) 
    // Your code here
}


************************************
Question ID: 461

int hammingDistance(int x, int y) {
    int dist = 0, xorResult = x ^ y;
    while (xorResult) {
        dist += xorResult & 1;
        xorResult >>= 1;
    }
    return dist;
}

-----
int hammingDistance(int x, int y) 
    // Your code here
}

************************************
Question ID: 462

int minMoves2(vector<int>& nums) {
    int n = nums.size();
    sort(nums.begin(), nums.end());
    int mid = nums[n / 2];
    int moves = 0;
    for (int i = 0; i < n; i++) {
        moves += abs(nums[i] - mid);
    }
    return moves;
}

-----
int minMoves2(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 463

int islandPerimeter(vector<vector<int>>& grid) {
    int perimeter = 0;
    for (int row = 0; row < grid.size(); row++) {
        for (int col = 0; col < grid[row].size(); col++) {
            if (grid[row][col] == 1) {
                perimeter += 4;
                if (row > 0 && grid[row - 1][col] == 1) perimeter -= 2;
                if (col > 0 && grid[row][col - 1] == 1) perimeter -= 2;
            }
        }
    }
    return perimeter;
}

-----
int islandPerimeter(vector<vector<int>>& grid) 
    // Your code here
}

************************************
Question ID: 464

#include <unordered_map>

bool canWin(int maxChoosableInteger, int desiredTotal, int state, std::unordered_map<int, bool>& memo) {
    if(desiredTotal <= 0) {
        return false;
    }
    if(memo.count(state) > 0) {
        return memo[state];
    }
    for(int i = 1; i <= maxChoosableInteger; i++) {
        int bitCheck = 1 << i;
        if((state & bitCheck) == 0) {
            if(!canWin(maxChoosableInteger, desiredTotal - i, state | bitCheck, memo)) {
                memo[state] = true;
                return true;
            }
        }
    }
    memo[state] = false;
    return false;
}

bool canIWin(int maxChoosableInteger, int desiredTotal) {
    if (maxChoosableInteger >= desiredTotal) return true;
    if ((maxChoosableInteger * (maxChoosableInteger + 1)) / 2 < desiredTotal) return false;

    std::unordered_map<int, bool> memo;
    int state = 0;
    return canWin(maxChoosableInteger, desiredTotal, state, memo);
}


-----
#include <unordered_map>

bool canWin(int maxChoosableInteger, int desiredTotal, int state, std::unordered_map<int, bool>& memo) 
    // Your code here
}


************************************
Question ID: 465

#include <vector>
#include <unordered_map>

int minTransfers(std::vector<std::vector<int>>& transactions) {
    std::unordered_map<int, int> balances;
    for (const auto& transaction : transactions) {
        balances[transaction[0]] -= transaction[2];
        balances[transaction[1]] += transaction[2];
    }

    std_msgs::vector<int> debts;
    for (const auto& balance : balances) {
        if (balance.second != 0) {
            debts.push_back(balance.second);
        }
    }
    return dfs(debts, 0);
}

int dfs(std::vector<int>& debts, int start) {
    while (start < debts.size() && debts[start] == 0) {
        start++;
    }
    if (start == debts.size()) {
        return 0;
    }
    int result = INT_MAX;
    for (int i = start + 1; i < debts.size(); ++i) {
        if ((debts[start] > 0) != (debts[i] > 0)) {
            debts[i] += debts[start];
            result = std::min(result, 1 + dfs(debts, start + 1));
            debts[i] -= debts[start];
        }
    }
    return result;
}


-----
#include <vector>
#include <unordered_map>

int minTransfers(std::vector<std::vector<int>>& transactions) 
    // Your code here
}


************************************
Question ID: 466

int getMaxRepetitions(string s1, int n1, string s2, int n2) {
    int count1 = 0, count2 = 0, i = 0, j = 0;
    while (count1 < n1) {
        if (s1[i] == s2[j]) {
            j++;
            if (j == s2.size()) {
                j = 0;
                count2++;
            }
        }
        i++;
        if (i == s1.size()) {
            i = 0;
            count1++;
        }
    }
    return count2 / n2;
}


-----
int getMaxRepetitions(string s1, int n1, string s2, int n2) 
    // Your code here
}


************************************
Question ID: 467

#include <string>
#include <vector>
#include <algorithm>

int findSubstringInWraproundString(const std::string& p) {
    std::vector<int> cnt(26, 0);
    int length = 0;

    for (int i = 0; i < p.size(); i++) {
        if (i > 0 && (p[i] == p[i - 1] + 1 || p[i - 1] - p[i] == 25)) {
            length++;
        } else {
            length = 1;
        }
        cnt[p[i] - 'a'] = std::max(cnt[p[i] - 'a'], length);
    }

    return std::accumulate(cnt.begin(), cnt.end(), 0);
}


-----
#include <string>
#include <vector>
#include <algorithm>

int findSubstringInWraproundString(const std::string& p) 
    // Your code here
}


************************************
Question ID: 468

#include <sstream>
#include <string>
#include <vector>

bool isValidIPv4(const std::string& part);
bool isValidIPv6(const std::string& part);

std::string validateIP(const std::string& queryIP) {
    std::stringstream ss(queryIP);
    std::string part;
    int partsCount = 0;

    if (queryIP.find(':') == std::string::npos) {
        while (getline(ss, part, '.')) {
            if (!isValidIPv4(part)) return "Neither";
            partsCount++;
        }
        if (partsCount == 4) return "IPv4";
    } else {
        while (getline(ss, part, ':')) {
            if (!isValidIPv6(part)) return "Neither";
            partsCount++;
        }
        if (partsCount == 8) return "IPv6";
    }

    return "Neither";
}

bool isValidIPv4(const std::string& part) {
    if (part.empty() || part.size() > 3) return false;
    if (part.size() > 1 && part[0] == '0') return false;

    int num = 0;
    for (char ch : part) {
        if (!isdigit(ch)) return false;
        num = num * 10 + (ch - '0');
    }

    return num >= 0 && num <= 255;
}

bool isValidIPv6(const std::string& part) {
    if (part.empty() || part.size() > 4) return false;

    for (char ch : part) {
        if (!isxdigit(ch)) return false;
    }

    return true;
}

-----
#include <sstream>
#include <string>
#include <vector>

bool isValidIPv4(const std::string& part);
bool isValidIPv6(const std::string& part);

std::string validateIP(const std::string& queryIP) 
    // Your code here
}

************************************
Question ID: 469

bool isConvex(vector<vector<int>>& points) {
    int n = points.size();
    int pre = 0, cur = 0;
    
    for (int i = 0; i < n; ++i) {
        int x1 = points[(i + 1) % n][0] - points[i][0];
        int y1 = points[(i + 1) % n][1] - points[i][1];
        int x2 = points[(i + 2) % n][0] - points[(i + 1) % n][0];
        int y2 = points[(i + 2) % n][1] - points[(i + 1) % n][1];
        cur = x1 * y2 - x2 * y1;
        
        if (cur == 0)
            continue;
        if (cur * pre < 0)
            return false;
        pre = cur;
    }

    return true;
}

-----
bool isConvex(vector<vector<int>>& points) 
    // Your code here
}

************************************
Question ID: 470

int rand7(); // Provided API

int rand10() {
    int result;
    do {
        result = (rand7() - 1) * 7 + rand7();
    } while (result > 40);
    return result % 10 + 1;
}

-----
int rand7(); // Provided API

int rand10() 
    // Your code here
}

************************************
Question ID: 471

std::string encode(std::string s) {
    int n = s.length();
    for (int i = n / 2; i > 0; i--) {
        if (n % i == 0) {
            int reps = n / i;
            std::string sub = s.substr(0, i);
            std::string composed = "";
            for (int j = 0; j < reps; j++) {
                composed += sub;
            }
            if (s == composed) {
                return std::to_string(reps) + "[" + sub + "]";
            }
        }
    }
    return s;
}

-----
std::string encode(std::string s) 
    // Your code here
}

************************************
Question ID: 472

#include <vector>
#include <string>
#include <unordered_set>
using namespace std;

bool isConcatenated(const string& word, unordered_set<string>& wordDict) {
    int n = word.size();
    vector<bool> dp(n + 1, false);
    dp[0] = true;

    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (dp[j] && wordDict.count(word.substr(j, i - j))) {
                dp[i] = true;
                break;
            }
        }
    }
    return dp[n];
}

vector<string> findAllConcatenatedWords(vector<string>& words) {
    unordered_set<string> wordDict(words.begin(), words.end());
    vector<string> result;

    for (const string& word : words) {
        if (isConcatenated(word, wordDict)) {
            result.push_back(word);
        }
    }
    
    return result;
}

-----
#include <vector>
#include <string>
#include <unordered_set>
using namespace std;

bool isConcatenated(const string& word, unordered_set<string>& wordDict) 
    // Your code here
}

************************************
Question ID: 473

#include <vector>
#include <numeric>
#include <algorithm>

bool makesquare(std::vector<int>& matchsticks) {
    if (matchsticks.size() < 4) return false;
    int sum = std::accumulate(matchsticks.begin(), matchsticks.end(), 0);
    if (sum % 4) return false;
    int target = sum / 4;
    std::sort(matchsticks.rbegin(), matchsticks.rend());
    std::vector<int> sums(4, 0);
    return dfs(matchsticks, sums, target, 0);
}

bool dfs(std::vector<int>& matchsticks, std::vector<int>& sums, int target, int index) {
    if (index == matchsticks.size()) {
        return sums[0] == target && sums[1] == target && sums[2] == target;
    }
    for (int i = 0; i < 4; ++i) {
        if (sums[i] + matchsticks[index] <= target) {
            sums[i] += matchsticks[index];
            if (dfs(matchsticks, sums, target, index + 1)) return true;
            sums[i] -= matchsticks[index];
        }
    }
    return false;
}


-----
#include <vector>
#include <numeric>
#include <algorithm>

bool makesquare(std::vector<int>& matchsticks) 
    // Your code here
}


************************************
Question ID: 474

#include <vector>
#include <string>
#include <algorithm>

int findMaxForm(std::vector<std::string>& strs, int m, int n) {
    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1));
    
    for (const std::string& str: strs) {
        int ones = std::count(str.begin(), str.end(), '1');
        int zeros = str.length() - ones;
        
        for (int i = m; i >= zeros; --i) {
            for (int j = n; j >= ones; --j) {
                dp[i][j] = std::max(dp[i][j], dp[i - zeros][j - ones] + 1);
            }
        }
    }
    return dp[m][n];
}

-----
#include <vector>
#include <string>
#include <algorithm>

int findMaxForm(std::vector<std::string>& strs, int m, int n) 
    // Your code here
}

************************************
Question ID: 475

int findRadius(vector<int>& houses, vector<int>& heaters) {
    sort(houses.begin(), houses.end());
    sort(heaters.begin(), heaters.end());

    int result = 0;
    int i = 0;

    for (int house : houses) {
        while (i < heaters.size() - 1 &&
               abs(heaters[i + 1] - house) <= abs(heaters[i] - house)) {
            i++;
        }
        result = max(result, abs(heaters[i] - house));
    }
    return result;
}

-----
int findRadius(vector<int>& houses, vector<int>& heaters) 
    // Your code here
}

************************************
Question ID: 476

int findComplement(int num) {
    int bitLength = 0;
    int mask = num;
    while (mask > 0) {
        mask >>= 1;
        bitLength++;
    }
    int allOnes = (1 << bitLength) - 1;

    return num ^ allOnes;
}

-----
int findComplement(int num) 
    // Your code here
}

************************************
Question ID: 477

int totalHammingDistance(vector<int>& nums) {
    int total_distance = 0, n = nums.size();
    
    for (int i = 0; i < 32; ++i) {
        int bit_count = 0;
        for (int num : nums) {
            bit_count += (num >> i) & 1;
        }
        total_distance += bit_count * (n - bit_count);
    }
    
    return total_distance;
}

-----
int totalHammingDistance(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 478

#include <random>
#include <cmath>

class Solution {
public:
    std::default_random_engine gen;
    std::uniform_real_distribution<double> dist;
    double radius, x_center, y_center;
    
    Solution(double radius, double x_center, double y_center): dist(0, 1), radius(radius), x_center(x_center), y_center(y_center) {}
    
    vector<double> randPoint() {
        double r = sqrt(dist(gen)) * radius;
        double theta = dist(gen) * 2 * M_PI;
        return {x_center + r * cos(theta), y_center + r * sin(theta)};
    }
};

-----
#include <random>
#include <cmath>

class Solution 
    // Your code here
};

************************************
Question ID: 479

int largestPalindrome(int n) {
    if (n == 1) return 9;
    int upper_limit = pow(10, n) - 1;
    int lower_limit = upper_limit / 10;
    for (int i = upper_limit; i > lower_limit; --i) {
        long long temp = i;
        long long reverse = 0;
        while (temp != 0) {
            reverse = reverse * 10 + temp % 10;
            temp /= 10;
        }
        long long palindrome = i * pow(10, n) + reverse;
        for (long long j = upper_limit; j > lower_limit; --j) {
            long long product = palindrome / j;
            if (palindrome % j == 0 && product <= upper_limit) {
                return palindrome % 1337;
            }
        }
    }
    return -1;
}

-----
int largestPalindrome(int n) 
    // Your code here
}

************************************
Question ID: 480

#include <vector>
#include <set>

std::vector<double> medianSlidingWindow(std::vector<int>& nums, int k) {
    std::multiset<int> window(nums.begin(), nums.begin() + k);
    auto mid = std::next(window.begin(), k / 2);
    std::vector<double> medians;

    for (int i = k;; i++) {
        medians.push_back((double(*mid) + *std::prev(mid, 1 - k % 2)) / 2);
        
        if (i == nums.size()) {
            return medians;
        }
        window.insert(nums[i]);
        if (nums[i] < *mid) {
            mid--;
        }
        if (nums[i - k] <= *mid) {
            mid++;
        }
        window.erase(window.lower_bound(nums[i - k]));
    }
}


-----
#include <vector>
#include <set>

std::vector<double> medianSlidingWindow(std::vector<int>& nums, int k) 
    // Your code here
}


************************************
Question ID: 481

int magicalString(int n) {
    if (n == 0) return 0;
    if (n <= 3) return 1;
    
    vector<int> magic = {1, 2, 2};
    int count_ones = 1;
    int index = 2;
    int value = 1;
    
    while (magic.size() < n) {
        for (int i = 0; i < magic[index]; ++i) {
            magic.push_back(value);
            if (value == 1 && magic.size() <= n) count_ones++;
        }
        value = 3 - value;
        index++;
    }
    
    return count_ones;
}


-----
int magicalString(int n) 
    // Your code here
}


************************************
Question ID: 482

#include <cctype>
#include <string>
using namespace std;

string licenseKeyFormatting(string s, int k) {
    string result = "";
    int count = 0;
    for (int i = s.size() - 1; i >= 0; i--) {
        if (s[i] != '-') {
            if (count == k) {
                result.push_back('-');
                count = 0;
            }
            result.push_back(toupper(s[i]));
            count++;
        }
    }
    reverse(result.begin(), result.end());
    return result;
}

-----
#include <cctype>
#include <string>
using namespace std;

string licenseKeyFormatting(string s, int k) 
    // Your code here
}

************************************
Question ID: 483

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

ll smallestGoodBase(string n) {
    ll num_n = stoll(n);
    
    for(int m = log2(num_n) + 1; m >= 1; m--) {
        ll k = pow(num_n, 1.0 / m);
        ll sum = 0;
        for(int i=0; i <= m; i++) {
            sum = sum * k + 1;
        }
        if(sum == num_n) {
            return k;
        }
    }
    
    return -1;
}

-----
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

ll smallestGoodBase(string n) 
    // Your code here
}

************************************
Question ID: 484

#include <vector>
#include <string>

std::vector<int> findPermutation(std::string s) {
    std::vector<int> perm(s.length() + 1);
    int left = 1;
    for(int i = 0; i < s.length(); i++) {
        if(s[i] == 'I') {
            perm[i] = left++;
            while(i + 1 < s.length() && s[i + 1] == 'D')
                i++;
        }
    }
    perm[s.length()] = left++;
    for(int i = s.length() - 1; i >= 0; i--)
        if(s[i] == 'D')
            perm[i] = left++;
    return perm;
}

-----
#include <vector>
#include <string>

std::vector<int> findPermutation(std::string s) 
    // Your code here
}

************************************
Question ID: 485

int findMaxConsecutiveOnes(vector<int>& nums) {
    int max_consecutive = 0, current_consecutive = 0;
    for (int num : nums) {
        current_consecutive = (num == 1) ? current_consecutive + 1 : 0;
        max_consecutive = max(max_consecutive, current_consecutive);
    }
    return max_consecutive;
}

-----
int findMaxConsecutiveOnes(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 486

#include <vector>

bool canWin(const std::vector<int>& nums) {
    int n = nums.size();
    std::vector<std::vector<int>> dp(n, std::vector<int>(n));
    for (int i = 0; i < n; i++) {
        dp[i][i] = nums[i];
    }
    for (int len = 1; len < n; len++) {
        for (int i = 0; i < n - len; i++) {
            int j = i + len;
            dp[i][j] = std::max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);
        }
    }
    return dp[0][n - 1] >= 0;
}


-----
#include <vector>

bool canWin(const std::vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 487

int findMaxConsecutiveOnes(vector<int>& nums) {
    int max_count = 0, count_zeros = 0, left = 0;
    for (int right = 0; right < nums.size(); ++right) {
        if (nums[right] == 0) count_zeros++;
        while (count_zeros > 1) {
            if (nums[left++] == 0) count_zeros--;
        }
        max_count = max(max_count, right - left + 1);
    }
    return max_count;
}

-----
int findMaxConsecutiveOnes(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 488

#include <string>
#include <unordered_map>
#include <vector>

using namespace std;

int find_min_step_helper(string& board, unordered_map<string, int>& memo, unordered_map<char, int>& hand) {
    if (board.empty()) return 0;
    if (memo.count(board)) return memo[board];

    int result = INT_MAX;
    for (int i = 0, j = 0; i < board.size(); i = j) {
        while (j < board.size() and board[i] == board[j]) ++j;
        char color = board[i];
        int required = 3 - (j - i);
        if (hand[color] >= required) {
            hand[color] -= required;
            string next_board = board.substr(0, i) + board.substr(j);
            int tmp = find_min_step_helper(next_board, memo, hand);
            if (tmp != -1) result = min(result, tmp + required);
            hand[color] += required;
        }
    }

    memo[board] = result == INT_MAX ? -1 : result;
    return memo[board];
}

int find_min_step(string board, string hand) {
    unordered_map<char, int> hand_map;
    for (char c : hand) ++hand_map[c];
    unordered_map<string, int> memo;
    return find_min_step_helper(board, memo, hand_map);
}


-----
#include <string>
#include <unordered_map>
#include <vector>

using namespace std;

int find_min_step_helper(string& board, unordered_map<string, int>& memo, unordered_map<char, int>& hand) 
    // Your code here
}


************************************
Question ID: 489

#include <string>
#include <vector>

int comb(int n, int r) {
    if(r > n - r) r = n - r;
    long res = 1;
    for(int i = 1; i <= r; i++) {
        res *= n - r + i;
        res /= i;
    }
    return (int)res;
}

std::string kthSmallestPath(std::vector<int>& destination, int k) {
    int row = destination[0];
    int col = destination[1];
    std::string ans;

    for(int i = 0; i < row + col; i++) {
        if(row == 0) {
            ans += 'H';
            col--;
        } else if(col == 0) {
            ans += 'V';
            row--;
        } else if(k <= comb(row + col - 1, row - 1)) {
            ans += 'H';
            col--;
        } else {
            ans += 'V';
            k -= comb(row + col - 1, row - 1);
            row--;
        }
    }

    return ans;
}


-----
#include <string>
#include <vector>

int comb(int n, int r) 
    // Your code here
}


************************************
Question ID: 490

bool hasPath(vector<vector<int>>& maze, vector<int>& start, vector<int>& destination) {
    vector<vector<int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    queue<pair<int, int>> q;
    q.push({start[0], start[1]});
    while (!q.empty()) {
        auto [x, y] = q.front(); q.pop();
        if (x == destination[0] && y == destination[1]) return true;
        for (auto [dx, dy] : dirs) {
            int i = x, j = y;
            while (i + dx >= 0 && i + dx < maze.size() && j + dy >= 0 && j + dy < maze[0].size() && maze[i + dx][j + dy] == 0) {
                i += dx, j += dy;
            }
            if (maze[i][j] == 0) {
                maze[i][j] = 1;
                q.push({i, j});
            }
        }
    }
    return false;
}

-----
bool hasPath(vector<vector<int>>& maze, vector<int>& start, vector<int>& destination) 
    // Your code here
}

************************************
Question ID: 491

#include <vector>
#include <set>

std::vector<std::vector<int>> findSubsequences(std::vector<int>& nums) {
    std::set<std::vector<int>> res;
    std::vector<int> path;
    dfs(nums, 0, path, res);
    return std::vector<std::vector<int>>(res.begin(), res.end());
}

void dfs(std::vector<int>& nums, int start, std::vector<int>& path, std::set<std::vector<int>>& res) {
    if (path.size() >= 2) {
        res.insert(path);
    }
    for (int i = start; i < nums.size(); i++) {
        if (!path.empty() && path.back() > nums[i]) {
            continue;
        }
        path.push_back(nums[i]);
        dfs(nums, i + 1, path, res);
        path.pop_back();
    }
}

-----
#include <vector>
#include <set>

std::vector<std::vector<int>> findSubsequences(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 492

#include <vector>
#include <cmath>

std::vector<int> constructRectangle(int area) {
    int width = std::sqrt(area);
    while(area % width != 0) {
        width -= 1;
    }
    int length = area / width;
    return {length, width};
}

-----
#include <vector>
#include <cmath>

std::vector<int> constructRectangle(int area) 
    // Your code here
}

************************************
Question ID: 493

#include <vector>

int merge(std::vector<int>& nums, std::vector<int>& temp, int left, int mid, int right) {
    int count = 0;
    int j = mid;
    for (int i = left; i < mid; i++) {
        while (j <= right && (long long)nums[i] > 2LL * nums[j]) {
            j++;
        }
        count += j - mid;
    }
    std::merge(nums.begin() + left, nums.begin() + mid, nums.begin() + mid, nums.begin() + right + 1, temp.begin() + left);
    
    return count;
}

int countReversePairs(std::vector<int>& nums, std::vector<int>& temp, int left, int right) {
    if (left >= right) {
        return 0;
    }
    int mid = left + (right - left) / 2;
    int count = countReversePairs(nums, temp, left, mid) + countReversePairs(nums, temp, mid + 1, right);
    count += merge(nums, temp, left, mid + 1, right);
    std::copy(temp.begin() + left, temp.begin() + right + 1, nums.begin() + left);
    
    return count;
}

int reversePairs(std::vector<int>& nums) {
    std::vector<int> temp(nums.size());
    return countReversePairs(nums, temp, 0, nums.size() - 1);
}

-----
#include <vector>

int merge(std::vector<int>& nums, std::vector<int>& temp, int left, int mid, int right) 
    // Your code here
}

************************************
Question ID: 494

#include <vector>

int findTargetSumWays(std::vector<int>& nums, int target) {
    int sum = 0;
    for (int num : nums) sum += num;
    if (sum < target || (sum + target) % 2 != 0) return 0;
    int target_sum = (sum + target) / 2;
    std::vector<int> dp(target_sum + 1, 0);
    dp[0] = 1;
    for (int num : nums) {
        for (int j = target_sum; j >= num; j--) {
            dp[j] += dp[j - num];
        }
    }
    return dp[target_sum];
}


-----
#include <vector>

int findTargetSumWays(std::vector<int>& nums, int target) 
    // Your code here
}


************************************
Question ID: 495

int findPoisonedDuration(vector<int>& timeSeries, int duration) {
    if (timeSeries.empty()) return 0;
    int total = 0;
    for (int i = 1; i < timeSeries.size(); ++i) {
        total += min(timeSeries[i] - timeSeries[i - 1], duration);
    }
    return total + duration;
}

-----
int findPoisonedDuration(vector<int>& timeSeries, int duration) 
    // Your code here
}

************************************
Question ID: 496

#include <vector>
#include <stack>
#include <unordered_map>

std::vector<int> nextGreaterElement(std::vector<int>& nums1, std::vector<int>& nums2) {
    std::unordered_map<int, int> nextGreater;
    std::stack<int> stk;

    for (int num : nums2) {
        while (!stk.empty() && stk.top() < num) {
            nextGreater[stk.top()] = num;
            stk.pop();
        }
        stk.push(num);
    }

    std::vector<int> result(nums1.size());
    for (size_t i = 0; i < nums1.size(); ++i) {
        result[i] = nextGreater.count(nums1[i]) ? nextGreater[nums1[i]] : -1;
    }

    return result;
}

-----
#include <vector>
#include <stack>
#include <unordered_map>

std::vector<int> nextGreaterElement(std::vector<int>& nums1, std::vector<int>& nums2) 
    // Your code here
}

************************************
Question ID: 497

#include <random>
#include <vector>

class Solution {
    std::vector<std::vector<int>> rects;
    std::vector<int> areas;
    int total_area;

public:
    Solution(std::vector<std::vector<int>>& rects) :
        rects(rects), 
        areas(rects.size()), 
        total_area(0) {
        for (int i = 0; i < rects.size(); ++i) {
            int area = (rects[i][2] - rects[i][0] + 1) * (rects[i][3] - rects[i][1] + 1);
            areas[i] = area;
            total_area += area;
        }
    }

    std::vector<int> pick() {
        std::default_random_engine generator;
        std::uniform_int_distribution<int> distribution(0, total_area - 1);
        int rnd = distribution(generator);
        
        int idx = 0;
        while (rnd >= areas[idx]) {
            rnd -= areas[idx];
            idx++;
        }

        std::uniform_int_distribution<int> x_distribution(rects[idx][0], rects[idx][2]);
        std::uniform_int_distribution<int> y_distribution(rects[idx][1], rects[idx][3]);
        
        return {
            x_distribution(generator),
            y_distribution(generator)
        };
    }
};


-----
#include <random>
#include <vector>

class Solution 
    // Your code here
};


************************************
Question ID: 498

#include <vector>
using namespace std;

vector<int> findDiagonalOrder(vector<vector<int>>& mat) {
    int m = mat.size();
    int n = mat[0].size();
    vector<int> result(m * n);
    int row = 0, col = 0;
    for (int i = 0; i < m * n; i++) {
        result[i] = mat[row][col];
        if ((row + col) % 2 == 0) {
            if (col == n - 1) {
                row++;
            } else if (row == 0) {
                col++;
            } else {
                row--;
                col++;
            }
        } else {
            if (row == m - 1) {
                col++;
            } else if (col == 0) {
                row++;
            } else {
                row++;
                col--;
            }
        }
    }
    return result;
}

-----
#include <vector>
using namespace std;

vector<int> findDiagonalOrder(vector<vector<int>>& mat) 
    // Your code here
}

************************************
Question ID: 499

#include <vector>
#include <queue>
#include <string>

using namespace std;

class Solution {
public:
    string findShortestWay(vector<vector<int>>& maze, vector<int>& ball, vector<int>& hole) {
        int m = maze.size(), n = maze[0].size();
        vector<vector<int>> dist(m, vector<int>(n, INT_MAX)); 
        vector<string> dirs = {"d", "l", "r", "u"};
        vector<vector<int>> dirs_vector = {{1, 0}, {0, -1}, {0, 1}, {-1, 0}};
        string res = "";
        dist[ball[0]][ball[1]] = 0;
        auto cmp = [&](const auto& p1, const auto& p2){
            return p1.first > p2.first || (p1.first == p2.first && p1.second > p2.second);
        };
        priority_queue<pair<int, string>, vector<pair<int, string>>, decltype(cmp)> pq(cmp);
        pq.push({0, ""});
        
        while (!pq.empty()) {
            int cur_dist = pq.top().first;
            string cur_path = pq.top().second;
            int x = ball[0], y = ball[1];
            for (char c : cur_path) {
                if (c == 'd') x += dirs_vector[0][0]; 
                if (c == 'l') y += dirs_vector[1][1];
                if (c == 'r') y += dirs_vector[2][1];
                if (c == 'u') x += dirs_vector[3][0];
            }
            pq.pop();
            if (x == hole[0] && y == hole[1]) return cur_path;

            for (int k = 0; k < 4; ++k) {
                int dist_move = 0, r = x, c = y;
                while (r >= 0 && r < m && c >= 0 && c < n && maze[r][c] == 0 && (r != hole[0] || c != hole[1])) {
                    r += dirs_vector[k][0];
                    c += dirs_vector[k][1];
                    ++dist_move;
                }
                r -= dirs_vector[k][0];
                c -= dirs_vector[k][1];
                --dist_move;
                
                if (dist[x][y] + dist_move < dist[r][c]) {
                    dist[r][c] = dist[x][y] + dist_move;
                    pq.push({cur_dist + dist_move, cur_path + dirs[k]});
                }
            }
        }
        
        return "impossible";
    }
};

-----
#include <vector>
#include <queue>
#include <string>

using namespace std;

class Solution 
    // Your code here
};

************************************
Question ID: 500

#include <vector>
#include <string>
#include <unordered_set>
using namespace std;

vector<string> findWords(vector<string>& words) {
    vector<unordered_set<char>> rows = {
        {'q','w','e','r','t','y','u','i','o','p'},
        {'a','s','d','f','g','h','j','k','l'},
        {'z','x','c','v','b','n','m'}
    };
    vector<string> result;
    
    for (const auto& word : words) {
        int row = -1;
        for (int i = 0; i < 3; ++i) {
            if (rows[i].count(tolower(word[0])) > 0) {
                row = i;
                break;
            }
        }
        
        bool isOneRow = true;
        for (const auto& letter : word) {
            if (rows[row].count(tolower(letter)) == 0) {
                isOneRow = false;
                break;
            }
        }
        
        if (isOneRow) {
            result.push_back(word);
        }
    }
    
    return result;
}


-----
#include <vector>
#include <string>
#include <unordered_set>
using namespace std;

vector<string> findWords(vector<string>& words) 
    // Your code here
}


************************************
Question ID: 501

void InOrder(TreeNode* root, unordered_map<int, int>& frequencies, int& max_frequency) {
    if (!root) return;
    InOrder(root->left, frequencies, max_frequency);
    frequencies[root->val]++;
    max_frequency = max(max_frequency, frequencies[root->val]);
    InOrder(root->right, frequencies, max_frequency);
}

vector<int> findMode(TreeNode* root) {
    unordered_map<int, int> frequencies;
    int max_frequency = 0;
    InOrder(root, frequencies, max_frequency);
    vector<int> modes;
    
    for (const auto& freq : frequencies) {
        if (freq.second == max_frequency) modes.push_back(freq.first);
    }
    
    return modes;
}

-----
void InOrder(TreeNode* root, unordered_map<int, int>& frequencies, int& max_frequency) 
    // Your code here
}

************************************
Question ID: 502

#include <queue>
#include <vector>
#include <algorithm>

using namespace std;

int findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {
    vector<pair<int, int>> project_pool;
    
    for (size_t i = 0; i < profits.size(); i++) {
        project_pool.emplace_back(capital[i], profits[i]);
    }
    
    sort(project_pool.begin(), project_pool.end());
    
    priority_queue<int> profit_pool;
    int index = 0;
    
    for (int i = 0; i < k; i++) {
        while (index < project_pool.size() &&
               project_pool[index].first <= w) {
            profit_pool.push(project_pool[index++].second);
        }
        
        if (!profit_pool.empty()) {
            w += profit_pool.top();
            profit_pool.pop();
        } else {
            break;
        }
    }
    
    return w;
}

-----
#include <queue>
#include <vector>
#include <algorithm>

using namespace std;

int findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) 
    // Your code here
}

************************************
Question ID: 503

#include <vector>
#include <stack>

std::vector<int> nextGreaterElements(std::vector<int>& nums) {
    std::vector<int> result(nums.size(), -1);
    std::stack<int> s;

    for (int i = 0; i < nums.size() * 2; ++i) {
        int index = i % nums.size();
        while (!s.empty() && nums[s.top()] < nums[index]) {
            result[s.top()] = nums[index];
            s.pop();
        }
        if (i < nums.size()) {
            s.push(index);
        }
    }
    return result;
}

-----
#include <vector>
#include <stack>

std::vector<int> nextGreaterElements(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 504

std::string convertToBase7(int num) {
    if (num == 0) return "0";
    std::string result = "";
    bool negative = num < 0;
    if (negative) num *= -1;
    while (num > 0) {
        result = std::to_string(num % 7) + result;
        num /= 7;
    }
    return negative ? "-" + result : result;
}

-----
std::string convertToBase7(int num) 
    // Your code here
}

************************************
Question ID: 505

#include <vector>
#include <queue>
#include <utility>

using namespace std;

int shortestDistance(vector<vector<int>>& maze, vector<int>& start, vector<int>& destination) {
    int m = maze.size(), n = maze[0].size();
    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    vector<vector<int>> dist(m, vector<int> (n, -1));

    queue<pair<int, int>> q;

    dist[start[0]][start[1]] = 0;
    q.push({start[0], start[1]});

    while (!q.empty()) {
        int x = q.front().first, y = q.front().second;
        q.pop();

        for (auto dir : directions) {
            int newX = x + dir.first;
            int newY = y + dir.second;
            int step = 0;

            while (newX >= 0 && newX < m && newY >= 0 && newY < n && maze[newX][newY] == 0) {
                newX += dir.first;
                newY += dir.second;
                step++;
            }

            newX -= dir.first;
            newY -= dir.second;

            if (dist[newX][newY] == -1 || dist[x][y] + step < dist[newX][newY]) {
                dist[newX][newY] = dist[x][y] + step;
                q.push({newX, newY});
            }
        }
    }

    return dist[destination[0]][destination[1]];
}


-----
#include <vector>
#include <queue>
#include <utility>

using namespace std;

int shortestDistance(vector<vector<int>>& maze, vector<int>& start, vector<int>& destination) 
    // Your code here
}


************************************
Question ID: 506

#include <vector>
#include <algorithm>

std::vector<int> findRelativeRanks(std::vector<int>& score) {
    std::vector<int> rank_sort(score.size());
    for(int i = 0; i < score.size(); ++i) rank_sort[i] = i;
    std::sort(rank_sort.begin(), rank_sort.end(), [&](int i1, int i2) { return score[i1] > score[i2]; });
    std::vector<int>  result(score.size());
    for(int i = 0; i < rank_sort.size(); ++i) result[rank_sort[i]] = i + 1;
    return result;
}


-----
#include <vector>
#include <algorithm>

std::vector<int> findRelativeRanks(std::vector<int>& score) 
    // Your code here
}


************************************
Question ID: 507

bool checkPerfectNumber(int num) {
    if (num <= 1) return false;
    int sum = 1;
    for (int i = 2; i * i <= num; ++i) {
        if (num % i == 0) {
            sum += i;
            if (i * i != num) sum += num / i;
        }
    }
    return sum == num;
}

-----
bool checkPerfectNumber(int num) 
    // Your code here
}

************************************
Question ID: 508

#include <map>
#include <vector>

void helper(TreeNode* root, std::map<int, int>& counts, int& max_count) {
    if (!root) return;
    int sum = root->val + helper(root->left, counts, max_count) + helper(root->right, counts, max_count);
    counts[sum]++;
    max_count = std::max(max_count, counts[sum]);
}

std::vector<int> findFrequentTreeSum(TreeNode* root) {
    std::map<int, int> counts;
    int max_count = 0;
    helper(root, counts, max_count);
    std::vector<int> result;
    for (const auto& pair : counts) {
        if (pair.second == max_count) result.push_back(pair.first);
    }
    return result;
}


-----
#include <map>
#include <vector>

void helper(TreeNode* root, std::map<int, int>& counts, int& max_count) 
    // Your code here
}


************************************
Question ID: 509

int fib(int n) {
    if(n < 2) {
        return n;
    }
    int a = 0, b = 1, c;
    for(int i = 2; i <= n; ++i) {
        c = a + b;
        a = b;
        b = c;
    }
    return b;
}

-----
int fib(int n) 
    // Your code here
}

************************************
Question ID: 513

int findBottomLeftValue(TreeNode* root) {
    int result = 0, maxDepth = 0;
    helper(root, 1, maxDepth, result);
    return result;
}

void helper(TreeNode* node, int depth, int& maxDepth, int& result) {
    if (!node) return;
    if (depth > maxDepth) {
        maxDepth = depth;
        result = node->val;
    }
    helper(node->left, depth+1, maxDepth, result);
    helper(node->right, depth+1, maxDepth, result);
}


-----
int findBottomLeftValue(TreeNode* root) 
    // Your code here
}


************************************
Question ID: 514

#include <string>
#include <vector>
#include <algorithm>

int findRotateSteps(std::string ring, std::string key) {
    int n = ring.size(), m = key.size();
    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n, 0));

    for (int i = m - 1; i >= 0; --i) {
        for (int j = 0; j < n; ++j) {
            dp[i][j] = INT_MAX;
            for (int k = 0; k < n; ++k) {
                if (ring[k] == key[i]) {
                    int diff = abs(j - k);
                    int step = std::min(diff, n - diff);
                    dp[i][j] = std::min(dp[i][j], step + dp[i + 1][k]);
                }
            }
        }
    }

    return dp[0][0] + m;
}


-----
#include <string>
#include <vector>
#include <algorithm>

int findRotateSteps(std::string ring, std::string key) 
    // Your code here
}


************************************
Question ID: 515

#include <vector>
#include <queue>
using namespace std;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
};

vector<int> largestValues(TreeNode* root) {
    if (!root) return {};
    vector<int> result;
    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        int size = q.size();
        int max_val = INT_MIN;
        for (int i = 0; i < size; ++i) {
            TreeNode* node = q.front();
            q.pop();
            max_val = max(max_val, node->val);

            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        result.push_back(max_val);
    }
    return result;
}

-----
#include <vector>
#include <queue>
using namespace std;

struct TreeNode 
    // Your code here
}

************************************
Question ID: 516

#include <string>
#include <vector>
using namespace std;

int longestPalindromeSubseq(string s) {
    int n = s.size();
    vector<vector<int>> dp(n, vector<int>(n, 0));
    for (int i = n - 1; i >= 0; i--) {
        dp[i][i] = 1;
        for (int j = i + 1; j < n; j++) {
            if (s[i] == s[j]) {
                dp[i][j] = 2 + dp[i + 1][j - 1];
            } else {
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[0][n - 1];
}

-----
#include <string>
#include <vector>
using namespace std;

int longestPalindromeSubseq(string s) 
    // Your code here
}

************************************
Question ID: 517

#include <vector>
#include <numeric>
#include <cmath>

int findMinMoves(std::vector<int>& machines) {
    int n = machines.size();
    int totalDresses = std::accumulate(machines.begin(), machines.end(), 0);
    if (totalDresses % n != 0) return -1;
    int average = totalDresses / n;
    int moves = 0, imbalance = 0;
    
    for (int i = 0; i < n; i++) {
        imbalance += machines[i] - average;
        moves = std::max(moves, std::max(abs(imbalance), machines[i] - average));
    }
    
    return moves;
}

-----
#include <vector>
#include <numeric>
#include <cmath>

int findMinMoves(std::vector<int>& machines) 
    // Your code here
}

************************************
Question ID: 518

int change(int amount, vector<int>& coins) {
    vector<int> dp(amount + 1, 0);
    dp[0] = 1;
    for (int coin : coins) {
        for (int i = coin; i <= amount; i++) {
            dp[i] += dp[i - coin];
        }
    }
    return dp[amount];
}

-----
int change(int amount, vector<int>& coins) 
    // Your code here
}

************************************
Question ID: 519

#include <vector>
#include <random>

class Solution {
    int rows, cols;
    int total;
    std::vector<std::vector<int>> matrix;

public:
    Solution(int m, int n) : rows(m), cols(n), total(m * n) {
        matrix = std::vector<std::vector<int>>(m, std::vector<int>(n, 0));
    }

    std::vector<int> flip() {
        int idx = rand() % total;
        total--;

        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                if (matrix[i][j] == 0) {
                    if (idx == 0) {
                        matrix[i][j] = 1;
                        return {i, j};
                    }
                    idx--;
                }
            }
        }
        return {-1, -1}; // This line should never be reached
    }

    void reset() {
        total = rows * cols;
        for (auto &row : matrix) {
            std::fill(row.begin(), row.end(), 0);
        }
    }
};


-----
#include <vector>
#include <random>

class Solution 
    // Your code here
};


************************************
Question ID: 520

bool detectCapitalUse(string word) {
    int numCapital = 0;
    for (char c : word) {
        if (isupper(c)) numCapital++;
    }
    return numCapital == 0 || numCapital == word.size() || (numCapital == 1 && isupper(word[0]));
}


-----
bool detectCapitalUse(string word) 
    // Your code here
}


************************************
Question ID: 521

int findLUSlength(string a, string b) {
    if (a == b) {
        return -1;
    }
    return max(a.length(), b.length());
}

-----
int findLUSlength(string a, string b) 
    // Your code here
}

************************************
Question ID: 522

#include <string>
#include <vector>
#include <algorithm>

int findLUSlength(std::vector<std::string>& strs) {
    int maxLength = -1;
    for(int i = 0; i < strs.size(); ++i) {
        bool isUncommon = true;
        for(int j = 0; j < strs.size(); ++j) {
            if(i != j && std::search(strs[j].begin(), strs[j].end(), strs[i].begin(), strs[i].end()) != strs[j].end()) {
                isUncommon = false;
                break;
            }
        }
        if(isUncommon) {
            maxLength = std::max(maxLength, static_cast<int>(strs[i].length()));
        }
    }
    return maxLength;
}


-----
#include <string>
#include <vector>
#include <algorithm>

int findLUSlength(std::vector<std::string>& strs) 
    // Your code here
}


************************************
Question ID: 523

#include <vector>
#include <unordered_map>

bool checkSubarraySum(std::vector<int>& nums, int k) {
    int n = nums.size(), sum = 0;
    std::unordered_map<int, int> mp;
    mp[0] = -1;
    for (int i = 0; i < n; ++i) {
        sum += nums[i];
        if (k != 0) sum %= k;
        if (mp.count(sum)) {
            if (i - mp[sum] > 1) return true;
        } else {
            mp[sum] = i;
        }
    }
    return false;
}

-----
#include <vector>
#include <unordered_map>

bool checkSubarraySum(std::vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 524

#include <string>
#include <vector>
#include <algorithm>

bool isSubsequence(const std::string &s, const std::string &word) {
    int i = 0, j = 0;
    while (i < s.size() && j < word.size()) {
        if (s[i] == word[j]) {
            j++;
        }
        i++;
    }
    return j == word.size();
}

std::string findLongestWord(std::string s, std::vector<std::string> &dictionary) {
    std::string longest = "";
    std::sort(dictionary.begin(), dictionary.end());
    for (const std::string &word : dictionary) {
        if (isSubsequence(s, word)) {
            if (word.size() > longest.size()) {
                longest = word;
            }
        }
    }
    return longest;
}


-----
#include <string>
#include <vector>
#include <algorithm>

bool isSubsequence(const std::string &s, const std::string &word) 
    // Your code here
}


************************************
Question ID: 525

int findMaxLength(vector<int>& nums) {
    unordered_map<int, int> counts;
    counts[0] = -1;
    int max_len = 0, count = 0;
    for (int i = 0; i < nums.size(); i++) {
        count += (nums[i] == 1) ? 1 : -1;
        if (counts.count(count))
            max_len = max(max_len, i - counts[count]);
        else
            counts[count] = i;
    }
    return max_len;
}

-----
int findMaxLength(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 526

int countArrangement(int n) {
    int res=0;
    vector<bool> visited(n+1,false); 
    helper(n,1,visited,res); 
    return res;
}

void helper(int n, int idx, vector<bool>& visited, int& res) {
    if (idx > n) {
        ++res;
    }

    for(int i=1; i<=n; i++){
        if (!visited[i] && (idx % i == 0 || i % idx == 0)) { 
            visited[i] = true; 
            helper(n, idx+1, visited, res); 
            visited[i] = false; 
        }
    }
}

-----
int countArrangement(int n) 
    // Your code here
}

************************************
Question ID: 527

#include <vector>
#include <string>
#include <unordered_map>

std::string abbrev(const std::string& s, int k) {
    int n = s.length();
    if (k >= n - 2) {
        return s;
    }
    return s.substr(0, k + 1) + std::to_string(n - k - 2) + s.back();
}

std::vector<std::string> wordsAbbreviation(std::vector<std::string>& words) {
    int n = words.size();
    std::vector<std::string> abbr;
    std::vector<int> prefixLen(n, 1);

    for (int i = 0; i < n; ++i) {
        abbr.push_back(abbrev(words[i], 1));
    }

    for (int i = 0; i < n; ++i) {
        while (true) {
            std::unordered_map<std::string, std::vector<int>> groups;
            for (int j = i + 1; j < n; ++j) {
                if (abbr[i] == abbr[j]) {
                    groups[abbr[j]].push_back(j);
                }
            }
            if (groups.empty()) {
                break;
            }
            for (const auto &group : groups) {
                for (int id : group.second) {
                    abbr[id] = abbrev(words[id], ++prefixLen[id]);
                }
            }
            abbr[i] = abbrev(words[i], ++prefixLen[i]);
        }
    }

    return abbr;
}

-----
#include <vector>
#include <string>
#include <unordered_map>

std::string abbrev(const std::string& s, int k) 
    // Your code here
}

************************************
Question ID: 529

#include<vector>
using namespace std;

void reveal(vector<vector<char>>& board, int row, int col, vector<vector<int>>& directions) {
    if (row < 0 || row >= board.size() || col < 0 || col >= board[0].size() || board[row][col] != 'E') return;

    int mines = 0;
    for (auto& dir : directions) {
        int newRow = row + dir[0], newCol = col + dir[1];
        if (newRow >= 0 && newRow < board.size() && newCol >= 0 && newCol < board[0].size() && board[newRow][newCol] == 'M') mines++;
    }

    if (mines > 0) {
        board[row][col] = '0' + mines;
    } else {
        board[row][col] = 'B';
        for (auto& dir : directions) {
            reveal(board, row + dir[0], col + dir[1], directions);
        }
    }
}

vector<vector<char>> updateBoard(vector<vector<char>>& board, vector<int>& click) {
    int row = click[0], col = click[1];

...
}

```
-----
#include<vector>
using namespace std;

void reveal(vector<vector<char>>& board, int row, int col, vector<vector<int>>& directions) 
    // Your code here
}

```
************************************
Question ID: 531

int findLonelyPixel(vector<vector<char>>& picture) {
    int m = picture.size(), n = picture[0].size();
    vector<int> row(m, 0), col(n, 0);
    
    for(int i = 0; i < m; ++i) {
        for(int j = 0; j < n; ++j) {
            if(picture[i][j] == 'B') {
                row[i]++;
                col[j]++;
            }
        }
    }
    
    int lonely = 0;
    for(int i = 0; i < m; ++i) {
        for(int j = 0; j < n; ++j) {
            if(picture[i][j] == 'B' && row[i] == 1 && col[j] == 1) {
                lonely++;
            }
        }
    }
    
    return lonely;
}

-----
int findLonelyPixel(vector<vector<char>>& picture) 
    // Your code here
}

************************************
Question ID: 532

#include <unordered_set>
#include <unordered_map>
int findPairs(vector<int>& nums, int k) {
    if (k < 0) return 0;
    unordered_set<int> starters;
    unordered_map<int, int> occurrences;
    for (int num : nums) {
        if (occurrences.count(num + k)) starters.insert(num);
        if (occurrences.count(num - k)) starters.insert(num - k);
        occurrences[num]++;
    }
    return starters.size();
}

-----
#include <unordered_set>
#include <unordered_map>
int findPairs(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 533

int findBlackPixel(vector<vector<char>>& picture, int target) {
    int m = picture.size();
    int n = picture[0].size();
    vector<int> rows(m, 0), cols(n, 0);
    unordered_map<string, int> rowCounts;
    for (int i = 0; i < m; ++i) {
        string row;
        for (int j = 0; j < n; ++j) {
            if (picture[i][j] == 'B') {
                rows[i]++;
                cols[j]++;
            }
            row.push_back(picture[i][j]);
        }
        if (rows[i] == target)
            rowCounts[row]++;
    }
    int ans = 0;
    for (auto &[row, count] : rowCounts) {
        if (count == target) {
            for (int j = 0; j < n; ++j) {
                if (row[j] == 'B' && cols[j] == target)
                    ans += count;
            }
        }
    }
    return ans;
}

-----
int findBlackPixel(vector<vector<char>>& picture, int target) 
    // Your code here
}

************************************
Question ID: 535

#include <unordered_map>
#include <string>
#include <random>

class Solution {
public:
    std::unordered_map<std::string, std::string> map;
    std::string alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    // Encodes a URL to a shortened URL.
    std::string encode(std::string longUrl) {
        std::string key;
        while (true) {
            key.clear();
            for (int i = 0; i < 6; i++) {
                key += alphabet[rand() % alphabet.length()];
            }
            if (map.count(key) == 0) {
                map[key] = longUrl;
                break;
            }
        }
        return "http://tinyurl.com/" + key;
    }

    // Decodes a shortened URL to its original URL.
    std::string decode(std::string shortUrl) {
        return map[shortUrl.substr(19, 6)];
    }
};

-----
#include <unordered_map>
#include <string>
#include <random>

class Solution 
    // Your code here
};

************************************
Question ID: 537

#include <string>
#include <sstream>

std::string complexNumberMultiply(std::string num1, std::string num2) {
    int real1, imag1, real2, imag2;
    sscanf(num1.c_str(), "%d+%di", &real1, &imag1);
    sscanf(num2.c_str(), "%d+%di", &real2, &imag2);
   
    int real = real1 * real2 - imag1 * imag2;
    int imag = real1 * imag2 + real2 * imag1;
   
    return std::to_string(real) + "+" + std::to_string(imag) + "i";
}

-----
#include <string>
#include <sstream>

std::string complexNumberMultiply(std::string num1, std::string num2) 
    // Your code here
}

************************************
Question ID: 539

#include <vector>
#include <string>
#include <algorithm>
#include <climits>

int findMinDifference(std::vector<std::string>& timePoints) {
    std::sort(timePoints.begin(), timePoints.end());
    int minDifference = INT_MAX;

    for (int i = 0; i < timePoints.size(); ++i) {
        int curDifference = abs((stoi(timePoints[i].substr(0, 2)) * 60 + stoi(timePoints[i].substr(3, 2))) - (stoi(timePoints[(i + 1) % timePoints.size()].substr(0, 2)) * 60 + stoi(timePoints[(i + 1) % timePoints.size()].substr(3, 2))));
        minDifference = std::min(minDifference, curDifference > 720 ? 1440 - curDifference : curDifference);
    }

    return minDifference;
}

-----
#include <vector>
#include <string>
#include <algorithm>
#include <climits>

int findMinDifference(std::vector<std::string>& timePoints) 
    // Your code here
}

************************************
Question ID: 540

int singleNonDuplicate(vector<int>& nums) {
    int low = 0, high = nums.size() - 1;
    while (low < high) {
        int mid = low + (high - low) / 2;
        if (mid % 2 == 1)
            mid--;
        if (nums[mid] == nums[mid + 1])
            low = mid + 2;
        else
            high = mid;
    }
    return nums[low];
}

-----
int singleNonDuplicate(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 541

#include <algorithm>
#include <string>
using namespace std;

string reverseStr(string s, int k) {
    for (int i = 0; i < s.size(); i += 2*k) {
        if (i + k <= s.size()) {
            reverse(s.begin() + i, s.begin() + i + k);
        } else {
            reverse(s.begin() + i, s.end());
        }
    }
    return s;
}

-----
#include <algorithm>
#include <string>
using namespace std;

string reverseStr(string s, int k) 
    // Your code here
}

************************************
Question ID: 542

#include <vector>
#include <queue>
using namespace std;

vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
    int m = mat.size();
    int n = mat[0].size();
    vector<vector<int>> ans(m, vector<int>(n, INT_MAX - 100000));
    
    queue<pair<int, int>> q;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (mat[i][j] == 0) {
                ans[i][j] = 0;
                q.push({i, j});
            }
        }
    }

    vector<pair<int, int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    while (!q.empty()) {
        int x = q.front().first;
        int y = q.front().second;
        q.pop();
        
        for (pair<int, int>& dir : dirs) {
            int newX = x + dir.first;
            int newY = y + dir.second;
            if (newX >= 0 && newY >= 0 && newX < m && newY < n && ans[newX][newY] > ans[x][y] + 1) {
                ans[newX][newY] = ans[x][y] + 1;
                q.push({newX, newY});
            }
        }
    }
    return ans;
}


-----
#include <vector>
#include <queue>
using namespace std;

vector<vector<int>> updateMatrix(vector<vector<int>>& mat) 
    // Your code here
}


************************************
Question ID: 544

#include <string>
#include <vector>
using namespace std;

string findContestMatch(int n) {
    vector<string> matches(n);
    for (int i = 1; i <= n; i++) {
        matches[i - 1] = to_string(i);
    }

    while (n > 1) {
        for (int i = 0; i < n / 2; i++) {
            matches[i] = "(" + matches[i] + "," + matches[n - 1 - i] + ")";
        }
        n /= 2;
    }

    return matches[0];
}


-----
#include <string>
#include <vector>
using namespace std;

string findContestMatch(int n) 
    // Your code here
}


************************************
Question ID: 546

int removeBoxes(vector<int>& boxes) {
    int dp[100][100][100] = {0};
    return dfs(boxes, dp, 0, boxes.size() - 1, 0);
}

int dfs(vector<int>& boxes, int dp[100][100][100], int l, int r, int k) {
    if (l > r) return 0;
    if (dp[l][r][k] != 0) return dp[l][r][k];

    while (r > l && boxes[r] == boxes[r - 1]) {r--; k++;}

    dp[l][r][k] = (k + 1) * (k + 1) + dfs(boxes, dp, l, r - 1, 0);

    for (int i = l; i < r; i++) {
        if (boxes[i] == boxes[r]) {
            dp[l][r][k] = max(dp[l][r][k], dfs(boxes, dp, l, i, k + 1) + dfs(boxes, dp, i + 1, r - 1, 0));
        }
    }

    return dp[l][r][k];
}

-----
int removeBoxes(vector<int>& boxes) 
    // Your code here
}

************************************
Question ID: 547

#include <vector>

using std::vector;

void dfs(vector<vector<int>>& isConnected, vector<bool>& visited, int i) {
    visited[i] = true;
    for (int j = 0; j < isConnected.size(); j++) {
        if (isConnected[i][j] == 1 && !visited[j]) {
            dfs(isConnected, visited, j);
        }
    }
}

int findCircleNum(vector<vector<int>>& isConnected) {
    int provinces = 0;
    vector<bool> visited(isConnected.size(), false);
    for (int i = 0; i < isConnected.size(); i++) {
        if (!visited[i]) {
            dfs(isConnected, visited, i);
            provinces++;
        }
    }
    return provinces;
}

-----
#include <vector>

using std::vector;

void dfs(vector<vector<int>>& isConnected, vector<bool>& visited, int i) 
    // Your code here
}

************************************
Question ID: 548

bool find_triplet_equal_sum(const std::vector<int>& nums) {
    int n = nums.size();
    std::vector<int> prefix_sum(n + 1, 0);

    for (int i = 0; i < n; ++i) {
        prefix_sum[i + 1] = prefix_sum[i] + nums[i];
    }

    for (int i = 1; i + 2 < n; ++i) {
        for (int j = i + 2; j + 1 < n; ++j) {
            for (int k = j + 2; k < n; ++k) {
                int s1 = prefix_sum[i];
                int s2 = prefix_sum[j] - prefix_sum[i + 1];
                int s3 = prefix_sum[k] - prefix_sum[j + 1];
                int s4 = prefix_sum[n] - prefix_sum[k + 1];
                if (s1 == s2 && s2 == s3 && s3 == s4) {
                    return true;
                }
            }
        }
    }
    return false;
}

-----
bool find_triplet_equal_sum(const std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 551

#include <string>

bool checkRecord(std::string s) {
    int late = 0, absent = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == 'A') {
            absent++;
            late = 0;
        } else if (s[i] == 'L') {
            late++;
        } else {
            late = 0;
        }

        if (absent >= 2 || late >= 3) return false;
    }
    return true;
}

-----
#include <string>

bool checkRecord(std::string s) 
    // Your code here
}

************************************
Question ID: 552

int checkRecord(int n) {
    int M = 1000000007;
    vector<long long> dp(6, 1);  // {latent state 0, latent state 1, ..., latent state 5}
    while (n--) {
        vector<long long> next_dp(6, 0);
        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M;
        next_dp[1] = dp[0];
        next_dp[2] = dp[1];
        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M;
        next_dp[4] = dp[3];
        next_dp[5] = dp[4];
        dp = next_dp;
    }
    return (dp[0] + dp[1] + dp[2] + dp[3] + dp[4] + dp[5]) % M;
}


-----
int checkRecord(int n) 
    // Your code here
}


************************************
Question ID: 553

#include <string>
#include <vector>

std::string optimalDivision(std::vector<int>& nums) {
    int n = nums.size();
    if (n == 1) return std::to_string(nums[0]);
    if (n == 2) return std::to_string(nums[0]) + "/" + std::to_string(nums[1]);
    std::string res = std::to_string(nums[0]) + "/(";
    for (int i = 1; i < n - 1; ++i) {
        res += std::to_string(nums[i]) + "/";
    }
    res += std::to_string(nums[n - 1]) + ")";
    return res;
}


-----
#include <string>
#include <vector>

std::string optimalDivision(std::vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 554

#include <vector>
#include <unordered_map>

int leastBricks(std::vector<std::vector<int>>& wall) {
    std::unordered_map<int, int> edge_count;
    int max_count = 0;

    for (const auto& row : wall) {
        int edge_position = 0;
        for (size_t i = 0; i < row.size() - 1; ++i) {
            edge_position += row[i];
            ++edge_count[edge_position];
            max_count = std::max(max_count, edge_count[edge_position]);
        }
    }

    return wall.size() - max_count;
}


-----
#include <vector>
#include <unordered_map>

int leastBricks(std::vector<std::vector<int>>& wall) 
    // Your code here
}


************************************
Question ID: 555

#include <vector>
#include <string>
#include <algorithm>

std::string splitLoopedString(std::vector<std::string>& strs) {
    std::string ans;
    std::string cur;
    for (auto &s : strs) {
        std::string rev(s.rbegin(), s.rend());
        cur += std::max(s, rev);
    }

    for (size_t i = 0, k = 0; i < strs.size(); ++i) {
        std::string rev(strs[i].rbegin(), strs[i].rend());
        for (auto &xstr : {strs[i], rev}) {
            for (size_t j = 0; j < xstr.size(); ++j) {
                std::string t = xstr.substr(j) + cur.substr(k + xstr.size()) + cur.substr(0, k) + xstr.substr(0, j);
                ans = std::max(ans, t);
            }
        }
        k += strs[i].size();
    }
    return ans;
}

-----
#include <vector>
#include <string>
#include <algorithm>

std::string splitLoopedString(std::vector<std::string>& strs) 
    // Your code here
}

************************************
Question ID: 556

#include <bits/stdc++.h>
using namespace std;

int32_t nextGreaterElement(int n) {
    string num = to_string(n);
    if (next_permutation(num.begin(), num.end())) {
        long long result = stoll(num);
        if (result <= INT32_MAX) {
            return result;
        }
    }
    return -1;
}

-----
#include <bits/stdc++.h>
using namespace std;

int32_t nextGreaterElement(int n) 
    // Your code here
}

************************************
Question ID: 557

#include <string>
#include <algorithm>
#include <sstream>

std::string reverseWordsInString(const std::string& s) {
    std::istringstream iss(s);
    std::ostringstream oss;
    std::string word;
    while (iss >> word) {
        std::reverse(word.begin(), word.end());
        oss << word << ' ';
    }
    std::string result = oss.str();
    if (!result.empty()) result.pop_back();
    return result;
}

-----
#include <string>
#include <algorithm>
#include <sstream>

std::string reverseWordsInString(const std::string& s) 
    // Your code here
}

************************************
Question ID: 560

int subarraySum(vector<int>& nums, int k) {
    unordered_map<int, int> prefixSumFrequency;
    prefixSumFrequency[0] = 1;
    int prefixSum = 0, result = 0;
    
    for (int num : nums) {
        prefixSum += num;
        result += prefixSumFrequency[prefixSum - k];
        prefixSumFrequency[prefixSum]++;
    }
    
    return result;
}

-----
int subarraySum(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 561

#include <vector>
#include <algorithm>

int arrayPairSum(std::vector<int>& nums) {
    std::sort(nums.begin(), nums.end());
    int sum = 0;
    for (int i = 0; i < nums.size(); i += 2) {
        sum += nums[i];
    }
    return sum;
}

-----
#include <vector>
#include <algorithm>

int arrayPairSum(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 562

int longestLine(vector<vector<int>>& mat) {
    int rows = mat.size();
    int cols = mat[0].size();
    int max_length = 0;
    vector<vector<vector<int>>> dp(rows, vector<vector<int>>(cols, vector<int>(4, 0)));

    for (int r = 0; r < rows; ++r) {
        for (int c = 0; c < cols; ++c) {
            if (mat[r][c] == 1) {
                dp[r][c][0] = r > 0 ? dp[r - 1][c][0] + 1 : 1;
                dp[r][c][1] = c > 0 ? dp[r][c - 1][1] + 1 : 1;
                dp[r][c][2] = (r > 0 && c > 0) ? dp[r - 1][c - 1][2] + 1 : 1;
                dp[r][c][3] = (r > 0 && c < cols - 1) ? dp[r - 1][c + 1][3] + 1 : 1;
                max_length = max(max_length, max(dp[r][c][0], max(dp[r][c][1], max(dp[r][c][2], dp[r][c][3]))));
            }
        }
    }
    return max_length;
}


-----
int longestLine(vector<vector<int>>& mat) 
    // Your code here
}


************************************
Question ID: 563

int findTiltUtil(TreeNode* root, int& tiltSum) {
    if (!root) return 0;

    int leftSum = findTiltUtil(root->left, tiltSum);
    int rightSum = findTiltUtil(root->right, tiltSum);

    tiltSum += abs(leftSum - rightSum);
    return root->val + leftSum + rightSum;
}

int findTilt(TreeNode* root) {
    int tiltSum = 0;
    findTiltUtil(root, tiltSum);
    return tiltSum;
}


-----
int findTiltUtil(TreeNode* root, int& tiltSum) 
    // Your code here
}


************************************
Question ID: 564

#include <string>
#include <cmath>
#include <limits>

bool isPalindrome(std::string str) {
    int left = 0;
    int right = str.length() - 1;
    while (left < right) {
        if (str[left] != str[right]) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}

int closestPalindrome(std::string n) {
    int num = std::stoi(n);
    int left = num - 1;
    int right = num + 1;

    while (true) {
        if (isPalindrome(std::to_string(left))) {
            return left;
        } 
        if (isPalindrome(std::to_string(right))) {
            return right;
        }
        left--;
        right++;
    }
}

-----
#include <string>
#include <cmath>
#include <limits>

bool isPalindrome(std::string str) 
    // Your code here
}

************************************
Question ID: 565

int arrayNesting(vector<int>& nums) {
    int n = nums.size();
    int max_len = 0;
    for (int i = 0; i < n; ++i) {
        if (nums[i] != -1) {       
            int start = nums[i];
            int count = 0;
            while (nums[start] != -1) {
                int temp = start;
                start = nums[start];
                count++;
                nums[temp]=-1;
            }
            max_len = max(max_len, count);
        }
    }
    return max_len;
}

-----
int arrayNesting(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 566

#include <vector>
using namespace std;

vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {
    int m = mat.size();
    int n = mat[0].size();
    if (m * n != r * c) {
        return mat;
    }

    vector<vector<int>> reshaped(r, vector<int>(c));
    for (int i = 0; i < m * n; ++i) {
        reshaped[i / c][i % c] = mat[i / n][i % n];
    }
    
    return reshaped;
}

-----
#include <vector>
using namespace std;

vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) 
    // Your code here
}

************************************
Question ID: 567

#include <vector>
bool checkInclusion(std::string s1, std::string s2) {
    std::vector<int> s1_map(26, 0);
    std::vector<int> s2_map(26, 0);
    if (s1.length() > s2.length()) return false;

    for (int i = 0; i < s1.length(); ++i) {
        ++s1_map[s1[i] - 'a'];
        ++s2_map[s2[i] - 'a'];
    }

    for (int i = 0; i < s2.length() - s1.length(); ++i) {
        if (s1_map == s2_map) return true;
        --s2_map[s2[i] - 'a'];
        ++s2_map[s2[i + s1.length()] - 'a'];
    }

    return s1_map == s2_map;
}


-----
#include <vector>
bool checkInclusion(std::string s1, std::string s2) 
    // Your code here
}


************************************
Question ID: 568

int dfs(const vector<vector<int>>& flights, const vector<vector<int>>& days, int currentWeek, int currentCity, vector<vector<int>>& memo) {
    if (currentWeek == days[currentCity].size()) {
        return 0;
    }
    if (memo[currentCity][currentWeek] != -1) {
        return memo[currentCity][currentWeek];
    }

    int maxVacation = days[currentCity][currentWeek] + dfs(flights, days, currentWeek + 1, currentCity, memo);

    for (int i = 0; i < flights.size(); i++) {
        if (flights[currentCity][i] == 1) {
            maxVacation = max(maxVacation, days[i][currentWeek] + dfs(flights, days, currentWeek + 1, i, memo));
        }
    }

    memo[currentCity][currentWeek] = maxVacation;
    return maxVacation;
}

int maxVacationDays(vector<vector<int>>& flights, vector<vector<int>>& days) {
    vector<vector<int>> memo(flights.size(), vector<int>(days[0].size(), -1));
    return dfs(flights, days, 0, 0, memo);
}


-----
int dfs(const vector<vector<int>>& flights, const vector<vector<int>>& days, int currentWeek, int currentCity, vector<vector<int>>& memo) 
    // Your code here
}


************************************
Question ID: 572


```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
};

bool isSubtree(TreeNode* root, TreeNode* subRoot) {
    if (root == nullptr) return false;
    if (isIdentical(root, subRoot)) return true;
    return isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);
}

bool isIdentical(TreeNode* n1, TreeNode* n2) {
    if (n1 == nullptr || n2 == nullptr) return n1 == n2;
    if (n1->val != n2->val) return false;
    return isIdentical(n1->left, n2->left) && isIdentical(n1->right, n2->right);
}
```


-----

```cpp
struct TreeNode 
    // Your code here
}
```


************************************
Question ID: 573

#include <vector>
using namespace std;

int minDistance(int height, int width, vector<int>& tree, vector<int>& squirrel, vector<vector<int>>& nuts) {
    int totalDist = 0;
    int minDiff = INT_MAX;
    
    for (vector<int>& nut : nuts) {
        int treeDist = abs(tree[0] - nut[0]) + abs(tree[1] - nut[1]);
        int squirrelDist = abs(squirrel[0] - nut[0]) + abs(squirrel[1] - nut[1]);
        
        totalDist += 2 * treeDist;
        minDiff = min(minDiff, squirrelDist - treeDist);
    }
    
    return totalDist + minDiff;
}


-----
#include <vector>
using namespace std;

int minDistance(int height, int width, vector<int>& tree, vector<int>& squirrel, vector<vector<int>>& nuts) 
    // Your code here
}


************************************
Question ID: 575

#include <vector>
#include <unordered_set>
using namespace std;

int maxNumberOfCandies(vector<int>& candyType) {
    unordered_set<int> uniqueCandies(candyType.begin(), candyType.end());
    return min(uniqueCandies.size(), candyType.size() / 2);
}


-----
#include <vector>
#include <unordered_set>
using namespace std;

int maxNumberOfCandies(vector<int>& candyType) 
    // Your code here
}


************************************
Question ID: 576

int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
    int MOD = 1e9 + 7;
    vector<vector<vector<int>>> dp(maxMove + 1, vector<vector<int>>(m, vector<int>(n, 0)));
    int moves[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

    for (int k = 1; k <= maxMove; k++) {
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (auto move : moves) {
                    int ni = i + move[0], nj = j + move[1];
                    if (ni < 0 || ni >= m || nj < 0 || nj >= n) {
                        dp[k][i][j] = (dp[k][i][j] + 1) % MOD;
                    } else {
                        dp[k][i][j] = (dp[k][i][j] + dp[k - 1][ni][nj]) % MOD;
                    }
                }
            }
        }
    }
    return dp[maxMove][startRow][startColumn];
}

-----
int findPaths(int m, int n, int maxMove, int startRow, int startColumn) 
    // Your code here
}

************************************
Question ID: 581

#include <vector>
#include <algorithm>
using namespace std;

int findUnsortedSubarray(vector<int>& nums) {
    vector<int> sorted_nums(nums);
    sort(sorted_nums.begin(), sorted_nums.end());
    int start = 0, end = nums.size() - 1;
    while (start < nums.size() && nums[start] == sorted_nums[start]) start++;
    while (end > start && nums[end] == sorted_nums[end]) end--;
    return end - start + 1;
}

-----
#include <vector>
#include <algorithm>
using namespace std;

int findUnsortedSubarray(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 582

#include <vector>
#include <unordered_map>
using namespace std;

vector<int> killProcess(vector<int>& pid, vector<int>& ppid, int kill) {
    unordered_map<int, vector<int>> children;
    for (int i = 0; i < pid.size(); i++) {
        children[ppid[i]].push_back(pid[i]);
    }

    vector<int> killed;
    function<void(int)> dfs = [&](int id) {
        killed.push_back(id);
        for (int child : children[id]) {
            dfs(child);
        }
    };
    dfs(kill);

    return killed;
}

-----
#include <vector>
#include <unordered_map>
using namespace std;

vector<int> killProcess(vector<int>& pid, vector<int>& ppid, int kill) 
    // Your code here
}

************************************
Question ID: 583

int minDistance(std::string word1, std::string word2) {
    int m = word1.length(), n = word2.length();
    std::vector<std::vector<int>> dp(m+1, std::vector<int>(n+1, 0));
    
    for(int i = 0; i <= m; i++) {
        for(int j = 0; j <= n; j++) {
            if(i == 0 || j == 0)
                dp[i][j] = i + j;
            else if(word1[i-1] == word2[j-1])
                dp[i][j] = dp[i-1][j-1];
            else
                dp[i][j] = 1 + std::min(dp[i-1][j], dp[i][j-1]);
        }
    }
    
    return dp[m][n];
}

-----
int minDistance(std::string word1, std::string word2) 
    // Your code here
}

************************************
Question ID: 587

#include <vector>
#include <algorithm>

using namespace std;

bool compare(const vector<int>& p, const vector<int>& q) {
    return p[0] < q[0] || (p[0] == q[0] && p[1] < q[1]);
}

int cross_product(const vector<int>& p, const vector<int>& q, const vector<int>& r) {
    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);
}

vector<vector<int>> fence(vector<vector<int>>& trees) {
    sort(trees.begin(), trees.end(), compare);
    vector<vector<int>> hull;
    for (const auto& p : trees) {
        while (hull.size() >= 2 && cross_product(hull[hull.size() - 2], hull[hull.size() - 1], p) > 0) {
            hull.pop_back();
        }
        hull.push_back(p);
    }
    for (int i = trees.size() - 1; i >= 0; --i) {
        const auto& p = trees[i];
        while (hull.size() >= 2 && cross_product(hull[hull.size() - 2], hull[hull.size() - 1], p) > 0) {
            hull.pop_back();
        }
        hull.push_back(p);
    }
    return hull;
}

-----
#include <vector>
#include <algorithm>

using namespace std;

bool compare(const vector<int>& p, const vector<int>& q) 
    // Your code here
}

************************************
Question ID: 591

bool is_valid(const std::string& code, size_t &i) {
    if (i >= code.size()) return false;
    if (code[i] != '<') return false;
    int name_len = 0;
    for (++i; i < code.size() && name_len < 9 && isupper(code[i]); ++i) ++name_len;
    if (name_len < 1 || name_len > 9 || code[i++] != '>') return false;

    while (i < code.size() && code[i] != '<') ++i;
    if (i >= code.size()) return false;

    if (code.substr(i, name_len + 3) != "</" + code.substr(i - name_len - 1, name_len) + ">") 
        return false;
    i += name_len + 3;
    return true;
}

bool validateCodeSnippet(const std::string &code) {
    size_t i = 0;
    return is_valid(code, i) && i == code.size();
}

-----
bool is_valid(const std::string& code, size_t &i) 
    // Your code here
}

************************************
Question ID: 592

#include <algorithm>
#include <string>
#include <sstream>
using namespace std;

int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}

string fractionAddition(string expression) {
    stringstream ss(expression);
    int num, den, A = 0, B = 1;
    char ch;

    while (ss >> num >> ch >> den) {
        A = A * den + B * num;
        B *= den;
        int GCD = gcd(abs(A), abs(B));
        A /= GCD;
        B /= GCD;
    }

    return to_string(A) + "/" + to_string(B);
}

-----
#include <algorithm>
#include <string>
#include <sstream>
using namespace std;

int gcd(int a, int b) 
    // Your code here
}

************************************
Question ID: 593

bool validSquare(vector<int>& p1, vector<int>& p2, vector<int>& p3, vector<int>& p4) {
    set<int> dist;
    vector<vector<int>> points{p1, p2, p3, p4};
    
    for (int i = 0; i < 4; i++) {
        for (int j = i + 1; j < 4; j++) {
            dist.insert(pow(points[i][0] - points[j][0], 2) + pow(points[i][1] - points[j][1], 2));
        }
    }
    
    return dist.size() == 2 && *dist.begin() != 0;
}

-----
bool validSquare(vector<int>& p1, vector<int>& p2, vector<int>& p3, vector<int>& p4) 
    // Your code here
}

************************************
Question ID: 594

#include <vector>
#include <unordered_map>
using namespace std;

int findLHS(vector<int>& nums) {
    unordered_map<int, int> count;
    for (int num : nums)
        count[num]++;
    
    int longest_sequence = 0;
    for (auto &elem : count) {
        if (count.find(elem.first + 1) != count.end())
            longest_sequence = max(longest_sequence, elem.second + count[elem.first + 1]);
    }
    
    return longest_sequence;
}

-----
#include <vector>
#include <unordered_map>
using namespace std;

int findLHS(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 598

#include <vector>
using namespace std;

int maxCount(int m, int n, vector<vector<int>>& ops) {
    for (vector<int>& op : ops) {
        m = min(m, op[0]);
        n = min(n, op[1]);
    }
    return m * n;
}

-----
#include <vector>
using namespace std;

int maxCount(int m, int n, vector<vector<int>>& ops) 
    // Your code here
}

************************************
Question ID: 599

#include <vector>
#include <unordered_map>
#include <string>

std::vector<std::string> findRestaurant(std::vector<std::string>& list1, std::vector<std::string>& list2) {
    std::unordered_map<std::string, int> restaurantMap;
    for (int i = 0; i < list1.size(); i++) {
        restaurantMap[list1[i]] = i;
    }

    int minSum = INT_MAX;
    std::vector<std::string> result;
    for (int j = 0; j < list2.size(); j++) {
        if (restaurantMap.count(list2[j])) {
            int sum = j + restaurantMap[list2[j]];
            if (sum < minSum) {
                result.clear();
                result.push_back(list2[j]);
                minSum = sum;
            } else if (sum == minSum) {
                result.push_back(list2[j]);
            }
        }
    }
    return result;
}


-----
#include <vector>
#include <unordered_map>
#include <string>

std::vector<std::string> findRestaurant(std::vector<std::string>& list1, std::vector<std::string>& list2) 
    // Your code here
}


************************************
Question ID: 600

int findIntegers(int n) {
    int dp[32][2] = {0};
    dp[0][0] = dp[0][1] = 1;

    for (int i = 1; i < 32; i++) {
        dp[i][0] = dp[i - 1][0] + dp[i - 1][1];
        dp[i][1] = dp[i - 1][0];
    }

    int ans = 0, prev_bit = 0;
    for (int i = 30; i >= 0; i--) {
        if (n & (1 << i)) {
            ans += dp[i][0];
            if (prev_bit) break;
            prev_bit = 1;
        } else {
            prev_bit = 0;
        }
    }

    return ans + 1;
}

-----
int findIntegers(int n) 
    // Your code here
}

************************************
Question ID: 605

bool canPlaceFlowers(vector<int>& flowerbed, int n) {
    int count = 0;
    for(int i = 0; i < flowerbed.size(); i++) {
        if(flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) && (i == flowerbed.size() - 1 || flowerbed[i + 1] == 0)) {
            flowerbed[i] = 1;
            count++;
        }
        if(count >= n) return true;
    }
    return count >= n;
}


-----
bool canPlaceFlowers(vector<int>& flowerbed, int n) 
    // Your code here
}


************************************
Question ID: 609

#include <vector>
#include <string>
#include <unordered_map>
#include <sstream>

std::vector<std::vector<std::string>> findDuplicate(std::vector<std::string>& paths) {
    std::unordered_map<std::string, std::vector<std::string>> content_map;
    for (const std::string &path : paths) {
        std::istringstream iss(path);
        std::string directory;
        iss >> directory;
        std::string file;
        while (iss >> file) {
            size_t start = file.find('(');
            size_t end = file.find(')');
            std::string content = file.substr(start + 1, end - start - 1);
            std::string file_path = directory + "/" + file.substr(0, start);
            content_map[content].push_back(file_path);
        }
    }
    std::vector<std::vector<std::string>> result;
    for (const auto &entry : content_map) {
        if (entry.second.size() > 1) {
            result.push_back(entry.second);
        }
    }
    return result;
}

-----
#include <vector>
#include <string>
#include <unordered_map>
#include <sstream>

std::vector<std::vector<std::string>> findDuplicate(std::vector<std::string>& paths) 
    // Your code here
}

************************************
Question ID: 611

int triangleNumber(vector<int>& nums) {
    sort(nums.begin(), nums.end());
    int count = 0;
    for (int i = 0; i < nums.size(); ++i) {
        for (int j = i + 1; j < nums.size(); ++j) {
            for (int k = j + 1; k < nums.size(); ++k) {
                if (nums[i] + nums[j] > nums[k]) {
                    ++count;
                }
                else {
                    break;
                }
            }
        }
    }
    return count;
}

-----
int triangleNumber(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 616

#include <string>
#include <vector>

std::string addBoldTag(std::string s, std::vector<std::string>& words) {
    int n = s.size();
    std::vector<bool> marked(n, false);
    for (const auto& word : words) {
        int pos = s.find(word, 0);
        while (pos != std::string::npos) {
            std::fill(marked.begin() + pos, marked.begin() + pos + word.size(), true);
            pos = s.find(word, pos + 1);
        }
    }
    std::string result;
    for (int i = 0; i < n; ++i) {
        if (marked[i] && (i == 0 || !marked[i - 1])) {
            result += "<b>";
        }
        result += s[i];
        if (marked[i] && (i == n - 1 || !marked[i + 1])) {
            result += "</b>";
        }
    }
    return result;
}

-----
#include <string>
#include <vector>

std::string addBoldTag(std::string s, std::vector<std::string>& words) 
    // Your code here
}

************************************
Question ID: 621

#include <vector>
#include <algorithm>
#include <unordered_map>

int leastInterval(std::vector<char>& tasks, int n) {
    std::unordered_map<char, int> task_freq;
    for (char task : tasks) {
        task_freq[task]++;
    }

    std::vector<int> frequencies;
    for (auto entry : task_freq) {
        frequencies.push_back(entry.second);
    }

    std::sort(frequencies.rbegin(), frequencies.rend());

    int max_f = frequencies[0] - 1;
    int idle_slots = max_f * n;

    for (int i = 1; i < frequencies.size(); i++) {
        idle_slots -= std::min(frequencies[i], max_f);
    }

    return idle_slots > 0 ? idle_slots + tasks.size() : tasks.size();
}


-----
#include <vector>
#include <algorithm>
#include <unordered_map>

int leastInterval(std::vector<char>& tasks, int n) 
    // Your code here
}


************************************
Question ID: 623

void addOneRowHelper(TreeNode* node, int val, int depth, int currentDepth) {
    if (node == nullptr) return;
    if (currentDepth == depth - 1) {
        TreeNode* left = node->left;
        TreeNode* right = node->right;
        node->left = new TreeNode(val);
        node->left->left = left;
        node->right = new TreeNode(val);
        node->right->right = right;
    } else {
        addOneRowHelper(node->left, val, depth, currentDepth + 1);
        addOneRowHelper(node->right, val, depth, currentDepth + 1);
    }
}

TreeNode* addOneRow(TreeNode* root, int val, int depth) {
    if (depth == 1) {
        TreeNode* newRoot = new TreeNode(val);
        newRoot->left = root;
        return newRoot;
    }
    addOneRowHelper(root, val, depth, 1);
    return root;
}

-----
void addOneRowHelper(TreeNode* node, int val, int depth, int currentDepth) 
    // Your code here
}

************************************
Question ID: 624

int maxDistance(vector<vector<int>>& arrays) {
    int max_dist = 0, min_val = arrays[0][0], max_val = arrays[0].back();
    for(int i = 1; i < arrays.size(); i++) {
        max_dist = max(max_dist, max(abs(arrays[i].back() - min_val), abs(max_val - arrays[i][0])));
        min_val = min(min_val, arrays[i][0]);
        max_val = max(max_val, arrays[i].back());
    }
    return max_dist;
}

-----
int maxDistance(vector<vector<int>>& arrays) 
    // Your code here
}

************************************
Question ID: 625

int smallestFactorization(int num) {
    if (num == 1) return 1;
    long result = 0, factor = 1;
    for (int i = 9; i > 1; --i) {
        while (num % i == 0) {
            num /= i;
            result += i * factor;
            factor *= 10;
            if (result > INT_MAX) return 0;
        }
    }
    return num == 1 ? result : 0;
}

-----
int smallestFactorization(int num) 
    // Your code here
}

************************************
Question ID: 628

int maximumProduct(vector<int>& nums) {
    sort(nums.begin(), nums.end());
    int n = nums.size();
    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3]);
}

-----
int maximumProduct(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 629

int kInversePairs(int n, int k) {
    int mod = 1e9 + 7;
    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));
    for (int i = 1; i <= n; ++i) {
        dp[i][0] = 1;
        for (int j = 1; j <= k; ++j) {
            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod;
            if (j - i >= 0) {
                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;
            }
        }
    }
    return dp[n][k];
}

-----
int kInversePairs(int n, int k) 
    // Your code here
}

************************************
Question ID: 630

#include <algorithm>
#include <queue>
#include <vector>

int scheduleCourse(std::vector<std::vector<int>>& courses) {
    std::sort(courses.begin(), courses.end(), [](const std::vector<int>& a, const std::vector<int>& b) {
        return a[1] < b[1];
    });

    std::priority_queue<int> pq;
    int time = 0;

    for (const auto& course : courses) {
        time += course[0];
        pq.push(course[0]);

        if (time > course[1]) {
            time -= pq.top();
            pq.pop();
        }
    }

    return pq.size();
}

-----
#include <algorithm>
#include <queue>
#include <vector>

int scheduleCourse(std::vector<std::vector<int>>& courses) 
    // Your code here
}

************************************
Question ID: 632

#include <vector>
#include <queue>
#include <limits>
#include <utility>

std::pair<int, int> smallestRange(std::vector<std::vector<int>>& nums) {
    auto listComparator = [](const auto& a, const auto& b) {
        return a.first > b.first;
    };

    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, decltype(listComparator)> minHeap(listComparator);

    int maxVal = std::numeric_limits<int>::min();
    for (int i = 0; i < nums.size(); i++) {
        minHeap.push({nums[i][0], i});
        maxVal = std::max(maxVal, nums[i][0]);
    }

    std::vector<int> listIndices(nums.size(), 0);
    int minRange = std::numeric_limits<int>::max();
    int start = -1, end = -1;

    while (minHeap.size() == nums.size()) {
        auto entry = minHeap.top();
        minHeap.pop();
        int val = entry.first;
        int listIdx = entry.second;
        int range = maxVal - val;

        if (range < minRange) {
            minRange = range;
            start = val;
            end = maxVal;
        }

        listIndices[listIdx]++;
        if (listIndices[listIdx] < nums[listIdx].size()) {
            int newVal = nums[listIdx][listIndices[listIdx]];
            minHeap.push({newVal, listIdx});
            maxVal = std::max(maxVal, newVal);
        }
    }

    return {start, end};
}

-----
#include <vector>
#include <queue>
#include <limits>
#include <utility>

std::pair<int, int> smallestRange(std::vector<std::vector<int>>& nums) 
    // Your code here
}

************************************
Question ID: 633

#include <cmath>

bool judgeSquareSum(int c) {
    for (int a = 0; a <= sqrt(c); ++a) {
        int b = sqrt(c - a * a);
        if (a * a + b * b == c) {
            return true;
        }
    }
    return false;
}

-----
#include <cmath>

bool judgeSquareSum(int c) 
    // Your code here
}

************************************
Question ID: 634

int findDerangement(int n) {
    long MOD = 1e9 + 7;
    vector<long> dp(n + 1, 0);
    dp[2] = 1;
    for (int i = 3; i <= n; ++i) {
        dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD;
    }
    return (int)dp[n];
}

-----
int findDerangement(int n) 
    // Your code here
}

************************************
Question ID: 636

#include <vector>
#include <string>
#include <stack>

std::vector<int> exclusiveTime(int n, std::vector<std::string>& logs) {
    std::vector<int> res(n, 0);
    std::stack<int> s;
    int prev_time = 0;
    
    for (const auto& log : logs) {
        auto colon1 = log.find(':');
        auto colon2 = log.rfind(':');
        
        int id = std::stoi(log.substr(0, colon1));
        std::string type = log.substr(colon1 + 1, colon2 - colon1 - 1);
        int time = std::stoi(log.substr(colon2 + 1));
        
        if (type == "start") {
            if (!s.empty()) {
                res[s.top()] += time - prev_time;
            }
            s.push(id);
            prev_time = time;
        } else {
            res[s.top()] += time - prev_time + 1;
            s.pop();
            prev_time = time + 1;
        }
    }
    
    return res;
}

-----
#include <vector>
#include <string>
#include <stack>

std::vector<int> exclusiveTime(int n, std::vector<std::string>& logs) 
    // Your code here
}

************************************
Question ID: 638

#include <vector>
#include <algorithm>
using namespace std;

int shoppingOffersHelper(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, int index) {
    if (index == special.size()) {
        int sum = 0;
        for (int i = 0; i < needs.size(); ++i) {
            sum += price[i] * needs[i];
        }
        return sum;
    }

    int no_offer = shoppingOffersHelper(price, special, needs, index + 1);
    bool can_apply_offer = true;
    for (int i = 0; i < needs.size(); ++i) {
        needs[i] -= special[index][i];
        if (needs[i] < 0) can_apply_offer = false;
    }

    int with_offer = INT_MAX;
    if (can_apply_offer) {
        int offer_cost = special[index][needs.size()] + shoppingOffersHelper(price, special, needs, index);
        with_offer = min(no_offer, offer_cost);
    }

    for (int i = 0; i < needs.size(); ++i) {
        needs[i] += special[index][i];
    }

    return can_apply_offer ? with_offer : no_offer;
}

int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {
    return shoppingOffersHelper(price, special, needs, 0);
}


-----
#include <vector>
#include <algorithm>
using namespace std;

int shoppingOffersHelper(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, int index) 
    // Your code here
}


************************************
Question ID: 639

int numDecodings(const std::string& s) {
    const int MOD = 1e9 + 7;
    int n = s.size();
    std::vector<long long> dp(n + 1, 0);
    dp[0] = 1;
    dp[1] = s[0] == '*' ? 9 : (s[0] == '0' ? 0 : 1);

    for (int i = 2; i <= n; ++i) {
        if (s[i - 1] == '*') {
            dp[i] = 9 * dp[i - 1];
            if (s[i - 2] == '1') dp[i] += 9 * dp[i - 2];
            else if (s[i - 2] == '2') dp[i] += 6 * dp[i - 2];
            else if (s[i - 2] == '*') dp[i] += 15 * dp[i - 2];
        } else {
            dp[i] = (s[i - 1] != '0') ? dp[i - 1] : 0;
            int num = std::stoi(s.substr(i - 2, 2));
            if (s[i - 2] == '1' || (s[i - 2] == '2' && num <= 26)) dp[i] += dp[i - 2];
            else if (s[i - 2] == '*') dp[i] += (num <= 26 && num >= 10) ? 2 * dp[i - 2] : dp[i - 2];
        }
        dp[i] %= MOD;
    }
    return dp[n];
}

-----
int numDecodings(const std::string& s) 
    // Your code here
}

************************************
Question ID: 640

#include <string>
#include <sstream>
using namespace std;

string solveEquation(string equation) {
    int coef = 0, val = 0, left = 1, operate = 1;
    istringstream in(equation + "+");
    char op;
    int n;
    string s;
    while (in >> op) {
        if (op == '=') {
            left = -1;
            operate = 1;
        } else {
            in >> n >> s;
            (s.size() == 0 ? val : coef) += (op == '+' ? 1 : -1) * left * operate * n;
            operate = s.size();
        }
    }

    if (coef == 0) {
        return val == 0 ? "Infinite solutions" : "No solution";
    } else {
        return "x=" + to_string(-val / coef);
    }
}


-----
#include <string>
#include <sstream>
using namespace std;

string solveEquation(string equation) 
    // Your code here
}


************************************
Question ID: 642

#include <vector>
#include <string>
#include <unordered_map>
#include <queue>

class AutocompleteSystem {
    struct TrieNode {
        std::unordered_map<char, TrieNode*> children;
        std::string sentence;
        int times;
        TrieNode() : times(0) {}
    };

    void insert(const std::string &sentence, int times) {
        TrieNode *curr = root;
        for (char c : sentence) {
            if (!curr->children[c]) {
                curr->children[c] = new TrieNode();
            }
            curr = curr->children[c];
        }
        curr->times += times;
        curr->sentence = sentence;
    }

    struct cmp {
        bool operator()(const TrieNode* a, const TrieNode* b) const {
            if (a->times == b->times) {
                return a->sentence > b->sentence;
            }
            return a->times < b->times;
        }
    };

    TrieNode *root;
    TrieNode *current;
    std::string search;

public:
    AutocompleteSystem(std::vector<std::string>& sentences, std::vector<int>& times) {
        root = new TrieNode();
        for (int i = 0; i < sentences.size(); ++i) {
            insert(sentences[i], times[i]);
        }
        current = root;
    }
    
    std::vector<std::string> input(char c) {
        if (c == '#') {
            insert(search, 1);
            search = "";
            current = root;
            return {};
        }
        search += c;
        if (!current) {
            return {};
        }
        current = current->children[c];
        if (!current) {
            return {};
        }
        std::priority_queue<TrieNode*, std::vector<TrieNode*>, cmp> pq;
        for (auto &[char_, node] : current->children) {
            if (node->times) {
                pq.push(node);
            }
        }
        
        std::vector<std::string> res;
        while (!pq.empty() && res.size() < 3) {
            res.push_back(pq.top()->sentence);
            pq.pop();
        }
        return res;
    }
};


-----
#include <vector>
#include <string>
#include <unordered_map>
#include <queue>

class AutocompleteSystem 
    // Your code here
};


************************************
Question ID: 643

double findMaxAverage(vector<int>& nums, int k) {
    int n = nums.size();
    double sum = 0;
    for (int i = 0; i < k; ++i) {
        sum += nums[i];
    }
    double max_avg = sum / k;
    for (int i = k; i < n; ++i) {
        sum = sum - nums[i - k] + nums[i];
        max_avg = max(max_avg, sum / k);
    }
    return max_avg;
}

-----
double findMaxAverage(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 644

double findMaxAverage(vector<int>& nums, int k) {
    long sum = 0;
    int n = nums.size();
    for(int i = 0; i < k; i++) {
        sum += nums[i];
    }

    double max_avg = static_cast<double>(sum) / k;
    
    for(int i = k; i < n; i++) {
        sum += nums[i] - nums[i - k];
        max_avg = max(max_avg, static_cast<double>(sum) / k);
    }
    
    return max_avg;
}

-----
double findMaxAverage(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 645

#include <vector>
using namespace std;

vector<int> findErrorNums(vector<int>& nums) {
    vector<int> result;
    for (int i = 0; i < nums.size(); i++) {
        int index = abs(nums[i]) - 1;
        if (nums[index] > 0) {
            nums[index] = -nums[index];
        } else {
            result.push_back(index + 1);
        }
    }
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] > 0) {
            result.push_back(i + 1);
            break;
        }
    }
    return result;
}

-----
#include <vector>
using namespace std;

vector<int> findErrorNums(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 646

#include <vector>
#include <algorithm>

int findLongestChain(std::vector<std::vector<int>>& pairs) {
    std::sort(pairs.begin(), pairs.end(), [](const std::vector<int>& a, const std::vector<int>& b) {
        return a[1] < b[1];
    });

    int max_chain_length = 0, last_right = INT_MIN;
    for (const auto& pair : pairs) {
        if (pair[0] > last_right) {
            last_right = pair[1];
            max_chain_length++;
        }
    }
    
    return max_chain_length;
}


-----
#include <vector>
#include <algorithm>

int findLongestChain(std::vector<std::vector<int>>& pairs) 
    // Your code here
}


************************************
Question ID: 647

int countSubstrings(std::string s) {
    int n = s.size(), count = 0;
    for (int center = 0; center < 2 * n - 1; ++center) {
        int left = center / 2;
        int right = left + center % 2;
        while (left >= 0 && right < n && s[left] == s[right]) {
            ++count;
            --left;
            ++right;
        }
    }
    return count;
}

-----
int countSubstrings(std::string s) 
    // Your code here
}

************************************
Question ID: 648

#include <string>
#include <vector>
#include <unordered_set>

std::string replaceWords(std::vector<std::string>& dict, std::string sentence) {
    std::unordered_set<std::string> roots(dict.begin(), dict.end());
    std::istringstream iss(sentence);
    std::string word, result;

    while (iss >> word) {
        std::string prefix;
        for (int i = 1; i <= word.length(); ++i) {
            prefix = word.substr(0, i);
            if (roots.count(prefix)) {
                break;
            }
        }
        result += prefix + " ";
    }
    result.pop_back();
    return result;
}

-----
#include <string>
#include <vector>
#include <unordered_set>

std::string replaceWords(std::vector<std::string>& dict, std::string sentence) 
    // Your code here
}

************************************
Question ID: 649

#include <string>
#include <queue>

std::string predictPartyVictory(std::string senate) {
    std::queue<int> radiant, dire;
    int n = senate.size();
    
    for (int i = 0; i < n; i++) {
        if (senate[i] == 'R')
            radiant.push(i);
        else
            dire.push(i);
    }

    while (!radiant.empty() && !dire.empty()) {
        int r = radiant.front();
        int d = dire.front();
        radiant.pop();
        dire.pop();

        if (r < d)
            radiant.push(r + n);
        else
            dire.push(d + n);
    }

    return radiant.empty() ? "Dire" : "Radiant";
}


-----
#include <string>
#include <queue>

std::string predictPartyVictory(std::string senate) 
    // Your code here
}


************************************
Question ID: 650

int minSteps(int n) {
    int result = 0;
    for (int i = 2; i <= n; ++i) {
        while (n % i == 0) {
            result += i;
            n /= i;
        }
    }
    return result;
}

-----
int minSteps(int n) 
    // Your code here
}

************************************
Question ID: 651

int maxA(int n) {
    vector<int> dp(n + 1);
    for(int i = 1; i <= n; ++i) {
        dp[i] = i;
        for(int j = 1; j <= i - 3; ++j)
            dp[i] = max(dp[i], dp[j] * (i - j - 1));
    }
    return dp[n];
}

-----
int maxA(int n) 
    // Your code here
}

************************************
Question ID: 653

bool findTarget(TreeNode* root, int k) {
    unordered_set<int> nodes;
    return findNode(root, k, nodes);
}

bool findNode(TreeNode* root, int k, unordered_set<int>& nodes) {
    if (!root) return false;
    if (nodes.count(k - root->val)) return true;
    nodes.insert(root->val);
    return findNode(root->left, k, nodes) || findNode(root->right, k, nodes);
}

-----
bool findTarget(TreeNode* root, int k) 
    // Your code here
}

************************************
Question ID: 655

#include <vector>
#include <string>
#include <queue>

using namespace std;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

vector<vector<string>> printTree(TreeNode* root) {
    if (!root) return {{}};
    
    // Calculate Depth
    int depth = 0;
    queue<TreeNode*> q;
    q.push(root);
    while (!q.empty()) {
        int size = q.size();
        depth++;
        for (int i = 0; i < size; i++) {
            TreeNode* node = q.front(); q.pop();
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
    }
    
    // Initialize matrix
    vector<vector<string>> res(depth, vector<string>((1 << depth) - 1, ""));

    // Fill in matrix
    q.push(root);
    int level = 0;
    int step = (1 << (depth - 1));
    while (!q.empty()) {
        int size = q.size();
        int curPos = step - 1;
        for (int i = 0; i < size; i++) {
            TreeNode* node = q.front(); q.pop();
            res[level][curPos] = to_string(node->val);
            curPos += (step << 1);
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        step >>= 1;
        level++;
    }
    
    return res;
}


-----
#include <vector>
#include <string>
#include <queue>

using namespace std;

struct TreeNode 
    // Your code here
}


************************************
Question ID: 656

#include <vector>
#include <queue>
#include <utility>
using namespace std;

vector<int> cheapestJump(vector<int>& coins, int maxJump) {
    int n = coins.size();
    vector<int> dp(n, 1e9), parent(n, -1);
    dp[0] = coins[0];
    for (int i = 0; i < n; ++i) {
        if (coins[i] == -1) continue;
        for (int j = 1; j <= maxJump && i + j < n; ++j) {
            int next = i + j;
            int cost = coins[next] + dp[i];
            if (cost < dp[next]) {
                dp[next] = cost;
                parent[next] = i;
            }
        }
    }
    vector<int> ans;
    if (dp[n - 1] == 1e9) return ans;
    int cur = n - 1;
    while (cur != -1) {
        ans.push_back(cur + 1);
        cur = parent[cur];
    }
    reverse(ans.begin(), ans.end());
    return ans;
}

-----
#include <vector>
#include <queue>
#include <utility>
using namespace std;

vector<int> cheapestJump(vector<int>& coins, int maxJump) 
    // Your code here
}

************************************
Question ID: 657

bool judgeCircle(string moves) {
    int x = 0, y = 0;
    for(char move : moves) {
        if(move == 'U') y++;
        else if(move == 'D') y--;
        else if(move == 'R') x++;
        else if(move == 'L') x--;
    }
    return x == 0 && y == 0;
}

-----
bool judgeCircle(string moves) 
    // Your code here
}

************************************
Question ID: 658

#include <vector>
#include <algorithm>

std::vector<int> findClosestElements(std::vector<int>& arr, int k, int x) {
    int left = 0;
    int right = arr.size() - k;
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (x - arr[mid] > arr[mid + k] - x) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    
    return std::vector<int>(arr.begin() + left, arr.begin() + left + k);
}

-----
#include <vector>
#include <algorithm>

std::vector<int> findClosestElements(std::vector<int>& arr, int k, int x) 
    // Your code here
}

************************************
Question ID: 659

#include <vector>
using namespace std;

bool canSplit(vector<int>& nums) {
    vector<int> freq(20001, 0), needed(20001, 0);
    for (int n : nums)
        freq[n]++;
    for (int n : nums) {
        if (!freq[n]) continue;
        if (!needed[n - 1]) {
            if (freq[n + 1] && freq[n + 2]) {
                freq[n]--; freq[n + 1]--; freq[n + 2]--;
                needed[n + 2]++;
            } else return false;
        } else {
            freq[n]--; needed[n - 1]--;
            needed[n]++;
        }
    }
    return true;
}

-----
#include <vector>
using namespace std;

bool canSplit(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 660

int newInteger(int n) {
    int result = 0, base = 1;
    while (n) {
        result += n % 9 * base;
        n /= 9;
        base *= 10;
    }
    return result;
}

-----
int newInteger(int n) 
    // Your code here
}

************************************
Question ID: 661

#include <vector>
using namespace std;

vector<vector<int>> imageSmoother(vector<vector<int>>& img) {
    int m = img.size(), n = img[0].size();
    vector<vector<int>> result(m, vector<int>(n, 0));

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            int count = 0, sum = 0;
            for (int x = i - 1; x <= i + 1; x++) {
                for (int y = j - 1; y <= j + 1; y++) {
                    if (x >= 0 && x < m && y >= 0 && y < n) {
                        sum += img[x][y];
                        count++;
                    }
                }
            }
            result[i][j] = sum / count;
        }
    }

    return result;
}

-----
#include <vector>
using namespace std;

vector<vector<int>> imageSmoother(vector<vector<int>>& img) 
    // Your code here
}

************************************
Question ID: 662

#include <queue>
#include <utility>

int widthOfBinaryTree(TreeNode* root) {
    if (!root) return 0;
    int maxWidth = 0;
    std::queue<std::pair<TreeNode*, int>> q;
    q.push(std::make_pair(root, 1));

    while (!q.empty()) {
        int levelSize = q.size();
        int left = q.front().second;
        int right = left;
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front().first;
            right = q.front().second;
            q.pop();

            if (node->left) {
                q.push(std::make_pair(node->left, 2 * right));
            }
            if (node->right) {
                q.push(std::make_pair(node->right, 2 * right + 1));
            }
        }
        maxWidth = std::max(maxWidth, right - left + 1);
    }
    return maxWidth;
}

-----
#include <queue>
#include <utility>

int widthOfBinaryTree(TreeNode* root) 
    // Your code here
}

************************************
Question ID: 664

int strangePrinter(string s) {
    int n = s.size();
    if(n == 0) return 0;
    vector<vector<int>> dp(n, vector<int>(n, 0));
    for(int i = 0; i < n; i++) dp[i][i] = 1;
    for(int len = 1; len < n; len++) {
        for(int i = 0; i < n - len; i++) {
            int j = i + len;
            dp[i][j] = dp[i+1][j] + 1;
            for(int k = i + 1; k <= j; k++) {
                if(s[i] == s[k]) {
                    dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k][j]);
                }
            }
        }
    }
    return dp[0][n-1];
}

-----
int strangePrinter(string s) 
    // Your code here
}

************************************
Question ID: 665

bool checkPossibility(vector<int>& nums) {
    int cnt = 0;
    for (int i = 1; i < nums.size(); i++) {
        if (nums[i] < nums[i - 1]) {
            cnt++;
            if (i == 1 || nums[i] >= nums[i - 2]) {
                nums[i-1] = nums[i];
            } else {
                nums[i] = nums[i - 1];
            }
            if (cnt > 1) return false;
        }
    }
    return true;
}

-----
bool checkPossibility(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 666

int sum(TreeNode* root, int val) {
    if (!root) return 0;
    val = val * 10 + root->val;
    if (!root->left && !root->right) return val;
    return sum(root->left, val) + sum(root->right, val);
}

int pathSum(vector<int>& nums) {
    TreeNode* root = new TreeNode(nums[0] % 10);
    for (int num : nums) {
        int depth = num / 100, pos = num % 100 / 10, val = num % 10;
        TreeNode* cur = root;
        for (int d = depth - 2; d >= 0; --d) {
            if ((pos >> d) & 1) {
                if (!cur->right) cur->right = new TreeNode(val);
                cur = cur->right;
            } else {
                if (!cur->left) cur->left = new TreeNode(val);
                cur = cur->left;
            }
        }
    }
    return sum(root, 0);
}

-----
int sum(TreeNode* root, int val) 
    // Your code here
}

************************************
Question ID: 667

#include <vector>
using namespace std;

vector<int> constructArray(int n, int k) {
    vector<int> answer(n);
    for (int i = 0; i < n; ++i) {
        if (i % 2 == 0) {
            answer[i] = i / 2 + 1;
        } else {
            answer[i] = n - (i - 1) / 2;
            --k;
        }
    }
    if (k > 0) {
        for (int i = n - 2; i >= 0 && k > 0; --i) {
            answer[i] = answer[i + 1] - answer[i];
            --k;
        }
    }
    return answer;
}

-----
#include <vector>
using namespace std;

vector<int> constructArray(int n, int k) 
    // Your code here
}

************************************
Question ID: 668

int findKthNumber(int m, int n, int k) {
    int low = 1, high = m * n;
    while (low < high) {
        int mid = low + (high - low) / 2;
        int count = 0;
        for (int i = 1; i <= m; i++) {
            count += std::min(mid / i, n);
        }
        if (count < k) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    return low;
}

-----
int findKthNumber(int m, int n, int k) 
    // Your code here
}

************************************
Question ID: 670

int maximumSwap(int num) {
    string num_str = to_string(num);
    vector<int> last(10, 0);
    
    for (int i = 0; i < num_str.size(); i++) {
        last[num_str[i] - '0'] = i;
    }
    
    for (int i = 0; i < num_str.size(); i++) {
        for (int d = 9; d > num_str[i] - '0'; d--) {
            if (last[d] > i) {
                swap(num_str[i], num_str[last[d]]);
                return stoi(num_str);
            }
        }
    }
    
    return num;
}

-----
int maximumSwap(int num) 
    // Your code here
}

************************************
Question ID: 672

#include <vector>

int numLightConfiguration(int n, int presses) {
    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(presses + 1, 0));
    dp[0][0] = 1;

    for (int i = 0; i <= n; ++i) {
        for (int j = 1; j <= presses; ++j) {
            dp[i][j] = dp[i][j - 1] * (i + 1) + (i > 0 ? dp[i - 1][j - 1] : 0);
        }
    }

    return dp[n][presses];
}

-----
#include <vector>

int numLightConfiguration(int n, int presses) 
    // Your code here
}

************************************
Question ID: 673

#include <vector>

int findNumberOfLIS(std::vector<int>& nums) {
    int n = nums.size(), maxLength = 0, ans = 0;
    std::vector<int> length(n, 0), count(n, 0);

    for (int i = 0; i < n; ++i) {
        length[i] = count[i] = 1;
        for (int j = 0; j < i; ++j) {
            if (nums[i] > nums[j]) {
                if (length[i] == length[j] + 1) {
                    count[i] += count[j];
                } else if (length[i] < length[j] + 1) {
                    length[i] = length[j] + 1;
                    count[i] = count[j];
                }
            }
        }
        if (maxLength == length[i]) {
            ans += count[i];
        } else if (maxLength < length[i]) {
            maxLength = length[i];
            ans = count[i];
        }
    }

    return ans;
}


-----
#include <vector>

int findNumberOfLIS(std::vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 674

int findLengthOfLCIS(vector<int>& nums) {
    if (nums.empty()) return 0;
    int result = 1, current = 1;
    for (int i = 1; i < nums.size(); ++i) {
        current = nums[i] > nums[i - 1] ? current + 1 : 1;
        result = max(result, current);
    }
    return result;
}

-----
int findLengthOfLCIS(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 675

#include <vector>
#include <queue>

int cutOffTree(std::vector<std::vector<int>>& forest) {
    if(forest.empty() || forest[0].empty()) return 0;
    int m = forest.size(), n = forest[0].size();
    std::vector<std::pair<int, int>> trees;
    
    for(int i = 0; i < m; i++)
        for(int j = 0; j < n; j++)
            if(forest[i][j] > 1)
                trees.push_back({i, j});
    
    std::sort(trees.begin(), trees.end(), [&forest](std::pair<int, int>& a, std::pair<int, int>& b) {
        return forest[a.first][a.second] < forest[b.first][b.second];
    });

    int startX = 0, startY = 0;
    int totalSteps = 0;
    for(std::pair<int, int>& tree : trees){
        int x = tree.first, y = tree.second;
        int steps = bfs(forest, startX, startY, x, y);
        if(steps == -1) return -1;
        totalSteps += steps;
        startX = x;
        startY = y;
    }
    
    return totalSteps;
}

int bfs(std::vector<std::vector<int>>& forest, int startX, int startY, int endX, int endY) {
    int m = forest.size(), n = forest[0].size();
    std::vector<std::vector<int>> visited(m, std::vector<int>(n, 0));
    std::queue<std::pair<int, int>> q;
    q.push({startX, startY});
    visited[startX][startY] = 1;
    int steps = 0;
    std::vector<int> dirs{-1, 0, 1, 0, -1};
    
    while(!q.empty()) {
        int size = q.size();
        for(int i = 0; i < size; i++) {
            int x = q.front().first;
            int y = q.front().second;
            q.pop();
            
            if(x == endX && y == endY) return steps;
            
            for(int k = 0; k < 4; k++) {
                int newX = x + dirs[k];
                int newY = y + dirs[k+1];
                if(newX >= 0 && newX < m && newY >= 0 && newY < n && !visited[newX][newY] && forest[newX][newY] != 0) {
                    q.push({newX, newY});
                    visited[newX][newY] = 1;
                }
            }
        }
        steps++;
    }
    
    return -1;
}

-----
#include <vector>
#include <queue>

int cutOffTree(std::vector<std::vector<int>>& forest) 
    // Your code here
}

************************************
Question ID: 678

bool checkValidString(string s) {
    int left_balance = 0, right_balance = 0;

    for (int i = 0; i < s.size(); i++) {
        left_balance += (s[i] == '(' || s[i] == '*') ? 1 : -1;
        right_balance += (s[s.size() - 1 - i] == ')' || s[s.size() - 1 - i] == '*') ? 1 : -1;

        if (left_balance < 0 || right_balance < 0)
            return false;
    }

    return true;
}


-----
bool checkValidString(string s) 
    // Your code here
}


************************************
Question ID: 679

#include <vector>
#include <cmath>

bool helper(std::vector<double>& cards) {
    if (cards.size() == 1) {
        return std::abs(cards[0] - 24) < 1e-6;
    }

    for (int i = 0; i < cards.size(); ++i) {
        for (int j = i + 1; j < cards.size(); ++j) {
            double a = cards[i], b = cards[j];
            std::vector<double> next = {a + b, a - b, a * b, a / b};

            cards.erase(cards.begin() + j);
            cards.erase(cards.begin() + i);

            for (auto& e : next) {
                cards.push_back(e);
                if (helper(cards)) {
                    return true;
                }
                cards.pop_back();
            }

            cards.insert(cards.begin() + i, a);
            cards.insert(cards.begin() + j, b);
        }
    }
    return false;
}

bool canGet24(std::vector<int>& cards) {
    std::vector<double> doubleCards(cards.begin(), cards.end());
    return helper(doubleCards);
}


-----
#include <vector>
#include <cmath>

bool helper(std::vector<double>& cards) 
    // Your code here
}


************************************
Question ID: 680

bool validPalindrome(string s) {
    for (int i = 0, j = s.size() - 1; i < j; i++, j--) {
        if (s[i] != s[j]) {
            int temp1 = i + 1, temp2 = j;
            while (temp1 < temp2 && s[temp1] == s[temp2]) { temp1++; temp2--; }
            if (temp1 >= temp2) return true;

            temp1 = i; temp2 = j - 1;
            while (temp1 < temp2 && s[temp1] == s[temp2]) { temp1++; temp2--; }
            if (temp1 >= temp2) return true;

            return false;
        }
    }
    return true;
}

-----
bool validPalindrome(string s) 
    // Your code here
}

************************************
Question ID: 681

#include <string>
#include <algorithm>
using namespace std;

string nextClosestTime(string time) {
    string digits = time.substr(0, 2) + time.substr(3);
    string next_time = time;
    int elapsed = INT_MAX;

    for (char a : digits) {
    for (char b : digits) {
    for (char c : digits) {
    for (char d : digits) {
        string candidate_time = string({a, b, ':', c, d});
        int cand_elapsed = (stoi(candidate_time.substr(0, 2)) * 60 + stoi(candidate_time.substr(3)) -
                            stoi(time.substr(0, 2)) * 60 - stoi(time.substr(3)) + 1440) % 1440;
        if (0 < cand_elapsed && cand_elapsed < elapsed) {
          elapsed = cand_elapsed;
          next_time = candidate_time;
        }
    }}}}

    return next_time;
}

-----
#include <string>
#include <algorithm>
using namespace std;

string nextClosestTime(string time) 
    // Your code here
}

************************************
Question ID: 682

#include <vector>
#include <string>

int calPoints(std::vector<std::string>& ops) {
    std::vector<int> record;
    for (const std::string& op : ops) {
        if (op == "+") {
            record.push_back(record[record.size() - 1] + record[record.size() - 2]);
        } else if (op == "D") {
            record.push_back(2 * record.back());
        } else if (op == "C") {
            record.pop_back();
        } else {
            record.push_back(stoi(op));
        }
    }
    return std::accumulate(record.begin(), record.end(), 0);
}


-----
#include <vector>
#include <string>

int calPoints(std::vector<std::string>& ops) 
    // Your code here
}


************************************
Question ID: 683

int kEmptySlots(vector<int>& bulbs, int k) {
    vector<int> days(bulbs.size());
    for(int i = 0; i < bulbs.size(); ++i) {
        days[bulbs[i] - 1] = i;
    }
    
    int ans = INT_MAX;
    int left = 0;
    int right = k + 1;
    while (right < days.size()) {
        int i = left + 1;
        for (; i < right; ++i) {
            if (days[i] < days[left] || days[i] < days[right]) {
                left = i;
                break;
            }
        }
        if (i == right) {
            ans = min(ans, max(days[left], days[right]));
            left ++;
            right ++;
        }
    }
    
    return ans == INT_MAX ? -1 : ans + 1;
}


-----
int kEmptySlots(vector<int>& bulbs, int k) 
    // Your code here
}


************************************
Question ID: 684

#include <vector>
using namespace std;

vector<int> findRedundantConnection(vector<vector<int>>& edges) {
    vector<int> parent(edges.size() + 1);
    for (int i = 1; i <= edges.size(); ++i) {
        parent[i] = i;
    }

    for (const auto& edge : edges) {
        int root1 = find(parent, edge[0]);
        int root2 = find(parent, edge[1]);
        if (root1 == root2) {
            return edge;
        }
        parent[root1] = root2;
    }

    return {};
}

int find(vector<int>& parent, int x) {
    if (parent[x] != x) {
        parent[x] = find(parent, parent[x]);
    }
    return parent[x];
}


-----
#include <vector>
using namespace std;

vector<int> findRedundantConnection(vector<vector<int>>& edges) 
    // Your code here
}


************************************
Question ID: 685

#include <vector>
using namespace std;

vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {
    vector<int> parent(edges.size() + 1, 0);
    vector<int> candidateA, candidateB;
    
    for (const auto& edge : edges) {
        int u = edge[0], v = edge[1];
        if (parent[v] > 0) {
            candidateA = {parent[v], v};
            candidateB = edge;
        } else {
            parent[v] = u;
        }
    }
    
    for (int i = 1; i <= edges.size(); ++i) {
        int cycle = i, steps = edges.size();
        while (parent[cycle] != 0 && steps-- > 0) {
            cycle = parent[cycle];
        }
        if (steps == -1) {
            if (candidateA.empty()) return {parent[i], i};
            else return candidateA;
        }
    }
    
    return candidateB;
}


-----
#include <vector>
using namespace std;

vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) 
    // Your code here
}


************************************
Question ID: 686

int minRepeatsToSubstring(const std::string& a, const std::string& b) {
    int times = (b.length() + a.length() - 1) / a.length();
    
    for(int i = 0; i < 2; i++){
        std::string repeated_a = "";
        for(int j = 0; j < times + i; j++){
            repeated_a += a;
        }
        
        if(repeated_a.find(b) != std::string::npos) return times + i;
    }
    
    return -1;
}

-----
int minRepeatsToSubstring(const std::string& a, const std::string& b) 
    // Your code here
}

************************************
Question ID: 687

int findUnivaluePath(TreeNode* node, int& maxLen) {
    if (!node) return 0;
    int left = findUnivaluePath(node->left, maxLen);
    int right = findUnivaluePath(node->right, maxLen);
    left = (node->left && node->left->val == node->val) ? left + 1 : 0;
    right = (node->right && node->right->val == node->val) ? right + 1 : 0;
    maxLen = max(maxLen, left + right);
    return max(left, right);
}

int longestUnivaluePath(TreeNode* root) {
    int maxLen = 0;
    findUnivaluePath(root, maxLen);
    return maxLen;
}


-----
int findUnivaluePath(TreeNode* node, int& maxLen) 
    // Your code here
}


************************************
Question ID: 688

double knightProbability(int n, int k, int row, int column) {
    vector<vector<vector<double>>> memo(n, vector<vector<double>>(n, vector<double>(k + 1, -1.0)));
    return helper(n, k, row, column, memo);
}

double helper(int n, int k, int row, int column, vector<vector<vector<double>>>& memo) {
    if (row < 0 || row >= n || column < 0 || column >= n) return 0.0;
    if (k == 0) return 1.0;
    if (memo[row][column][k] >= 0) return memo[row][column][k];
    
    double result = 0.0;
    int moves[8][2] = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};
    for (int i = 0; i < 8; ++i)
        result += helper(n, k - 1, row + moves[i][0], column + moves[i][1], memo) / 8;
    
    memo[row][column][k] = result;
    return result;
}

-----
double knightProbability(int n, int k, int row, int column) 
    // Your code here
}

************************************
Question ID: 689

#include <vector>

std::vector<int> max_sum_of_three_subarrays(std::vector<int> &nums, int k) {
    int n = nums.size();
    std::vector<int> sums(n - k + 1);
    std::vector<int> left(n), right(n), ans(3);
    int acc_sum = 0;

    for (int i = 0; i < n; ++i) {
        acc_sum += nums[i];
        if (i >= k) {
            acc_sum -= nums[i - k];
        }
        if (i >= k - 1) {
            sums[i - k + 1] = acc_sum;
        }
    }

    left[0] = 0;
    right[n - k] = n - k;

    for (int i = 1; i < n - k + 1; ++i) {
        left[i] = sums[i] > sums[left[i - 1]] ? i : left[i - 1];
    }

    for (int i = n - k - 1; i >= 0; --i) {
        right[i] = sums[i] >= sums[right[i + 1]] ? i : right[i + 1];
    }

    int max_sum = 0;

    for (int i = k; i < n - 2 * k + 1; ++i) {
        int left_idx = left[i - k], right_idx = right[i + k], total_sum = sums[left_idx] + sums[i] + sums[right_idx];
        if (total_sum > max_sum) {
            max_sum = total_sum;
            ans = {left_idx, i, right_idx};
        }
    }

    return ans;
}

-----
#include <vector>

std::vector<int> max_sum_of_three_subarrays(std::vector<int> &nums, int k) 
    // Your code here
}

************************************
Question ID: 691

#include <vector>
#include <string>
#include <unordered_map>
using namespace std;

int minStickers(vector<string>& stickers, string target) {
    unordered_map<string, int> memo;
    vector<int> target_count(26, 0);
    for (char c : target) target_count[c - 'a']++;
    
    for (string& s : stickers) {
        vector<int> sticker_count(26, 0);
        int connection = 0;
        for (char c : s) {
            if (!target_count[c - 'a']) continue;
            connection = 1;
            sticker_count[c - 'a']++;
        }
        if (!connection) continue;
        
        string state = "";
        for (int i = 0; i < 26; ++i)
            state += string(sticker_count[i], 'a' + i);
        memo[state] = 1;
    }
    
    function<int(const string&)> dp = [&](const string& state) {
        if (memo.count(state)) return memo[state];
        vector<int> counts(26, 0);
        for (char c : state) counts[c - 'a']++;
        int ans = INT_MAX;
        for (const auto& kv : memo) {
            bool ok = true;
            for (int i = 0; i < 26 && ok; ++i)
                ok = counts[i] >= kv.first[i] - 'a';
            if (!ok) continue;
            ans = min(ans, dp(state.substr(kv.first.size())) + kv.second);
        }
        memo[state] = ans == INT_MAX ? -1 : ans;
        return memo[state];
    };
    
    string start = "";
    for (int i = 0; i < 26; ++i)
        start += string(target_count[i], 'a' + i);
    return dp(start);
}

-----
#include <vector>
#include <string>
#include <unordered_map>
using namespace std;

int minStickers(vector<string>& stickers, string target) 
    // Your code here
}

************************************
Question ID: 692

#include <vector>
#include <string>
#include <unordered_map>
#include <queue>
using namespace std;

vector<string> kFrequentWords(vector<string>& words, int k) {
    unordered_map<string, int> wordCount;
    for (const auto& word : words) {
        wordCount[word]++;
    }

    auto comp = [](const pair<string, int>& a, const pair<string, int>& b) {
        if (a.second == b.second) {
            return a.first > b.first;
        }
        return a.second < b.second;
    };
    priority_queue<pair<string, int>, vector<pair<string, int>>, decltype(comp)> pq(comp);

    for (const auto& wc : wordCount) {
        pq.push(wc);
    }

    vector<string> result;
    for (int i = 0; i < k; ++i) {
        result.push_back(pq.top().first);
        pq.pop();
    }

    return result;
}

-----
#include <vector>
#include <string>
#include <unordered_map>
#include <queue>
using namespace std;

vector<string> kFrequentWords(vector<string>& words, int k) 
    // Your code here
}

************************************
Question ID: 693

bool hasAlternatingBits(int n) {
    int prevBit = n % 2;
    n /= 2;
    while (n > 0) {
        int currBit = n % 2;
        if (currBit == prevBit) return false;
        prevBit = currBit;
        n /= 2;
    }
    return true;
}


-----
bool hasAlternatingBits(int n) 
    // Your code here
}


************************************
Question ID: 694

#include<vector>
#include<set>
using namespace std;

void dfs(vector<vector<int>>& grid, int i, int j, int i0, int j0, vector<pair<int, int>>& shape) {
    if (i >= 0 && i < grid.size() && j >= 0 && j < grid[0].size() && grid[i][j] == 1) {
        grid[i][j] = 2;
        shape.push_back({i - i0, j - j0});
        dfs(grid, i - 1, j, i0, j0, shape);
        dfs(grid, i + 1, j, i0, j0, shape);
        dfs(grid, i, j - 1, i0, j0, shape);
        dfs(grid, i, j + 1, i0, j0, shape);
    }
}

int numDistinctIslands(vector<vector<int>>& grid) {
    set<vector<pair<int, int>>> unique_islands;
    for (int i = 0; i < grid.size(); ++i) {
        for (int j = 0; j < grid[0].size(); ++j) {
            if (grid[i][j] == 1) {
                vector<pair<int,int>> island_shape;
                dfs(grid, i, j, i, j, island_shape);
                sort(island_shape.begin(), island_shape.end());
                unique_islands.insert(island_shape);
            }
        }
    }
    return unique_islands.size();
}

-----
#include<vector>
#include<set>
using namespace std;

void dfs(vector<vector<int>>& grid, int i, int j, int i0, int j0, vector<pair<int, int>>& shape) 
    // Your code here
}

************************************
Question ID: 695

int maxAreaOfIsland(vector<vector<int>>& grid) {
    int max_area = 0;

    function<int(int, int)> dfs = [&](int i, int j) {
        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == 0) {
            return 0;
        }
        grid[i][j] = 0;
        return 1 + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1);
    };

    for (int i = 0; i < grid.size(); i++) {
        for (int j = 0; j < grid[0].size(); j++) {
            if (grid[i][j]) {
                max_area = max(max_area, dfs(i, j));
            }
        }
    }
    return max_area;
}

-----
int maxAreaOfIsland(vector<vector<int>>& grid) 
    // Your code here
}

************************************
Question ID: 696

int countBinarySubstrings(string s) {
    int prev = 0, curr = 1, result = 0;
    for (int i = 1; i < s.length(); i++) {
        if (s[i] == s[i - 1]) {
            curr++;
        } else {
            result += min(prev, curr);
            prev = curr;
            curr = 1;
        }
    }
    return result + min(prev, curr);
}

-----
int countBinarySubstrings(string s) 
    // Your code here
}

************************************
Question ID: 697

#include <unordered_map>
#include <vector>

int findShortestSubArray(std::vector<int>& nums) {
    std::unordered_map<int, int> freq_map, start_map;
    int max_freq = 0, min_length = nums.size();

    for (int i = 0; i < nums.size(); ++i) {
        if (start_map.count(nums[i]) == 0) {
            start_map[nums[i]] = i;
        }
        freq_map[nums[i]]++;

        int freq = freq_map[nums[i]];
        if (freq > max_freq) {
            max_freq = freq;
            min_length = i - start_map[nums[i]] + 1;
        } else if (freq == max_freq) {
            min_length = std::min(min_length, i - start_map[nums[i]] + 1);
        }
    }

    return min_length;
}

-----
#include <unordered_map>
#include <vector>

int findShortestSubArray(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 698

#include <vector>
#include <numeric>

bool canPartitionKSubsets(std::vector<int>& nums, int k) {
  int sum = std::accumulate(nums.begin(), nums.end(), 0);
  if (sum % k != 0) return false;
  int target = sum / k;
  std::vector<bool> visited(nums.size(), false);
  return dfs(nums, visited, 0, target, 0, k);
}

bool dfs(std::vector<int>& nums, std::vector<bool>& visited, int start, int target, int curr_sum, int k) {
  if (k == 1) return true;
  if (curr_sum == target) return dfs(nums, visited, 0, target, 0, k - 1);
  for (int i = start; i < nums.size(); i++) {
    if (!visited[i] && curr_sum + nums[i] <= target) {
      visited[i] = true;
      if (dfs(nums, visited, i + 1, target, curr_sum + nums[i], k)) return true;
      visited[i] = false;
    }
  }
  return false;
}

-----
#include <vector>
#include <numeric>

bool canPartitionKSubsets(std::vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 699

#include<vector>
using namespace std;

vector<int> fallingSquares(vector<vector<int>>& positions) {
    vector<int> ans;
    vector<pair<int, int>> intervals;

    for (auto p : positions) {
        int L = p[0];
        int R = p[0] + p[1];
        int h = p[1];
        for (auto it : intervals) {
            if (it.first < R && L < it.second) {
                h = max(h, p[1] + it.first);
            }
        }

        int maxHeight = h;
        for (auto it : intervals) {
            maxHeight = max(maxHeight, it.first);
        }

        ans.push_back(maxHeight);
        intervals.push_back(make_pair(h, R));
    }
    
    return ans;
}

-----
#include<vector>
using namespace std;

vector<int> fallingSquares(vector<vector<int>>& positions) 
    // Your code here
}

************************************
Question ID: 702

int search(const ArrayReader& reader, int target) {
    int left = 0, right = 1;
    while (reader.get(right) < target) {
        left = right;
        right <<= 1;
    }

    while (left <= right) {
        int mid = left + ((right - left) >> 1);
        int val = reader.get(mid);
        if (val == target)
            return mid;
        if (val > target)
            right = mid - 1;
        else
            left = mid + 1;
    }
    return -1;
}

-----
int search(const ArrayReader& reader, int target) 
    // Your code here
}

************************************
Question ID: 703

#include <queue>
#include <vector>

class KthLargest {
public:
    int k;
    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;

    KthLargest(int k, std::vector<int>& nums) {
        this->k = k;
        for (int num : nums) {
            add(num);
        }
    }
    
    int add(int val) {
        minHeap.push(val);
        if (minHeap.size() > k) {
            minHeap.pop();
        }
        return minHeap.top();
    }
};

-----
#include <queue>
#include <vector>

class KthLargest 
    // Your code here
};

************************************
Question ID: 704

int search(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) return mid;
        if (nums[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}


-----
int search(vector<int>& nums, int target) 
    // Your code here
}


************************************
Question ID: 709

#include <string>

std::string toLowerCase(std::string s) {
    for (char& c : s) {
        if (c >= 'A' && c <= 'Z') {
            c = c - 'A' + 'a';
        }
    }
    return s;
}

-----
#include <string>

std::string toLowerCase(std::string s) 
    // Your code here
}

************************************
Question ID: 710

#include <unordered_map>
#include <vector>
#include <algorithm>
#include <random>

class Solution {
public:
    Solution(int n, std::vector<int>& blacklist) {
        std::sort(blacklist.begin(), blacklist.end());
        auto it = blacklist.begin();
        int idx = 0;
        for (int i = 0; i < blacklist.size(); ++i) {
            int black = *it++;
            while (idx < black) {
                mapping[idx++] = n - 1;
                --n;
            }
            ++idx;
            --n;
        }
        last = n;
    }
    
    int pick() {
        int num = rand() % last;
        auto res = mapping.find(num);
        return res == mapping.end() ? num : res->second;
    }

private:
    std::unordered_map<int, int> mapping;
    int last;
};

-----
#include <unordered_map>
#include <vector>
#include <algorithm>
#include <random>

class Solution 
    // Your code here
};

************************************
Question ID: 712

int minimumDeleteSum(std::string s1, std::string s2) {
    int dp[1001][1001] = {0};
    for (int i = 1; i <= s1.size(); i++) {
        dp[i][0] = dp[i - 1][0] + s1[i - 1];
    }
    for (int j = 1; j <= s2.size(); j++) {
        dp[0][j] = dp[0][j - 1] + s2[j - 1];
    }
    for (int i = 1; i <= s1.size(); i++) {
        for (int j = 1; j <= s2.size(); j++) {
            if (s1[i - 1] == s2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = std::min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);
            }
        }
    }
    return dp[s1.size()][s2.size()];
}

-----
int minimumDeleteSum(std::string s1, std::string s2) 
    // Your code here
}

************************************
Question ID: 713

int numSubarrayProductLessThanK(vector<int>& nums, int k) {
    if (k <= 1) return 0;
    int prod = 1, count = 0, left = 0;
    for (int right = 0; right < nums.size(); right++) {
        prod *= nums[right];
        while (prod >= k) prod /= nums[left++];
        count += right - left + 1;
    }
    return count;
}

-----
int numSubarrayProductLessThanK(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 714

int maxProfit(vector<int>& prices, int fee) {
    int cash = 0, hold = -prices[0];
    for (int price : prices) {
        int temp = cash;
        cash = max(cash, hold + price - fee);
        hold = max(hold, temp - price);
    }
    return cash;
}

-----
int maxProfit(vector<int>& prices, int fee) 
    // Your code here
}

************************************
Question ID: 716

#include <set>
#include <stack>

class MaxStack {
    std::stack<int> mainStack;
    std::multiset<int> maxSet;

public:
    MaxStack() {}
    
    void push(int x) {
        mainStack.push(x);
        maxSet.insert(x);
    }
    
    int pop() {
        int top = mainStack.top();
        mainStack.pop();
        maxSet.erase(maxSet.find(top));
        return top;
    }
    
    int top() {
        return mainStack.top();
    }
    
    int peekMax() {
        return *maxSet.rbegin();
    }
    
    int popMax() {
        int max = *maxSet.rbegin();
        maxSet.erase(maxSet.find(max));
        
        std::stack<int> tempStack;
        while (mainStack.top() != max) {
            tempStack.push(mainStack.top());
            mainStack.pop();
        }
        mainStack.pop();
        while (!tempStack.empty()) {
            mainStack.push(tempStack.top());
            tempStack.pop();
        }
        
        return max;
    }
};

-----
#include <set>
#include <stack>

class MaxStack 
    // Your code here
};

************************************
Question ID: 717

bool isOneBitCharacter(std::vector<int>& bits) {
    int i;
    for (i = 0; i < bits.size() - 1; i++) {
        i += bits[i];
    }
    return i == bits.size() - 1;
}

-----
bool isOneBitCharacter(std::vector<int>& bits) 
    // Your code here
}

************************************
Question ID: 718

int findLength(vector<int>& nums1, vector<int>& nums2) {
    int m = nums1.size();
    int n = nums2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    int maxLength = 0;

    for (int i = m - 1; i >= 0; i--) {
        for (int j = n - 1; j >= 0; j--) {
            if (nums1[i] == nums2[j]) {
                dp[i][j] = dp[i + 1][j + 1] + 1;
                maxLength = max(maxLength, dp[i][j]);
            }
        }
    }

    return maxLength;
}

-----
int findLength(vector<int>& nums1, vector<int>& nums2) 
    // Your code here
}

************************************
Question ID: 719

#include <algorithm>
#include <vector>

int smallestDistancePair(std::vector<int>& nums, int k) {
    std::sort(nums.begin(), nums.end());
    int low = 0, high = nums.back() - nums.front();
    
    while (low < high) {
        int mid = (low + high) / 2;
        int count = 0, left = 0;

        for (int right = 0; right < nums.size(); ++right) {
            while (nums[right] - nums[left] > mid) {
                ++left;
            }
            count += (right - left);
        }

        if (count < k) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    
    return low;
}


-----
#include <algorithm>
#include <vector>

int smallestDistancePair(std::vector<int>& nums, int k) 
    // Your code here
}


************************************
Question ID: 720

#include <string>
#include <vector>
#include <algorithm>
#include <set>

std::string longestWord(std::vector<std::string>& words) {
    std::sort(words.begin(), words.end());
    std::set<std::string> built_words;
    std::string result = "";

    for (const auto& word : words) {
        if (word.size() == 1 || built_words.find(word.substr(0, word.size() - 1)) != built_words.end()) {
            result = (word.size() > result.size()) ? word : result;
            built_words.insert(word);
        }
    }

    return result;
}


-----
#include <string>
#include <vector>
#include <algorithm>
#include <set>

std::string longestWord(std::vector<std::string>& words) 
    // Your code here
}


************************************
Question ID: 721

#include <vector>
#include <string>
#include <set>
#include <map>

using namespace std;

void dfs(int id, const vector<vector<string>>& accounts, vector<bool>& visited, set<string>& merged_emails, map<string, int>& email_to_id) {
    if (visited[id]) return;
    visited[id] = true;
    for (int j = 1; j < accounts[id].size(); ++j) {
        const string& email = accounts[id][j];
        merged_emails.insert(email);
        int next_id = email_to_id[email];
        dfs(next_id, accounts, visited, merged_emails, email_to_id);
    }
}

vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
    map<string, int> email_to_id;
    for (int i = 0; i < accounts.size(); ++i)
        for (int j = 1; j < accounts[i].size(); ++j)
            email_to_id[accounts[i][j]] = i;

    vector<vector<string>> result;
    vector<bool> visited(accounts.size(), false);
    for (int i = 0; i < accounts.size(); ++i) {
        if (!visited[i]) {
            set<string> merged_emails;
            dfs(i, accounts, visited, merged_emails, email_to_id);
            vector<string> merged_account(merged_emails.begin(), merged_emails.end());
            merged_account.insert(merged_account.begin(), accounts[i][0]);
            result.push_back(merged_account);
        }
    }
    return result;
}


-----
#include <vector>
#include <string>
#include <set>
#include <map>

using namespace std;

void dfs(int id, const vector<vector<string>>& accounts, vector<bool>& visited, set<string>& merged_emails, map<string, int>& email_to_id) 
    // Your code here
}


************************************
Question ID: 722

vector<string> removeComments(vector<string>& source) {
    vector<string> result;
    string buffer;
    bool in_block_comment = false;
    
    for (const auto& line : source) {
        for (size_t i = 0; i < line.size(); ++i) {
            if (in_block_comment) {
                if (i < line.size() - 1 && line[i] == '*' && line[i + 1] == '/') {
                    in_block_comment = false;
                    ++i;
                }
            } else {
                if (i < line.size() - 1 && line[i] == '/' && line[i + 1] == '*') {
                    in_block_comment = true;
                    ++i;
                } else if (i < line.size() - 1 && line[i] == '/' && line[i + 1] == '/') {
                    break;
                } else {
                    buffer.push_back(line[i]);
                }
            }
        }
        if (!in_block_comment && !buffer.empty()) {
            result.push_back(buffer);
            buffer.clear();
        }
    }
    return result;
}


-----
vector<string> removeComments(vector<string>& source) 
    // Your code here
}


************************************
Question ID: 723

#include<vector>
using namespace std;
vector<vector<int>> candyCrush(vector<vector<int>>& board) {
    int rows = board.size(), cols = board[0].size();
    bool toDo = false;
    
    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols - 2; c++) {
            int val = abs(board[r][c]);
            if (val && val == abs(board[r][c + 1]) && val == abs(board[r][c + 2])) {
                board[r][c] = board[r][c + 1] = board[r][c + 2] = -val;
                toDo = true;
            }
        }
    }
    
    for (int r = 0; r < rows - 2; r++) {
        for (int c = 0; c < cols; c++) {
            int val = abs(board[r][c]);
            if (val && val == abs(board[r + 1][c]) && val == abs(board[r + 2][c])) {
                board[r][c] = board[r + 1][c] = board[r + 2][c] = -val;
                toDo = true;
            }
        }
    }
    
    for (int c = 0; c < cols; c++) {
        int wr = rows - 1;
        for (int r = rows - 1; r >= 0; r--)
            if (board[r][c] > 0)
                board[wr--][c] = board[r][c];
        while (wr >= 0)
            board[wr--][c] = 0;
    }
    
    return toDo ? candyCrush(board) : board;
}

-----
#include<vector>
using namespace std;
vector<vector<int>> candyCrush(vector<vector<int>>& board) 
    // Your code here
}

************************************
Question ID: 724

int pivotIndex(vector<int>& nums) {
    int total_sum = 0, left_sum = 0;
    for (int num : nums)
        total_sum += num;
    for (int i = 0; i < nums.size(); ++i) {
        if (left_sum == total_sum - left_sum - nums[i])
            return i;
        left_sum += nums[i];
    }
    return -1;
}


-----
int pivotIndex(vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 726

#include <map>
#include <string>
using namespace std;

map<string, int> parse(const string &formula, int &i) {
    map<string, int> counts;
    while (i < formula.size()) {
        if (formula[i] == '(') {
            map<string, int> temp = parse(formula, ++i);
            int count = 0;
            while (isdigit(formula[i])) {
                count = count * 10 + (formula[i++] - '0');
            }
            if (count == 0) count = 1;
            for (const auto &e : temp) {
                counts[e.first] += e.second * count;
            }
        } else if (formula[i] == ')') {
            ++i;
            return counts;
        } else {
            string name;
            name += formula[i++];
            while (islower(formula[i])) {
                name += formula[i++];
            }
            int count = 0;
            while (isdigit(formula[i])) {
                count = count * 10 + (formula[i++] - '0');
            }
            if (count == 0) count = 1;
            counts[name] += count;
        }
    }
    return counts;
}

string countOfAtoms(string formula) {
    int i = 0;
    map<string, int> counts = parse(formula, i);
    string ans;
    for (const auto &e : counts) {
        ans += e.first;
        if (e.second > 1) ans += to_string(e.second);
    }
    return ans;
}


-----
#include <map>
#include <string>
using namespace std;

map<string, int> parse(const string &formula, int &i) 
    // Your code here
}


************************************
Question ID: 727

#include <string>
#include <vector>

std::string min_window_sub_sequence(std::string s1, std::string s2) {
    int m = s1.length(), n = s2.length();
    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(m + 1, -1));

    for (int j = 0; j <= m; ++j) {
        dp[0][j] = j;
    }

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (s1[j - 1] == s2[i - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = dp[i][j - 1];
            }
        }
    }
    
    int start = 0, length = m + 1;
    for (int j = 1; j <= m; ++j) {
        if (dp[n][j] != -1 && j - dp[n][j] < length) {
            start = dp[n][j];
            length = j - start;
        }
    }

    return length == m + 1 ? "" : s1.substr(start, length);
}

-----
#include <string>
#include <vector>

std::string min_window_sub_sequence(std::string s1, std::string s2) 
    // Your code here
}

************************************
Question ID: 728

#include <vector>

bool isSelfDividing(int num) {
    int n = num;
    while (n) {
        int digit = n % 10;
        if (digit == 0 || num % digit != 0)
            return false;
        n /= 10;
    }
    return true;
}

std::vector<int> selfDividingNumbers(int left, int right) {
    std::vector<int> result;
    for (int i = left; i <= right; ++i) {
        if (isSelfDividing(i))
            result.push_back(i);
    }
    return result;
}

-----
#include <vector>

bool isSelfDividing(int num) 
    // Your code here
}

************************************
Question ID: 729

#include <map>

class MyCalendar {
public:
    std::map<int, int> calendar;

    bool book(int start, int end) {
        auto it = calendar.lower_bound(start);
        if (it != calendar.begin() && (--it)->second > start) return false;
        if (it != calendar.end() && end > it->first) return false;
        calendar[start] = end;
        return true;
    }
};

-----
#include <map>

class MyCalendar 
    // Your code here
};

************************************
Question ID: 730

#include <vector>
#include <string>
using namespace std;

int countPalindromicSubsequences(string s) {
    int n = s.length();
    int MOD = 1000000007;
    vector<vector<int>> dp(4, vector<int>(n + 1, 0));

    for (int i = n - 1; i >= 0; i--) {
        for (int j = i + 1; j <= n; j++) {
            int c = s[i] - 'a';
            dp[c][j] = dp[0][j - 1] + dp[1][j - 1] + dp[2][j - 1] + dp[3][j - 1] - dp[c][i] + 2;
            dp[c][j] = (dp[c][j] + MOD) % MOD;
        }
    }

    return (dp[0][n] + dp[1][n] + dp[2][n] + dp[3][n]) % MOD;
}


-----
#include <vector>
#include <string>
using namespace std;

int countPalindromicSubsequences(string s) 
    // Your code here
}


************************************
Question ID: 732

#include <map>

class MyCalendarThree {
public:
    std::map<int, int> timeline;

    int book(int start, int end) {
        timeline[start]++;
        timeline[end]--;
        int ongoing = 0, k = 0;
        for (auto& t : timeline) {
            k = std::max(k, ongoing += t.second);
        }
        return k;
    }
};


-----
#include <map>

class MyCalendarThree 
    // Your code here
};


************************************
Question ID: 733

#include<vector>
using namespace std;

void fill(vector<vector<int>>& image, int sr, int sc, int newColor, int startColor) {
    if (sr < 0 || sc < 0 || sr >= image.size() || sc >= image[0].size() || image[sr][sc] != startColor || image[sr][sc] == newColor) return;
    image[sr][sc] = newColor;
    fill(image, sr - 1, sc, newColor, startColor);
    fill(image, sr + 1, sc, newColor, startColor);
    fill(image, sr, sc - 1, newColor, startColor);
    fill(image, sr, sc + 1, newColor, startColor);
}

vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {
    int startColor = image[sr][sc];
    fill(image, sr, sc, newColor, startColor);
    return image;
}


-----
#include<vector>
using namespace std;

void fill(vector<vector<int>>& image, int sr, int sc, int newColor, int startColor) 
    // Your code here
}


************************************
Question ID: 734

#include <vector>
#include <string>
#include <unordered_map>
using namespace std;

bool areSentencesSimilar(vector<string>& sentence1, vector<string>& sentence2, vector<vector<string>>& similarPairs) {
    if (sentence1.size() != sentence2.size()) return false;
    unordered_map<string, unordered_set<string>> similarityMap;
    for (const auto& pair : similarPairs) {
        similarityMap[pair[0]].insert(pair[1]);
        similarityMap[pair[1]].insert(pair[0]);
    }
    for (int i = 0; i < sentence1.size(); ++i) {
        if (sentence1[i] != sentence2[i] && !similarityMap[sentence1[i]].count(sentence2[i]))
            return false;
    }
    return true;
}


-----
#include <vector>
#include <string>
#include <unordered_map>
using namespace std;

bool areSentencesSimilar(vector<string>& sentence1, vector<string>& sentence2, vector<vector<string>>& similarPairs) 
    // Your code here
}


************************************
Question ID: 735

#include <vector>
using namespace std;

vector<int> asteroidCollision(vector<int>& asteroids) {
    vector<int> s;
    for (int i = 0; i < asteroids.size(); i++) {
        if (asteroids[i] > 0 || s.empty() || s.back() < 0) {
            s.push_back(asteroids[i]);
        } else if (s.back() <= -asteroids[i]) {
            if (s.back() < -asteroids[i]) i--;
            s.pop_back();
        }
    }
    return s;
}


-----
#include <vector>
using namespace std;

vector<int> asteroidCollision(vector<int>& asteroids) 
    // Your code here
}


************************************
Question ID: 736

#include <string>
#include <unordered_map>
using namespace std;

int calculate(string &expression, const int &start, int &end, unordered_map<string, int> &variables) {
    if (expression[start] == '(') {
        if (expression.substr(start + 1, 3) == "add") {
            int first = start + 5;
            int second = first;
            calculate(expression, first, second, variables);
            int value1 = variables[" "];
            calculate(expression, second + 1, end, variables);
            int value2 = variables[" "];
            end++;
            return value1 + value2;
        } else if (expression.substr(start + 1, 4) == "mult") {
            int first = start + 6;
            int second = first;
            calculate(expression, first, second, variables);
            int value1 = variables[" "];
            calculate(expression, second + 1, end, variables);
            int value2 = variables[" "];
            end++;
            return value1 * value2;
        } else {
            unordered_map<string, int> inner = unordered_map<string, int>(variables);
            int idx = start + 5;
            while (idx < end - 1 && expression[idx] != '(') {
                int temp = idx;
                idx = expression.find(' ', idx + 1);
                string var = expression.substr(temp, idx - temp);
                temp = idx + 1;
                if (expression[temp] == '(') {
                    idx++;
                } else {
                    idx = expression.find(' ', idx + 1);
                }
                int result = calculate(expression, temp, idx, variables);
                inner[var] = result;
                variables = inner;
            }
            return calculate(expression, idx, end, variables);
        }
    } else {
        if (isdigit(expression[start]) || expression[start] == '-') {
            end = expression.find(' ', start);
            return stoi(expression.substr(start, end - start));
        } else {
            int idx = expression.find(' ', start);
            end = (idx == -1) ? end : idx;
            return variables[expression.substr(start, end - start)];
        }
    }
}

int evaluate(string expression) {
    int end = expression.size();
    unordered_map<string, int> variables;
    int result = calculate(expression, 0, end, variables);
    return result;
}

-----
#include <string>
#include <unordered_map>
using namespace std;

int calculate(string &expression, const int &start, int &end, unordered_map<string, int> &variables) 
    // Your code here
}

************************************
Question ID: 737

#include <vector>
#include <unordered_map>
#include <string>

bool areSentencesSimilar(std::vector<std::string>& sentence1, std::vector<std::string>& sentence2, std::vector<std::vector<std::string>>& pairs) {
    if (sentence1.size() != sentence2.size()) return false;

    std::unordered_map<std::string, std::unordered_set<std::string>> graph;
    for (const auto& p : pairs) {
        graph[p[0]].insert(p[1]);
        graph[p[1]].insert(p[0]);
    }
    
    for (int i = 0; i < sentence1.size(); ++i) {
        if (sentence1[i] == sentence2[i]) continue;
        if (graph[sentence1[i]].find(sentence2[i]) == graph[sentence1[i]].end()) return false;
    }
    return true;
}

-----
#include <vector>
#include <unordered_map>
#include <string>

bool areSentencesSimilar(std::vector<std::string>& sentence1, std::vector<std::string>& sentence2, std::vector<std::vector<std::string>>& pairs) 
    // Your code here
}

************************************
Question ID: 738

int monotoneIncreasingDigits(int n) {
    string n_str = to_string(n);
    int n_len = n_str.size();

    int i = n_len - 1;
    while (i > 0) {
        if (n_str[i] < n_str[i - 1]) {
            n_str[i - 1] -= 1;
            for (int j = i; j < n_len; ++j) {
                n_str[j] = '9';
            }
        }
        --i;
    }

    return stoi(n_str);
}

-----
int monotoneIncreasingDigits(int n) 
    // Your code here
}

************************************
Question ID: 739

#include <vector>
#include <stack>

std::vector<int> dailyTemperatures(std::vector<int>& temperatures) {
    std::vector<int> result(temperatures.size(), 0);
    std::stack<int> stack;

    for (size_t i = 0; i < temperatures.size(); ++i) {
        while (!stack.empty() && temperatures[i] > temperatures[stack.top()]) {
            int idx = stack.top();
            stack.pop();
            result[idx] = i - idx;
        }
        stack.push(i);
    }

    return result;
}

-----
#include <vector>
#include <stack>

std::vector<int> dailyTemperatures(std::vector<int>& temperatures) 
    // Your code here
}

************************************
Question ID: 740

int maxPoints(vector<int>& nums) {
    vector<int> dp(100001, 0);
    int max_points = 0;
    for (int num : nums) {
        dp[num]++;
    }
    for (int i = 2; i < dp.size(); i++) {
        dp[i] = max(dp[i - 1], dp[i - 2] + i * dp[i]);
        max_points = max(max_points, dp[i]);
    }
    return max_points;
}

-----
int maxPoints(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 741

int helper(vector<vector<int>>& grid, vector<vector<vector<int>>>& memo, int r1, int c1, int r2) {
    int c2 = r1 + c1 - r2;
    if (r1 == grid.size() || r2 == grid.size() || c1 == grid.size() || c2 == grid.size() ||
        grid[r1][c1] == -1 || grid[r2][c2] == -1) {
        return INT_MIN;
    } else if (r1 == grid.size() - 1 && c1 == grid.size() - 1) {
        return grid[r1][c1];
    } else if (memo[r1][c1][r2] != INT_MIN) {
        return memo[r1][c1][r2];
    } else {
        memo[r1][c1][r2] = grid[r1][c1] + (r1 != r2 ? grid[r2][c2] : 0);
        int max_cherries = max(max(helper(grid, memo, r1 + 1, c1, r2 + 1), helper(grid, memo, r1, c1 + 1, r2 + 1)),
                               max(helper(grid, memo, r1 + 1, c1, r2), helper(grid, memo, r1, c1 + 1, r2)));
        memo[r1][c1][r2] += max_cherries;
    }
    return memo[r1][c1][r2];
}

int cherryPickup(vector<vector<int>>& grid) {
    int n = grid.size();
    vector<vector<vector<int>>> memo(n, vector<vector<int>>(n, vector<int>(n, INT_MIN)));
    return max(0, helper(grid, memo, 0, 0, 0));
}


-----
int helper(vector<vector<int>>& grid, vector<vector<vector<int>>>& memo, int r1, int c1, int r2) 
    // Your code here
}


************************************
Question ID: 742

#include <algorithm>
#include <cctype>

std::string toLowerCase(std::string s) {
    std::transform(s.begin(), s.end(), s.begin(), ::tolower);
    return s;
}

-----
#include <algorithm>
#include <cctype>

std::string toLowerCase(std::string s) 
    // Your code here
}

************************************
Question ID: 743

#include <vector>
#include <queue>
#include <limits>

using namespace std;

int networkDelayTime(vector<vector<int>>& times, int n, int k) {
    vector<vector<pair<int, int>>> graph(n + 1);
    for (auto& edge : times) {
        graph[edge[0]].push_back({edge[1], edge[2]});
    }

    vector<int> dist(n + 1, INT_MAX);
    dist[k] = 0;

    priority_queue<pair<int, int>, vector<pair<int,int>>, greater<pair<int, int>>> pq;
    pq.push({0, k});

    while (!pq.empty()) {
        int u = pq.top().second;
        int curr_dist = pq.top().first;
        pq.pop();

        for (auto& neighbor : graph[u]) {
            int v = neighbor.first;
            int weight = neighbor.second;
            if (curr_dist + weight < dist[v]) {
                dist[v] = curr_dist + weight;
                pq.push({dist[v], v});
            }
        }
    }

    int max_time = 0;
    for (int i = 1; i <= n; ++i) {
        if (dist[i] == INT_MAX) return -1;
        max_time = max(max_time, dist[i]);
    }

    return max_time;
}

-----
#include <vector>
#include <queue>
#include <limits>

using namespace std;

int networkDelayTime(vector<vector<int>>& times, int n, int k) 
    // Your code here
}

************************************
Question ID: 744

#include <vector>
#include <queue>
#include <algorithm>
#include <limits>

int networkDelayTime(std::vector<std::vector<int>>& times, int n, int k) {
    std::vector<std::vector<std::pair<int, int>>> graph(n + 1);
    for (const auto &edge : times)
        graph[edge[0]].emplace_back(edge[1], edge[2]);

    std::vector<int> dist(n + 1, std::numeric_limits<int>::max());
    dist[k] = 0;

    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> pq;
    pq.emplace(0, k);

    while (!pq.empty()) {
        int time = pq.top().first, node = pq.top().second;
        pq.pop();

        if (time > dist[node]) continue;
        for (const auto &neighbour : graph[node]) {
            int nextNode = neighbour.first, nextTime = neighbour.second;
            if (time + nextTime < dist[nextNode]) {
                dist[nextNode] = time + nextTime;
                pq.push({dist[nextNode], nextNode});
            }
        }
    }

    int maxTime = *std::max_element(dist.begin() + 1, dist.end());
    return maxTime == std::numeric_limits<int>::max() ? -1 : maxTime;
}

-----
#include <vector>
#include <queue>
#include <algorithm>
#include <limits>

int networkDelayTime(std::vector<std::vector<int>>& times, int n, int k) 
    // Your code here
}

************************************
Question ID: 745

char nextGreatestLetter(vector<char>& letters, char target) {
    for (char letter : letters) {
        if (letter > target) {
            return letter;
        }
    }
    return letters[0];
}

-----
char nextGreatestLetter(vector<char>& letters, char target) 
    // Your code here
}

************************************
Question ID: 747

int minCostClimbingStairs(vector<int>& cost) {
    int n = cost.size();
    for(int i=2; i<n; i++)
        cost[i] += min(cost[i-1], cost[i-2]);
    return min(cost[n-1], cost[n-2]);
}

-----
int minCostClimbingStairs(vector<int>& cost) 
    // Your code here
}

************************************
Question ID: 748

#include <string>
#include <vector>
#include <unordered_map>
#include <algorithm>

std::string shortestCompletingWord(std::string licensePlate, std::vector<std::string>& words) {
    std::unordered_map<char, int> lp_count;
    for (char c : licensePlate)
        if (isalpha(c))
            lp_count[tolower(c)]++;

    std::string result = "";
    for (const std::string& word : words) {
        std::unordered_map<char, int> word_count;
        for (char c : word)
            word_count[c]++;

        bool valid = true;
        for (const auto& [ch, count] : lp_count)
            if (word_count[ch] < count) {
                valid = false;
                break;
            }

        if (valid && (result.empty() || word.length() < result.length()))
            result = word;
    }
    return result;
}


-----
#include <string>
#include <vector>
#include <unordered_map>
#include <algorithm>

std::string shortestCompletingWord(std::string licensePlate, std::vector<std::string>& words) 
    // Your code here
}


************************************
Question ID: 749

#include <string>
#include <vector>
#include <algorithm>
#include <cctype>

std::string shortestCompletingWord(std::string licensePlate, std::vector<std::string> words) {
    std::vector<int> target(26, 0);
    for (char c : licensePlate)
        if (isalpha(c)) target[tolower(c) - 'a']++;

    std::string result;
    for (const std::string& word : words) {
        std::vector<int> current(26, 0);
        for (char c : word)
            if (isalpha(c)) current[tolower(c) - 'a']++;

        if (std::equal(target.begin(), target.end(), current.begin(), [](int a, int b){ return a <= b; }))
            if (result.empty() || word.size() < result.size()) result = word;
    }

    return result;
}

-----
#include <string>
#include <vector>
#include <algorithm>
#include <cctype>

std::string shortestCompletingWord(std::string licensePlate, std::vector<std::string> words) 
    // Your code here
}

************************************
Question ID: 750

int countCornerRectangles(vector<vector<int>>& grid) {
    int count = 0;
    int m = grid.size();
    int n = grid[0].size();
    
    for (int i = 0; i < m - 1; i++) {
        for (int j = 0; j < n - 1; j++) {
            if (grid[i][j] == 1) {
                for (int k = i + 1; k < m; k++) {
                    for (int l = j + 1; l < n; l++) {
                        if (grid[k][l] == 1 && grid[i][l] == 1 && grid[k][j] == 1) {
                            count++;
                        }
                    }
                }
            }
        }
    }
    return count;
}

-----
int countCornerRectangles(vector<vector<int>>& grid) 
    // Your code here
}

************************************
Question ID: 751

#include <bitset>
#include <vector>
#include <string>
#include <sstream>
using namespace std;

vector<string> ipToCIDR(string ip, int n) {
    stringstream ss(ip);
    int a, b, c, d;
    char ch;
    ss >> a >> ch >> b >> ch >> c >> ch >> d;
    unsigned mask = 0xFFFFFFFF;
    unsigned start = (a << 24) + (b << 16) + (c << 8) + d;
    unsigned end = start + n - 1;
    
    vector<string> ans;
    while (start <= end) {
        int samePrefixBits = __builtin_ctz(~(start & -start));
        while ((mask >> samePrefixBits) & 1)
            ++samePrefixBits;
        while (((end - start) >> samePrefixBits) < 1)
            --samePrefixBits;
        unsigned range = 1 << samePrefixBits;
        stringstream res;
        res << (start >> 24) << "." << ((start >> 16) & 255) << "." << ((start >> 8) & 255) << "." << (start & 255) << "/" << (32 - samePrefixBits);
        ans.push_back(res.str());
        start += range;
    }
    
    return ans;
}


-----
#include <bitset>
#include <vector>
#include <string>
#include <sstream>
using namespace std;

vector<string> ipToCIDR(string ip, int n) 
    // Your code here
}


************************************
Question ID: 752

#include <vector>
#include <string>
#include <queue>
#include <set>
using namespace std;

int openLock(vector<string>& deadends, string target) {
    set<string> dead(deadends.begin(), deadends.end());
    set<string> visited;
    queue<string> q;
    string start = "0000";

    if (dead.find(start) != dead.end()) return -1;
    q.push(start);
    visited.insert(start);

    int moves = 0;
    while (!q.empty()) {
        int levelSize = q.size();
        for (int i = 0; i < levelSize; ++i) {
            string cur = q.front();
            q.pop();

            if (cur == target) return moves;

            for (int j = 0; j < 4; ++j) {
                for (int k = -1; k <= 1; k += 2) {
                    string next = cur;
                    next[j] = (next[j] - '0' + k + 10) % 10 + '0';

                    if (visited.find(next) == visited.end() && dead.find(next) == dead.end()) {
                        visited.insert(next);
                        q.push(next);
                    }
                }
            }
        }
        moves++;
    }

    return -1;
}


-----
#include <vector>
#include <string>
#include <queue>
#include <set>
using namespace std;

int openLock(vector<string>& deadends, string target) 
    // Your code here
}


************************************
Question ID: 753

#include <vector>
#include <string>
#include <queue>
#include <unordered_set>

int openLock(std::vector<std::string> &deadends, std::string target) {
    std::unordered_set<std::string> dead(deadends.begin(), deadends.end());
    std::unordered_set<std::string> visited;
    std::queue<std::pair<std::string, int>> wheel_states;

    if (dead.find("0000") != dead.end()) return -1;
    wheel_states.push({"0000", 0});
    visited.insert("0000");

    while (!wheel_states.empty()) {
        auto [current_state, turns] = wheel_states.front(); wheel_states.pop();

        if (current_state == target) return turns;

        for (int i = 0; i < 4; ++i) {
            std::string up_state = current_state;
            std::string down_state = current_state;
            up_state[i] = (up_state[i] - '0' + 1) % 10 + '0';
            down_state[i] = (down_state[i] - '0' + 9) % 10 + '0';

            if (!visited.count(up_state) && !dead.count(up_state)) {
                wheel_states.push({up_state, turns + 1});
                visited.insert(up_state);
            }

            if (!visited.count(down_state) && !dead.count(down_state)) {
                wheel_states.push({down_state, turns + 1});
                visited.insert(down_state);
            }
        }
    }
    return -1;
}

-----
#include <vector>
#include <string>
#include <queue>
#include <unordered_set>

int openLock(std::vector<std::string> &deadends, std::string target) 
    // Your code here
}

************************************
Question ID: 754

int reachNumber(int target) {
    target = abs(target);
    int step = 0, sum = 0;
    while (sum < target) {
        step++;
        sum += step;
    }
    while ((sum - target) % 2 != 0) {
        step++;
        sum += step;
    }
    return step;
}


-----
int reachNumber(int target) 
    // Your code here
}


************************************
Question ID: 755

int min_moves(int target) {
    target = abs(target);
    int step = 0;
    int sum = 0;
    while (sum < target || (sum - target) % 2 == 1) {
        step++;
        sum += step;
    }
    return step;
}


-----
int min_moves(int target) 
    // Your code here
}


************************************
Question ID: 756

#include <string>
#include <vector>
#include <unordered_map>

bool pyramidTransitionHelper(std::string& bottom, std::string& top, int idx, std::unordered_map<std::string, std::vector<char>>& mapping) {
    if (bottom.length() == 1) return true;
    if (idx == bottom.length() - 1) return pyramidTransitionHelper(top, "", 0, mapping);
    std::string key = bottom.substr(idx, 2);
    if (mapping.find(key) == mapping.end()) return false;
    for (char c : mapping[key]) {
        top.push_back(c);
        if (pyramidTransitionHelper(bottom, top, idx + 1, mapping)) return true;
        top.pop_back();
    }
    return false;
}

bool pyramidTransition(std::string bottom, std::vector<std::string>& allowed) {
    std::unordered_map<std::string, std::vector<char>> mapping;
    for (const auto& s : allowed) mapping[s.substr(0, 2)].push_back(s[2]);
    return pyramidTransitionHelper(bottom, "", 0, mapping);
}


-----
#include <string>
#include <vector>
#include <unordered_map>

bool pyramidTransitionHelper(std::string& bottom, std::string& top, int idx, std::unordered_map<std::string, std::vector<char>>& mapping) 
    // Your code here
}


************************************
Question ID: 757

#include <string>
#include <unordered_map>
#include <vector>

bool dfs(std::string curr, std::string bottom, std::unordered_map<std::string, std::vector<char>>& mapping) {
    if (bottom.size() == 1) return true;

    for (int i = 0; i < bottom.size() - 1; ++i) {
        std::string s = bottom.substr(i, 2);
        if (mapping.count(s) == 0) return false;
    }

    curr = "";
    for (int i = 0; i < bottom.size() - 1; ++i) {
        curr += mapping[bottom.substr(i, 2)][0];
    }

    return dfs(curr, curr, mapping);
}

bool pyramidTransition(std::string bottom, std::vector<std::string>& allowed) {
    std::unordered_map<std::string, std::vector<char>> mapping;
    for (std::string& s : allowed) {
        mapping[s.substr(0, 2)].emplace_back(s[2]);
    }
    return dfs("", bottom, mapping);
}


-----
#include <string>
#include <unordered_map>
#include <vector>

bool dfs(std::string curr, std::string bottom, std::unordered_map<std::string, std::vector<char>>& mapping) 
    // Your code here
}


************************************
Question ID: 758

#include <vector>
#include <string>

std::string addBoldTag(std::vector<std::string>& words, std::string s) {
    std::vector<bool> bold(s.size(), false);
    for (std::string word : words) {
        int pos = s.find(word);
        while (pos != std::string::npos) {
            for (int i = pos; i < pos + word.size(); i++) {
                bold[i] = true;
            }
            pos = s.find(word, pos + 1);
        }
    }

    std::string result = "";
    for (int i = 0; i < s.size(); i++) {
        if (bold[i] && (i == 0 || !bold[i - 1])) result += "<b>";
        result += s[i];
        if (bold[i] && (i == s.size() - 1 || !bold[i + 1])) result += "</b>";
    }

    return result;
}

-----
#include <vector>
#include <string>

std::string addBoldTag(std::vector<std::string>& words, std::string s) 
    // Your code here
}

************************************
Question ID: 759

#include <vector>
#include <algorithm>

int minSetSize(std::vector<std::pair<int, int>> intervals) {
    std::sort(intervals.begin(), intervals.end());
    int n = intervals.size();
    int end = intervals[0].second;
    int count = 1;

    for (int i = 1; i < n; i++) {
        if (end < intervals[i].first) {
            end = intervals[i].second;
            count++;
        } else {
            end = std::min(end, intervals[i].second);
        }
    }
    return count * 2;
}

-----
#include <vector>
#include <algorithm>

int minSetSize(std::vector<std::pair<int, int>> intervals) 
    // Your code here
}

************************************
Question ID: 760

#include <vector>
#include <unordered_map>
using namespace std;

vector<int> anagramMappings(vector<int>& nums1, vector<int>& nums2) {
    unordered_map<int, int> num_map;
    for (int i = 0; i < nums2.size(); i++) {
        num_map[nums2[i]] = i;
    }
    vector<int> mapping(nums1.size());
    for (int i = 0; i < nums1.size(); i++) {
        mapping[i] = num_map[nums1[i]];
    }
    return mapping;
}


-----
#include <vector>
#include <unordered_map>
using namespace std;

vector<int> anagramMappings(vector<int>& nums1, vector<int>& nums2) 
    // Your code here
}


************************************
Question ID: 761

#include <string>
#include <vector>
#include <algorithm>

std::string makeLargestSpecial(std::string s) {
    int count = 0, i = 0;
    std::vector<std::string> subs;

    for (int j = 0; j < s.size(); j++) {
        if (s[j] == '1') count++;
        else count--;

        if (count == 0) {
            subs.push_back('1' + makeLargestSpecial(s.substr(i+1, j-i-1)) + '0');
            i = j + 1;
        }
    }

    std::sort(subs.rbegin(), subs.rend());
    std::string res;
    for (const auto& sub : subs) {
        res += sub;
    }
    return res;
}


-----
#include <string>
#include <vector>
#include <algorithm>

std::string makeLargestSpecial(std::string s) 
    // Your code here
}


************************************
Question ID: 762

#include <bitset>

bool isPrime(int n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    for (int i = 5; i * i <= n; i += 6)
        if (n % i == 0 || n % (i + 2) == 0) return false;
    return true;
}

int countPrimeSetBits(int left, int right) {
    int count = 0;
    for (int i = left; i <= right; ++i)
        count += isPrime(std::bitset<32>(i).count());
    return count;
}


-----
#include <bitset>

bool isPrime(int n) 
    // Your code here
}


************************************
Question ID: 763

#include <vector>
#include <string>
#include <unordered_map>

std::vector<int> partitionLabels(std::string s) {
    std::unordered_map<char, int> last;
    for (int i = 0; i < s.size(); i++) {
        last[s[i]] = i;
    }
    std::vector<int> ans;
    int j = 0, anchor = 0;
    for (int i = 0; i < s.size(); i++) {
        j = std::max(j, last[s[i]]);
        if (i == j) {
            ans.push_back(i - anchor + 1);
            anchor = i + 1;
        }
    }
    return ans;
}

-----
#include <vector>
#include <string>
#include <unordered_map>

std::vector<int> partitionLabels(std::string s) 
    // Your code here
}

************************************
Question ID: 764

#include <vector>
#include <queue>

using std::vector;
using std::queue;

class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};

vector<vector<int>> levelOrder(Node* root) {
    vector<vector<int>> result;
    if (root == nullptr) return result;

    queue<Node*> toVisit;
    toVisit.push(root);

    while (!toVisit.empty()) {
        int size = toVisit.size();
        vector<int> level;

        for (int i = 0; i < size; i++) {
            Node* currentNode = toVisit.front();
            toVisit.pop();
            level.push_back(currentNode->val);

            for (Node* child : currentNode->children) {
                toVisit.push(child);
            }
        }
        result.push_back(level);
    }

    return result;
}

-----
#include <vector>
#include <queue>

using std::vector;
using std::queue;

class Node 
    // Your code here
}

************************************
Question ID: 765

int minSwapsCouples(vector<int>& row) {
    int n = row.size();
    vector<int> position(n);
    for (int i = 0; i < n; ++i)
        position[row[i]] = i;

    int swaps = 0;
    for (int i = 0; i < n; i += 2) {
        int partner = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1;
        if (row[i + 1] != partner) {
            swap(row[position[partner]], row[i + 1]);
            swap(position[row[i + 1]], position[partner]);
            swaps++;
        }
    }
    return swaps;
}


-----
int minSwapsCouples(vector<int>& row) 
    // Your code here
}


************************************
Question ID: 767

#include <bitset>
#include <vector>

bool is_prime(int n) {
    if (n <= 1) return false;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) return false;
    }
    return true;
}

int count_prime_set_bits(int left, int right) {
    int count = 0;
    for (int i = left; i <= right; i++) {
        if (is_prime(std::bitset<32>(i).count())) count++;
    }
    return count;
}

-----
#include <bitset>
#include <vector>

bool is_prime(int n) 
    // Your code here
}

************************************
Question ID: 768

#include <vector>
#include <string>
#include <unordered_map>

std::vector<int> partitionLabels(const std::string& s) {
    std::unordered_map<char, int> lastPos;
    for (int i = 0; i < s.size(); i++) {
        lastPos[s[i]] = i;
    }

    std::vector<int> partitions;
    int start = 0, end = 0;
    for (int i = 0; i < s.size(); i++) {
        end = std::max(end, lastPos[s[i]]);
        if (i == end) {
            partitions.push_back(end - start + 1);
            start = i + 1;
        }
    }
    return partitions;
}


-----
#include <vector>
#include <string>
#include <unordered_map>

std::vector<int> partitionLabels(const std::string& s) 
    // Your code here
}


************************************
Question ID: 769

int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {
    vector<vector<int>> grid(n, vector<int>(n, 1));
    for (const auto& mine : mines)
        grid[mine[0]][mine[1]] = 0;
        
    vector<vector<int>> left(grid), right(grid), up(grid), down(grid);
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (grid[i][j]) {
                left[i][j] = j > 0 ? left[i][j - 1] + 1 : 1;
                up[i][j] = i > 0 ? up[i - 1][j] + 1 : 1;
            }
            if (grid[n - i - 1][n - j - 1]) {
                right[n - i - 1][n - j - 1] = j > 0 ? right[n - i - 1][n - j] + 1 : 1;
                down[n - i - 1][n - j - 1] = i > 0 ? down[n - i][n - j - 1] + 1 : 1;
            }
        }
    }

    int ans = 0;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            ans = max(ans, min({left[i][j], right[i][j], up[i][j], down[i][j]}));
    return ans;
}


-----
int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) 
    // Your code here
}


************************************
Question ID: 770

#include <vector>
#include <unordered_map>
using namespace std;

int minSwapsCouples(vector<int>& row) {
    int n = row.size() / 2;
    int swaps = 0;
    unordered_map<int, int> position;

    for (int i = 0; i < row.size(); i++) {
        position[row[i]] = i;
    }

    for (int i = 0; i < row.size(); i += 2) {
        int couple = (row[i] % 2 == 0) ? row[i] + 1 : row[i] - 1;
        if (row[i + 1] != couple) {
            swap(row[i + 1], row[position[couple]]);
            swap(position[row[i + 1]], position[couple]);
            swaps++;
        }
    }
    return swaps;
}

-----
#include <vector>
#include <unordered_map>
using namespace std;

int minSwapsCouples(vector<int>& row) 
    // Your code here
}

************************************
Question ID: 771

int numJewelsInStones(string jewels, string stones) {
    int count = 0;
    for (char stone : stones) {
        if (jewels.find(stone) != std::string::npos) {
            count++;
        }
    }
    return count;
}

-----
int numJewelsInStones(string jewels, string stones) 
    // Your code here
}

************************************
Question ID: 777

bool isToeplitzMatrix(vector<vector<int>>& matrix) {
    int rows = matrix.size();
    int cols = matrix[0].size();
    for(int i = 0; i < rows - 1; ++i) {
        for(int j = 0; j < cols - 1; ++j) {
            if(matrix[i][j] != matrix[i+1][j+1]) return false;
        }
    }
    return true;
}


-----
bool isToeplitzMatrix(vector<vector<int>>& matrix) 
    // Your code here
}


************************************
Question ID: 778

#include <queue>

std::string rearrangeString(std::string s) {
    std::unordered_map<char, int> counts;
    for (char c : s) {
        counts[c]++;
    }
    
    auto cmp = [](const auto& a, const auto& b) {
        return a.second < b.second;
    };
    
    std::priority_queue<std::pair<char, int>, std::vector<std::pair<char, int>>, decltype(cmp)> pq(cmp);
    
    for (auto& count : counts) {
        pq.push(count);
    }
    
    std::string result;
    std::pair<char, int> previous = {-1, 0};
    
    while (!pq.empty()) {
        auto current = pq.top();
        pq.pop();
        result += current.first;
        
        if (previous.second > 0) {
            pq.push(previous);
        }
        
        current.second--;
        previous = current;
    }
    
    return result.size() == s.size() ? result : "";
}


-----
#include <queue>

std::string rearrangeString(std::string s) 
    // Your code here
}


************************************
Question ID: 779

int maxChunksToSorted(vector<int>& arr) {
    int max_val = 0, chunks = 0;
    for (int i = 0; i < arr.size(); ++i) {
        max_val = max(max_val, arr[i]);
        if (max_val == i) {
            chunks++;
        }
    }
    return chunks;
}

-----
int maxChunksToSorted(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 780

int maxChunksToSorted(vector<int>& arr) {
    int max_so_far = 0, count = 0;
    for (int i = 0; i < arr.size(); i++) {
        max_so_far = max(max_so_far, arr[i]);
        if (max_so_far == i) {
            count++;
        }
    }
    return count;
}


-----
int maxChunksToSorted(vector<int>& arr) 
    // Your code here
}


************************************
Question ID: 781

#include <vector>
#include <unordered_map>
using namespace std;

int numRabbits(vector<int>& answers) {
    unordered_map<int, int> count;
    int rabbits = 0;
    for (int ans : answers) {
        count[ans]++;
    }
    for (auto& [ans, cnt] : count) {
        rabbits += (ans + cnt) / (ans + 1) * (ans + 1);
    }
    return rabbits;
}


-----
#include <vector>
#include <unordered_map>
using namespace std;

int numRabbits(vector<int>& answers) 
    // Your code here
}


************************************
Question ID: 782

int numJewelsInStones(string jewels, string stones) {
    int count = 0;
    for (char s : stones) {
        if (jewels.find(s) != string::npos) {
            count++;
        }
    }
    return count;
}

-----
int numJewelsInStones(string jewels, string stones) 
    // Your code here
}

************************************
Question ID: 785

#include <vector>
using namespace std;

bool dfs(int node, int color, vector<int>& colors, vector<vector<int>>& graph) {
    if (colors[node] != 0) {
        return colors[node] == color;
    }

    colors[node] = color;
    for (int neighbor : graph[node]) {
        if (!dfs(neighbor, 3 - color, colors, graph)) {
            return false;
        }
    }

    return true;
}

bool isBipartite(vector<vector<int>>& graph) {
    int n = graph.size();
    vector<int> colors(n, 0);

    for (int i = 0; i < n; ++i) {
        if (colors[i] == 0 && !dfs(i, 1, colors, graph)) {
            return false;
        }
    }

    return true;
}

-----
#include <vector>
using namespace std;

bool dfs(int node, int color, vector<int>& colors, vector<vector<int>>& graph) 
    // Your code here
}

************************************
Question ID: 786

#include <vector>
#include <queue>
using namespace std;

vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {
    auto compare = [&](pair<int, int>& a, pair<int, int>& b) {
        return arr[a.first] * arr[b.second] > arr[a.second] * arr[b.first];
    };
    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(compare)> pq(compare);
    for (int i = 0; i < arr.size() - 1; ++i) {
        pq.push({i, arr.size() - 1});
    }
    for (int i = 0; i < k - 1; ++i) {
        auto [row, col] = pq.top();
        pq.pop();
        if (--col > row) {
            pq.push({row, col});
        }
    }
    return {arr[pq.top().first], arr[pq.top().second]};
}

-----
#include <vector>
#include <queue>
using namespace std;

vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) 
    // Your code here
}

************************************
Question ID: 787

#include <vector>
#include <queue>
#include <string>

using namespace std;

int slidingPuzzle(vector<vector<int>>& board) {
    int m = 2, n = 3;
    string target = "123450";
    string start = "";
    for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j)
            start += to_string(board[i][j]);
    vector<vector<int>> dirs{{1, 3}, {0, 2, 4}, {1, 5}, {0, 4}, {1, 3, 5}, {2, 4}};
    queue<string> q{{start}};
    int res = 0;
    unordered_set<string> visited{start};
    while (!q.empty()) {
        for (int k = q.size(); k > 0; --k) {
            string cur = q.front(); q.pop();
            if (cur == target) return res;
            int zero_idx = cur.find("0");
            for (int dir : dirs[zero_idx]) {
                string neighbor = cur;
                swap(neighbor[zero_idx], neighbor[dir]);
                if (!visited.count(neighbor)) {
                    visited.insert(neighbor);
                    q.push(neighbor);
                }
            }
        }
        ++res;
    }
    return -1;
}

-----
#include <vector>
#include <queue>
#include <string>

using namespace std;

int slidingPuzzle(vector<vector<int>>& board) 
    // Your code here
}

************************************
Question ID: 788

int rotatedDigits(int n) {
    int count = 0;
    for (int i = 1; i <= n; i++) {
        if (isGood(i))
            count++;
    }
    return count;
}

bool isGood(int num) {
    bool changed = false;
    while (num) {
        int digit = num % 10;
        if (digit == 3 || digit == 4 || digit == 7) return false;
        if (digit == 2 || digit == 5 || digit == 6 || digit == 9) changed = true;
        num /= 10;
    }
    return changed;
}

-----
int rotatedDigits(int n) 
    // Your code here
}

************************************
Question ID: 789

#include <queue>
#include <vector>

class KthLargest {
public:
    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;
    int k;

    KthLargest(int k, std::vector<int>& nums) {
        this->k = k;
        for (int num : nums) {
            add(num);
        }
    }
    
    int add(int val) {
        minHeap.push(val);
        if (minHeap.size() > k) {
            minHeap.pop();
        }
        return minHeap.top();
    }
};

-----
#include <queue>
#include <vector>

class KthLargest 
    // Your code here
};

************************************
Question ID: 790

bool isIdealPermutation(vector<int>& nums) {
    for (int i = 0; i < nums.size(); ++i) {
        if (abs(nums[i] - i) > 1) {
            return false;
        }
    }
    return true;
}


-----
bool isIdealPermutation(vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 791

#include <algorithm>
#include <string>
#include <unordered_map>

std::string customSortString(const std::string& order, std::string& s) {
    std::unordered_map<char, int> priority;
    for (int i = 0; i < order.size(); i++) {
        priority[order[i]] = i;
    }

    std::sort(s.begin(), s.end(), [&](char a, char b) {
        return priority[a] < priority[b];
    });

    return s;
}

-----
#include <algorithm>
#include <string>
#include <unordered_map>

std::string customSortString(const std::string& order, std::string& s) 
    // Your code here
}

************************************
Question ID: 792

int search(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;
}


-----
int search(vector<int>& nums, int target) 
    // Your code here
}


************************************
Question ID: 793

bool canTransform(string start, string end) {
    if (start.size() != end.size()) return false;

    int i = 0, j = 0;
    int n = start.size();
    while (i < n && j < n) {
        while (i < n && start[i] == 'X') i++;
        while (j < n && end[j] == 'X') j++;

        if (start[i] != end[j]) return false;

        if ((start[i] == 'R' && i > j) || (start[i] == 'L' && i < j)) return false;

        i++; j++;
    }
    return true;
}

-----
bool canTransform(string start, string end) 
    // Your code here
}

************************************
Question ID: 794

#include <queue>
#include <vector>
#include <utility>

using namespace std;

int swim(int n, vector<vector<int>>& grid) {
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    vector<vector<bool>> visited(n, vector<bool>(n, false));
    
    pq.push({grid[0][0], 0});

    int dr[] = {-1, 0, 1, 0};
    int dc[] = {0, 1, 0, -1};

    while (!pq.empty()) {
        int curR = pq.top().second / n;
        int curC = pq.top().second % n;
        int curT = pq.top().first;
        pq.pop();

        if (curR == n - 1 && curC == n - 1) return curT;

        for (int d = 0; d < 4; d++) {
            int newRow = curR + dr[d];
            int newCol = curC + dc[d];
            if (0 <= newRow && newRow < n && 0 <= newCol && newCol < n && !visited[newRow][newCol]) {
                visited[newRow][newCol] = true;
                pq.push({max(curT, grid[newRow][newCol]), newRow * n + newCol});
            }
        }
    }
    return -1;
}

-----
#include <queue>
#include <vector>
#include <utility>

using namespace std;

int swim(int n, vector<vector<int>>& grid) 
    // Your code here
}

************************************
Question ID: 795

int kthSymbolInGrammar(int n, int k) {
    if (n == 1) return 0;
    if (k % 2 == 0) return 1 - kthSymbolInGrammar(n - 1, k / 2);
    else return kthSymbolInGrammar(n - 1, (k + 1) / 2);
}

-----
int kthSymbolInGrammar(int n, int k) 
    // Your code here
}

************************************
Question ID: 796

bool canTransform(int sx, int sy, int tx, int ty) {
    while (sx != tx || sy != ty) {
        if (sx > tx || sy > ty) return false;
        if (sx < tx) {
            tx -= ty;
        } else {
            ty -= sx;
        }
    }
    return true;
}

-----
bool canTransform(int sx, int sy, int tx, int ty) 
    // Your code here
}

************************************
Question ID: 797

#include <unordered_map>
int numRabbits(vector<int>& answers) {
    unordered_map<int, int> count;
    int res = 0;
    for (int a : answers) {
        ++count[a];
        if (count[a] == 1) {
            res += (a + 1);
        } else if (count[a] > a + 1) {
            count[a] = 1;
            res += (a + 1);
        }
    }
    return res;
}


-----
#include <unordered_map>
int numRabbits(vector<int>& answers) 
    // Your code here
}


************************************
Question ID: 798

#include <bitset>
#include <vector>

int movesToChessboard(std::vector<std::vector<int>>& board) {
  int N = board.size();
  std::bitset<30> row, col;

  for (int i = 0; i < N; ++i)
    for (int j = 0; j < N; ++j)
      if (board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j])
        return -1;

  for (int i = 0; i < N; ++i) {
    row.flip(i);
    col.flip(i);
  }

  int c = board[0] & col;
  int d = row.count() - row.count() & col;
  int max_count = max(c, d);

  if (max_count == N) return 0;

  if (N & 1) return max_count & 1 ? max_count / 2 : max_count / 2 + 1;
  else return max_count / 2;
}

-----
#include <bitset>
#include <vector>

int movesToChessboard(std::vector<std::vector<int>>& board) 
    // Your code here
}

************************************
Question ID: 800

#include <vector>
#include <string>

void backtrack(std::string s, int index, std::vector<std::string>& result) {
    if (index == s.length()) {
        result.push_back(s);
        return;
    }
    backtrack(s, index + 1, result);
    if (isalpha(s[index])) {
        s[index] ^= (1 << 5);
        backtrack(s, index + 1, result);
    }
}

std::vector<std::string> letterCasePermutation(std::string s) {
    std::vector<std::string> result;
    backtrack(s, 0, result);
    return result;
}

-----
#include <vector>
#include <string>

void backtrack(std::string s, int index, std::vector<std::string>& result) 
    // Your code here
}

************************************
Question ID: 801

#include <vector>
#include <queue>

bool isBipartite(std::vector<std::vector<int>>& graph) {
    std::vector<int> colors(graph.size(), 0);
    for(int i = 0; i < graph.size(); i++){
        if(colors[i] != 0) continue;
        colors[i] = 1;
        std::queue<int> q;
        q.push(i);
        while(!q.empty()){
            int node = q.front(); q.pop();
            for(int neighbor : graph[node]){
                if(colors[neighbor] == 0){
                    colors[neighbor] = -colors[node];
                    q.push(neighbor);
                } else if(colors[neighbor] == colors[node]){
                    return false;
                }
            }
        }
    }
    return true;
}


-----
#include <vector>
#include <queue>

bool isBipartite(std::vector<std::vector<int>>& graph) 
    // Your code here
}


************************************
Question ID: 802

#include <vector>
#include <queue>

std::vector<int> kthSmallestPrimeFraction(std::vector<int>& arr, int k) {
    auto compare = [&](const std::pair<int, int>& a, const std::pair<int, int>& b) {
        return (long long)arr[a.first] * arr[b.second] > (long long)arr[a.second] * arr[b.first];
    };

    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, decltype(compare)> pq(compare);

    for (int i = 0; i < arr.size() - 1; ++i) {
        pq.push({i, arr.size() - 1});
    }

    for (int i = 1; i < k; ++i) {
        auto curr = pq.top();
        pq.pop();
        curr.second--;
        if (curr.first < curr.second) {
            pq.push(curr);
        }
    }

    return {arr[pq.top().first], arr[pq.top().second]};
}

-----
#include <vector>
#include <queue>

std::vector<int> kthSmallestPrimeFraction(std::vector<int>& arr, int k) 
    // Your code here
}

************************************
Question ID: 803

#include <vector>
#include <queue>
using namespace std;

int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
    vector<vector<pair<int, int>>> graph(n);
    for (auto& flight : flights)
        graph[flight[0]].push_back({flight[1], flight[2]});
        
    priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
    pq.push({0, src, k + 1});
    
    while (!pq.empty()) {
        auto info = pq.top(); pq.pop();
        int price = info[0], city = info[1], stops = info[2];
        
        if (city == dst)
            return price;
        
        if (stops > 0) {
            for (auto& p : graph[city])
                pq.push({price + p.second, p.first, stops - 1});
        }
    }
    
    return -1;
}


-----
#include <vector>
#include <queue>
using namespace std;

int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) 
    // Your code here
}


************************************
Question ID: 804

int rotatedDigits(int n) {
    int count = 0;
    for (int i = 1; i <= n; ++i) {
        bool is_valid_after_rotation = true;
        bool is_different_after_rotation = false;
        int num = i;
        while (num != 0) {
            int digit = num % 10;
            if (digit == 3 || digit == 4 || digit == 7) {
                is_valid_after_rotation = false;
                break;
            }
            if (digit == 2 || digit == 5 || digit == 6 || digit == 9) {
                is_different_after_rotation = true;
            }
            num /= 10;
        }
        if (is_valid_after_rotation && is_different_after_rotation) {
            count++;
        }
    }
    return count;
}

-----
int rotatedDigits(int n) 
    // Your code here
}

************************************
Question ID: 805

#include <vector>
#include <algorithm>
#include <cmath>

bool escapeGhosts(std::vector<std::vector<int>>& ghosts, std::vector<int>& target) {
    int max_dist = std::abs(target[0]) + std::abs(target[1]);
    for (const auto& ghost : ghosts) {
        int ghost_dist = std::abs(ghost[0] - target[0]) + std::abs(ghost[1] - target[1]);
        if (ghost_dist <= max_dist) {
            return false;
        }
    }
    return true;
}


-----
#include <vector>
#include <algorithm>
#include <cmath>

bool escapeGhosts(std::vector<std::vector<int>>& ghosts, std::vector<int>& target) 
    // Your code here
}


************************************
Question ID: 806

```c++
int numberOfWays(int n) {
    int MOD = 1000000007;
    vector<int> dp(n + 1, 0);
    dp[0] = 1;
    dp[1] = 1;

    for (int i = 2; i <= n; ++i)
        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD;

    return dp[n];
}


-----
```c++
int numberOfWays(int n) 
    // Your code here
}


************************************
Question ID: 807

#include <algorithm>
#include <string>
using namespace std;

string customSortString(string order, string s) {
    sort(s.begin(), s.end(), [&](char a, char b) { return order.find(a) < order.find(b); });
    return s;
}


-----
#include <algorithm>
#include <string>
using namespace std;

string customSortString(string order, string s) 
    // Your code here
}


************************************
Question ID: 808

#include <string>
#include <vector>

int numMatchingSubseq(const std::string& s, const std::vector<std::string>& words) {
    std::vector<std::vector<int>> positions(26);

    for (int i = 0; i < s.size(); ++i) {
        positions[s[i] - 'a'].push_back(i);
    }

    int count = 0;

    for (const auto& word : words) {
        int index = -1;
        bool isSubsequence = true;

        for (const char& c : word) {
            auto it = std::upper_bound(positions[c - 'a'].begin(), positions[c - 'a'].end(), index);
            if (it == positions[c - 'a'].end()) {
                isSubsequence = false;
                break;
            }
            index = *it;
        }

        if (isSubsequence) {
            ++count;
        }
    }
    
    return count;
}

-----
#include <string>
#include <vector>

int numMatchingSubseq(const std::string& s, const std::vector<std::string>& words) 
    // Your code here
}

************************************
Question ID: 809

int num_zeros(int k) {
    int x = 0;
    for (int i = 5; k / i >= 1; i *= 5) {
        x += k / i;
    }
    return x;
}

-----
int num_zeros(int k) 
    // Your code here
}

************************************
Question ID: 810

bool validTicTacToe(std::vector<std::string> &board) {
    int xCount = 0, oCount = 0;
    for (const std::string& row : board) {
        for (char c : row) {
            if (c == 'X') xCount++;
            else if (c == 'O') oCount++;
        }
    }
    if (xCount != oCount && xCount != oCount + 1) return false;

    bool xWin = false, oWin = false;
    for (int i = 0; i < 3; ++i) {
        if (board[i][0] == board[i][1] && board[i][1] == board[i][2])
            board[i][0] == 'X' ? xWin = true : (board[i][0] == 'O' ? oWin = true : 0);
        if (board[0][i] == board[1][i] && board[1][i] == board[2][i])
            board[0][i] == 'X' ? xWin = true : (board[0][i] == 'O' ? oWin = true : 0);
    }
    if (board[0][0] == board[1][1] && board[1][1] == board[2][2])
        board[0][0] == 'X' ? xWin = true : (board[0][0] == 'O' ? oWin = true : 0);
    if (board[0][2] == board[1][1] && board[1][1] == board[2][0])
        board[0][2] == 'X' ? xWin = true : (board[0][2] == 'O' ? oWin = true : 0);
    
    if (xWin && oWin) return false;
    if (xWin && xCount == oCount) return false;
    if (oWin && xCount > oCount) return false;

    return true;
}

-----
bool validTicTacToe(std::vector<std::string> &board) 
    // Your code here
}

************************************
Question ID: 811

int numSubarrayBoundedMax(vector<int>& nums, int left, int right) {
    int result = 0, prev = 0, start = -1;
    for (int i = 0; i < nums.size(); ++i) {
        if (nums[i] >= left && nums[i] <= right) {
            prev = i - start;
            result += prev;
        } else if (nums[i] < left) {
            result += prev;
        } else {
            start = i;
            prev = 0;
        }
    }
    return result;
}


-----
int numSubarrayBoundedMax(vector<int>& nums, int left, int right) 
    // Your code here
}


************************************
Question ID: 812

bool isShifted(string s, string goal) {
    if(s.length() != goal.length()) return false;

    s = s + s;
    return s.find(goal) != string::npos;
}

-----
bool isShifted(string s, string goal) 
    // Your code here
}

************************************
Question ID: 813

#include <vector>
using namespace std;

void DFS(vector<vector<int>>& graph, vector<vector<int>>& result, vector<int>& path, int currentNode) {
    path.push_back(currentNode);
    if (currentNode == graph.size()-1) {
        result.push_back(path);
    } else {
        for (int neighbor : graph[currentNode]) {
            DFS(graph, result, path, neighbor);
        }
    }
    path.pop_back();
}

vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
    vector<vector<int>> result;
    vector<int> path;
    DFS(graph, result, path, 0);
    return result;
}

-----
#include <vector>
using namespace std;

void DFS(vector<vector<int>>& graph, vector<vector<int>>& result, vector<int>& path, int currentNode) 
    // Your code here
}

************************************
Question ID: 814

#include <vector>

int best_rotation(std::vector<int>& nums) {
    int n = nums.size();
    std::vector<int> change(n, 0);

    for (int i = 0; i < n; ++i) {
        change[(i - nums[i] + 1 + n) % n] -= 1;
        change[(i + 1) % n] += 1;
    }

    int max_score = 0;
    for (int i = 1, cur_score = change[0]; i < n; ++i) {
        cur_score += change[i];
        if (cur_score > max_score) {
            max_score = cur_score;
        }
    }
    return max_score;
}

-----
#include <vector>

int best_rotation(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 815

#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <queue>

int numBusesToDestination(std::vector<std::vector<int>>& routes, int source, int target) {
    if (source == target) return 0;

    std::unordered_map<int, std::unordered_set<int>> stop_route_map;
    for (int i = 0; i < routes.size(); ++i) {
        for (int stop : routes[i]) {
            stop_route_map[stop].insert(i);
        }
    }

    std::queue<int> q;
    std::unordered_set<int> visited_sources;

    q.push(source);
    visited_sources.insert(source);
    int transfers = 0;

    while (!q.empty()) {
        int size = q.size();
        while (size--) {
            int curr = q.front();
            q.pop();
            if (curr == target) return transfers;

            for (int route : stop_route_map[curr]) {
                for (int stop : routes[route]) {
                    if (visited_sources.count(stop) == 0) {
                        q.push(stop);
                        visited_sources.insert(stop);
                    }
                }
                stop_route_map[curr].erase(route);
            }
        }
        transfers++;
    }
    return -1;
}

-----
#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <queue>

int numBusesToDestination(std::vector<std::vector<int>>& routes, int source, int target) 
    // Your code here
}

************************************
Question ID: 818

int racecar(int target) {
    unordered_map<int, unordered_map<int, int>> memo;
    function<int(int, int)> dp = [&](int pos, int speed) {
        if (abs(pos) > 2 * target) return target + 1;
        if (pos == target) return speed == 1 ? 0 : 1;
        if (memo[pos][speed]) return memo[pos][speed];
        int ans = (speed > 0 ? dp(pos + speed / 2, -speed / 2) : dp(pos - speed / 2, -speed / 2)) + 1;
        ans = min(ans, dp(pos + speed, speed * 2) + 1);
        return memo[pos][speed] = ans;
    };
    return dp(0, 1);
}

-----
int racecar(int target) 
    // Your code here
}

************************************
Question ID: 819

int minSwaps(vector<int>& nums1, vector<int>& nums2) {
    int n = nums1.size();
    vector<int> noSwap(n, INT_MAX);
    vector<int> doSwap(n, INT_MAX);
    noSwap[0] = 0;
    doSwap[0] = 1;

    for (int i = 1; i < n; i++) {
        if (nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) {
            noSwap[i] = noSwap[i - 1];
            doSwap[i] = doSwap[i - 1] + 1;
        }
        if (nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1]) {
            noSwap[i] = min(noSwap[i], doSwap[i - 1]);
            doSwap[i] = min(doSwap[i], noSwap[i - 1] + 1);
        }
    }

    return min(noSwap[n - 1], doSwap[n - 1]);
}

-----
int minSwaps(vector<int>& nums1, vector<int>& nums2) 
    // Your code here
}

************************************
Question ID: 820

#include <vector>

std::vector<int> eventualSafeNodes(std::vector<std::vector<int>>& graph) {
    int n = graph.size();
    std::vector<int> color(n, 0);
    std::vector<int> ans;

    bool hasCycle(int node, std::vector<int>& color, std::vector<std::vector<int>>& graph) {
        if (color[node] > 0)
            return color[node] == 1;
        color[node] = 1;
        for (int neighbor : graph[node]) {
            if (hasCycle(neighbor, color, graph))
                return true;
        }
        color[node] = 2;
        return false;
    }

    for (int i = 0; i < n; ++i) {
        if (!hasCycle(i, color, graph))
            ans.push_back(i);
    }
    return ans;
}

-----
#include <vector>

std::vector<int> eventualSafeNodes(std::vector<std::vector<int>>& graph) 
    // Your code here
}

************************************
Question ID: 821

#include <vector>

std::vector<int> hitBricks(std::vector<std::vector<int>>& grid, std::vector<std::vector<int>>& hits) {
    const int m = grid.size(), n = grid[0].size();
    std::vector<int> result;
    std::vector<std::vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

    for (const auto& hit : hits) {
        grid[hit[0]][hit[1]]--;
    }

    function<int(int, int)> dfs = [&](int x, int y) {
        if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] <= 0) {
            return 0;
        }
        grid[x][y] = -1;
        int sum = 1;
        for (const auto& d : directions) {
            sum += dfs(x + d[0], y + d[1]);
        }
        return sum;
    };

    for (int i = 0; i < n; ++i) {
        if (grid[0][i] == 1) {
            dfs(0, i);
        }
    }

    for (const auto& hit : hits) {
        grid[hit[0]][hit[1]]++;
        if (grid[hit[0]][hit[1]] != 1) {
            result.push_back(0);
            continue;
        }
        for (const auto& d : directions) {
            if (dfs(hit[0] + d[0], hit[1] + d[1])) {
                result.push_back(dfs(hit[0], hit[1]) - 1);
                break;
            }
        }
    }

    return result;
}

-----
#include <vector>

std::vector<int> hitBricks(std::vector<std::vector<int>>& grid, std::vector<std::vector<int>>& hits) 
    // Your code here
}

************************************
Question ID: 822

#include <unordered_set>
#include <vector>
#include <string>

int uniqueMorseRepresentations(std::vector<std::string>& words) {
    std::vector<std::string> morse = {".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};
    std::unordered_set<std::string> transformations;

    for (const auto& word : words) {
        std::string morseCode;
        for (char c : word) {
            morseCode += morse[c - 'a'];
        }
        transformations.insert(morseCode);
    }

    return transformations.size();
}

-----
#include <unordered_set>
#include <vector>
#include <string>

int uniqueMorseRepresentations(std::vector<std::string>& words) 
    // Your code here
}

************************************
Question ID: 823

bool isPossibleToSplit(const vector<int>& nums) {
    int n = nums.size();
    int total_sum = accumulate(nums.begin(), nums.end(), 0);
    
    if (total_sum % n != 0) return false;

    int target_sum = total_sum * (n / 2) / n;
    vector<vector<bool>> dp(n / 2 + 1, vector<bool>(target_sum + 1, false));
    dp[0][0] = true;

    for (int num : nums) {
        for (int count = n / 2; count >= 1; --count) {
            for (int sum = target_sum; sum >= num; --sum) {
                dp[count][sum] = dp[count][sum] || dp[count - 1][sum - num];
            }
        }
        if (dp[n / 2][target_sum]) return true;
    }

    return false;
}


-----
bool isPossibleToSplit(const vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 824

#include <vector>
#include <string>
std::vector<int> numberOfLines(std::vector<int>& widths, std::string s) {
    int lines = 1;
    int currentPixel = 0;
    for (char c : s) {
        int letterPixels = widths[c - 'a'];
        if (currentPixel + letterPixels > 100) {
            lines++;
            currentPixel = 0;
        }
        currentPixel += letterPixels;
    }
    return {lines, currentPixel};
}


-----
#include <vector>
#include <string>
std::vector<int> numberOfLines(std::vector<int>& widths, std::string s) 
    // Your code here
}


************************************
Question ID: 825

int maxIncreaseKeepingSkyline(vector<vector<int>>& grid) {
    int n = grid.size();
    vector<int> row_max(n, 0);
    vector<int> col_max(n, 0);
    
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            row_max[i] = max(row_max[i], grid[i][j]);
            col_max[j] = max(col_max[j], grid[i][j]);
        }
    }
    
    int total_sum = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            total_sum += min(row_max[i], col_max[j]) - grid[i][j];
        }
    }
    
    return total_sum;
}

-----
int maxIncreaseKeepingSkyline(vector<vector<int>>& grid) 
    // Your code here
}

************************************
Question ID: 826

#include <vector>
#include <algorithm>

int maxProfitAssignment(std::vector<int>& difficulty, std::vector<int>& profit, std::vector<int>& worker) {
    int n = difficulty.size();
    std::vector<std::pair<int, int>> jobs(n);

    for (int i = 0; i < n; ++i) {
        jobs[i] = {difficulty[i], profit[i]};
    }

    std::sort(jobs.begin(), jobs.end());
    std::sort(worker.begin(), worker.end());

    int max_profit = 0;
    int total_profit = 0;
    int job_idx = 0;

    for (int w : worker) {
        while (job_idx < n && w >= jobs[job_idx].first) {
            max_profit = std::max(max_profit, jobs[job_idx].second);
            job_idx++;
        }
        total_profit += max_profit;
    }

    return total_profit;
}

-----
#include <vector>
#include <algorithm>

int maxProfitAssignment(std::vector<int>& difficulty, std::vector<int>& profit, std::vector<int>& worker) 
    // Your code here
}

************************************
Question ID: 827

int maxAreaOfIsland(vector<vector<int>>& grid)
{
    function<int(int, int)> dfs = [&](int x, int y) {
        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == 0) {
            return 0;
        }
        grid[x][y] = 0;
        return dfs(x - 1, y) + dfs(x + 1, y) + dfs(x, y - 1) + dfs(x, y + 1) + 1;
    };

    int ans = 0;
    for (int i = 0; i < grid.size(); ++i)
        for (int j = 0; j < grid[i].size(); ++j)
            if (grid[i][j] == 0) {
                grid[i][j] = 1;
                ans = max(ans, dfs(i, j));
                grid[i][j] = 0;
            }
    return ans;
}

-----
int maxAreaOfIsland(vector<vector<int>>& grid)

    // Your code here
}

************************************
Question ID: 828

bool xorGame(const std::vector<int>& nums) {
    int xorSum = 0;
    for (int num : nums) {
        xorSum ^= num;
    }
    return xorSum == 0 || nums.size() % 2 == 0;
}

-----
bool xorGame(const std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 829

#include <string>
#include <vector>
#include <unordered_map>
using namespace std;

vector<string> subdomainVisits(vector<string>& cpdomains) {
    unordered_map<string, int> counts;
    vector<string> result;

    for (const string& cpdomain : cpdomains) {
        int index = cpdomain.find(' ');
        int count = stoi(cpdomain.substr(0, index));
        string domain = cpdomain.substr(index + 1);

        for (int i = 0; i < domain.size(); ++i) {
            if (domain[i] == '.') {
                counts[domain.substr(i + 1)] += count;
            }
        }
        counts[domain] += count;
    }

    for (const auto& pair : counts) {
        result.push_back(to_string(pair.second) + ' ' + pair.first);
    }

    return result;
}


-----
#include <string>
#include <vector>
#include <unordered_map>
using namespace std;

vector<string> subdomainVisits(vector<string>& cpdomains) 
    // Your code here
}


************************************
Question ID: 830

#include <vector>
#include <algorithm>
using namespace std;

double largestTriangleArea(vector<vector<int>>& points) {
    double max_area = 0.0;
    for (int i = 0; i < points.size(); ++i) {
        for (int j = i + 1; j < points.size(); ++j) {
            for (int k = j + 1; k < points.size(); ++k) {
                max_area = max(max_area, 0.5 * abs(points[i][0] * (points[j][1] - points[k][1])
                                                  + points[j][0] * (points[k][1] - points[i][1])
                                                  + points[k][0] * (points[i][1] - points[j][1])));
            }
        }
    }
    return max_area;
}

-----
#include <vector>
#include <algorithm>
using namespace std;

double largestTriangleArea(vector<vector<int>>& points) 
    // Your code here
}

************************************
Question ID: 832

TreeNode* pruneTree(TreeNode* root) {
    if (!root) return nullptr;
    root->left = pruneTree(root->left);
    root->right = pruneTree(root->right);
    if (root->val == 0 && !root->left && !root->right) return nullptr;
    return root;
}

-----
TreeNode* pruneTree(TreeNode* root) 
    // Your code here
}

************************************
Question ID: 833

#include <vector>
#include <unordered_set>
#include <queue>

int numBusesToDestination(std::vector<std::vector<int>>& routes, int source, int target) {
    if (source == target) return 0;

    std::unordered_map<int, std::unordered_set<int>> stopToBuses;
    for (int i = 0; i < routes.size(); ++i) {
        for (int stop : routes[i]) {
            stopToBuses[stop].insert(i);
        }
    }

    std::queue<int> q;
    std::unordered_set<int> visitedBuses;
    int numBuses = 0;
    q.push(source);

    while (!q.empty()) {
        int size = q.size();
        while (size--) {
            int stop = q.front();
            q.pop();
            for (int bus : stopToBuses[stop]) {
                if (visitedBuses.count(bus)) continue;
                visitedBuses.insert(bus);
                for (int nextStop : routes[bus]) {
                    if (nextStop == target) return numBuses + 1;
                    q.push(nextStop);
                }
            }
        }
        numBuses++;
    }

    return -1;
}

-----
#include <vector>
#include <unordered_set>
#include <queue>

int numBusesToDestination(std::vector<std::vector<int>>& routes, int source, int target) 
    // Your code here
}

************************************
Question ID: 834

#include <vector>
#include <string>

std::vector<std::string> ambiguousCoordinates(std::string s) {
    int n = s.size();
    std::vector<std::string> res;
    
    for (int i = 2; i < n - 1; ++i) {
        auto first = generateNumber(s.substr(1, i - 1));
        auto second = generateNumber(s.substr(i, n - 1 - i));
        
        for (const auto& f : first) {
            for (const auto& sec : second) {
                res.push_back("(" + f + ", " + sec + ")");
            }
        }
    }
    return res;
}

std::vector<std::string> generateNumber(const std::string& s) {
    int n = s.size();
    std::vector<std::string> res;
    
    if (n == 0 || (n > 1 && s[0] == '0' && s[n - 1] == '0')) return res;
    if (n > 1 && s[0] == '0') {
        res.push_back("0." + s.substr(1));
        return res;
    }
    res.push_back(s);
    if (n == 1 || s[n - 1] == '0') return res;
    
    for (int i = 1; i < n; ++i) {
        res.push_back(s.substr(0, i) + "." + s.substr(i));
    }
    return res;
}


-----
#include <vector>
#include <string>

std::vector<std::string> ambiguousCoordinates(std::string s) 
    // Your code here
}


************************************
Question ID: 836

int racecar(int target) {
    unordered_map<int, unordered_map<int, int>> memo;
    function<int(int, int)> dp = [&](int pos, int speed) {
        if (pos == target) return 0;
        if (abs(pos) > 2 * target) return INT_MAX;

        int &ans = memo[pos][speed];
        if (ans) return ans;

        if (speed == -1) {
            int op1 = dp(pos + speed, 2 * speed) + 1;
            int op2 = dp(pos, -speed) + 2;

            ans = min(op1, op2);
        } else {
            int op1 = dp(pos - speed, -2 * speed) + 1;
            int op2 = dp(pos, -speed) + 2;

            ans = min(op1, op2);
        }

        return ans;
    };

    return dp(0, target) + 1;
}

-----
int racecar(int target) 
    // Your code here
}

************************************
Question ID: 837

#include <string>
#include <vector>
#include <unordered_map>
#include <algorithm>
#include <cctype>

std::string mostCommonWord(std::string paragraph, std::vector<std::string>& banned) {
    std::unordered_map<std::string, int> wordCount;
    std::string currentWord;
    for (char c : paragraph) {
        if (isalpha(c)) {
            currentWord.push_back(tolower(c));
        } else if (!currentWord.empty()) {
            wordCount[currentWord]++;
            currentWord.clear();
        }
    }

    if (!currentWord.empty()) {
        wordCount[currentWord]++;
    }

    for (std::string &ban : banned) {
        transform(ban.begin(), ban.end(), ban.begin(), ::tolower);
        wordCount[ban] = 0;
    }

    return std::max_element(wordCount.begin(), wordCount.end(), [](const auto &a, const auto &b) {
        return a.second < b.second;
    })->first;
}


-----
#include <string>
#include <vector>
#include <unordered_map>
#include <algorithm>
#include <cctype>

std::string mostCommonWord(std::string paragraph, std::vector<std::string>& banned) 
    // Your code here
}


************************************
Question ID: 838

string pushDominoes(string dominoes) {
    int n = dominoes.size();
    vector<int> forces(n, 0);
    
    int force = 0;
    for (int i = 0; i < n; ++i) {
        if (dominoes[i] == 'R') force = n;
        else if (dominoes[i] == 'L') force = 0;
        else force = max(force - 1, 0);
        forces[i] += force;
    }
    
    force = 0;
    for (int i = n - 1; i >= 0; --i) {
        if (dominoes[i] == 'L') force = n;
        else if (dominoes[i] == 'R') force = 0;
        else force = max(force - 1, 0);
        forces[i] -= force;
    }
    
    string result = "";
    for (int force : forces) {
        if (force > 0) result += 'R';
        else if (force < 0) result += 'L';
        else result += '.';
    }
    
    return result;
}


-----
string pushDominoes(string dominoes) 
    // Your code here
}


************************************
Question ID: 839

#include <string>
#include <unordered_set>
#include <vector>

int minimal_length_encoding(const std::vector<std::string>& words) {
    std::unordered_set<std::string> word_set(words.begin(), words.end());

    for (const std::string& word : words) {
        for (int i = 1; i < word.size(); ++i) {
            word_set.erase(word.substr(i));
        }
    }

    int len = 0;
    for (const std::string& word : word_set) {
        len += word.size() + 1;
    }
    return len;
}

-----
#include <string>
#include <unordered_set>
#include <vector>

int minimal_length_encoding(const std::vector<std::string>& words) 
    // Your code here
}

************************************
Question ID: 840

int numMagicSquaresInside(vector<vector<int>>& grid) {
    int count = 0;
    for (int i = 0; i < grid.size() - 2; ++i) {
        for (int j = 0; j < grid[0].size() - 2; ++j) {
            if (grid[i][j] <= 9 && grid[i + 1][j + 1] == 5 && isMagic(grid, i, j)) {
                count++;
            }
        }
    }
    return count;
}

bool isMagic(vector<vector<int>>& grid, int x, int y) {
    vector<int> temp(16, 0);
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            int num = grid[x + i][y + j];
            temp[num]++;
            if (num > 9 || temp[num] > 1) {
                return false;
            }
        }
    }
    int sum = grid[x][y] + grid[x][y+1] + grid[x][y+2];
    for (int i = 0; i < 3; ++i) {
        int rowSum = 0, colSum = 0;
        for (int j = 0; j < 3; ++j) {
            rowSum += grid[x + i][y + j];
            colSum += grid[x + j][y + i];
        }
        if (rowSum != sum || colSum != sum)
            return false;
    }
    if (grid[x][y] + grid[x + 1][y + 1] + grid[x + 2][y + 2] != sum)
        return false;
    if (grid[x][y + 2] + grid[x + 1][y + 1] + grid[x + 2][y] != sum)
        return false;

    return true;
}


-----
int numMagicSquaresInside(vector<vector<int>>& grid) 
    // Your code here
}


************************************
Question ID: 841

#include <vector>
#include <string>
#include <algorithm>

std::vector<int> shortestToChar(const std::string& s, char c) {
    int n = s.size();
    std::vector<int> result(n, n);
    
    int pos = -n;
    for (int i = 0; i < n; ++i) {
        if (s[i] == c)
            pos = i;
        result[i] = i - pos;
    }
    
    for (int i = pos - 1; i >= 0; --i) {
        if (s[i] == c)
            pos = i;
        result[i] = std::min(result[i], pos - i);
    }
    
    return result;
}


-----
#include <vector>
#include <string>
#include <algorithm>

std::vector<int> shortestToChar(const std::string& s, char c) 
    // Your code here
}


************************************
Question ID: 842

#include <set>
#include <algorithm>

int smallestGoodInteger(std::vector<int>& fronts, std::vector<int>& backs) {
    std::set<int> notGood;
    int n = fronts.size();
    for (int i = 0; i < n; ++i)
        if (fronts[i] == backs[i]) notGood.insert(fronts[i]);
    
    int result = INT_MAX;
    for (int i = 0; i < n; ++i) {
        if (!notGood.count(fronts[i])) result = std::min(result, fronts[i]);
        if (!notGood.count(backs[i])) result = std::min(result, backs[i]);
    }
    return result == INT_MAX ? 0 : result;
}

-----
#include <set>
#include <algorithm>

int smallestGoodInteger(std::vector<int>& fronts, std::vector<int>& backs) 
    // Your code here
}

************************************
Question ID: 843

int numFactoredBinaryTrees(vector<int>& arr) {
    long long MOD = 1e9 + 7;
    int n = arr.size();
    sort(arr.begin(), arr.end());
    unordered_map<int, long long> dp;
    for (int i = 0; i < n; ++i) {
        dp[arr[i]] = 1;
        for (int j = 0; j < i; ++j) {
            if (arr[i] % arr[j] == 0 && dp.count(arr[i] / arr[j]))
                dp[arr[i]] = (dp[arr[i]] + dp[arr[j]] * dp[arr[i] / arr[j]]) % MOD;
        }
    }
    long long ans = 0;
    for (const auto& it : dp) ans = (ans + it.second) % MOD;
    return ans;
}

-----
int numFactoredBinaryTrees(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 844

bool backspaceCompare(string s, string t) {
    int i = s.length() - 1, j = t.length() - 1;
    while (true) {
        int back;
        for (back = 0; i >= 0 && (back > 0 || s[i] == '#'); --i)
            back += s[i] == '#' ? 1 : -1;
        for (back = 0; j >= 0 && (back > 0 || t[j] == '#'); --j)
            back += t[j] == '#' ? 1 : -1;
        if (i >= 0 && j >= 0 && s[i] == t[j])
            i--, j--;
        else
            return i == -1 && j == -1;
    }
}

-----
bool backspaceCompare(string s, string t) 
    // Your code here
}

************************************
Question ID: 845

int longestMountain(vector<int>& arr) {
    int n = arr.size(), res = 0, up = 0, down = 0;

    for (int i = 1; i < n; ++i) {
        if (down && arr[i - 1] < arr[i] || arr[i - 1] == arr[i]) {
            up = down = 0;
        }

        up += arr[i - 1] < arr[i];
        down += arr[i - 1] > arr[i];

        if (up && down) {
            res = max(res, up + down + 1);
        }
    }
    return res;
}

-----
int longestMountain(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 846

#include <vector>
#include <map>

bool isPossibleDivide(std::vector<int>& hand, int groupSize) {
    std::map<int, int> cardCount;
    for (int card : hand) {
        cardCount[card]++;
    }

    for (auto it = cardCount.begin(); it != cardCount.end(); ++it) {
        if (it->second > 0) {
            int count = it->second;
            for (int i = 1; i < groupSize; ++i) {
                cardCount[it->first + i] -= count;
                if (cardCount[it->first + i] < 0) {
                    return false;
                }
            }
        }
    }

    return true;
}


-----
#include <vector>
#include <map>

bool isPossibleDivide(std::vector<int>& hand, int groupSize) 
    // Your code here
}


************************************
Question ID: 847

#include <queue>
#include <vector>

int shortestPathLength(const std::vector<std::vector<int>>& graph) {
    int n = graph.size();
    std::queue<std::tuple<int, int, int>> q;
    std::vector<std::vector<bool>> visited(n, std::vector<bool>(1 << n, false));

    for (int i = 0; i < n; ++i) {
        q.push({i, 1 << i, 0});
        visited[i][1 << i] = true;
    }

    while (!q.empty()) {
        auto [node, bitmask, length] = q.front();
        q.pop();

        if (bitmask == (1 << n) - 1) return length;

        for (int nei : graph[node]) {
            int next_bitmask = bitmask | (1 << nei);
            if (!visited[nei][next_bitmask]) {
                visited[nei][next_bitmask] = true;
                q.push({nei, next_bitmask, length + 1});
            }
        }
    }

    return 0;
}

-----
#include <queue>
#include <vector>

int shortestPathLength(const std::vector<std::vector<int>>& graph) 
    // Your code here
}

************************************
Question ID: 848

#include<string>
#include<vector>
using namespace std;

string shiftingLetters(string s, vector<int>& shifts) {
    for (int i = shifts.size() - 2; i >= 0; i--) {
        shifts[i] += shifts[i + 1] % 26;
    }
    
    for (int i = 0; i < s.size(); i++) {
        s[i] = (s[i] - 'a' + shifts[i] % 26) % 26 + 'a';
    }
    
    return s;
}

-----
#include<string>
#include<vector>
using namespace std;

string shiftingLetters(string s, vector<int>& shifts) 
    // Your code here
}

************************************
Question ID: 849

int maxDistToClosest(vector<int>& seats) {
    int n = seats.size();
    int maxDist = 0, lastPerson = -1;

    for (int i = 0; i < n; ++i) {
        if (seats[i] == 1) {
            if (lastPerson == -1)
                maxDist = i;
            else
                maxDist = max(maxDist, (i - lastPerson) / 2);
            lastPerson = i;
        }
    }
    maxDist = max(maxDist, n - 1 - lastPerson);
    return maxDist;
}

-----
int maxDistToClosest(vector<int>& seats) 
    // Your code here
}

************************************
Question ID: 850

#include <vector>
#include <set>
using namespace std;

int rectangleArea(vector<vector<int>>& rectangles) {
    const int64_t mod = 1e9 + 7;
    int n = rectangles.size();
    vector<int> X, Y;
    for (const auto &rect : rectangles) {
        X.push_back(rect[0]);
        X.push_back(rect[2]);
        Y.push_back(rect[1]);
        Y.push_back(rect[3]);
    }
    sort(X.begin(), X.end());
    sort(Y.begin(), Y.end());

    X.erase(unique(X.begin(), X.end()), X.end());
    Y.erase(unique(Y.begin(), Y.end()), Y.end());

    vector<vector<int>> cnt(X.size() - 1, vector<int>(Y.size() - 1));

    for (const auto &rect : rectangles) {
        int x1_idx = lower_bound(X.begin(), X.end(), rect[0]) - X.begin();
        int x2_idx = lower_bound(X.begin(), X.end(), rect[2]) - X.begin() - 1;
        int y1_idx = lower_bound(Y.begin(), Y.end(), rect[1]) - Y.begin();
        int y2_idx = lower_bound(Y.begin(), Y.end(), rect[3]) - Y.begin() - 1;
        for (int i = x1_idx; i <= x2_idx; ++i) {
            for (int j = y1_idx; j <= y2_idx; ++j) {
                cnt[i][j] = 1;
            }
        }
    }
    int64_t total_area = 0;
    for (int i = 0; i < X.size() - 1; ++i) {
        for (int j = 0; j < Y.size() - 1; ++j) {
            if (cnt[i][j]) {
                total_area += (int64_t)(X[i + 1] - X[i]) * (Y[j + 1] - Y[j]);
                total_area %= mod;
            }
        }
    }
    return total_area;
}

-----
#include <vector>
#include <set>
using namespace std;

int rectangleArea(vector<vector<int>>& rectangles) 
    // Your code here
}

************************************
Question ID: 851

#include <sstream>

std::string toGoatLatin(std::string sentence) {
    std::istringstream ss(sentence);
    std::string word, result, suffix = "a";
    const std::string vowels = "AEIOUaeiou";

    while (ss >> word) {
        if (vowels.find(word[0]) == std::string::npos) {
            word = word.substr(1) + word[0];
        }
        result += word + "ma" + suffix + " ";
        suffix += "a";
    }

    result.pop_back();
    return result;
}

-----
#include <sstream>

std::string toGoatLatin(std::string sentence) 
    // Your code here
}

************************************
Question ID: 852

int numFriendRequests(vector<int>& ages) {
    vector<int> count(121, 0);
    int total_requests = 0;

    for (int age : ages) count[age]++;

    for (int a = 1; a <= 120; a++) {
        for (int b = 1; b <= 120; b++) {
            if (a * 0.5 + 7 >= b) continue;
            if (a < b) continue;
            if (a < b * 2) {
                total_requests += count[a] * count[b];
                if (a == b) total_requests -= count[a];
            }
        }
    }

    return total_requests;
}

-----
int numFriendRequests(vector<int>& ages) 
    // Your code here
}

************************************
Question ID: 853

#include <vector>
#include <algorithm>

int maxProfitAssignment(std::vector<int>& difficulty, std::vector<int>& profit, std::vector<int>& worker) {
    std::vector<std::pair<int, int>> jobs;
    for (int i = 0; i < difficulty.size(); ++i)
        jobs.push_back({difficulty[i], profit[i]});
    std::sort(jobs.begin(), jobs.end());
    std::sort(worker.begin(), worker.end());

    int i = 0, max_profit = 0, total_profit = 0;
    for (int& ability : worker) {
        while (i < difficulty.size() && ability >= jobs[i].first) {
            max_profit = std::max(max_profit, jobs[i].second);
            ++i;
        }
        total_profit += max_profit;
    }
    return total_profit;
}

-----
#include <vector>
#include <algorithm>

int maxProfitAssignment(std::vector<int>& difficulty, std::vector<int>& profit, std::vector<int>& worker) 
    // Your code here
}

************************************
Question ID: 854

int kSimilarity(const std::string& s1, const std::string& s2) {
    int k = 0;
    std::string temp = s1;

    for (int i = 0; i < temp.length(); ++i) {
        if (temp[i] != s2[i]) {
            int j = i + 1;
            while (temp[j] != s2[i] || s2[j] == temp[j]) {
                ++j;
            }
            std::swap(temp[i], temp[j]);
            k++;
        }
    }
    return k;
}

-----
int kSimilarity(const std::string& s1, const std::string& s2) 
    // Your code here
}

************************************
Question ID: 855

#include <unordered_set>

int countUniqueChars(const std::string &s) {
    std::unordered_set<char> uniqueChars(s.begin(), s.end());
    return uniqueChars.size();
}

int sumCountUniqueChars(const std::string &s) {
    int sum = 0;
    for (int i = 0; i < s.size(); ++i) {
        for (int j = i + 1; j <= s.size(); ++j) {
            sum += countUniqueChars(s.substr(i, j - i));
        }
    }
    return sum;
}

-----
#include <unordered_set>

int countUniqueChars(const std::string &s) 
    // Your code here
}

************************************
Question ID: 856

int consecutiveNumbersSum(int n) {
    int count = 0;
    for (int i = 1; i * (i - 1) / 2 < n; i++) {
        if ((n - i * (i - 1) / 2) % i == 0) {
            count++;
        }
    }
    return count;
}


-----
int consecutiveNumbersSum(int n) 
    // Your code here
}


************************************
Question ID: 857

#include <vector>
#include <string>
using namespace std;

vector<vector<int>> largeGroupPositions(string s) {
    vector<vector<int>> result;
    int start = 0;
    for (int i = 1; i < s.size(); ++i) {
        if (s[i] != s[start]) {
            if (i - start >= 3) {
                result.push_back({start, i - 1});
            }
            start = i;
        }
    }
    if (s.size() - start >= 3) {
        result.push_back({start, static_cast<int>(s.size()) - 1});
    }
    return result;
}


-----
#include <vector>
#include <string>
using namespace std;

vector<vector<int>> largeGroupPositions(string s) 
    // Your code here
}


************************************
Question ID: 858

#include <string>
using namespace std;

string maskInformation(string s) {
    if (s.find('@') != string::npos) {
        for (char& c : s) c = tolower(c);
        return s[0] + string(5, '*') + s.substr(s.find('@') - 1);
    } else {
        string digits = "";
        for (char c : s) if (isdigit(c)) digits += c;
        if (digits.length() == 10) return "***-***-" + digits.substr(6);
        string prefix = string(digits.length() - 10, '*') + '-';
        return '+' + prefix + "***-***-" + digits.substr(digits.length() - 4);
    }
}

-----
#include <string>
using namespace std;

string maskInformation(string s) 
    // Your code here
}

************************************
Question ID: 859

class MyCircularDeque {
public:
    vector<int> buffer;
    int front, rear, size;

    MyCircularDeque(int k) {
        buffer.resize(k);
        front = 0;
        rear = 0;
        size = 0;
    }

    bool insertFront(int value) {
        if (size == buffer.size()) return false;
        front = (front - 1 + buffer.size()) % buffer.size();
        buffer[front] = value;
        size++;
        return true;
    }

    bool insertLast(int value) {
        if (size == buffer.size()) return false;
        buffer[rear] = value;
        rear = (rear + 1) % buffer.size();
        size++;
        return true;
    }

    bool deleteFront() {
        if (size == 0) return false;
        front = (front + 1) % buffer.size();
        size--;
        return true;
    }

    bool deleteLast() {
        if (size == 0) return false;
        rear = (rear - 1 + buffer.size()) % buffer.size();
        size--;
        return true;
    }

    int getFront() {
        if (size == 0) return -1;
        return buffer[front];
    }

    int getRear() {
        if (size == 0) return -1;
        return buffer[(rear - 1 + buffer.size()) % buffer.size()];
    }

    bool isEmpty() {
        return size == 0;
    }

    bool isFull() {
        return size == buffer.size();
    }
};

#
-----
class MyCircularDeque 
    // Your code here
};

#
************************************
Question ID: 861

#include <vector>
using namespace std;

vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {
    for (auto &row : image) {
        reverse(row.begin(), row.end());
        for (int &pixel : row) {
            pixel = 1 - pixel;
        }
    }
    return image;
}

-----
#include <vector>
using namespace std;

vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) 
    // Your code here
}

************************************
Question ID: 862

#include <string>
#include <vector>

std::string findReplaceString(std::string s, std::vector<int>& indices, std::vector<std::string>& sources, std::vector<std::string>& targets) {
    std::vector<std::pair<int, int>> indexMapping(indices.size());
    
    for (int i = 0; i < indices.size(); ++i) {
        if (s.substr(indices[i], sources[i].size()) == sources[i]) {
            indexMapping[i] = {indices[i], i};
        } else {
            indexMapping[i] = {-1, i};
        }
    }

    sort(indexMapping.begin(), indexMapping.end());
    std::string result = "";
    int lastIdx = 0;
    
    for (const auto& p : indexMapping) {
        if (p.first >= 0) {
            result += s.substr(lastIdx, p.first - lastIdx) + targets[p.second];
            lastIdx = p.first + sources[p.second].size();
        }
    }
    
    result += s.substr(lastIdx);
    return result;
}

-----
#include <string>
#include <vector>

std::string findReplaceString(std::string s, std::vector<int>& indices, std::vector<std::string>& sources, std::vector<std::string>& targets) 
    // Your code here
}

************************************
Question ID: 863

#include <vector>
using namespace std;

vector<int> sumOfDistancesInTree(int n, vector<vector<int>>& edges) {
    vector<vector<int>> tree(n);
    vector<int> count(n);
    vector<int> res(n);
    
    for (const auto &edge : edges) {
        tree[edge[0]].push_back(edge[1]);
        tree[edge[1]].push_back(edge[0]);
    }
    
    function<void(int, int)> dfs = [&](int node, int parent) {
        for (int child : tree[node]) {
            if (child != parent) {
                dfs(child, node);
                count[node] += count[child];
                res[node] += res[child] + count[child];
            }
        }
        count[node]++;
    };
    
    function<void(int, int)> dfs2 = [&](int node, int parent) {
        for (int child : tree[node]) {
            if (child != parent) {
                res[child] = res[node] - count[child] + n - count[child];
                dfs2(child, node);
            }
        }
    };
    
    dfs(0, -1);
    dfs2(0, -1);
    
    return res;
}


-----
#include <vector>
using namespace std;

vector<int> sumOfDistancesInTree(int n, vector<vector<int>>& edges) 
    // Your code here
}


************************************
Question ID: 864

int largestOverlap(vector<vector<int>>& img1, vector<vector<int>>& img2) {
    int n = img1.size();
    vector<pair<int, int>> onesImg1, onesImg2;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (img1[i][j]) onesImg1.emplace_back(i, j);
            if (img2[i][j]) onesImg2.emplace_back(i, j);
        }
    }

    unordered_map<int, int> overlaps;
    for (const auto& pt1 : onesImg1) {
        for (const auto& pt2 : onesImg2) {
            int dx = pt2.first - pt1.first;
            int dy = pt2.second - pt1.second;
            int key = (dx << 16) + dy;
            ++overlaps[key];
        }
    }

    int maxOverlap = 0;
    for (const auto& pair : overlaps) {
        maxOverlap = max(maxOverlap, pair.second);
    }
    return maxOverlap;
}

-----
int largestOverlap(vector<vector<int>>& img1, vector<vector<int>>& img2) 
    // Your code here
}

************************************
Question ID: 866

bool isRectangleOverlap(vector<int>& rec1, vector<int>& rec2) {
    return rec1[2] > rec2[0] && rec1[3] > rec2[1] && rec1[0] < rec2[2] && rec1[1] < rec2[3];
}

-----
bool isRectangleOverlap(vector<int>& rec1, vector<int>& rec2) 
    // Your code here
}

************************************
Question ID: 867

#include <vector>
using namespace std;

double new21Game(int n, int k, int maxPts) {
    if (k == 0 || n >= k + maxPts) {
        return 1;
    }
    
    vector<double> dp(n + 1, 0);
    dp[0] = 1;
    double sum = 1, ans = 0;
    
    for (int i = 1; i <= n; ++i) {
        dp[i] = sum / maxPts;
        if (i < k) {
            sum += dp[i];
        } else {
            ans += dp[i];
        }
        if (i >= maxPts) {
            sum -= dp[i - maxPts];
        }
    }
    
    return ans;
}


-----
#include <vector>
using namespace std;

double new21Game(int n, int k, int maxPts) 
    // Your code here
}


************************************
Question ID: 868

#include <string>
using namespace std;

string pushDominoes(string dominoes) {
    int n = dominoes.size();
    string prev, cur = dominoes;
    do {
        prev = cur;
        for (int i = 0; i < n; ++i) {
            if (prev[i] == 'L' && i > 0 && prev[i - 1] == '.')
                cur[i - 1] = 'L';
            else if (prev[i] == 'R' && i < n - 1 && prev[i + 1] == '.')
                cur[i + 1] = 'R';
        }
    } while (prev != cur);
    return cur;
}

-----
#include <string>
using namespace std;

string pushDominoes(string dominoes) 
    // Your code here
}

************************************
Question ID: 869

#include <vector>
#include <string>
using namespace std;

bool is_similar(const string& a, const string& b) {
    int diff_count = 0;
    for (int i = 0; i < a.size(); ++i) {
        if (a[i] != b[i]) {
            ++diff_count;
            if (diff_count > 2) {
                return false;
            }
        }
    }
    return true;
}

int count_groups(vector<string>& strs) {
    int count = 0;
    vector<bool> visited(strs.size(), false);
    for (int i = 0; i < strs.size(); ++i) {
        if (!visited[i]) {
            ++count;
            visited[i] = true;
            for (int j = i + 1; j < strs.size(); ++j) {
                if (is_similar(strs[i], strs[j])) {
                    visited[j] = true;
                }
            }
        }
    }
    return count;
}


-----
#include <vector>
#include <string>
using namespace std;

bool is_similar(const string& a, const string& b) 
    // Your code here
}


************************************
Question ID: 870

#include <vector>
#include <set>

std::vector<int> advantageCount(std::vector<int>& nums1, std::vector<int>& nums2) {
    std::multiset<int> s(nums1.begin(), nums1.end());
    std::vector<int> res;
    for (int i : nums2) {
        auto it = s.upper_bound(i);
        if (it == s.end()) it = s.begin();
        res.push_back(*it);
        s.erase(it);
    }
    return res;
}

-----
#include <vector>
#include <set>

std::vector<int> advantageCount(std::vector<int>& nums1, std::vector<int>& nums2) 
    // Your code here
}

************************************
Question ID: 871

#include <vector>
#include <unordered_set>

bool canVisitAllRooms(const std::vector<std::vector<int>>& rooms) {
    std::unordered_set<int> visited;
    std::vector<int> stack = {0};

    while (!stack.empty()) {
        int currentRoom = stack.back();
        stack.pop_back();

        visited.insert(currentRoom);

        for (int key : rooms[currentRoom]) {
            if (!visited.count(key)) {
                stack.push_back(key);
            }
        }
    }

    return visited.size() == rooms.size();
}

-----
#include <vector>
#include <unordered_set>

bool canVisitAllRooms(const std::vector<std::vector<int>>& rooms) 
    // Your code here
}

************************************
Question ID: 872

```c++
#include <vector>
#include <string>

std::vector<int> splitIntoFibonacci(std::string num) {
    std::vector<int> ans;
    backtrack(num, ans, 0, 0, 0);
    return ans;
}

bool backtrack(std::string& num, std::vector<int>& ans, int index, int prev1, int prev2) {
    if (index == num.size()) {
        return ans.size() >= 3;
    }
    long curr = 0;
    for (int i = index; i < num.size(); ++i) {
        if (i > index && num[index] == '0') {
            break;
        }
        curr = curr * 10 + num[i] - '0';
        if (curr > INT32_MAX) {
            break;
        }
        
        if (ans.size() >= 2) {
            long sum = (long)prev1 + prev2;
            if (curr < sum) {
                continue;
            } else if (curr > sum) {
                break;
            }
        }
        
        ans.push_back(curr);
        if (backtrack(num, ans, i + 1, prev2, curr)) {
            return true;
        }
        ans.pop_back();
    }
    return false;
}

-----
```c++
#include <vector>
#include <string>

std::vector<int> splitIntoFibonacci(std::string num) 
    // Your code here
}

************************************
Question ID: 873

#include <vector>
#include <string>

int match(const std::string& a, const std::string& b) {
    int matches = 0;
    for (int i = 0; i < 6; ++i)
        if (a[i] == b[i]) matches++;
    return matches;
}

void findSecretWord(std::vector<std::string>& wordlist, Master& master) {
    int n = word_list.size();
    for (int i = 0, match_cnt=0; i < 10 && match_cnt < 6; ++i) {
        std::string guess = wordlist[rand() %n];
        match_cnt = master.guess(guess);
        std::vector<std::string> candidates;
        for (const std::string& word : wordlist)
            if (match(word, guess) == match_cnt)
                candidates.push_back(word);
        wordlist = candidates;
        n = wordlist.size();
    }
}

-----
#include <vector>
#include <string>

int match(const std::string& a, const std::string& b) 
    // Your code here
}

************************************
Question ID: 874

#include <iostream>
#include <string>
#include <stack>

bool backspaceCompare(std::string s, std::string t) {
    std::stack<char> sStack, tStack;

    for (char c : s) {
        if (c != '#') {
            sStack.push(c);
        } else if (!sStack.empty()) {
            sStack.pop();
        }
    }

    for (char c : t) {
        if (c != '#') {
            tStack.push(c);
        } else if (!tStack.empty()) {
            tStack.pop();
        }
    }

    return sStack == tStack;
}

-----
#include <iostream>
#include <string>
#include <stack>

bool backspaceCompare(std::string s, std::string t) 
    // Your code here
}

************************************
Question ID: 875

#include <vector>
int longestMountain(std::vector<int>& arr) {
    int n = arr.size();
    int max_length = 0;
    int i = 1;
    while (i < n - 1) {
        if (arr[i - 1] < arr[i] && arr[i] > arr[i + 1]) {
            int left = i - 1;
            int right = i + 1;
            while (left > 0 && arr[left - 1] < arr[left]) {
                left--;
            }
            while (right < n - 1 && arr[right] > arr[right + 1]) {
                right++;
            }
            max_length = std::max(max_length, right - left + 1);
            i = right;
        } else {
            i++;
        }
    }
    return max_length;
}

-----
#include <vector>
int longestMountain(std::vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 876

#include <map>
#include <vector>
using namespace std;

bool isNStraightHand(vector<int>& hand, int groupSize) {
    map<int, int> counts;

    for (int card : hand) {
        counts[card]++;
    }

    for (auto it = counts.begin(); it != counts.end(); ++it) {
        if (it->second > 0) {
            for (int i = groupSize - 1; i >= 0; --i) {
                if (counts[it->first + i] < it->second) {
                    return false;
                }
                counts[it->first + i] -= it->second;
            }
        }
    }
    
    return true;
}


-----
#include <map>
#include <vector>
using namespace std;

bool isNStraightHand(vector<int>& hand, int groupSize) 
    // Your code here
}


************************************
Question ID: 877

#include <vector>
#include <queue>
#include <bitset>
using namespace std;

int shortestPathLength(vector<vector<int>>& graph) {
    int n = graph.size();
    queue<pair<int, bitset<12>>> q;
    
    for(int i = 0; i < n; i++) {
        q.push({i, 1 << i});
    }
    int steps = -1;
    vector<vector<bool>> visited(n, vector<bool>(1 << n));
    
    while(!q.empty()) {
        steps++;
        int size = q.size();
        
        for(int k = 0; k < size; k++) {
            int currNode = q.front().first;
            bitset<12> currVisits = q.front().second;
            q.pop();
            
            if(currVisits.count() == n) return steps;
            
            for(int nextNode: graph[currNode]) {
                bitset<12> nextVisits = currVisits;
                nextVisits.set(nextNode);
                
                if(!visited[nextNode][nextVisits.to_ulong()]) {
                    visited[nextNode][nextVisits.to_ulong()] = true;
                    q.push({nextNode, nextVisits});
                }
            }
        }
    }
    
    return -1;
}


-----
#include <vector>
#include <queue>
#include <bitset>
using namespace std;

int shortestPathLength(vector<vector<int>>& graph) 
    // Your code here
}


************************************
Question ID: 878

#include <string>
#include <vector>

std::string shiftingLetters(std::string s, std::vector<int>& shifts) {
    int n = s.size();
    for (int i = n - 2; i >= 0; i--) {
        shifts[i] = (shifts[i] + shifts[i + 1]) % 26;
    }
    
    for (int i = 0; i < n; i++) {
        s[i] = (s[i] - 'a' + shifts[i]) % 26 + 'a';
    }
    
    return s;
}

-----
#include <string>
#include <vector>

std::string shiftingLetters(std::string s, std::vector<int>& shifts) 
    // Your code here
}

************************************
Question ID: 879

int maxDistToClosest(vector<int>& seats) {
    int max_dist = 0, last_person = -1;
    for (int i = 0; i < seats.size(); ++i) {
        if (seats[i] == 1) {
            max_dist = last_person < 0 ? i : max(max_dist, (i - last_person) / 2);
            last_person = i;
        }
    }
    return max(max_dist, (int)(seats.size() - 1 - last_person));
}

-----
int maxDistToClosest(vector<int>& seats) 
    // Your code here
}

************************************
Question ID: 880

#include<vector>
#include<algorithm>
#include<map>
using namespace std;

int rectangleArea(vector<vector<int>>& rectangles) {
    int mod = 1e9 + 7;
    vector<int> X;
    map<int,int> Xcompress;
    for(auto r : rectangles){
        X.push_back(r[0]);
        X.push_back(r[2]);
    }
    sort(X.begin(), X.end());
    int idx = 0;
    for(auto x : X){
        if(!Xcompress.count(x))
            Xcompress[x] = idx++;
    }

    vector<vector<int>> events;
    for(auto r : rectangles){
        events.push_back({Xcompress[r[0]], 1, r[1], r[3]});
        events.push_back({Xcompress[r[2]], -1, r[1], r[3]});
    }
    sort(events.begin(), events.end());

    int area = 0;
    vector<int> cnt(idx,0);
    int active = 0;
    for(auto e : events){
        int idx = e[0], type = e[1],	y1 = e[2], y2 = e[3];
        area = (area + (long long)(X[idx+1] - X[idx]) * active % mod) % mod;
        cnt[y1] += type;
        cnt[y2] -= type;
        active = 0;
        for(int i = 0; i < idx; ++i){
            if(cnt[i])
                active += X[i+1] - X[i];
        }
    }
    return area;
}

-----
#include<vector>
#include<algorithm>
#include<map>
using namespace std;

int rectangleArea(vector<vector<int>>& rectangles) 
    // Your code here
}

************************************
Question ID: 881

#include <vector>
using namespace std;

void dfs(int x, vector<vector<int>>& graph, vector<int>& quiet, vector<int>& answer) {
    if (answer[x] != -1) return;
    answer[x] = x;

    for (int y : graph[x]) {
        dfs(y, graph, quiet, answer);
        if (quiet[answer[y]] < quiet[answer[x]])
            answer[x] = answer[y];
    }
}

vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
    int n = quiet.size();
    vector<vector<int>> graph(n);
    for (auto& entry : richer)
        graph[entry[1]].push_back(entry[0]);

    vector<int> answer(n, -1);
    for (int i = 0; i < n; ++i)
        dfs(i, graph, quiet, answer);

    return answer;
}


-----
#include <vector>
using namespace std;

void dfs(int x, vector<vector<int>>& graph, vector<int>& quiet, vector<int>& answer) 
    // Your code here
}


************************************
Question ID: 882

int peakIndexInMountainArray(vector<int>& arr) {
    int low = 0, high = arr.size() - 1;
    while (low < high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] < arr[mid + 1])
            low = mid + 1;
        else
            high = mid;
    }
    return low;
}

-----
int peakIndexInMountainArray(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 883

int carFleet(int target, vector<int>& position, vector<int>& speed) {
    int n = position.size();
    vector<pair<int, int>> cars;
    for (int i = 0; i < n; ++i) {
        cars.emplace_back(position[i], speed[i]);
    }
    sort(cars.begin(), cars.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
        return a.first > b.first;
    });

    int fleets = 0;
    double last_arrival = -1;
    for (int i = 0; i < n; ++i) {
        double arrival = (double)(target - cars[i].first) / cars[i].second;
        if (arrival > last_arrival) {
            ++fleets;
            last_arrival = arrival;
        }
    }

    return fleets;
}


-----
int carFleet(int target, vector<int>& position, vector<int>& speed) 
    // Your code here
}


************************************
Question ID: 884

int kSimilarity(const std::string& s1, const std::string& s2) {
    int k = 0;
    std::string a = s1, b = s2;
    for (int i = 0; i < a.size(); ++i) {
        if (a[i] != b[i]) {
            for (int j = i + 1; j < b.size(); ++j) {
                if (a[i] == b[j] && a[j] != b[j]) {
                    std::swap(a[i], a[j]);
                    k++;
                    break;
                }
            }
        }
    }
    return k;
}

-----
int kSimilarity(const std::string& s1, const std::string& s2) 
    // Your code here
}

************************************
Question ID: 885

class ExamRoom {
public:
    set<int> students;
    int n;
    
    ExamRoom(int n) {
        this->n = n;
    }
    
    int seat() {
        if (students.empty()) {
            students.insert(0);
            return 0;
        }
        
        int distance = *students.begin(), seat_index = 0;
                
        for (auto itr = next(students.begin()); itr != students.end(); ++itr) {
            auto prev = prev(itr);
            int d = (*itr - *prev) / 2;
            
            if (d > distance) {
                distance = d;
                seat_index = *prev + d;
            }
        }
        
        if (n - 1 - *students.rbegin() > distance)
            seat_index = n - 1;
        
        students.insert(seat_index);
        return seat_index;
    }
    
    void leave(int p) {
        students.erase(p);
    }
};


-----
class ExamRoom 
    // Your code here
};


************************************
Question ID: 886

int scoreOfParentheses(string s) {
    int score = 0, depth = 0;
    for (int i = 0; i < s.size(); i++) {
        if (s[i] == '(')
            depth++;
        else {
            depth--;
            if (s[i - 1] == '(')
                score += 1 << depth;
        }
    }
    return score;
}

-----
int scoreOfParentheses(string s) 
    // Your code here
}

************************************
Question ID: 887

#include <vector>
#include <queue>
#include <algorithm>

double mincostToHireWorkers(std::vector<int>& quality, std::vector<int>& wage, int k) {
    std::vector<std::pair<double, int>> workers;
    for (int i = 0; i < quality.size(); i++) {
        workers.emplace_back((double)wage[i] / quality[i], quality[i]);
    }
    std::sort(workers.begin(), workers.end());
    
    int sum_quality = 0;
    double result = 1e60;
    std::priority_queue<int> pq;
    
    for (auto [ratio, q] : workers) {
        sum_quality += q;
        pq.push(q);
        
        if (pq.size() > k) {
            sum_quality -= pq.top();
            pq.pop();
        }
        
        if (pq.size() == k) {
            result = std::min(result, ratio * sum_quality);
        }
    }
    
    return result;
}

-----
#include <vector>
#include <queue>
#include <algorithm>

double mincostToHireWorkers(std::vector<int>& quality, std::vector<int>& wage, int k) 
    // Your code here
}

************************************
Question ID: 888

int mirrorReflection(int p, int q) {
    int m = p, n = q;
    int gcd;
    while (n) {
        gcd = m % n;
        m = n;
        n = gcd;
    }

    if ((p / m) % 2 == 0) return 2;
    if ((q / m) % 2 == 0) return 0;
    return 1;
}

-----
int mirrorReflection(int p, int q) 
    // Your code here
}

************************************
Question ID: 889

bool areAlmostEqual(std::string s, std::string goal) {
    if (s == goal) return true;
    int count = 0;
    int index1 = -1, index2 = -1;
    for (int i = 0; i < s.size(); i++) {
        if (s[i] != goal[i]) {
            count++;
            if (index1 == -1) index1 = i;
            else index2 = i;
            if (count > 2) return false;
        }
    }
    return (count == 2 && s[index1] == goal[index2] && s[index2] == goal[index1]);
}

-----
bool areAlmostEqual(std::string s, std::string goal) 
    // Your code here
}

************************************
Question ID: 890

bool lemonadeChange(std::vector<int>& bills) {
    int five = 0, ten = 0;
    for (int bill : bills) {
        if (bill == 5)
            five++;
        else if (bill == 10) {
            if (!five) return false;
            five--;
            ten++;
        } else {
            if (ten && five) {
                ten--;
                five--;
            } else if (five >= 3)
                five -= 3;
            else
                return false;
        }
    }
    return true;
}


-----
bool lemonadeChange(std::vector<int>& bills) 
    // Your code here
}


************************************
Question ID: 891

int matrixScore(std::vector<std::vector<int>>& grid) {
    int m = grid.size(), n = grid[0].size();
    for(int i = 0; i < m; i++) {
        if(grid[i][0] == 0) {
            for(int j = 0; j < n; j++) {
                grid[i][j] = 1 - grid[i][j];
            }
        }
    }
    for(int j = 1; j < n; j++) {
        int count = 0;
        for(int i = 0; i < m; i++) {
            count += grid[i][j];
        }
        if(count <= m / 2) {
            for(int i = 0; i < m; i++) {
                grid[i][j] = 1 - grid[i][j];
            }
        }
    }
    int sum = 0;
    for(int i = 0; i < m; i++) {
        int num = 0;
        for(int j = 0; j < n; j++) {
            num = num * 2 + grid[i][j];
        }
        sum += num;
    }
    return sum;
}

-----
int matrixScore(std::vector<std::vector<int>>& grid) 
    // Your code here
}

************************************
Question ID: 892

#include <deque>
#include <vector>
using namespace std;

int shortestSubarray(vector<int>& nums, int k) {
    int n = nums.size();
    vector<int> prefix_sum(n + 1, 0);
    for (int i = 0; i < n; i++) prefix_sum[i + 1] = prefix_sum[i] + nums[i];

    int res = n + 1;
    deque<int> dq;
    for (int i = 0; i < n + 1; i++) {
        while (!dq.empty() && prefix_sum[i] - prefix_sum[dq.front()] >= k) {
            res = min(res, i - dq.front());
            dq.pop_front();
        }
        while (!dq.empty() && prefix_sum[i] <= prefix_sum[dq.back()]) {
            dq.pop_back();
        }
        dq.push_back(i);
    }
    return res <= n ? res : -1;
}

-----
#include <deque>
#include <vector>
using namespace std;

int shortestSubarray(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 893

#include <vector>
#include <unordered_map>
#include <unordered_set>
using namespace std;

struct TreeNode {
  int val;
  TreeNode *left;
  TreeNode *right;
  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

vector<int> findNodesAtDistanceK(TreeNode* root, int targetVal, int k) {
    if (k < 0) return {};
    unordered_map<TreeNode*, TreeNode*> parentMap;
    unordered_set<TreeNode*> visited;
    TreeNode* targetNode = nullptr;
    initializeParentMap(root, nullptr, targetVal, parentMap, targetNode);

    vector<int> result;
    findNodesAtDistanceKHelper(targetNode, k, visited, parentMap, result);
    return result;
}

void initializeParentMap(TreeNode* node, TreeNode* parent, int targetVal, unordered_map<TreeNode*, TreeNode*> &parentMap, TreeNode* &targetNode) {
    if (!node || targetNode) return;
    if (node->val == targetVal) targetNode = node;
    parentMap[node] = parent;
    initializeParentMap(node->left, node, targetVal, parentMap, targetNode);
    initializeParentMap(node->right, node, targetVal, parentMap, targetNode);
}

void findNodesAtDistanceKHelper(TreeNode* node, int k, unordered_set<TreeNode*> &visited, unordered_map<TreeNode*, TreeNode*> &parentMap, vector<int> &result) {
    if (!node || visited.count(node)) return;
    visited.insert(node);
    if (k == 0) {
        result.push_back(node->val);
        return;
    }
    
    findNodesAtDistanceKHelper(node->left, k-1, visited, parentMap, result);
    findNodesAtDistanceKHelper(node->right, k-1, visited, parentMap, result);
    findNodesAtDistanceKHelper(parentMap[node], k-1, visited, parentMap, result);
}


-----
#include <vector>
#include <unordered_map>
#include <unordered_set>
using namespace std;

struct TreeNode 
    // Your code here
}


************************************
Question ID: 894

#include <vector>
#include <unordered_map>
#include <random>

class Solution {
public:
    std::unordered_map<int, int> blacklist_map;
    int reduced_n;

    Solution(int n, std::vector<int>& blacklist) {
        for (int b : blacklist) {
            if (b < n) {
                blacklist_map[b] = -1;
            }
        }
        reduced_n = n - blacklist_map.size();

        for (int b : blacklist) {
            if (b >= reduced_n) continue;
            while (blacklist_map.count(--n)) {}
            blacklist_map[b] = n;
        } 
    }

    int pick() {
        int random_int = rand() % reduced_n;
        if (blacklist_map.count(random_int)) {
            return blacklist_map[random_int];
        }
        return random_int;
    }
};

-----
#include <vector>
#include <unordered_map>
#include <random>

class Solution 
    // Your code here
};

************************************
Question ID: 895

#include <vector>
#include <queue>
#include <unordered_set>
#include <string>

using namespace std;

int shortestPathAllKeys(vector<string>& grid) {
    int m = grid.size(), n = grid[0].size(), steps = 0, k = 0, x = -1, y = -1, mask = 0;
    queue<vector<int>> q;
    
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == '@') {
                x = i;
                y = j;
            } else if (grid[i][j] >= 'a' && grid[i][j] <= 'f') {
                k = max(k, grid[i][j] - 'a' + 1);
            }
        }
    }
    
    q.push({ x, y, 0 });
    unordered_set<string> visited;
    visited.insert(to_string(x) + "," + to_string(y) + "," + to_string(mask));
    
    vector<vector<int>> dirs = { {-1, 0}, {1, 0}, {0, 1}, {0, -1} };
    
    while (!q.empty()) {
        int qs = q.size();
        
        for (int sz = 0; sz < qs; sz++) {
            vector<int> cur = q.front(); q.pop();
            int x = cur[0], y = cur[1], mask = cur[2];
            
            if (mask == (1 << k) - 1) return steps;
            
            for (vector<int>& dir : dirs) {
                int nx = x + dir[0], ny = y + dir[1], nmask = mask;
                
                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                    if (grid[nx][ny] >= 'A' && grid[nx][ny] <= 'F' && !(nmask & (1 << (grid[nx][ny] - 'A')))) continue;
                    if (grid[nx][ny] >= 'a' && grid[nx][ny] <= 'f') nmask |= (1 << (grid[nx][ny] - 'a'));
                    
                    string key = to_string(nx) + "," + to_string(ny) + "," + to_string(nmask);
                    
                    if (visited.count(key)) continue;
                    
                    visited.insert(key);
                    q.push({ nx, ny, nmask });
                }
            }
        }
        
        steps++;
    }
    
    return -1;
}


-----
#include <vector>
#include <queue>
#include <unordered_set>
#include <string>

using namespace std;

int shortestPathAllKeys(vector<string>& grid) 
    // Your code here
}


************************************
Question ID: 897

bool isPrime(int n) {
    if (n <= 1) return false;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) return false;
    }
    return true;
}

bool isPalindrome(int n) {
    int rev = 0, orig = n;
    while (n > 0) {
        rev = rev * 10 + n % 10;
        n /= 10;
    }
    return orig == rev;
}

int primePalindrome(int n) {
    while (true) {
        if (isPrime(n) && isPalindrome(n)) return n;
        n++;
    }
}

-----
bool isPrime(int n) 
    // Your code here
}

************************************
Question ID: 898

#include<vector>
using namespace std;

vector<vector<int>> transpose(vector<vector<int>>& matrix) {
    int rows = matrix.size();
    int cols = matrix[0].size();
    vector<vector<int>> result(cols, vector<int>(rows));
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            result[j][i] = matrix[i][j];
        }
    }
    return result;
}

-----
#include<vector>
using namespace std;

vector<vector<int>> transpose(vector<vector<int>>& matrix) 
    // Your code here
}

************************************
Question ID: 899

int longest_distance(int n) {
    int last = -1, longest = 0;
    for (int i = 0; n > 0; n >>= 1, i++) {
        if (n & 1) {
            if (last >= 0)
                longest = std::max(longest, i - last);
            last = i;
        }
    }
    return longest;
}

-----
int longest_distance(int n) 
    // Your code here
}

************************************
Question ID: 900

#include <algorithm>
#include <bitset>
#include <string>

bool reorderedPowerOf2(int n) {
    std::string s = std::to_string(n);
    std::sort(s.begin(), s.end());
    do {
        if (s[0] != '0' && (std::bitset<32>(std::stoi(s)).count() == 1)) {
            return true;
        }
    } while (std::next_permutation(s.begin(), s.end()));
    return false;
}


-----
#include <algorithm>
#include <bitset>
#include <string>

bool reorderedPowerOf2(int n) 
    // Your code here
}


************************************
Question ID: 901

#include <vector>
#include <algorithm>
using namespace std;

vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {
    multiset<int> s(nums1.begin(), nums1.end());
    vector<int> res;
    for (int num : nums2) {
        auto it = s.upper_bound(num);
        if (it == s.end())
            it = s.begin();
        res.push_back(*it);
        s.erase(it);
    }
    return res;
}

-----
#include <vector>
#include <algorithm>
using namespace std;

vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) 
    // Your code here
}

************************************
Question ID: 902

#include <queue>
#include <vector>
using namespace std;

int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {
    int i = 0, stops = 0, curFuel = startFuel;
    priority_queue<int> pq;
    while (curFuel < target) {
        while (i < stations.size() && stations[i][0] <= curFuel) {
            pq.push(stations[i][1]);
            i++;
        }
        if (pq.empty()) return -1;
        curFuel += pq.top();
        pq.pop();
        stops++;
    }
    return stops;
}


-----
#include <queue>
#include <vector>
using namespace std;

int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) 
    // Your code here
}


************************************
Question ID: 903

int rand7(); // Given API

int rand10() {
    int result;
    do {
        result = (rand7() - 1) * 7 + rand7();
    } while (result > 40);
    return result % 10 + 1;
}

-----
int rand7(); // Given API

int rand10() 
    // Your code here
}

************************************
Question ID: 904

bool leafSimilar(TreeNode* root1, TreeNode* root2) {
    std::vector<int> leaves1;
    std::vector<int> leaves2;
    getLeaves(root1, leaves1);
    getLeaves(root2, leaves2);
    return leaves1 == leaves2;
}

void getLeaves(TreeNode* node, std::vector<int>& leaves) {
    if (!node) return;
    if (!node->left && !node->right) leaves.push_back(node->val);
    getLeaves(node->left, leaves);
    getLeaves(node->right, leaves);
}

-----
bool leafSimilar(TreeNode* root1, TreeNode* root2) 
    // Your code here
}

************************************
Question ID: 905

#include <unordered_map>
#include <vector>

int lenLongestFibSubseq(std::vector<int>& arr) {
    int n = arr.size();
    std::unordered_map<int, int> index;
    for (int i = 0; i < n; ++i)
        index[arr[i]] = i;

    std::unordered_map<int, int> longest;
    int ans = 0;

    for (int k = 0; k < n; ++k)
        for (int j = 0; j < k; ++j) {
            int i = index.find(arr[k] - arr[j]) == index.end() ? -1 : index[arr[k] - arr[j]];
            if (i >= 0 && i < j) {
                longest[j * n + k] = longest.find(i * n + j) == longest.end() ? 2 : longest[i * n + j] + 1;
                ans = std::max(ans, longest[j * n + k] + 1);
            }
        }

    return ans >= 3 ? ans : 0;
}

-----
#include <unordered_map>
#include <vector>

int lenLongestFibSubseq(std::vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 907

int minEatingSpeed(vector<int>& piles, int h) {
    int left = 1, right = *max_element(piles.begin(), piles.end());
    while (left < right) {
        int mid = left + (right - left) / 2;
        int totalHours = 0;
        for (int pile : piles)
            totalHours += (pile + mid - 1) / mid;
        if (totalHours > h)
            left = mid + 1;
        else
            right = mid;
    }
    return left;
}

-----
int minEatingSpeed(vector<int>& piles, int h) 
    // Your code here
}

************************************
Question ID: 909

bool aliceWins(vector<int>& piles) {
    int n = piles.size();
    int dp[n][n];
    for (int gap = 0; gap < n; ++gap) {
        for (int i = 0, j = gap; j < n; ++i, ++j) {
            int x = ((i + 2) <= j) ? dp[i + 2][j] : 0;
            int y = ((i + 1) <= (j - 1)) ? dp[i + 1][j - 1] : 0;
            int z = (i <= (j - 2)) ? dp[i][j - 2] : 0;
            dp[i][j] = max(piles[i] + min(x, y), piles[j] + min(y, z));
        }
    }
    int sum = accumulate(piles.begin(), piles.end(), 0);
    return dp[0][n - 1] > (sum - dp[0][n - 1]);
}

-----
bool aliceWins(vector<int>& piles) 
    // Your code here
}

************************************
Question ID: 910

int nthMagicalNumber(int n, int a, int b) {
    long long mod = 1000000007, lcm = a * b / __gcd(a, b);
    long long left = 1, right = 1e14, mid;
    while(left < right) {
        mid = left + (right - left) / 2;
        if ((mid / a + mid / b - mid / lcm) < n) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left % mod;
}

-----
int nthMagicalNumber(int n, int a, int b) 
    // Your code here
}

************************************
Question ID: 911

int profitableSchemes(int n, int minProfit, vector<int>& group, vector<int>& profit) {
    int dp[n+1][minProfit+1], mod = 1e9 + 7;
    dp[0][0] = 1;
    for (int i = 0; i < group.size(); ++i) {
        for (int j = n; j >= group[i]; --j) {
            for (int k = minProfit; k >= 0; --k) {
                dp[j][k] = (dp[j][k] + dp[j - group[i]][max(0, k - profit[i])]) % mod;
            }
        }
    }
    int res = 0;
    for (int i = 1; i <= n; ++i) {
        res = (res + dp[i][minProfit]) % mod;
    }
    return res;
}

-----
int profitableSchemes(int n, int minProfit, vector<int>& group, vector<int>& profit) 
    // Your code here
}

************************************
Question ID: 912

#include <vector>
#include <random>

class Solution {
public:
    std::vector<int> prefixSum;
    std::default_random_engine generator;
    std::uniform_real_distribution<double> distribution;

    Solution(std::vector<int>& w) {
        prefixSum.push_back(w[0]);
        for (size_t i = 1; i < w.size(); ++i) {
            prefixSum.push_back(prefixSum.back() + w[i]);
        }
        distribution = std::uniform_real_distribution<double>(0, prefixSum.back());
    }

    int pickIndex() {
        double num = distribution(generator);
        return std::lower_bound(prefixSum.begin(), prefixSum.end(), num) - prefixSum.begin();
    }
};

-----
#include <vector>
#include <random>

class Solution 
    // Your code here
};

************************************
Question ID: 913

#include <vector>
#include <random>

class Solution {
public:
    Solution(int m, int n) : _grid(m, std::vector<int>(n, 0)), _zero_count(m * n), _rng(std::random_device{}()) {}

    std::pair<int, int> pick() {
        std::uniform_int_distribution<int> dist(0, _zero_count - 1);
        int index = dist(_rng);

        for (int i = 0; i < _grid.size(); ++i) {
            for (int j = 0; j < _grid[0].size(); ++j) {
                if (_grid[i][j] == 0) {
                    if (index == 0) {
                        _grid[i][j] = 1;
                        --_zero_count;
                        return {i, j};
                    }
                    --index;
                }
            }
        }
        return {-1, -1};  // Should not happen
    }

private:
    std::vector<std::vector<int>> _grid;
    int _zero_count;
    std::mt19937 _rng;
};

-----
#include <vector>
#include <random>

class Solution 
    // Your code here
};

************************************
Question ID: 914

#include <vector>
#include <random>

class Solution {
public:
    std::vector<std::vector<int>> rects;
    std::vector<int> areas;
    int total_area;
    std::default_random_engine generator;

    Solution(std::vector<std::vector<int>>& rectangles) {
        rects = rectangles;
        total_area = 0;
        for (const auto& rect : rects) {
            int area = (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1);
            total_area += area;
            areas.push_back(total_area);
        }
    }

    std::vector<int> pick() {
        std::uniform_int_distribution<int> area_distribution(0, total_area - 1);
        int random_area = area_distribution(generator);
        int rect_index = std::lower_bound(areas.begin(), areas.end(), random_area + 1) - areas.begin();

        std::uniform_int_distribution<int> x_distribution(rects[rect_index][0], rects[rect_index][2]);
        std::uniform_int_distribution<int> y_distribution(rects[rect_index][1], rects[rect_index][3]);

        int x = x_distribution(generator);
        int y = y_distribution(generator);

        return {x, y};
    }
};


-----
#include <vector>
#include <random>

class Solution 
    // Your code here
};


************************************
Question ID: 915

#include <math.h>
#include <random>

class Solution {
public:
    double radius, x_center, y_center;

    Solution(double radius, double x_center, double y_center) {
        this->radius = radius;
        this->x_center = x_center;
        this->y_center = y_center;
    }
    
    vector<double> randPoint() {
        double angle = (double)rand() / RAND_MAX * 2 * M_PI;
        double r = sqrt((double)rand() / RAND_MAX) * radius;
        return {x_center + r * cos(angle), y_center + r * sin(angle)};
    }
};

-----
#include <math.h>
#include <random>

class Solution 
    // Your code here
};

************************************
Question ID: 916

#include <string>

char findKthCharacter(const std::string& s, int k) {
    int n = s.length();
    long long size = 0;

    for (auto c : s) {
        if (isdigit(c)) {
            size *= c - '0';
        } else {
            size++;
        }
    }

    for (int i = n - 1; i >= 0; --i) {
        char c = s[i];
        k %= size;
        if (k == 0 && !isdigit(c)) {
            return c;
        }

        if (isdigit(c)) {
            size /= c - '0';
        } else {
            size--;
        }
    }

    return '-';
}

-----
#include <string>

char findKthCharacter(const std::string& s, int k) 
    // Your code here
}

************************************
Question ID: 917

#include <algorithm>
#include <vector>

int numRescueBoats(std::vector<int>& people, int limit) {
    std::sort(people.begin(), people.end());
    int left = 0, right = people.size() - 1;
    int boats = 0;
    while (left <= right) {
        if (people[left] + people[right] <= limit) {
            left++;
        }
        right--;
        boats++;
    }
    return boats;
}

-----
#include <algorithm>
#include <vector>

int numRescueBoats(std::vector<int>& people, int limit) 
    // Your code here
}

************************************
Question ID: 918

#include <vector>
#include <unordered_set>
#include <queue>

using namespace std;

int reachableNodes(vector<vector<int>>& edges, int maxMoves, int n) {
    vector<vector<pair<int, int>>> graph(n);
    for (const auto& edge : edges) {
        int u = edge[0], v = edge[1], cnt = edge[2];
        graph[u].emplace_back(v, cnt + 1);
        graph[v].emplace_back(u, cnt + 1);
    }

    unordered_set<int> visited;
    priority_queue<pair<int, int>> pq;
    pq.emplace(maxMoves, 0);

    while (!pq.empty()) {
        int moves_left = pq.top().first;
        int node = pq.top().second;
        pq.pop();

        if (visited.count(node)) continue;
        visited.insert(node);

        for (const auto& neighbor : graph[node]) {
            int next_node = neighbor.first;
            int moves_needed = neighbor.second;
            int moves_left_after = moves_left - moves_needed;

            if (!visited.count(next_node) && moves_left_after > 0) {
                pq.emplace(moves_left_after, next_node);
            }
        }
    }

    return visited.size();
}


-----
#include <vector>
#include <unordered_set>
#include <queue>

using namespace std;

int reachableNodes(vector<vector<int>>& edges, int maxMoves, int n) 
    // Your code here
}


************************************
Question ID: 919

int projectionArea(vector<vector<int>>& grid) {
    int n = grid.size();
    int top = 0, front = 0, side = 0;
    for (int i = 0; i < n; ++i) {
        int maxFront = 0, maxSide = 0;
        for (int j = 0; j < n; ++j) {
            if (grid[i][j] > 0) {
                ++top;
            }
            maxFront = max(maxFront, grid[i][j]);
            maxSide = max(maxSide, grid[j][i]);
        }
        front += maxFront;
        side += maxSide;
    }
    return top + front + side;
}

-----
int projectionArea(vector<vector<int>>& grid) 
    // Your code here
}

************************************
Question ID: 920

#include <vector>
#include <string>
#include <unordered_map>
#include <sstream>

std::vector<std::string> uncommonFromSentences(std::string s1, std::string s2) {
    std::unordered_map<std::string, int> word_count;
    std::istringstream is(s1 + ' ' + s2);
    std::string word;

    while (is >> word) {
        word_count[word]++;
    }

    std::vector<std::string> result;
    for (const auto &pair : word_count) {
        if (pair.second == 1) {
            result.push_back(pair.first);
        }
    }

    return result;
}

-----
#include <vector>
#include <string>
#include <unordered_map>
#include <sstream>

std::vector<std::string> uncommonFromSentences(std::string s1, std::string s2) 
    // Your code here
}

************************************
Question ID: 921

#include <vector>

std::vector<std::vector<int>> spiral_walk(int rows, int cols, int rStart, int cStart) {
    std::vector<std::vector<int>> result;
    int dr[] = {0, 1, 0, -1};
    int dc[] = {1, 0, -1, 0};
    int moves = rows * cols;
    int r = rStart, c = cStart, dir = 0;
    
    while (result.size() < moves) {
        result.push_back({r, c});
        r += dr[dir];
        c += dc[dir];
        
        if (r < 0 || r >= rows || c < 0 || c >= cols) {
            r -= dr[dir];
            c -= dc[dir];
            dir = (dir + 1) % 4;
            r += dr[dir];
            c += dc[dir];
        }
    }

    return result;
}

-----
#include <vector>

std::vector<std::vector<int>> spiral_walk(int rows, int cols, int rStart, int cStart) 
    // Your code here
}

************************************
Question ID: 922

#include <vector>
using namespace std;

bool dfs(int person, int group, vector<int> &groups, vector<vector<int>> &dislikeList) {
    if (groups[person] != 0) {
        return groups[person] == group;
    }
    groups[person] = group;
    for (int other : dislikeList[person]) {
        if (!dfs(other, -group, groups, dislikeList)) {
            return false;
        }
    }
    return true;
}

bool possible_bipartition(int n, vector<vector<int>> &dislikes) {
    vector<int> groups(n + 1, 0);
    vector<vector<int>> dislikeList(n + 1);

    for (auto &dislikePair : dislikes) {
        dislikeList[dislikePair[0]].push_back(dislikePair[1]);
        dislikeList[dislikePair[1]].push_back(dislikePair[0]);
    }

    for (int person = 1; person <= n; person++) {
        if (groups[person] == 0 && !dfs(person, 1, groups, dislikeList)) {
            return false;
        }
    }

    return true;
}


-----
#include <vector>
using namespace std;

bool dfs(int person, int group, vector<int> &groups, vector<vector<int>> &dislikeList) 
    // Your code here
}


************************************
Question ID: 923

int min_moves(int k, int n) {
    if (k == 1 || n == 0 || n == 1) {
        return n;
    }
    int res = INT_MAX;
    for (int i = 1; i <= n; i++) {
        int temp = max(min_moves(k - 1, i - 1), min_moves(k, n - i));
        res = min(res, temp);
    }
    return res + 1;
}

-----
int min_moves(int k, int n) 
    // Your code here
}

************************************
Question ID: 924

#include <vector>

std::vector<int> fairCandySwap(std::vector<int>& aliceSizes, std::vector<int>& bobSizes) {
    int aliceTotal = 0, bobTotal = 0;
    for (int candy : aliceSizes) aliceTotal += candy;
    for (int candy : bobSizes) bobTotal += candy;

    int delta = (bobTotal - aliceTotal) / 2;
    for (int a : aliceSizes) {
        for (int b : bobSizes) {
            if (a + delta == b) {
                return {a, b};
            }
        }
    }
    return {};
}

-----
#include <vector>

std::vector<int> fairCandySwap(std::vector<int>& aliceSizes, std::vector<int>& bobSizes) 
    // Your code here
}

************************************
Question ID: 926

#include <vector>
#include <string>
#include <unordered_map>

std::vector<std::string> findAndReplacePatterns(std::vector<std::string>& words, std::string pattern) {
    std::vector<std::string> result;
    for (const std::string& word : words) {
        if (word.size() != pattern.size()) continue;

        std::unordered_map<char, char> w2p;
        std::unordered_map<char, char> p2w;
        bool matches = true;
        for (size_t i = 0; i < word.size(); ++i) {
            char cWord = word[i];
            char cPattern = pattern[i];

            if (!w2p.count(cWord)) w2p[cWord] = cPattern;
            if (!p2w.count(cPattern)) p2w[cPattern] = cWord;

            if (w2p[cWord] != cPattern || p2w[cPattern] != cWord) {
                matches = false;
                break;
            }
        }
        if (matches) result.push_back(word);
    }
    return result;
}


-----
#include <vector>
#include <string>
#include <unordered_map>

std::vector<std::string> findAndReplacePatterns(std::vector<std::string>& words, std::string pattern) 
    // Your code here
}


************************************
Question ID: 927

#include <algorithm>
#include <vector>

const int MOD = 1e9 + 7;

int sumOfWidths(std::vector<int>& nums) {
    int n = nums.size();
    std::sort(nums.begin(), nums.end());
    long long res = 0, c = 1;
    
    for (int i = 0; i < n; i++, c = c * 2 % MOD)
        res = (res + (nums[i] - nums[n - i - 1]) * c) % MOD;
        
    return res;
}

-----
#include <algorithm>
#include <vector>

const int MOD = 1e9 + 7;

int sumOfWidths(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 928

int surfaceArea(vector<vector<int>>& grid) {
    int n = grid.size();
    int area = 0;

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (grid[i][j]) {
                area += 4 * grid[i][j] + 2;
                if (i > 0) area -= 2 * min(grid[i][j], grid[i - 1][j]);
                if (j > 0) area -= 2 * min(grid[i][j], grid[i][j - 1]);
            }
        }
    }

    return area;
}

-----
int surfaceArea(vector<vector<int>>& grid) 
    // Your code here
}

************************************
Question ID: 929

#include <vector>
#include <string>
#include <unordered_set>
#include <algorithm>

int numSpecialEquivalentGroups(std::vector<std::string>& words) {
    std::unordered_set<std::string> groups;

    for (std::string word : words) {
        std::string evens, odds;

        for (size_t i = 0; i < word.size(); ++i) {
            if (i % 2 == 0) evens += word[i];
            else odds += word[i];
        }

        std::sort(evens.begin(), evens.end());
        std::sort(odds.begin(), odds.end());

        groups.insert(evens + odds);
    }

    return groups.size();
}


-----
#include <vector>
#include <string>
#include <unordered_set>
#include <algorithm>

int numSpecialEquivalentGroups(std::vector<std::string>& words) 
    // Your code here
}


************************************
Question ID: 931

#include <unordered_map>
#include <map>
#include <stack>

class FreqStack {
    std::unordered_map<int, int> freq;
    std::map<int, std::stack<int>> group;

public:
    FreqStack() {}

    void push(int x) {
        int f = ++freq[x];
        group[f].push(x);
    }

    int pop() {
        auto& st = group.rbegin()->second;
        int x = st.top();
        st.pop();
        if (st.empty()) {
            group.erase(group.rbegin()->first);
        }
        --freq[x];
        return x;
    }
};


-----
#include <unordered_map>
#include <map>
#include <stack>

class FreqStack 
    // Your code here
};


************************************
Question ID: 932

bool isMonotonic(vector<int>& nums) {
    bool increasing = true, decreasing = true;
    for (int i = 1; i < nums.size(); i++) {
        if (nums[i] > nums[i - 1]) decreasing = false;
        if (nums[i] < nums[i - 1]) increasing = false;
    }
    return increasing || decreasing;
}

-----
bool isMonotonic(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 934

#include <set>
#include <vector>

int subarrayBitwiseORs(std::vector<int>& arr) {
    std::set<int> result, current, temp;
    for (int num : arr) {
        temp = {num};
        for (int c : current) {
            temp.insert(num | c);
        }
        current = std::move(temp);
        result.insert(current.begin(), current.end());
    }
    return result.size();
}

-----
#include <set>
#include <vector>

int subarrayBitwiseORs(std::vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 935

#include <string>
using namespace std;

string lex_smallest_string(string s, int k) {
    string res = s;
    for (int i = 0; i < k; ++i) {
        string tmp = s.substr(i) + s.substr(0, i);
        if (tmp < res) res = tmp;
    }
    return res;
}

-----
#include <string>
using namespace std;

string lex_smallest_string(string s, int k) 
    // Your code here
}

************************************
Question ID: 938

#include <vector>
#include <string>
using namespace std;

int num_digits_less_than_n(vector<int>& digits, int n) {
    int ans = 0, factor = 1;
    string n_str = to_string(n);
    for (int i = n_str.size() - 1; i >= 0; --i) {
        ans += (upper_bound(digits.begin(), digits.end(), n_str[i] - '0') - digits.begin()) * factor;
        factor *= digits.size();
    }
    return ans;
}

-----
#include <vector>
#include <string>
using namespace std;

int num_digits_less_than_n(vector<int>& digits, int n) 
    // Your code here
}

************************************
Question ID: 939

#include <vector>
#define MOD 1000000007

int findValidPermutations(const std::string& s) {
    int n = s.size();
    std::vector<long long> dp(n + 2, 0);
    dp[0] = 1;

    for (char c : s) {
        std::vector<long long> new_dp(n + 2, 0);
        if (c == 'I') {
            for (int i = 0; i < n; ++i) {
                new_dp[i + 1] = (new_dp[i + 1] + dp[i]) % MOD;
            }
        } else {
            for (int i = n - 1; i >= 0; --i) {
                new_dp[i] = (new_dp[i + 1] + dp[i + 1]) % MOD;
            }
        }
        dp = new_dp;
    }
    return dp[0];
}

-----
#include <vector>
#define MOD 1000000007

int findValidPermutations(const std::string& s) 
    // Your code here
}

************************************
Question ID: 940

#include <vector>
#include <unordered_map>
using namespace std;

int totalFruit(vector<int>& fruits) {
    int left = 0, right = 0, max_count = 0, n = fruits.size();
    unordered_map<int, int> count;

    while (right < n) {
        count[fruits[right]]++;
        while (count.size() > 2) {
            count[fruits[left]]--;
            if (count[fruits[left]] == 0) {
                count.erase(fruits[left]);
            }
            left++;
        }
        max_count = max(max_count, right - left + 1);
        right++;
    }
    return max_count;
}

-----
#include <vector>
#include <unordered_map>
using namespace std;

int totalFruit(vector<int>& fruits) 
    // Your code here
}

************************************
Question ID: 941

#include <vector>
using namespace std;

void moveEvenOdd(vector<int>& nums) {
    int evenIndex = 0;
    int oddIndex = nums.size() - 1;

    while (evenIndex < oddIndex) {
        if (nums[evenIndex] % 2 == 0) {
            evenIndex++;
        } else {
            swap(nums[evenIndex], nums[oddIndex]);
            oddIndex--;
        }
    }
}

-----
#include <vector>
using namespace std;

void moveEvenOdd(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 942

bool isPalindrome(long num) {
    string str = to_string(num);
    string revStr = str;
    reverse(revStr.begin(), revStr.end());
    return str == revStr;
}

int superpalindromesInRange(string left, string right) {
    long l = stol(left);
    long r = stol(right);
    int cnt = 0;
    for (long base = 1; base * base <= r; ++base) {
        if (isPalindrome(base) && isPalindrome(base * base)) {
            if (base * base >= l) {
                cnt++;
            }
        }
    }
    return cnt;
}


-----
bool isPalindrome(long num) 
    // Your code here
}


************************************
Question ID: 943

int sumOfMins(vector<int>& arr) {
    int mod = 1e9 + 7;
    int n = arr.size();
    vector<int> left(n), right(n);
    stack<int> st;

    for (int i = 0; i < n; i++) {
        while (!st.empty() && arr[st.top()] > arr[i]) {
            st.pop();
        }
        left[i] = st.empty() ? -1 : st.top();
        st.push(i);
    }

    while (!st.empty()) st.pop();
    for (int i = n - 1; i >= 0; i--) {
        while (!st.empty() && arr[st.top()] > arr[i]) {
            st.pop();
        }
        right[i] = st.empty() ? n : st.top();
        st.push(i);
    }

    int ans = 0;
    for (int i = 0; i < n; i++) {
        ans = (ans + arr[i] * (i - left[i]) * (right[i] - i)) % mod;
    }
    return ans;
}

-----
int sumOfMins(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 944

int minDifference(vector<int>& nums, int k) {
    if(nums.size() <= 1) return 0;
    sort(nums.begin(), nums.end());
    int min_diff = nums.back() - nums.front();
    for(int i=1; i<nums.size(); i++) {
        int high = max(nums[i-1] + k, nums.back() - k);
        int low = min(nums[i] - k, nums.front() + k);
        min_diff = min(min_diff, high - low);
    }
    return min_diff;
}

-----
int minDifference(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 945

int snakesAndLadders(vector<vector<int>> &board) {
    int n = board.size();
    auto getRowCol = [&](int x) {
        int r = (x - 1) / n, c = (x - 1) % n;
        if (r % 2) c = n - 1 - c;
        return make_pair(n - 1 - r, c);
    };

    vector<bool> visited(n * n + 1, false);
    queue<pair<int, int>> q;
    q.push({1, 0});
    visited[1] = true;

    while (!q.empty()) {
        auto cur = q.front(); q.pop();
        int x = cur.first;
        int steps = cur.second;
        for (int jump = 1; jump <= 6; jump++) {
            int next_x = x + jump;
            if (next_x > n * n) break;
            auto nextRC = getRowCol(next_x);
            if (board[nextRC.first][nextRC.second] != -1) {
                next_x = board[nextRC.first][nextRC.second];
            }
            if (next_x == n * n) return steps + 1;
            if (!visited[next_x]) {
                visited[next_x] = true;
                q.push({next_x, steps + 1});
            }
        }
    }
    return -1;
}


-----
int snakesAndLadders(vector<vector<int>> &board) 
    // Your code here
}


************************************
Question ID: 946

int minimumScore(vector<int>& nums, int k) {
    sort(nums.begin(), nums.end());
    int n = nums.size();
    int res = nums[n - 1] - nums[0];
    
    for (int i = 0; i < n - 1; ++i) {
        int high = max(nums[i] + k, nums[n - 1] - k);
        int low = min(nums[i + 1] - k, nums[0] + k);
        res = min(res, high - low);
    }
    
    return res;
}

-----
int minimumScore(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 947

#include <vector>
#include <map>
using namespace std;

class TopVotedCandidate {
public:
    map<int, int> leaderMap;

    TopVotedCandidate(vector<int> persons, vector<int> times) {
        int leader = -1;
        map<int, int> votes;
        for (int i = 0; i < times.size(); ++i){
            votes[persons[i]]++;
            if (votes[persons[i]] >= votes[leader]){
                leader = persons[i];
            }
            leaderMap[times[i]] = leader;
        }
    }

    int q(int t){
        auto it = leaderMap.upper_bound(t);
        return prev(it)->second;
    }
};

-----
#include <vector>
#include <map>
using namespace std;

class TopVotedCandidate 
    // Your code here
};

************************************
Question ID: 948

#include <vector>
#include <algorithm>

void sortArray(std::vector<int>& nums) {
    std::sort(nums.begin(), nums.end());
}

-----
#include <vector>
#include <algorithm>

void sortArray(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 949

#include <vector>
#include <queue>
#include <tuple>
using namespace std;

int catMouseGame(vector<vector<int>>& graph) {
    int n = graph.size();
    vector<vector<vector<int>>> status(n, vector<vector<int>>(n, vector<int>(3, -1)));
    queue<tuple<int, int, int, int>> q;
    for (int i = 1; i < n; ++i) {
        status[i][i][1] = 2;
        status[i][i][2] = 2;
        q.push({i, i, 2, 2});
        q.push({i, i, 1, 2});
    }
    while (!q.empty()) {
        tuple<int, int, int, int> t = q.front();
        q.pop();
        int pos_m = get<0>(t), pos_c = get<1>(t), t_type = get<2>(t), t_result = get<3>(t);
        for (int prev : t_type == 1 ? graph[pos_m] : graph[pos_c]) {
            if (t_type == 2 && prev == 0 || t_result == 2 && status[prev][pos_c][3 - t_type] != -1) continue;
            if (status[prev][pos_c][3 - t_type] != -1) continue;
            q.push({pos_c, prev, 3 - t_type, 3 - t_result});
            status[prev][pos_c][3 - t_type] = 3 - t_result;
        }
    }
    return status[1][2][1];
}


-----
#include <vector>
#include <queue>
#include <tuple>
using namespace std;

int catMouseGame(vector<vector<int>>& graph) 
    // Your code here
}


************************************
Question ID: 950

#include <vector>
#include <unordered_map>
#include <algorithm>
using namespace std;

bool hasGroupsSizeX(vector<int>& deck) {
    unordered_map<int, int> counts;
    for (int card : deck) {
        counts[card]++;
    }
    int gcd_result = 0;
    for (auto& count : counts) {
        gcd_result = gcd(gcd_result, count.second);
    }
    return gcd_result > 1;
}

-----
#include <vector>
#include <unordered_map>
#include <algorithm>
using namespace std;

bool hasGroupsSizeX(vector<int>& deck) 
    // Your code here
}

************************************
Question ID: 951

#include <vector>
using namespace std;

int partitionDisjoint(vector<int>& nums) {
    int leftMax = nums[0], globalMax = nums[0], leftLength = 1;
    for (int i = 1; i < nums.size(); ++i) {
        if (nums[i] < leftMax) {
            leftMax = globalMax;
            leftLength = i + 1;
        } else {
            globalMax = max(globalMax, nums[i]);
        }
    }
    return leftLength;
}

-----
#include <vector>
using namespace std;

int partitionDisjoint(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 952

#include <vector>
#include <string>
#include <unordered_map>

std::vector<std::string> wordSubsets(std::vector<std::string>& words1, std::vector<std::string>& words2) {
    std::unordered_map<char, int> max_chars;
    for (const auto& word : words2) {
        std::unordered_map<char, int> chars;
        for (char c : word) {
            chars[c]++;
        }
        for (const auto& entry : chars) {
            max_chars[entry.first] = std::max(max_chars[entry.first], entry.second);
        }
    }

    std::vector<std::string> result;
    for (const auto& word : words1) {
        std::unordered_map<char, int> word_chars;
        for (char c : word) {
            word_chars[c]++;
        }

        bool universal = true;
        for (const auto& entry : max_chars) {
            if (word_chars[entry.first] < entry.second) {
                universal = false;
                break;
            }
        }

        if (universal) {
            result.push_back(word);
        }
    }

    return result;
}


-----
#include <vector>
#include <string>
#include <unordered_map>

std::vector<std::string> wordSubsets(std::vector<std::string>& words1, std::vector<std::string>& words2) 
    // Your code here
}


************************************
Question ID: 953

#include <string>
#include <algorithm>

std::string reverseString(const std::string& s) {
    std::string result = s;
    std::reverse(result.begin(), result.end());
    return result;
}


-----
#include <string>
#include <algorithm>

std::string reverseString(const std::string& s) 
    // Your code here
}


************************************
Question ID: 954

bool canReorderDoubled(vector<int>& arr) {
    map<int, int> count;
    for (int a : arr) {
        count[a]++;
    }
    
    for (const auto& [a, c] : count) {
        if (c > 0) {
            int target = a < 0 ? a / 2 : a * 2;
            if (count[target] < c) return false;
            count[target] -= c;
        }
    }

    return true;
}

-----
bool canReorderDoubled(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 955

#include <queue>

class TreeNode {
public:
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class CBTInserter {
public:
    TreeNode* root;
    std::queue<TreeNode*> q;
    
    CBTInserter(TreeNode* root) {
        this->root = root;
        q.push(root);
        while (!q.empty()) {
            TreeNode* node = q.front();
            if (!node->left || !node->right) break;
            q.push(node->left);
            q.push(node->right);
            q.pop();
        }
    }
    
    int insert(int v) {
        TreeNode* newNode = new TreeNode(v);
        TreeNode* parentNode = q.front();
        if (!parentNode->left) {
            parentNode->left = newNode;
        } else {
            parentNode->right = newNode;
            q.push(parentNode->left);
            q.push(parentNode->right);
            q.pop();
        }
        return parentNode->val;
    }
    
    TreeNode* get_root() {
        return root;
    }
};


-----
#include <queue>

class TreeNode 
    // Your code here
};


************************************
Question ID: 956

#include <vector>
#define MOD 1000000007

int numMusicPlaylists(int n, int goal, int k) {
    std::vector<std::vector<long long>> dp(goal + 1, std::vector<long long>(n + 1, 0));
    dp[0][0] = 1;
    for (int i = 1; i <= goal; i++) {
        for (int j = 1; j <= n; j++) {
            dp[i][j] = ((dp[i - 1][j - 1] * (n - (j - 1))) % MOD + (dp[i - 1][j] * std::max(0, j - k)) % MOD) % MOD;
        }
    }
    return dp[goal][n];
}

-----
#include <vector>
#define MOD 1000000007

int numMusicPlaylists(int n, int goal, int k) 
    // Your code here
}

************************************
Question ID: 957

int minAddToMakeValid(string s) {
    int result = 0, balance = 0;
    for (char c : s) {
        balance += (c == '(') ? 1 : -1;
        if (balance == -1) {
            result++;
            balance++;
        }
    }
    return result + balance;
}

-----
int minAddToMakeValid(string s) 
    // Your code here
}

************************************
Question ID: 958

vector<int> sortArrayByParityII(vector<int>& nums) {
    int j = 1;
    for (int i = 0; i < nums.size(); i += 2) {
        if (nums[i] % 2) {
            while (nums[j] % 2) {
                j += 2;
            }
            swap(nums[i], nums[j]);
        }
    }
    return nums;
}

-----
vector<int> sortArrayByParityII(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 959

#include <vector>
#include <algorithm>

int threeSumMulti(std::vector<int>& arr, int target) {
    const int MOD = 1000000007;
    long long ans = 0;

    sort(arr.begin(), arr.end());
    int n = arr.size();

    for (int i = 0; i < n - 2; ++i) {
        int j = i + 1, k = n - 1;
        while (j < k) {
            int sum = arr[i] + arr[j] + arr[k];
            if (sum > target) {
                k--;
            } else if (sum < target) {
                j++;
            } else {
                if (arr[j] != arr[k]) {
                    int left_count = 1, right_count = 1;

                    while (arr[j] == arr[j + 1]){
                        left_count++; 
                        j++;
                    }
                    while (arr[k] == arr[k - 1]){
                        right_count++;
                        k--;
                    }

                    ans += left_count * right_count;
                    ans %= MOD;
                    j++, k--;
                } else {
                    ans += (long long)(k - j + 1) * (k - j) / 2;
                    ans %= MOD;
                    break;
                }
            }
        }
    }

    return ans;
}

-----
#include <vector>
#include <algorithm>

int threeSumMulti(std::vector<int>& arr, int target) 
    // Your code here
}

************************************
Question ID: 960

#include <vector>
#include <unordered_set>
#include <queue>

int minMalwareSpread(std::vector<std::vector<int>>& graph, std::vector<int>& initial) {
    int n = graph.size();
    std::sort(initial.begin(), initial.end());
    
    std::unordered_set<int> malware(initial.begin(), initial.end());
    
    int minNode = initial[0], minSpread = n + 1;
    for (int node : initial) {
        std::queue<int> q;
        std::vector<bool> visited(n, false);
        
        for (int otherNode : initial) {
            if (node != otherNode) {
                q.push(otherNode);
                visited[otherNode] = true;
            }
        }

        while (!q.empty()) {
            int cur = q.front(); q.pop();
            for (int next = 0; next < n; ++next) {
                if (graph[cur][next] == 1 && !visited[next] && !malware.count(next)) {
                    visited[next] = true;
                    q.push(next);
                }
            }
        }
        
        int spread = 0;
        for (bool v : visited) {
            spread += v;
        }

        if (spread < minSpread) {
            minNode = node;
            minSpread = spread;
        }
    }
    
    return minNode;
}


-----
#include <vector>
#include <unordered_set>
#include <queue>

int minMalwareSpread(std::vector<std::vector<int>>& graph, std::vector<int>& initial) 
    // Your code here
}


************************************
Question ID: 961

bool isLongPressedName(string name, string typed) {
    int i = 0, j = 0;
    while (j < typed.length()) {
        if (i < name.length() && name[i] == typed[j]) {
            i++;
        } else if (j == 0 || typed[j] != typed[j - 1]) {
            return false;
        }
        j++;
    }
    return i == name.length();
}

-----
bool isLongPressedName(string name, string typed) 
    // Your code here
}

************************************
Question ID: 962

int minFlipsMonoIncr(string s) {
    int flipCount = 0, oneCount = 0;
    for (char c : s) {
        if (c == '1') {
            oneCount++;
        } else {
            flipCount = min(flipCount + 1, oneCount);
        }
    }
    return flipCount;
}

-----
int minFlipsMonoIncr(string s) 
    // Your code here
}

************************************
Question ID: 963

#include <vector>

std::vector<int> find_same_binary_value_parts(const std::vector<int>& arr) {
    int ones = 0;
    for (int n : arr) ones += n;

    if (ones % 3 != 0) return {-1, -1};

    int target = ones / 3;
    if (target == 0) return {0, static_cast<int>(arr.size()) - 2};

    int count = 0, i = -1, j = -1;
    ones = 0;
    for (int idx = 0; idx < arr.size(); ++idx) {
        if (arr[idx] == 1) {
            ones++;
            if (ones == target + 1) count++;
            if (count == 1 && i == -1) i = idx;
            if (count == 2 && j == -1) j = idx;
            if (count == 3) break;
        }
    }

    return {i, j};
}

-----
#include <vector>

std::vector<int> find_same_binary_value_parts(const std::vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 964

#include <vector>
#include <set>
#include <queue>
using namespace std;

int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    int n = graph.size(), res = 0, minSize = INT_MAX;
    vector<int> color(n, -1);
    int colors = 0;

    for (int i = 0; i < n; ++i) {
        if (color[i] == -1) {
            queue<int> q;
            q.push(i);
            color[i] = colors;

            while (!q.empty()) {
                int t = q.front(); q.pop();
                for (int j = 0; j < n; ++j) {
                    if (graph[t][j] == 1 && color[j] == -1) {
                        q.push(j);
                        color[j] = colors;
                    }
                }
            }
            ++colors;
        }
    }

    vector<int> area(colors, 0), count(colors, 0);
    set<int> initiallyInfected(initial.begin(), initial.end());
    for (int i = 0; i < n; ++i) {
        ++area[color[i]];
        if (initiallyInfected.count(i)) {
            ++count[color[i]];
        }
    }

    for (int i : initial) {
        if (count[color[i]] == 1) {
            if (area[color[i]] < minSize) {
                minSize = area[color[i]];
                res = i;
            } else if (area[color[i]] == minSize && i < res) {
                res = i;
            }
        }
    }

    return res;
}

-----
#include <vector>
#include <set>
#include <queue>
using namespace std;

int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) 
    // Your code here
}

************************************
Question ID: 965

#include <string>
#include <vector>
#include <set>

int numUniqueEmails(std::vector<std::string>& emails) {
    std::set<std::string> unique_emails;

    for (auto& email : emails) {
        std::string local_name, domain_name;
        bool at_sign_found = false, plus_sign_found = false;

        for (char c : email) {
            if (!at_sign_found) {
                if (c == '+') plus_sign_found = true;
                else if (c == '@') at_sign_found = true;
                else if (!plus_sign_found && c != '.') local_name += c;
            }
            else domain_name += c;
        }

        unique_emails.insert(local_name + "@" + domain_name);
    }

    return unique_emails.size();
}

-----
#include <string>
#include <vector>
#include <set>

int numUniqueEmails(std::vector<std::string>& emails) 
    // Your code here
}

************************************
Question ID: 966

#include <vector>
#include <unordered_map>

int numSubarraysWithSum(std::vector<int>& nums, int goal) {
    std::unordered_map<int, int> prefix_sum_count = {{0, 1}};
    int sum = 0, result = 0;
    
    for (const auto& num : nums) {
        sum += num;
        result += prefix_sum_count[sum - goal];
        prefix_sum_count[sum]++;
    }
    
    return result;
}

-----
#include <vector>
#include <unordered_map>

int numSubarraysWithSum(std::vector<int>& nums, int goal) 
    // Your code here
}

************************************
Question ID: 967

int minFallingPathSum(vector<vector<int>>& matrix) {
    int n = matrix.size();
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            int min_val = matrix[i - 1][j];
            if (j > 0) min_val = min(min_val, matrix[i - 1][j - 1]);
            if (j < n - 1) min_val = min(min_val, matrix[i - 1][j + 1]);
            matrix[i][j] += min_val;
        }
    }
    return *min_element(matrix.back().begin(), matrix.back().end());
}

-----
int minFallingPathSum(vector<vector<int>>& matrix) 
    // Your code here
}

************************************
Question ID: 968

vector<int> beautifulArray(int n) {
    vector<int> result = {1};
    while (result.size() < n) {
        vector<int> temp;
        for (int i : result) {
            if (i * 2 - 1 <= n)
                temp.push_back(i * 2 - 1);
        }
        for (int i : result) {
            if (i * 2 <= n)
                temp.push_back(i * 2);
        }
        result = temp;
    }
    return result;
}

-----
vector<int> beautifulArray(int n) 
    // Your code here
}

************************************
Question ID: 969

#include <deque>

class RecentCounter {
public:
    std::deque<int> requests;
    
    RecentCounter() { }
    
    int ping(int t) {
        requests.push_back(t);
        while (requests.front() < t - 3000) {
            requests.pop_front();
        }
        return requests.size();
    }
};

-----
#include <deque>

class RecentCounter 
    // Your code here
};

************************************
Question ID: 970

#include <vector>
#include <cmath>
#include <set>

std::vector<int> powerfulIntegers(int x, int y, int bound) {
    int max_i = x == 1 ? 0 : std::ceil(std::log(bound) / std::log(x));
    int max_j = y == 1 ? 0 : std::ceil(std::log(bound) / std::log(y));
    std::set<int> result_set;
    
    for (int i = 0; i <= max_i; i++) {
        for (int j = 0; j <= max_j; j++) {
            int powerful_num = std::pow(x, i) + std::pow(y, j);
            if (powerful_num <= bound) {
                result_set.insert(powerful_num);
            }
        }
    }
    
    return std::vector<int>(result_set.begin(), result_set.end());
}

-----
#include <vector>
#include <cmath>
#include <set>

std::vector<int> powerfulIntegers(int x, int y, int bound) 
    // Your code here
}

************************************
Question ID: 971

#include <vector>
#include <queue>

using namespace std;

int shortestBridge(vector<vector<int>>& grid) {
    int n = grid.size();
    queue<pair<int, int>> q;
    bool flag = false;
    
    for (int i = 0; i < n && !flag; ++i) {
        for (int j = 0; j < n; ++j) {
            if (grid[i][j] == 1) {
                dfs(grid, q, i, j);
                flag = true;
                break;
            }
        }
    }
    
    int steps = 0;
    vector<vector<int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    
    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; ++i) {
            auto [x, y] = q.front(); q.pop();
            for (auto& [dx, dy] : directions) {
                int nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] != 2) {
                    if (grid[nx][ny] == 1) return steps;
                    grid[nx][ny] = 2;
                    q.push({nx, ny});
                }
            }
        }
        ++steps;
    }
    
    return -1;
}

void dfs(vector<vector<int>>& grid, queue<pair<int, int>>& q, int i, int j) {
    int n = grid.size();
    if (i < 0 || i >= n || j < 0 || j >= n || grid[i][j] != 1) return;
    grid[i][j] = 2;
    q.push({i, j});
    dfs(grid, q, i - 1, j);
    dfs(grid, q, i + 1, j);
    dfs(grid, q, i, j - 1);
    dfs(grid, q, i, j + 1);
}


-----
#include <vector>
#include <queue>

using namespace std;

int shortestBridge(vector<vector<int>>& grid) 
    // Your code here
}


************************************
Question ID: 972

int knightDialer(int n) {
    if (n == 1) return 10;
    const int mod = 1e9 + 7;
    vector<vector<int>> moves = {
        {4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9},
        {}, {1, 7, 0}, {2, 6}, {1, 3}, {2, 4}
    };
    vector<int> dp(10, 1);
    for (int i = 2; i <= n; ++i) {
        vector<int> new_dp(10, 0);
        for (int j = 0; j < 10; ++j)
            for (const auto& move : moves[j])
                new_dp[j] = (new_dp[j] + dp[move]) % mod;
        dp = std::move(new_dp);
    }
    return accumulate(dp.begin(), dp.end(), 0, [&](int a, int b) { return (a + b) % mod; });
}

-----
int knightDialer(int n) 
    // Your code here
}

************************************
Question ID: 973

#include <vector>
#include <string>

std::vector<int> movesToStamp(std::string stamp, std::string target) {
    std::vector<int> result;
    int stamp_count = 0;
    bool isStamped[10000] = {false};
    
    while (stamp_count < 10 * target.length()) {
        bool found_stamp = false;
        for (int i = 0; i <= target.length() - stamp.length(); ++i) {
            if (isStamped[i]) continue;
            int j = 0;
            int overlap = 0;
            while (j < stamp.length() && (target[i + j] == '?' || target[i + j] == stamp[j])) {
                if (target[i + j] == stamp[j]) overlap++;
                j++;
            }
            if (j == stamp.length() && overlap > 0) {
                for (j = 0; j < stamp.length(); ++j)
                    target[i + j] = '?';
                result.push_back(i);
                isStamped[i] = true;
                found_stamp = true;
            }
        }
        if (!found_stamp)
            break;       
        
        stamp_count++;
    }
    for (char c : target)
        if (c != '?') return {};
    
    std::reverse(result.begin(), result.end());
    return result;
}


-----
#include <vector>
#include <string>

std::vector<int> movesToStamp(std::string stamp, std::string target) 
    // Your code here
}


************************************
Question ID: 974

int subarraysDivByK(vector<int>& nums, int k) {
    vector<int> prefixSumsModK(k, 0);
    prefixSumsModK[0] = 1;
    int runningSum = 0;
    int count = 0;
    
    for (int i = 0; i < nums.size(); ++i) {
        runningSum += nums[i];
        int mod = (runningSum % k + k) % k;
        count += prefixSumsModK[mod]++;
    }
    
    return count;
}

-----
int subarraysDivByK(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 975

int rangeSumBST(TreeNode* root, int low, int high) {
    if (!root) return 0;
    if (root->val < low) return rangeSumBST(root->right, low, high);
    if (root->val > high) return rangeSumBST(root->left, low, high);
    return root->val + rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);
}

-----
int rangeSumBST(TreeNode* root, int low, int high) 
    // Your code here
}

************************************
Question ID: 976

#include <set>
#include <vector>

double minAreaRect(std::vector<std::vector<int>>& points) {
    std::set<std::pair<int, int>> point_set;
    for (const auto& point : points) {
        point_set.emplace(point[0], point[1]);
    }

    double min_area = INT32_MAX;
    for (const auto& p1 : point_set) {
        for (const auto& p2 : point_set) {
            if (p1.first != p2.first && p1.second != p2.second) {
                if (point_set.count({p1.first, p2.second}) && point_set.count({p2.first, p1.second})) {
                    min_area = std::min(min_area, abs((p1.first - p2.first) * (p1.second - p2.second)));
                }
            }
        }
    }

    return min_area == INT32_MAX ? 0 : min_area;
}


-----
#include <set>
#include <vector>

double minAreaRect(std::vector<std::vector<int>>& points) 
    // Your code here
}


************************************
Question ID: 977

#include <iostream>
#include <string>

int distinctSubseqII(std::string s) {
    int mod = 1e9 + 7;
    int n = s.size();
    std::vector<int> dp(n + 1);
    dp[0] = 1;
    std::vector<int> last(26, -1); 

    for (int i = 1; i <= n; ++i) {
        dp[i] = (dp[i - 1] * 2) % mod;
        if (last[s[i - 1] - 'a'] != -1) {
            dp[i] = (dp[i] - dp[last[s[i - 1] - 'a']] + mod) % mod;
        }
        last[s[i - 1] - 'a'] = i - 1;
    }

    dp[n] = (dp[n] - 1 + mod) % mod;
    return dp[n];
}

-----
#include <iostream>
#include <string>

int distinctSubseqII(std::string s) 
    // Your code here
}

************************************
Question ID: 978

bool validMountainArray(vector<int>& arr) {
    int n = arr.size(), i = 0, j = n - 1;
    while (i + 1 < n && arr[i] < arr[i + 1]) i++;
    while (j > 0 && arr[j - 1] > arr[j]) j--;
    return i > 0 && i == j && j < n - 1;
}

-----
bool validMountainArray(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 979

#include <vector>
#include <string>
using namespace std;

vector<int> decode_permutation(string s) {
    int n = s.length();
    vector<int> perm(n + 1);
    int next_zero = 0, next_one = n;

    for (char c : s) {
        if (c == '0') {
            perm[next_zero++] = next_one--;
        } else {
            perm[next_one--] = next_zero++;
        }
    }
    perm[next_zero] = next_one;
    return perm;
}


-----
#include <vector>
#include <string>
using namespace std;

vector<int> decode_permutation(string s) 
    // Your code here
}


************************************
Question ID: 980

#include <string>
#include <vector>
#include <algorithm>

std::string smallestSuperstring(std::vector<std::string>& words) {
    while (words.size() > 1) {
        int maxLength = -1, p1 = 0, p2 = 0;
        std::string temp;
        for (int i = 0; i < words.size(); ++i) {
            for (int j = i + 1; j < words.size(); ++j) {
                int sharedLength = std::min(words[i].length(), words[j].length());
                for (; sharedLength > maxLength; --sharedLength) {
                    if (words[i].substr(words[i].length() - sharedLength) == words[j].substr(0, sharedLength)) {
                        maxLength = sharedLength;
                        p1 = i;
                        p2 = j;
                        temp = words[i] + words[j].substr(sharedLength);
                        break;
                    }
                }
            }
        }
        words[p1] = temp;
        words.erase(words.begin() + p2);
    }
    return words[0];
}

-----
#include <string>
#include <vector>
#include <algorithm>

std::string smallestSuperstring(std::vector<std::string>& words) 
    // Your code here
}

************************************
Question ID: 981

int minDeletionSize(vector<string>& strs) {
    int num_deleted = 0;
    for (int col = 0; col < strs[0].size(); ++col) {
        for (int row = 1; row < strs.size(); ++row) {
            if (strs[row][col] < strs[row - 1][col]) {
                ++num_deleted;
                break;
            }
        }
    }
    return num_deleted;
}


-----
int minDeletionSize(vector<string>& strs) 
    // Your code here
}


************************************
Question ID: 982

#include <algorithm>
#include <vector>

int min_moves_unique(std::vector<int>& nums) {
    std::sort(nums.begin(), nums.end());
    int moves = 0;
    for (size_t i = 1; i < nums.size(); ++i) {
        if (nums[i] <= nums[i - 1]) {
            moves += nums[i - 1] - nums[i] + 1;
            nums[i] = nums[i - 1] + 1;
        }
    }
    return moves;
}

-----
#include <algorithm>
#include <vector>

int min_moves_unique(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 983

#include <vector>
#include <stack>

bool validateStackSequences(std::vector<int>& pushed, std::vector<int>& popped) {
    std::stack<int> stack;
    int popIndex = 0;
    
    for (int pushValue : pushed) {
        stack.push(pushValue);
        while (!stack.empty() && stack.top() == popped[popIndex]) {
            stack.pop();
            popIndex++;
        }
    }
    
    return stack.empty();
}


-----
#include <vector>
#include <stack>

bool validateStackSequences(std::vector<int>& pushed, std::vector<int>& popped) 
    // Your code here
}


************************************
Question ID: 984

#include <unordered_map>
#include <vector>

int removeStones(std::vector<std::vector<int>>& stones) {
    std::unordered_map<int, int> row_groups, col_groups;
    int group_count = 0;

    std::function<int(int, bool)> getGroupId = [&](int idx, bool isRow) -> int {
        auto& groups = isRow ? row_groups : col_groups;
        if (!groups.count(idx)) {
            groups[idx] = group_count++;
        }
        return groups[idx];
    };

    std::vector<std::vector<int>> groups(group_count);
    for (auto& [x, y] : stones) {
        int group_x = getGroupId(x, true);
        int group_y = getGroupId(10001 + y, false); // Offset by max row index
        groups[group_x].push_back(group_y);
        groups[group_y].push_back(group_x);
    }

    int max_stones = 0;
    std::vector<bool> visited(group_count);

    auto dfs = [&](int groupId, auto& dfs_ref) -> int {
        if (visited[groupId]) return 0;
        visited[groupId] = true;
        int size = 1;
        for (int neighbor : groups[groupId]) {
            size += dfs_ref(neighbor, dfs_ref);
        }
        return size;
    };

    for (int groupId = 0; groupId < group_count; groupId++) {
        max_stones += dfs(groupId, dfs) - 1;
    }

    return max_stones;
}

-----
#include <unordered_map>
#include <vector>

int removeStones(std::vector<std::vector<int>>& stones) 
    // Your code here
}

************************************
Question ID: 985

#include <vector>
#include <algorithm>

int bagOfTokensScore(std::vector<int>& tokens, int power) {
    std::sort(tokens.begin(), tokens.end());
    int score = 0, maxScore = 0;
    int left = 0, right = tokens.size() - 1;
    
    while (left <= right) {
        if (power >= tokens[left]) {
            power -= tokens[left++];
            score++;
            maxScore = std::max(maxScore, score);
        } else if (score > 0) {
            power += tokens[right--];
            score--;
        } else {
            break;
        }
    }
    return maxScore;
}

-----
#include <vector>
#include <algorithm>

int bagOfTokensScore(std::vector<int>& tokens, int power) 
    // Your code here
}

************************************
Question ID: 986

#include <algorithm>
#include <string>
#include <vector>

std::string largestTimeFromDigits(std::vector<int>& arr) {
    std::sort(arr.begin(), arr.end(), std::greater<>());
    do {
        if ((arr[0] < 3 || (arr[0] == 2 && arr[1] < 4)) && arr[2] < 6){
            return std::to_string(arr[0]) + std::to_string(arr[1]) + ':' + std::to_string(arr[2]) + std::to_string(arr[3]);
        }
    } while (std::prev_permutation(arr.begin(), arr.end()));
    return "";
}

-----
#include <algorithm>
#include <string>
#include <vector>

std::string largestTimeFromDigits(std::vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 987

#include <vector>
#include <deque>
#include <algorithm>

std::vector<int> deckRevealedIncreasing(std::vector<int>& deck) {
    int n = deck.size();
    std::deque<int> index;
    for (int i = 0; i < n; ++i)
        index.push_back(i);

    std::vector<int> ans(n);
    std::sort(deck.begin(), deck.end());

    for (int card : deck) {
        ans[index.front()] = card;
        index.pop_front();
        if (!index.empty()) {
            index.push_back(index.front());
            index.pop_front();
        }
    }

    return ans;
}

-----
#include <vector>
#include <deque>
#include <algorithm>

std::vector<int> deckRevealedIncreasing(std::vector<int>& deck) 
    // Your code here
}

************************************
Question ID: 989

#include<vector>
#include<unordered_set>
#include<unordered_map>

using namespace std;

int primes(int n) {
    for (int i = 2; i * i <= n; ++i) {
        if (n % i == 0) return i;
    }
    return n;
}

int largestComponentSize(vector<int>& nums) {
    int count = 0;
    unordered_map<int, unordered_set<int>> graph;
    unordered_set<int> visited;
    for (int num : nums) {
        int prime = primes(num);
        graph[prime].insert(num);
        if (num != prime) graph[num].insert(prime);
    }

    function<int(int)> dfs = [&](int node) {
        if (!visited.insert(node).second) return 0;
        int res = 1;
        for (int neighbor : graph[node]) {
            res += dfs(neighbor);
        }
        return res;
    };

    for (int num : nums) {
        count = max(count, dfs(num));
    }
    return count;
}

-----
#include<vector>
#include<unordered_set>
#include<unordered_map>

using namespace std;

int primes(int n) 
    // Your code here
}

************************************
Question ID: 990

bool isAlienSorted(vector<string>& words, string order) {
    int alien_order[26];
    for (int i = 0; i < 26; ++i) {
        alien_order[order[i] - 'a'] = i;
    }

    for (int i = 1; i < words.size(); ++i) {
        for (int j = 0; j < words[i - 1].size(); ++j) {
            if (j == words[i].size()) {
                return false;
            }

            if (words[i - 1][j] != words[i][j]) {
                if (alien_order[words[i - 1][j] - 'a'] > alien_order[words[i][j] - 'a']) {
                    return false;
                }
                break;
            }
        }
    }

    return true;
}

-----
bool isAlienSorted(vector<string>& words, string order) 
    // Your code here
}

************************************
Question ID: 991

#include <vector>
#include <unordered_map>
#include <algorithm>

bool canReorderArray(std::vector<int>& arr) {
    std::unordered_map<int, int> count;
    for (int n : arr) {
        count[n]++;
    }
    sort(arr.begin(), arr.end());
    for (int x : arr) {
        if (count[x] == 0) {
            continue;
        }
        if (count[2 * x] > 0) {
            count[x]--;
            count[2 * x]--;
        } else {
            return false;
        }
    }
    return true;
}

-----
#include <vector>
#include <unordered_map>
#include <algorithm>

bool canReorderArray(std::vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 993

int tallestBillboard(vector<int>& rods) {
    int n = rods.size();
    int totalLength = accumulate(rods.begin(), rods.end(), 0);
    vector<vector<int>> dp(n + 1, vector<int>(totalLength + 1, -1));
    dp[0][0] = 0;
    
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= totalLength; j++) {
            dp[i][j] = dp[i - 1][j];
            if (rods[i - 1] <= j) dp[i][j] = max(dp[i][j], dp[i - 1][j - rods[i - 1]] + rods[i - 1]);
            if (rods[i - 1] <= totalLength - j) dp[i][j] = max(dp[i][j], dp[i - 1][j + rods[i - 1]]);
        }
    }
    
    return dp[n][0] / 2;
}


-----
int tallestBillboard(vector<int>& rods) 
    // Your code here
}


************************************
Question ID: 994

#include <vector>

std::vector<int> prisonAfterNDays(std::vector<int>& cells, int n) {
    std::vector<int> temp(8, 0);
    n = n % 14 == 0 ? 14 : n % 14; // Pattern repeats every 14 days

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j < 7; ++j) {
            temp[j] = !(cells[j - 1] ^ cells[j + 1]);
        }
        cells = temp;
    }

    return cells;
}

-----
#include <vector>

std::vector<int> prisonAfterNDays(std::vector<int>& cells, int n) 
    // Your code here
}

************************************
Question ID: 995

int minKBitFlips(vector<int>& nums, int k) {
    int n = nums.size();
    vector<int> flipped(n, 0);
    int flips = 0, ans = 0;
    for (int i = 0; i < n; ++i) {
        if (i >= k) flips = (flips - flipped[i - k]) % 2;
        if ((flips + nums[i]) % 2 == 0) {
            if (i + k > n) return -1;
            flipped[i] = 1;
            flips = (flips + 1) % 2;
            ans++;
        }
    }
    return ans;
}

-----
int minKBitFlips(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 996

#include <vector>
#include <unordered_map>

bool isSquare(int n) {
    int root = sqrt(n);
    return root * root == n;
}

void dfs(std::vector<int>& nums, int idx, int& count,
         std::unordered_map<int, int>& counter) {
    if (idx == nums.size()) {
        count++;
        return;
    }

    for (auto it : counter) {
        if (it.second && (idx == 0 || isSquare(nums[idx - 1] + it.first))) {
            counter[it.first]--;
            nums[idx] = it.first;
            dfs(nums, idx + 1, count, counter);
            counter[it.first]++;
        }
    }
}

int numSquarefulPerms(std::vector<int>& nums) {
    std::unordered_map<int, int> counter;
    for (int num : nums)
        counter[num]++;

    int count = 0;
    dfs(nums, 0, count, counter);
    return count;
}


-----
#include <vector>
#include <unordered_map>

bool isSquare(int n) 
    // Your code here
}


************************************
Question ID: 997

int findJudge(int n, vector<vector<int>>& trust) {
    vector<int> trustCounts(n + 1, 0);
    for (auto& t : trust) {
        trustCounts[t[0]]--;
        trustCounts[t[1]]++;
    }
    for (int i = 1; i <= n; i++) {
        if (trustCounts[i] == n - 1)
            return i;
    }
    return -1;
}

-----
int findJudge(int n, vector<vector<int>>& trust) 
    // Your code here
}

************************************
Question ID: 999

#include <vector>
#include <string>

int regionsBySlashes(std::vector<std::string>& grid) {
    int n = grid.size();
    std::vector<std::vector<int>> graph(n * 3, std::vector<int>(n * 3, 0));

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (grid[i][j] == '/') {
                graph[i * 3][j * 3 + 2] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3] = 1;
            }
            if (grid[i][j] == '\\') {
                graph[i * 3][j * 3] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3 + 2] = 1;
            }
        }
    }

    int regions = 0;
    for (int i = 0; i < n * 3; ++i) {
        for (int j = 0; j < n * 3; ++j) {
            if (!graph[i][j]) {
                regions++;
                dfs(graph, i, j);
            }
        }
    }

    return regions;
}

void dfs(std::vector<std::vector<int>>& graph, int i, int j) {
    int n = graph.size();
    if (i < 0 || j < 0 || i >= n || j >= n || graph[i][j]) return;
    
    graph[i][j] = 1;
    dfs(graph, i - 1, j);
    dfs(graph, i + 1, j);
    dfs(graph, i, j - 1);
    dfs(graph, i, j + 1);
}

-----
#include <vector>
#include <string>

int regionsBySlashes(std::vector<std::string>& grid) 
    // Your code here
}

************************************
Question ID: 1000

#include <vector>
#include <string>

int minDeletionSize(std::vector<std::string>& strs) {
    int rows = strs.size(), cols = strs[0].size();
    int count = 0;
    for (int c = 0; c < cols; ++c) {
        for (int r = 1; r < rows; ++r) {
            if (strs[r - 1][c] > strs[r][c]) {
                ++count;
                break;
            }
        }
    }
    return count;
}


-----
#include <vector>
#include <string>

int minDeletionSize(std::vector<std::string>& strs) 
    // Your code here
}


************************************
Question ID: 1001

int repeatedNTimes(vector<int>& nums) {
    unordered_map<int, int> hashMap;
    for (int num : nums) {
        if (++hashMap[num] > 1) return num;
    }
}


-----
int repeatedNTimes(vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 1002


```cpp
#include <vector>
#include <algorithm>

int maxWidthRamp(std::vector<int>& nums) {
    std::vector<int> indices(nums.size());
    for (int i = 0; i < nums.size(); ++i) {
        indices[i] = i;
    }
    
    std::sort(indices.begin(), indices.end(), [&](int i, int j) {
        return nums[i] == nums[j] ? i < j : nums[i] < nums[j];
    });
    
    int maxWidth = 0;
    int minIndex = std::numeric_limits<int>::max();
    for (int index : indices) {
        maxWidth = std::max(maxWidth, index - minIndex);
        minIndex = std::min(minIndex, index);
    }
    
    return maxWidth;
}
```


-----

```cpp
#include <vector>
#include <algorithm>

int maxWidthRamp(std::vector<int>& nums) 
    // Your code here
}
```


************************************
Question ID: 1003

#include <unordered_map>
#include <set>
#include <cmath>
#include <vector>
#include <limits>

using namespace std;

double minAreaFreeRect(vector<vector<int>>& points) {
    double minArea = numeric_limits<double>::infinity();
    unordered_map<int, set<int>> xGroups;

    for (const auto& point : points) {
        xGroups[point[0]].insert(point[1]);
    }

    for (const auto& [x1, ys1] : xGroups) {
        for (const auto& [x2, ys2] : xGroups) {
            if (x1 == x2) continue;

            for (int y1 : ys1) {
                for (int y2 : ys2) {
                    if (ys1.find(y2) != ys1.end() && ys2.find(y1) != ys2.end()) {
                        double area = sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2)) * sqrt(pow(x1 - x2, 2) + pow(y1 - y1, 2));
                        minArea = min(minArea, area);
                    }
                }
            }
        }
    }

    return minArea == numeric_limits<double>::infinity() ? 0 : minArea;
}


-----
#include <unordered_map>
#include <set>
#include <cmath>
#include <vector>
#include <limits>

using namespace std;

double minAreaFreeRect(vector<vector<int>>& points) 
    // Your code here
}


************************************
Question ID: 1004

int leastOpsExpressTarget(int x, int target) {
    if (x == target) return 0;
    if (target == 1) return 1;
    if (x > target) return min(2 * target - 1, 2 * (x - target));
    
    int k = 0;
    long long p = x;
    while (p < target) {
        k++;
        p *= x;
    }
    
    int ans = INT_MAX;
    long long d = 1;

    for (int i = k - 1; i >= 0; i--) {
        while (p >= target + d * (1 - x)) {
            p -= d;
            ans = min(ans, i + (int) (log2(target / d) + 1) + (int) (d == 1 ? -1 : 0));
        }
        d = d * x + 1;
    }

    return ans;
}


-----
int leastOpsExpressTarget(int x, int target) 
    // Your code here
}


************************************
Question ID: 1005

bool isUnivalued(TreeNode* root, int val = -1) {
    if (!root) return true;
    if (val == -1) val = root->val;
    return root->val == val && isUnivalued(root->left, val) && isUnivalued(root->right, val);
}

-----
bool isUnivalued(TreeNode* root, int val = -1) 
    // Your code here
}

************************************
Question ID: 1006

#include <string>
#include <vector>
#include <unordered_map>
#include <algorithm>

std::vector<std::string> spellchecker(std::vector<std::string>& wordlist, std::vector<std::string>& queries) {
    std::unordered_map<std::string, std::string> wordMap;
    std::unordered_map<std::string, std::string> wordMapLowerCase;
    std::unordered_map<std::string, std::string> wordMapVowelReplaced;
    
    for (const auto &word : wordlist) {
        std::string lowerWord = word;
        for (auto &ch : lowerWord) ch = tolower(ch);
        std::string vowelReplacedWord = lowerWord;
        for (auto &ch : vowelReplacedWord)
            if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') ch = '#';

        wordMap[word] = word;
        if (!wordMapLowerCase.count(lowerWord)) wordMapLowerCase[lowerWord] = word;
        if (!wordMapVowelReplaced.count(vowelReplacedWord)) wordMapVowelReplaced[vowelReplacedWord] = word;
    }

    std::vector<std::string> result;
    for (const auto &query : queries) {
        std::string lowerQuery = query;
        for (auto &ch : lowerQuery) ch = tolower(ch);
        std::string vowelReplacedQuery = lowerQuery;
        for (auto &ch : vowelReplacedQuery)
            if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') ch = '#';

        if (wordMap.count(query)) {
            result.push_back(wordMap[query]);
        } else if (wordMapLowerCase.count(lowerQuery)) {
            result.push_back(wordMapLowerCase[lowerQuery]);
        } else if (wordMapVowelReplaced.count(vowelReplacedQuery)) {
            result.push_back(wordMapVowelReplaced[vowelReplacedQuery]);
        } else {
            result.push_back("");
        }
    }

    return result;
}


-----
#include <string>
#include <vector>
#include <unordered_map>
#include <algorithm>

std::vector<std::string> spellchecker(std::vector<std::string>& wordlist, std::vector<std::string>& queries) 
    // Your code here
}


************************************
Question ID: 1007

#include <vector>
#include <string>

std::vector<int> numsSameConsecDiff(int n, int k) {
    std::vector<int> result;
    if (n == 1) result.push_back(0);

    std::function<void(std::string)> dfs = [&](std::string current) {
        if (current.size() == n) {
            result.push_back(stoi(current));
            return;
        }

        char last_digit = current.back();
        if (last_digit - k >= '0') dfs(current + static_cast<char>(last_digit - k));
        if (k != 0 && last_digit + k <= '9') dfs(current + static_cast<char>(last_digit + k));
    };

    for (char i = '1'; i <= '9'; ++i) {
        dfs(std::string(1, i));
    }

    return result;
}

-----
#include <vector>
#include <string>

std::vector<int> numsSameConsecDiff(int n, int k) 
    // Your code here
}

************************************
Question ID: 1008

int minCameraCover(TreeNode* root) {
    int ans = 0;
    return (dfs(root, ans) < 1 ? 1 : 0) + ans;
}

int dfs(TreeNode* node, int& ans) {
    if (!node) return 2;
    int left = dfs(node->left, ans);
    int right = dfs(node->right, ans);
    if (left == 0 || right == 0) {
        ans++;
        return 1;
    }
    return left == 1 || right == 1 ? 2 : 0;
}


-----
int minCameraCover(TreeNode* root) 
    // Your code here
}


************************************
Question ID: 1009

#include <vector>
#include <algorithm>
using namespace std;

vector<int> pancakeSort(vector<int>& arr) {
    vector<int> flips;
    for (int size = arr.size(); size > 1; --size) {
        int maxIdx = max_element(arr.begin(), arr.begin() + size) - arr.begin();
        flips.push_back(maxIdx + 1);
        flips.push_back(size);
        reverse(arr.begin(), arr.begin() + maxIdx + 1);
        reverse(arr.begin(), arr.begin() + size);
    }
    return flips;
}

-----
#include <vector>
#include <algorithm>
using namespace std;

vector<int> pancakeSort(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1010

#include <set>
#include <vector>
#include <cmath>

std::vector<int> powerful_integers(int x, int y, int bound) {
    std::set<int> result;
    for (int i = 0; pow(x, i) <= bound; ++i) {
        for (int j = 0; pow(x, i) + pow(y, j) <= bound; ++j) {
            result.insert(pow(x, i) + pow(y, j));
        }
    }
    return std::vector<int>(result.begin(), result.end());
}


-----
#include <set>
#include <vector>
#include <cmath>

std::vector<int> powerful_integers(int x, int y, int bound) 
    // Your code here
}


************************************
Question ID: 1011

#include <vector>
#include <queue>
using namespace std;

void flipRecur(TreeNode* node, vector<int>& voyage, int& idx, vector<int>& flipped)
{
    if (node == nullptr) return;
    if (node->val != voyage[idx++])
    {
        flipped = {-1};
        return;
    }
    if (idx < voyage.size() && node->left != nullptr && node->left->val != voyage[idx])
    {
        flipped.push_back(node->val);
        flipRecur(node->right, voyage, idx, flipped);
        flipRecur(node->left, voyage, idx, flipped);
    }
    else
    {
        flipRecur(node->left, voyage, idx, flipped);
        flipRecur(node->right, voyage, idx, flipped);
    }
}

vector<int> flipMatchVoyage(TreeNode* root, vector<int>& voyage) {
    vector<int> flipped;
    int idx = 0;
    flipRecur(root, voyage, idx, flipped);
    return flipped;
}


-----
#include <vector>
#include <queue>
using namespace std;

void flipRecur(TreeNode* node, vector<int>& voyage, int& idx, vector<int>& flipped)

    // Your code here
}


************************************
Question ID: 1012

bool isRationalEqual(std::string s, std::string t) {
    auto eval = [](std::string s) {
        int i = s.find('(');
        if (i != std::string::npos) {
            std::string base = s.substr(0, i);
            std::string rep = s.substr(i + 1, s.length() - i - 2);
            for (int k = 0; k < 20; ++k) base += rep;
            return stod(base);
        }
        return stod(s);
    };
    return fabs(eval(s) - eval(t)) < 1e-12;
}

-----
bool isRationalEqual(std::string s, std::string t) 
    // Your code here
}

************************************
Question ID: 1013

int fib(int n) {
    if (n <= 1)
        return n;
    int a = 0, b = 1, c;
    for (int i = 2; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    return b;
}

-----
int fib(int n) 
    // Your code here
}

************************************
Question ID: 1014

#include <algorithm>
#include <vector>

std::vector<std::vector<int>> kClosest(std::vector<std::vector<int>>& points, int k) {
    std::partial_sort(points.begin(), points.begin() + k, points.end(), [](const std::vector<int>& a, const std::vector<int>& b) {
        return a[0] * a[0] + a[1] * a[1] < b[0] * b[0] + b[1] * b[1];
    });

    return std::vector<std::vector<int>>(points.begin(), points.begin() + k);
}

-----
#include <algorithm>
#include <vector>

std::vector<std::vector<int>> kClosest(std::vector<std::vector<int>>& points, int k) 
    // Your code here
}

************************************
Question ID: 1015

int smallestRepunitDivByK(int k) {
    if (k % 2 == 0 || k % 5 == 0) return -1;
    int n = 0;
    for (int i = 1; i <= k; i++) {
        n = (n * 10 + 1) % k;
        if (n == 0) return i;
    }
    return -1;
}

-----
int smallestRepunitDivByK(int k) 
    // Your code here
}

************************************
Question ID: 1016

int subarraysDivByK(vector<int>& nums, int k) {
    unordered_map<int, int> counts;
    counts[0] = 1;
    int sum = 0, result = 0;

    for (int num : nums) {
        sum += num;
        int mod = ((sum % k) + k) % k;
        result += counts[mod];
        counts[mod]++;
    }

    return result;
}

-----
int subarraysDivByK(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 1017

#include <vector>
#include <map>

int oddEvenJumps(std::vector<int>& arr) {
    int n = arr.size();
    std::vector<bool> canReachOdd(n, false), canReachEven(n, false);
    canReachOdd[n - 1] = canReachEven[n - 1] = true;
    std::map<int, int> indexMap;
    indexMap[arr[n - 1]] = n - 1;

    int goodIndices = 1;
    for (int i = n - 2; i >= 0; --i) {
        auto oddJump = indexMap.lower_bound(arr[i]);
        auto evenJump = indexMap.upper_bound(arr[i]);

        if (oddJump != indexMap.end())
            canReachOdd[i] = canReachEven[oddJump->second];
        if (evenJump != indexMap.begin())
            canReachEven[i] = canReachOdd[(--evenJump)->second];

        if (canReachOdd[i]) ++goodIndices;

        indexMap[arr[i]] = i;
    }

    return goodIndices;
}

-----
#include <vector>
#include <map>

int oddEvenJumps(std::vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1018

#include <vector>
#include <algorithm>

int largestPerimeter(std::vector<int>& nums) {
    std::sort(nums.begin(), nums.end(), std::greater<int>());

    for (size_t i = 0; i < nums.size() - 2; ++i) {
        if (nums[i] < nums[i + 1] + nums[i + 2]) {
            return nums[i] + nums[i + 1] + nums[i + 2];
        }
    }

    return 0;
}

-----
#include <vector>
#include <algorithm>

int largestPerimeter(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1019

#include<vector>
#include<algorithm>
using namespace std;

vector<int> sortedSquares(vector<int>& nums) {
    for(int i = 0; i < nums.size(); i++) {
        nums[i] *= nums[i];
    }
    sort(nums.begin(), nums.end());
    return nums;
}

-----
#include<vector>
#include<algorithm>
using namespace std;

vector<int> sortedSquares(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1020

int maxTurbulenceSize(vector<int>& arr) {
    int n = arr.size();
    int result = 1;
    int i = 0;

    while (i < n - 1) {
        if (arr[i] == arr[i + 1]) {
            i++;
            continue;
        }

        int j = i + 1;
        while (j < n - 1 && ((arr[j] > arr[j + 1]) != (arr[j - 1] > arr[j])))
            j++;
        
        result = max(result, j - i + 1);
        i = j;
    }

    return result;
}


-----
int maxTurbulenceSize(vector<int>& arr) 
    // Your code here
}


************************************
Question ID: 1021

int distributeCoins(TreeNode* root, int &moves) {
    if (root == nullptr) return 0;
    int left = distributeCoins(root->left, moves);
    int right = distributeCoins(root->right, moves);
    moves += abs(left) + abs(right);
    return root->val + left + right - 1;
}

int distributeCoins(TreeNode* root) {
    int moves = 0;
    distributeCoins(root, moves);
    return moves;
}

-----
int distributeCoins(TreeNode* root, int &moves) 
    // Your code here
}

************************************
Question ID: 1022

int dfs(vector<vector<int>>& grid, int x, int y, int empty) {
    if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == -1) {
        return 0;
    }
    if (grid[x][y] == 2) {
        return empty == -1 ? 1 : 0;
    }
    grid[x][y] = -1;
    int paths = dfs(grid, x + 1, y, empty - 1) + dfs(grid, x - 1, y, empty - 1) + dfs(grid, x, y + 1, empty - 1) + dfs(grid, x, y - 1, empty - 1);
    grid[x][y] = 0;
    return paths;
}

int uniquePathsIII(vector<vector<int>>& grid) {
    int x = 0, y = 0, empty = 1;
    for (int i = 0; i < grid.size(); ++i) {
        for (int j = 0; j < grid[0].size(); ++j) {
            if (grid[i][j] == 1) {
                x = i, y = j;
            } else if (grid[i][j] == 0) {
                empty++;
            }
        }
    }
    return dfs(grid, x, y, empty);
}

-----
int dfs(vector<vector<int>>& grid, int x, int y, int empty) 
    // Your code here
}

************************************
Question ID: 1023

#include <map>
#include <string>

class TimeMap {
public:
    std::map<std::string, std::map<int, std::string>> data;

    void set(const std::string& key, const std::string& value, int timestamp) {
        data[key][timestamp] = value;
    }

    std::string get(const std::string& key, int timestamp) {
        if (!data.count(key)) return "";
        auto it = data[key].upper_bound(timestamp);
        if (it == data[key].begin()) return "";
        return prev(it)->second;
    }
};

-----
#include <map>
#include <string>

class TimeMap 
    // Your code here
};

************************************
Question ID: 1024

int countAndTriples(vector<int>& nums) {
    int count = 0;
    for (int i = 0; i < nums.size(); ++i) {
        for (int j = i + 1; j < nums.size(); ++j) {
            for (int k = j + 1; k < nums.size(); ++k) {
                if (nums[i] & nums[j] & nums[k])
                    ++count;
            }
        }
    }
    return count;
}

-----
int countAndTriples(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1025

#include <vector>
#include <unordered_set>
#include <algorithm>
using namespace std;

int mincostTickets(vector<int>& days, vector<int>& costs) {
  unordered_set<int> travel_days(days.begin(), days.end());
  vector<int> dp(366, 0);

  for (int i = 1; i <= 365; ++i) {
    if (travel_days.count(i) == 0) {
      dp[i] = dp[i - 1];
    } else {
      dp[i] = min({dp[i - 1] + costs[0],
                   dp[max(0, i - 7)] + costs[1],
                   dp[max(0, i - 30)] + costs[2]});
    }
  }

  return dp[365];
}

-----
#include <vector>
#include <unordered_set>
#include <algorithm>
using namespace std;

int mincostTickets(vector<int>& days, vector<int>& costs) 
    // Your code here
}

************************************
Question ID: 1027

#include <vector>
using namespace std;

vector<int> sumEvenAfterQueries(vector<int>& nums, vector<vector<int>>& queries) {
    vector<int> answer;
    int even_sum = 0;
    
    for (int num : nums) {
        if (num % 2 == 0) {
            even_sum += num;
        }
    }
    
    for (vector<int>& query : queries) {
        int value = query[0];
        int index = query[1];
        
        if (nums[index] % 2 == 0) {
            even_sum -= nums[index];
        }
        nums[index] += value;
        if (nums[index] % 2 == 0) {
            even_sum += nums[index];
        }
        answer.push_back(even_sum);
    }
    
    return answer;
}


-----
#include <vector>
using namespace std;

vector<int> sumEvenAfterQueries(vector<int>& nums, vector<vector<int>>& queries) 
    // Your code here
}


************************************
Question ID: 1028

#include <vector>
using namespace std;

vector<vector<int>> intervalIntersection(vector<vector<int>>& firstList, vector<vector<int>>& secondList) {
    vector<vector<int>> result;
    int i = 0, j = 0;
    
    while (i < firstList.size() && j < secondList.size()) {
        int start = max(firstList[i][0], secondList[j][0]);
        int end = min(firstList[i][1], secondList[j][1]);
        
        if (start <= end) {
            result.push_back({start, end});
        }
        
        if (firstList[i][1] < secondList[j][1]) {
            i++;
        } else {
            j++;
        }
    }
    
    return result;
}

-----
#include <vector>
using namespace std;

vector<vector<int>> intervalIntersection(vector<vector<int>>& firstList, vector<vector<int>>& secondList) 
    // Your code here
}

************************************
Question ID: 1029

#include <vector>
#include <map>
#include <queue>

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

std::vector<std::vector<int>> verticalTraversal(TreeNode* root) {
    std::vector<std::vector<int>> result;
    if (!root) return result;
    
    std::map<int, std::map<int, std::multiset<int>>> columns;
    std::queue<std::tuple<TreeNode*, int, int>> q;
    q.push({root, 0, 0});
    
    while (!q.empty()) {
        auto [node, row, col] = q.front();
        q.pop();
        columns[col][row].insert(node->val);
        
        if (node->left) q.push({node->left, row + 1, col - 1});
        if (node->right) q.push({node->right, row + 1, col + 1});
    }
    
    for (auto &[_, columnData] : columns) {
        result.emplace_back();
        for (auto &[_, nodes] : columnData) {
            result.back().insert(result.back().end(), nodes.begin(), nodes.end());
        }
    }
    
    return result;
}

-----
#include <vector>
#include <map>
#include <queue>

struct TreeNode 
    // Your code here
}

************************************
Question ID: 1031

#include <vector>
#include <algorithm>
using namespace std;

vector<int> addToArrayForm(vector<int>& num, int k) {
    // add k to the least significant digit of the integer represented by num
    num.back() += k;
    // sum digits from least to most significant digit
    for (int i = num.size() - 1; i > 0 && num[i]; --i) {
        num[i - 1] += num[i] / 10;
        num[i] %= 10;
    }
    // handle possible remaining carry
    while (num[0] >= 10) {
        num.insert(num.begin(), num[0] / 10);
        num[1] %= 10;
    }
    return num;
}


-----
#include <vector>
#include <algorithm>
using namespace std;

vector<int> addToArrayForm(vector<int>& num, int k) 
    // Your code here
}


************************************
Question ID: 1032

#include <vector>
#include <string>

bool equationsPossible(std::vector<std::string>& equations) {
    std::vector<int> parent(26, 0);

    for (int i = 0; i < 26; ++i) {
        parent[i] = i;
    }

    for (const auto& eq : equations) {
        if (eq[1] == '=') {
            int x = eq[0] - 'a';
            int y = eq[3] - 'a';
            parent[find(x, parent)] = find(y, parent);
        }
    }

    for (const auto& eq : equations) {
        if (eq[1] == '!' && find(eq[0] - 'a', parent) == find(eq[3] - 'a', parent)) {
            return false;
        }
    }

    return true;
}

int find(int x, std::vector<int>& parent) {
    if (parent[x] != x) {
        parent[x] = find(parent[x], parent);
    }

    return parent[x];
}


-----
#include <vector>
#include <string>

bool equationsPossible(std::vector<std::string>& equations) 
    // Your code here
}


************************************
Question ID: 1033

int brokenCalc(int startValue, int target) {
    int operations = 0;
    while (target > startValue) {
        target = (target % 2 == 0) ? target / 2 : target + 1;
        operations++;
    }
    return operations + startValue - target;
}

-----
int brokenCalc(int startValue, int target) 
    // Your code here
}

************************************
Question ID: 1034

#include <unordered_map>

int good_subarrays(vector<int>& nums, int k) {
    int count = 0;
    for (int i = 0; i < nums.size(); i++) {
        unordered_map<int, int> frequency;
        for (int j = i; j < nums.size(); j++) {
            frequency[nums[j]]++;
            if (frequency.size() > k) break;
            if (frequency.size() == k) count++;
        }
    }
    return count;
}

-----
#include <unordered_map>

int good_subarrays(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 1036

#include <queue>
#include <vector>

int orangesRotting(std::vector<std::vector<int>>& grid) {
    int m = grid.size();
    int n = grid[0].size();
    int freshOranges = 0;
    std::queue<std::pair<int, int>> rotten;

    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (grid[i][j] == 1)
                freshOranges++;
            else if (grid[i][j] == 2)
                rotten.push({i, j});
        }
    }
    
    int minutes = 0;
    std::vector<std::vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    
    while (!rotten.empty() && freshOranges != 0) {
        int size = rotten.size();
        for (int i = 0; i < size; ++i) {
            auto current = rotten.front();
            rotten.pop();

            for (auto& direction : directions) {
                int x = current.first + direction[0];
                int y = current.second + direction[1];

                if (x < 0 || y < 0 || x >= m || y >= n || grid[x][y] != 1)
                    continue;

                grid[x][y] = 2;
                freshOranges--;
                rotten.push({x, y});
            }
        }
        minutes++;
    }
    
    return freshOranges == 0 ? minutes : -1;
}


-----
#include <queue>
#include <vector>

int orangesRotting(std::vector<std::vector<int>>& grid) 
    // Your code here
}


************************************
Question ID: 1037

int minKBitFlips(vector<int>& nums, int k) {
    int n = nums.size(), res = 0, flipped = 0;
    vector<int> change(n, 0);
    for (int i = 0; i <= n - k; i++) {
        flipped ^= change[i];
        if (nums[i] ^ flipped == 0) {
            res++;
            flipped ^= 1;
            if (i + k < n) change[i + k] ^= 1;
        }
    }
    for (int i = n - k + 1; i < n; i++) {
        flipped ^= change[i];
        if (nums[i] ^ flipped == 0) return -1;
    }
    return res;
}


-----
int minKBitFlips(vector<int>& nums, int k) 
    // Your code here
}


************************************
Question ID: 1038

#include<cmath>
#include<algorithm>

bool is_squareful(int x, int y) {
    int s = sqrt(x + y);
    return s * s == x + y;
}

void count_permutations(const vector<int>& nums, int start, int &count) {
    if (start == nums.size()) {
        count++;
        return;
    }
    for (int i = start; i < nums.size(); i++) {
        if (i == start || nums[i] != nums[start]) {
            if (start == 0 || is_squareful(nums[start - 1], nums[i])) {
                swap(nums[i], nums[start]);
                count_permutations(nums, start + 1, count);
                swap(nums[i], nums[start]);
            }
        }
    }
}

int squareful_perms(vector<int> nums) {
    int count = 0;
    sort(nums.begin(), nums.end());
    count_permutations(nums, 0, count);
    return count;
}


-----
#include<cmath>
#include<algorithm>

bool is_squareful(int x, int y) 
    // Your code here
}


************************************
Question ID: 1039

int findJudge(int n, vector<vector<int>>& trust) {
    vector<int> trustCounts(n + 1, 0);
    for (vector<int>& relation : trust) {
        trustCounts[relation[0]]--;
        trustCounts[relation[1]]++;
    }
    
    for (int i = 1; i <= n; ++i) {
        if (trustCounts[i] == n - 1) {
            return i;
        }
    }
    return -1;
}

-----
int findJudge(int n, vector<vector<int>>& trust) 
    // Your code here
}

************************************
Question ID: 1040

TreeNode* insertIntoMaxTree(TreeNode* root, int val) {
    if (!root || val > root->val) {
        TreeNode *newNode = new TreeNode(val);
        newNode->left = root;
        return newNode;
    }
    root->right = insertIntoMaxTree(root->right, val);
    return root;
}


-----
TreeNode* insertIntoMaxTree(TreeNode* root, int val) 
    // Your code here
}


************************************
Question ID: 1041

#include <vector>
#include <string>

int numRookCaptures(std::vector<std::string>& board) {
    int x = 0, y = 0, captures = 0;
    for (x = 0; x < 8; ++x) {
        for (y = 0; y < 8; ++y) {
            if (board[x][y] == 'R') {
                break;
            }
        }
        if (y < 8) break;
    }

    std::vector<std::pair<int, int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    for (auto& dir : dirs) {
        int nx = x + dir.first;
        int ny = y + dir.second;
        while (nx >= 0 && nx < 8 && ny >= 0 && ny < 8) {
            if (board[nx][ny] == 'p') {
                captures++;
                break;
            } else if (board[nx][ny] == 'B') {
                break;
            }
            nx += dir.first;
            ny += dir.second;
        }
    }
    
    return captures;
}


-----
#include <vector>
#include <string>

int numRookCaptures(std::vector<std::string>& board) 
    // Your code here
}


************************************
Question ID: 1042

int mergeStones(vector<int>& stones, int k) {
    int n = stones.size();
    if ((n - 1) % (k - 1) != 0) return -1;
    vector<int> prefixSum(n + 1, 0);
    vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(k + 1, 0)));

    for (int i = 0; i < n; ++i) {
        prefixSum[i + 1] = prefixSum[i] + stones[i];
    }

    for (int l = 2; l <= n; ++l) {
        for (int i = 0; i <= n - l; ++i) {
            int j = i + l - 1;
            for (int m = 2; m <= k; ++m) {
                for (int p = i; p + m <= j + 1; p += k - 1) {
                    dp[i][j][m] = (dp[i][p][1] + dp[p + 1][j][m - 1]) % (1e9 + 7);
                }
            }
            if ((j - i) % (k - 1) == 0) {
                dp[i][j][1] = (dp[i][j][k] + prefixSum[j + 1] - prefixSum[i]) % (1e9 + 7);
            }
        }
    }
    return dp[0][n - 1][1];
}

-----
int mergeStones(vector<int>& stones, int k) 
    // Your code here
}

************************************
Question ID: 1043

#include <vector>
#include <unordered_set>
using namespace std;

vector<int> gridIllumination(int n, vector<vector<int>>& lamps, vector<vector<int>>& queries) {
    unordered_set<int> lampCols, lampRows, lampLeftDiag, lampRightDiag;
    vector<int> ans;

    for (auto& lamp : lamps) {
        int row = lamp[0];
        int col = lamp[1];
        lampRows.insert(row);
        lampCols.insert(col);
        lampLeftDiag.insert(row - col);
        lampRightDiag.insert(row + col);
    }

    for (auto& query : queries) {
        int row = query[0];
        int col = query[1];
        if (lampRows.count(row) || lampCols.count(col) || lampLeftDiag.count(row - col) || lampRightDiag.count(row + col)) {
            ans.push_back(1);
        } else {
            ans.push_back(0);
        }
        for (int i = -1; i <= 1; i++) {
            for (int j = -1; j <= 1; j++) {
                int newRow = row + i;
                int newCol = col + j;
                lampRows.erase(newRow);
                lampCols.erase(newCol);
                lampLeftDiag.erase(newRow - newCol);
                lampRightDiag.erase(newRow + newCol);
            }
        }
    }
    return ans;
}


-----
#include <vector>
#include <unordered_set>
using namespace std;

vector<int> gridIllumination(int n, vector<vector<int>>& lamps, vector<vector<int>>& queries) 
    // Your code here
}


************************************
Question ID: 1044

#include <vector>
#include <string>
#include <unordered_map>

std::vector<char> commonChars(std::vector<std::string>& words) {
    std::unordered_map<char, int> merged;
    for (const auto& word : words) {
        std::unordered_map<char, int> word_map;
        for (char c : word) {
            ++word_map[c];
        }
        if (merged.empty()) {
            merged = word_map;
        }
        else {
            for (auto& entry : merged) {
                entry.second = std::min(entry.second, word_map[entry.first]);
            }
        }
    }

    std::vector<char> result;
    for (const auto& entry : merged) {
        for (int i = 0; i < entry.second; ++i) {
            result.push_back(entry.first);
        }
    }
    return result;
}

-----
#include <vector>
#include <string>
#include <unordered_map>

std::vector<char> commonChars(std::vector<std::string>& words) 
    // Your code here
}

************************************
Question ID: 1046

int longestOnes(vector<int>& nums, int k) {
    int left = 0, right = 0, maxOnes = 0, zeroCount = 0;
    while (right < nums.size()) {
        if (nums[right] == 0) zeroCount++;
        while (zeroCount > k) {
            if (nums[left] == 0) zeroCount--;
            left++;
        }
        maxOnes = max(maxOnes, right - left + 1);
        right++;
    }
    return maxOnes;
}


-----
int longestOnes(vector<int>& nums, int k) 
    // Your code here
}


************************************
Question ID: 1047

int maxSumAfterKOperations(vector<int>& nums, int k) {
    priority_queue<int, vector<int>, greater<int>> pq(nums.begin(), nums.end());
    while(k--){
        int current = pq.top();
        pq.pop();
        pq.push(-current);
    }
    return accumulate(nums.begin(), nums.end(), 0);
}

-----
int maxSumAfterKOperations(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 1048

int clumsy(int n) {
    if (n <= 2) {
        return n;
    }
    if (n == 3) {
        return 6;
    }
    int result = n * (n - 1) / (n - 2) + (n - 3);
    n -= 4;
    while (n >= 4) {
        result = result - (n * (n - 1) / (n - 2)) + (n - 3);
        n -= 4;
    }
    return result - clumsy(n);
}


-----
int clumsy(int n) 
    // Your code here
}


************************************
Question ID: 1049

#include <vector>
#include <algorithm>

int min_rotations(std::vector<int>& tops, std::vector<int>& bottoms) {
    int res = INT_MAX;

    for (int target : {tops[0], bottoms[0]}) {
        int top_rot = 0, bot_rot = 0;
        for (int i = 0; i < tops.size(); ++i) {
            if (tops[i] != target && bottoms[i] != target) {
                top_rot = bot_rot = INT_MAX;
                break;
            }
            top_rot += tops[i] != target;
            bot_rot += bottoms[i] != target;
        }
        res = std::min({res, top_rot, bot_rot});
    }

    return res == INT_MAX ? -1 : res;
}

-----
#include <vector>
#include <algorithm>

int min_rotations(std::vector<int>& tops, std::vector<int>& bottoms) 
    // Your code here
}

************************************
Question ID: 1051

#include <vector>
#include <algorithm>

int heightChecker(std::vector<int>& heights) {
    std::vector<int> expected = heights;
    std::sort(expected.begin(), expected.end());

    int count = 0;
    for (int i = 0; i < heights.size(); ++i) {
        if (heights[i] != expected[i]) {
            ++count;
        }
    }

    return count;
}

-----
#include <vector>
#include <algorithm>

int heightChecker(std::vector<int>& heights) 
    // Your code here
}

************************************
Question ID: 1052

int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
    int total_customers = 0, max_extra_customers = 0, extra_customers = 0;
    for (int i = 0; i < customers.size(); ++i) {
        if (grumpy[i] == 0) {
            total_customers += customers[i];
        }
        if (i < minutes) {
            extra_customers += customers[i] * grumpy[i];
        } else {
            extra_customers += (customers[i] * grumpy[i]) - (customers[i - minutes] * grumpy[i - minutes]);
        }
        max_extra_customers = max(max_extra_customers, extra_customers);
    }
    return total_customers + max_extra_customers;
}


-----
int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) 
    // Your code here
}


************************************
Question ID: 1053

#include <vector>
using namespace std;

vector<int> prevPermOpt1(vector<int>& arr) {
    int n = arr.size();
    for (int i = n - 2; i >= 0; i--) {
        if (arr[i] > arr[i + 1]) {
            int j = i + 1;
            while (j < n && arr[j] < arr[i]) j++;
            swap(arr[i], arr[j - 1]);
            break;
        }
    }
    return arr;
}


-----
#include <vector>
using namespace std;

vector<int> prevPermOpt1(vector<int>& arr) 
    // Your code here
}


************************************
Question ID: 1054

int bitwiseComplement(int n) {
    int x = 1;
    while (n > x) {
        x = x * 2 + 1;
    }
    return x - n;
}

-----
int bitwiseComplement(int n) 
    // Your code here
}

************************************
Question ID: 1055

#include <vector>
using namespace std;

int numPairsDivisibleBy60(vector<int>& time) {
    int count[60] = {0};
    int pairs = 0;

    for (int t : time) {
        int mod = t % 60;
        pairs += count[(60 - mod) % 60];
        count[mod]++;
    }

    return pairs;
}

-----
#include <vector>
using namespace std;

int numPairsDivisibleBy60(vector<int>& time) 
    // Your code here
}

************************************
Question ID: 1056


```cpp
#include <vector>
#include <algorithm>

int shipWithinDays(std::vector<int>& weights, int days) {
    int left = *max_element(weights.begin(), weights.end());
    int right = accumulate(weights.begin(), weights.end(), 0);
    while (left < right) {
        int mid = left + (right - left) / 2;
        int day_count = 1, curr_capacity = 0;
        for (int w : weights) {
            curr_capacity += w;
            if (curr_capacity > mid) {
                day_count++;
                curr_capacity = w;
            }
        }
        if (day_count > days) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}
```

-----

```cpp
#include <vector>
#include <algorithm>

int shipWithinDays(std::vector<int>& weights, int days) 
    // Your code here
}
```

************************************
Question ID: 1057

#include <set>
using namespace std;

int numDupDigitsAtMostN(int n) {
    int count = 0;
    for (int i = 1; i <= n; i++) {
        set<int> digits;
        int num = i;
        while (num != 0) {
            int digit = num % 10;
            if (digits.count(digit)) {
                count++;
                break;
            } else {
                digits.insert(digit);
            }
            num /= 10;
        }
    }
    return count;
}

-----
#include <set>
using namespace std;

int numDupDigitsAtMostN(int n) 
    // Your code here
}

************************************
Question ID: 1058

#include <vector>
#include <cmath>
#include <string>
using namespace std;

string findRoundingError(vector<string>& prices, int target) {
    int n = prices.size();
    vector<double> decimals(n);
    int rounded_sum = 0;
    double error_sum = 0.0;

    for (int i = 0; i < n; ++i) {
        double price = stod(prices[i]);
        decimals[i] = price - floor(price);
        rounded_sum += floor(price);
        error_sum += decimals[i];
    }

    if (target < rounded_sum || target > rounded_sum + n) {
        return "-1 ";
    }

    int ceil_count = target - rounded_sum;
    double rounding_error = 0.0;

    for (int i = 0; i < n; ++i) {
        if (ceil_count > 0) {
            rounding_error += 1 - decimals[i];
            --ceil_count;
        } else {
            rounding_error += decimals[i];
        }
    }

    return to_string(rounding_error).substr(0, 5) + " ";
}


-----
#include <vector>
#include <cmath>
#include <string>
using namespace std;

string findRoundingError(vector<string>& prices, int target) 
    // Your code here
}


************************************
Question ID: 1059

#include <vector>
#include <unordered_map>

bool dfs(int node, const std::unordered_map<int, std::vector<int>>& graph, std::vector<int>& visited, int destination) {
    if (graph.find(node) == graph.end()) return node == destination;
    if (visited[node] != 0) return visited[node] == 2;

    visited[node] = 1;
    for (int neighbor : graph.at(node)) {
        if (!dfs(neighbor, graph, visited, destination)) return false;
    }

    visited[node] = 2;
    return true;
}

bool leadsToDestination(int n, const std::vector<std::vector<int>>& edges, int source, int destination) {
    std::unordered_map<int, std::vector<int>> graph;
    for (const auto& edge : edges) {
        graph[edge[0]].push_back(edge[1]);
    }

    std::vector<int> visited(n, 0);
    return dfs(source, graph, visited, destination);
}

-----
#include <vector>
#include <unordered_map>

bool dfs(int node, const std::unordered_map<int, std::vector<int>>& graph, std::vector<int>& visited, int destination) 
    // Your code here
}

************************************
Question ID: 1060

int findKthPositive(vector<int>& nums, int k) {
    int left = 0, right = nums.size();
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] - mid - 1 < k) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left + k;
}

-----
int findKthPositive(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 1061

#include <iostream>
#include <map>

std::string lexSmallestEquivalent(std::string s1, std::string s2, std::string baseStr) {
    std::map<char, char> parent;
    for (char ch = 'a'; ch <= 'z'; ch++) {
        parent[ch] = ch;
    }

    for (int i = 0; i < s1.size(); i++) {
        char root1 = s1[i], root2 = s2[i];
        while (parent[root1] != root1) root1 = parent[root1];
        while (parent[root2] != root2) root2 = parent[root2];
        if (root1 != root2) {
            parent[root1] = std::min(root1, root2);
            parent[root2] = std::min(root1, root2);
        }
    }

    for (int i = 0; i < baseStr.size(); i++) {
        char ch = baseStr[i];
        while (parent[ch] != ch) ch = parent[ch];
        baseStr[i] = ch;
    }

    return baseStr;
}

-----
#include <iostream>
#include <map>

std::string lexSmallestEquivalent(std::string s1, std::string s2, std::string baseStr) 
    // Your code here
}

************************************
Question ID: 1062

int findLongestRepeatingSubstring(const std::string &s) {
    int n = s.length();
    int max_substr_length = 0;
    for (int len = 1; len <= n/2; ++len) {
        int max_repeat_count = 0, repeat_count = 0;
        for (int i = 0; i < n - len; ++i) {
            if (s.substr(i, len) == s.substr(i + len, len)) {
                repeat_count++;
            } else {
                max_repeat_count = std::max(max_repeat_count, repeat_count);
                repeat_count = 0;
            }
        }
        max_substr_length = std::max(max_substr_length, max_repeat_count * len);
    }
    return max_substr_length;
}

-----
int findLongestRepeatingSubstring(const std::string &s) 
    // Your code here
}

************************************
Question ID: 1063

int maxScoreSightseeingPair(vector<int>& values) {
    int max_score = 0, max_score_left = values[0] + 0;
    for (int j = 1; j < values.size(); ++j) {
        max_score = max(max_score, max_score_left + values[j] - j);
        max_score_left = max(max_score_left, values[j] + j);
    }
    return max_score;
}

-----
int maxScoreSightseeingPair(vector<int>& values) 
    // Your code here
}

************************************
Question ID: 1064

int fixedPoint(vector<int>& arr) {
    int left = 0, right = arr.size() - 1;
    while (left < right) {
        int middle = left + (right - left) / 2;
        if (arr[middle] < middle) {
            left = middle + 1;
        } else {
            right = middle;
        }
    }
    return arr[left] == left ? left : -1;
}

-----
int fixedPoint(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1065

bool hasAllCodesInRange(const std::string& s, int n) {
    std::unordered_set<std::string> substrings;
    int length = std::to_string(n).length();
    for (int i = 0; i < s.length() - length + 1; ++i) {
        substrings.insert(s.substr(i, length));
    }
    return substrings.size() == n;
}


-----
bool hasAllCodesInRange(const std::string& s, int n) 
    // Your code here
}


************************************
Question ID: 1066

#include<vector>
#include<climits>
using namespace std;

int manhattanDistance(vector<int>& worker, vector<int>& bike) {
    return abs(worker[0] - bike[0]) + abs(worker[1] - bike[1]);
}

void dfs(vector<vector<int>>& workers, vector<vector<int>>& bikes, vector<bool>& used, int index, int dist, int& minDist) {
    if (index == workers.size()) {
        minDist = min(minDist, dist);
        return;
    }
    
    if (dist >= minDist) {
        return;
    }
    
    for (int i = 0; i < bikes.size(); i++) {
        if (used[i]) {
            continue;
        }
        used[i] = true;
        int curDist = manhattanDistance(workers[index], bikes[i]);
        dfs(workers, bikes, used, index+1, dist + curDist, minDist);
        used[i] = false;
    }
}

int assignBikes(vector<vector<int>>& workers, vector<vector<int>>& bikes) {
    int minDist = INT_MAX;
    vector<bool> used(bikes.size(), false);
    dfs(workers, bikes, used, 0, 0, minDist);
    return minDist;
}

-----
#include<vector>
#include<climits>
using namespace std;

int manhattanDistance(vector<int>& worker, vector<int>& bike) 
    // Your code here
}

************************************
Question ID: 1067

int countDigit(int d, int low, int high) {
    int count = 0;
    for (int i = low; i <= high; ++i) {
        int num = i;
        while (num) {
            if (num % 10 == d) {
                count++;
            }
            num /= 10;
        }
    }
    return count;
}

-----
int countDigit(int d, int low, int high) 
    // Your code here
}

************************************
Question ID: 1071

#include <vector>

std::vector<bool> prefixesDivBy5(std::vector<int>& nums) {
    std::vector<bool> result;
    int current = 0;
    for (int num : nums) {
        current = ((current << 1) | num) % 5;
        result.push_back(current == 0);
    }
    return result;
}

-----
#include <vector>

std::vector<bool> prefixesDivBy5(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1073

#include <vector>
using namespace std;

vector<int> addNegabinary(vector<int>& arr1, vector<int>& arr2) {
    vector<int> res;
    int carry = 0, i = arr1.size() - 1, j = arr2.size() - 1;
    while (i >= 0 || j >= 0 || carry) {
        if (i >= 0) carry += arr1[i--];
        if (j >= 0) carry += arr2[j--];
        res.push_back(carry & 1);
        carry = -(carry >> 1);
    }
    while (res.size() > 1 && res.back() == 0) res.pop_back();
    reverse(res.begin(), res.end());
    return res;
}


-----
#include <vector>
using namespace std;

vector<int> addNegabinary(vector<int>& arr1, vector<int>& arr2) 
    // Your code here
}


************************************
Question ID: 1074

int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {
    int rows = matrix.size(), cols = matrix[0].size();
    for (int row = 0; row < rows; ++row)
        for (int col = 1; col < cols; ++col)
            matrix[row][col] += matrix[row][col-1];
    
    int count = 0;
    unordered_map<int, int> counter;
    for (int col1 = 0; col1 < cols; ++col1) {
        for (int col2 = col1; col2 < cols; ++col2) {
            counter.clear();
            counter[0] = 1;
            int cur_sum = 0;
            for (int row = 0; row < rows; ++row) {
                cur_sum += matrix[row][col2] - (col1 > 0 ? matrix[row][col1-1] : 0);
                count += counter[cur_sum - target];
                ++counter[cur_sum];
            }
        }
    }
    return count;
}

-----
int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) 
    // Your code here
}

************************************
Question ID: 1078

#include <string>
#include <stack>

std::string removeOuterParentheses(std::string s) {
    std::string result;
    int opened = 0;

    for (char c : s) {
        if (c == '(' && opened++ > 0) {
            result += c;
        }
        if (c == ')' && opened-- > 1) {
            result += c;
        }
    }
    return result;
}


-----
#include <string>
#include <stack>

std::string removeOuterParentheses(std::string s) 
    // Your code here
}


************************************
Question ID: 1079

int sumRootToLeaf(TreeNode* root, int path_val = 0) {
    if (!root) return 0;
    path_val = path_val * 2 + root->val;
    if (!root->left && !root->right) return path_val;
    return sumRootToLeaf(root->left, path_val) + sumRootToLeaf(root->right, path_val);
}

-----
int sumRootToLeaf(TreeNode* root, int path_val = 0) 
    // Your code here
}

************************************
Question ID: 1080

// Definition for a binary tree node.
// struct TreeNode {
//     int val;
//     TreeNode *left;
//     TreeNode *right;
//     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
// };

class Solution {
public:
    TreeNode* sufficientSubset(TreeNode* root, int limit) {
        if(!root) return nullptr;
        if(!root->left && !root->right) {
            if(root->val < limit) return nullptr;
            return root;
        }
        root->left = sufficientSubset(root->left, limit - root->val);
        root->right = sufficientSubset(root->right, limit - root->val);
        if(!root->left && !root->right) return nullptr;

        return root;
    }
};


-----
// Definition for a binary tree node.
// struct TreeNode 
    // Your code here
};


************************************
Question ID: 1081

#include <vector>
#include <algorithm>
using namespace std;

int videoStitching(vector<vector<int>>& clips, int time) {
    vector<int> dp(time + 1, INT_MAX);
    dp[0] = 0;
    for (int i = 1; i <= time; ++i) {
        for (const auto& clip : clips) {
            if (clip[0] < i && i <= clip[1]) {
                dp[i] = min(dp[i], dp[clip[0]] + 1);
            }
        }
    }
    return dp[time] == INT_MAX ? -1 : dp[time];
}

-----
#include <vector>
#include <algorithm>
using namespace std;

int videoStitching(vector<vector<int>>& clips, int time) 
    // Your code here
}

************************************
Question ID: 1085

int sumOfDigits(vector<int>& nums) {
    int minVal = *min_element(nums.begin(), nums.end());
    int digitSum = 0;
    while (minVal > 0) {
        digitSum += minVal % 10;
        minVal /= 10;
    }
    return digitSum % 2 == 0 ? 1 : 0;
}


-----
int sumOfDigits(vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 1086

bool aliceWin(int n) {
    return n % 2 == 0;
}


-----
bool aliceWin(int n) 
    // Your code here
}


************************************
Question ID: 1087

#include <vector>
#include <unordered_map>
using namespace std;

int longestArithSeqLength(vector<int>& nums) {
    int n = nums.size();
    int longest = 0;
    vector<unordered_map<int, int>> dp(n);
    
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            int diff = nums[i] - nums[j];
            dp[i][diff] = dp[j].count(diff) ? dp[j][diff] + 1 : 2;
            longest = max(longest, dp[i][diff]);
        }
    }
    
    return longest;
}

-----
#include <vector>
#include <unordered_map>
using namespace std;

int longestArithSeqLength(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1088

int findConfusingNumbers(int num, int& n, unordered_map<int, int>& mp) {
    if (num > n) return 0;
    int rotated = 0, src = num, newNum;
    while (src > 0) {
        rotated = rotated * 10 + mp[src % 10];
        src /= 10;
    }
    return (num != rotated) + findConfusingNumbers(num * 10 + 6, n, mp)
           + findConfusingNumbers(num * 10 + 9, n, mp)
           + findConfusingNumbers(num * 10 + 0, n, mp)
           + findConfusingNumbers(num * 10 + 1, n, mp)
           + findConfusingNumbers(num * 10 + 8, n, mp);
}

int confusingNumberII(int n) {
    unordered_map<int, int> mp = {{0,0},{1,1},{6,9},{8,8},{9,6}};
    return findConfusingNumbers(6, n, mp) + findConfusingNumbers(9, n, mp) +
           findConfusingNumbers(1, n, mp) + findConfusingNumbers(8, n, mp) + findConfusingNumbers(0, n, mp);
}

-----
int findConfusingNumbers(int num, int& n, unordered_map<int, int>& mp) 
    // Your code here
}

************************************
Question ID: 1089

void duplicateZeros(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; ++i) {
        if (arr[i] == 0) {
            for (int j = n - 1; j > i + 1; --j) {
                arr[j] = arr[j - 1];
            }
            arr[++i] = 0;
        }
    }
}

-----
void duplicateZeros(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1090

#include <vector>
#include <unordered_map>
#include <algorithm>

int largestValsFromLabels(std::vector<int>& values, std::vector<int>& labels, int numWanted, int useLimit) {
    std::vector<std::pair<int, int>> items;
    for (int i = 0; i < values.size(); ++i) {
        items.push_back({values[i], labels[i]});
    }

    std::sort(items.begin(), items.end(), [](const std::pair<int, int>& a, const std::pair<int, int>& b) {
        return a.first > b.first;
    });

    std::unordered_map<int, int> labelCount;
    int ans = 0;

    for (const auto& item : items) {
        if (labelCount[item.second] < useLimit) {
            ans += item.first;
            labelCount[item.second]++;
            if (--numWanted == 0) break;
        }
    }
    return ans;
}


-----
#include <vector>
#include <unordered_map>
#include <algorithm>

int largestValsFromLabels(std::vector<int>& values, std::vector<int>& labels, int numWanted, int useLimit) 
    // Your code here
}


************************************
Question ID: 1091

#include <vector>
#include <queue>

using namespace std;

int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
    int n = grid.size();
    if (grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;

    vector<vector<int>> dir = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};
    queue<pair<int, int>> q;
    q.push({0, 0});
    grid[0][0] = 1;

    int pathLength = 1;

    while (!q.empty()) {
        int qlen = q.size();
        for (int i = 0; i < qlen; i++) {
            int x = q.front().first;
            int y = q.front().second;
            q.pop();

            if (x == n - 1 && y == n - 1) return pathLength;

            for (vector<int>& d : dir) {
                int newX = x + d[0];
                int newY = y + d[1];

                if (newX >= 0 && newX < n && newY >= 0 && newY < n && grid[newX][newY] == 0) {
                    q.push({newX, newY});
                    grid[newX][newY] = 1;
                }
            }
        }
        pathLength++;
    }

    return -1;
}

-----
#include <vector>
#include <queue>

using namespace std;

int shortestPathBinaryMatrix(vector<vector<int>>& grid) 
    // Your code here
}

************************************
Question ID: 1094

#include <vector>
#include <algorithm>

std::vector<std::vector<int>> allCellsDistOrder(int rows, int cols, int rCenter, int cCenter) {
    std::vector<std::vector<int>> coordinates;

    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            coordinates.push_back({i, j});
        }
    }

    std::sort(coordinates.begin(), coordinates.end(), [&](const std::vector<int>& a, const std::vector<int>& b) {
        return abs(a[0] - rCenter) + abs(a[1] - cCenter) < abs(b[0] - rCenter) + abs(b[1] - cCenter);
    });

    return coordinates;
}

-----
#include <vector>
#include <algorithm>

std::vector<std::vector<int>> allCellsDistOrder(int rows, int cols, int rCenter, int cCenter) 
    // Your code here
}

************************************
Question ID: 1095

#include <vector>
#include <algorithm>

int twoCitySchedCost(std::vector<std::vector<int>>& costs) {
    std::sort(costs.begin(), costs.end(), [](const std::vector<int>& a, const std::vector<int>& b){
        return (a[0] - a[1]) < (b[0] - b[1]);
    });

    int totalCost = 0;
    int n = costs.size() / 2;

    for (int i = 0; i < n; i++) {
        totalCost += costs[i][0] + costs[i+n][1];
    }

    return totalCost;
}

-----
#include <vector>
#include <algorithm>

int twoCitySchedCost(std::vector<std::vector<int>>& costs) 
    // Your code here
}

************************************
Question ID: 1099

int maxSumUnderK(vector<int>& nums, int k) {
    int maxSum = -1;
    for (int i = 0; i < nums.size(); i++) {
        for (int j = i + 1; j < nums.size(); j++) {
            int sum = nums[i] + nums[j];
            if (sum < k && sum > maxSum) {
                maxSum = sum;
            }
        }
    }
    return maxSum;
}

-----
int maxSumUnderK(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 1100

int numKLenSubstrNoRepeats(string s, int k) {
    int n = s.length();
    if (k > n) return 0;
    
    int result = 0;
    unordered_set<char> window;
    
    for (int i = 0, j = 0; j < n; ++j) {
        while (window.find(s[j]) != window.end()) {
            window.erase(s[i++]);
        }
        window.insert(s[j]);
        if (j - i + 1 == k) {
            ++result;
            window.erase(s[i++]);
        }
    }
    return result;
}

-----
int numKLenSubstrNoRepeats(string s, int k) 
    // Your code here
}

************************************
Question ID: 1101

#include <vector>
#include <algorithm>

int parent(int x, std::vector<int>& parents) {
    return x == parents[x] ? x : parents[x] = parent(parents[x], parents);
}

int earliestAcq(std::vector<std::vector<int>>& logs, int n) {
    std::vector<int> parents(n);
    for (int i = 0; i < n; ++i) parents[i] = i;
    
    std::sort(logs.begin(), logs.end());
    
    int groupCount = n;
    for (const auto& log : logs) {
        int rootX = parent(log[1], parents);
        int rootY = parent(log[2], parents);
        if (rootX != rootY) {
            parents[rootX] = rootY;
            groupCount--;
        }
        if (groupCount == 1) {
            return log[0];
        }
    }
    return -1;
}

-----
#include <vector>
#include <algorithm>

int parent(int x, std::vector<int>& parents) 
    // Your code here
}

************************************
Question ID: 1102

int maxScore(vector<vector<int>>& grid) {
    int m = grid.size(), n = grid[0].size();
    
    for (int i = 1; i < n; i++) {
        grid[0][i] = min(grid[0][i], grid[0][i - 1]);
    }
    
    for (int i = 1; i < m; i++) {
        grid[i][0] = min(grid[i][0], grid[i - 1][0]);
        
        for (int j = 1; j < n; j++) {
            grid[i][j] = max(min(grid[i - 1][j], grid[i][j]), min(grid[i][j - 1], grid[i][j]));
        }
    }
    
    return grid[m - 1][n - 1];
}



-----
int maxScore(vector<vector<int>>& grid) 
    // Your code here
}



************************************
Question ID: 1103

#include <vector>

std::vector<int> distributeCandies(int candies, int num_people) {
    std::vector<int> result(num_people, 0);
    int i = 0, count = 1;

    while (candies > 0) {
        result[i % num_people] += std::min(candies, count);
        candies -= count;
        count++;
        i++;
    }

    return result;
}


-----
#include <vector>

std::vector<int> distributeCandies(int candies, int num_people) 
    // Your code here
}


************************************
Question ID: 1104

#include <vector>

void dfs(std::vector<std::vector<int>>& grid, int row, int col, int current, int color) {
    if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] != current)
        return;
    
    grid[row][col] = color;
    dfs(grid, row+1, col, current, color);
    dfs(grid, row-1, col, current, color);
    dfs(grid, row, col+1, current, color);
    dfs(grid, row, col-1, current, color);
}

std::vector<std::vector<int>> colorBorder(std::vector<std::vector<int>>& grid, int row, int col, int color) {
    int current = grid[row][col];
    if (current == color)
        return grid;
    
    dfs(grid, row, col, current, color + 1000);
    
    for (int i = 0; i < grid.size(); ++i) {
        for (int j = 0; j < grid[0].size(); ++j) {
            if (grid[i][j] > 1000)
                grid[i][j] -= 1000;
        }
    }
    
    return grid;
}

-----
#include <vector>

void dfs(std::vector<std::vector<int>>& grid, int row, int col, int current, int color) 
    // Your code here
}

************************************
Question ID: 1105

#include <vector>
using namespace std;

int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
    int m = nums1.size();
    int n = nums2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (nums1[i - 1] == nums2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}

-----
#include <vector>
using namespace std;

int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) 
    // Your code here
}

************************************
Question ID: 1106

#include <unordered_set>
#include <vector>
#include <string>

const int MAX_STEPS = 200;

bool dfs(int x, int y, int tx, int ty, std::unordered_set<std::string> &blocked, std::unordered_set<std::string> &visited, int steps) {
    std::string pos = std::to_string(x) + "_" + std::to_string(y);
    if (x < 0 || x >= 1000000 || y < 0 || y >= 1000000 || steps >= MAX_STEPS || blocked.count(pos) || visited.count(pos))
        return false;

    if (x == tx && y == ty)
        return true;

    visited.insert(pos);

    if (dfs(x + 1, y, tx, ty, blocked, visited, steps + 1) || dfs(x, y + 1, tx, ty, blocked, visited, steps + 1) ||
        dfs(x - 1, y, tx, ty, blocked, visited, steps + 1) || dfs(x, y - 1, tx, ty, blocked, visited, steps + 1))
        return true;

    return false;
}

bool isEscapePossible(std::vector<std::vector<int>>& blocked, std::vector<int>& source, std::vector<int>& target) {
    std::unordered_set<std::string> blockedSet, visited;
    for (auto &block : blocked)
        blockedSet.insert(std::to_string(block[0]) + "_" + std::to_string(block[1]));

    return dfs(source[0], source[1], target[0], target[1], blockedSet, visited, 0);
}


-----
#include <unordered_set>
#include <vector>
#include <string>

const int MAX_STEPS = 200;

bool dfs(int x, int y, int tx, int ty, std::unordered_set<std::string> &blocked, std::unordered_set<std::string> &visited, int steps) 
    // Your code here
}


************************************
Question ID: 1108

#include <string>
using namespace std;

string defangIPaddr(string address) {
    string defanged = "";
    for (char c : address) {
        if (c == '.')
            defanged += "[.]";
        else
            defanged += c;
    }
    return defanged;
}

-----
#include <string>
using namespace std;

string defangIPaddr(string address) 
    // Your code here
}

************************************
Question ID: 1109

#include <vector>
using namespace std;

vector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {
    vector<int> seats(n, 0);
    for (auto& booking : bookings) {
        seats[booking[0] - 1] += booking[2];
        if (booking[1] < n) {
            seats[booking[1]] -= booking[2];
        }
    }
    for (int i = 1; i < n; ++i) {
        seats[i] += seats[i - 1];
    }
    return seats;
}

-----
#include <vector>
using namespace std;

vector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) 
    // Your code here
}

************************************
Question ID: 1111

int minScoreTriangulation(vector<int>& values) {
    int n = values.size();
    vector<vector<int>> dp(n, vector<int>(n, 0));

    for (int len = 3; len <= n; ++len) {
        for (int i = 0; i + len - 1 < n; ++i) {
            int j = i + len - 1;
            dp[i][j] = INT_MAX;
            for (int k = i + 1; k < j; ++k) {
                dp[i][j] = min(dp[i][j], values[i] * values[j] * values[k] + dp[i][k] + dp[k][j]);
            }
        }
    }

    return dp[0][n - 1];
}


-----
int minScoreTriangulation(vector<int>& values) 
    // Your code here
}


************************************
Question ID: 1118

int numberOfDays(int year, int month) {
    if(month == 2) {
        if((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)
            return 29;
        return 28;
    }
    if(month == 4 || month == 6 || month == 9 || month == 11)
        return 30;
    return 31;
}

-----
int numberOfDays(int year, int month) 
    // Your code here
}

************************************
Question ID: 1119

bool isRobotBounded(string instructions) {
    int x = 0, y = 0, dir = 0;
    vector<vector<int>> moves {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

    for (char c : instructions) {
        if (c == 'G') {
            x += moves[dir][0];
            y += moves[dir][1];
        } else if (c == 'L') {
            dir = (dir + 3) % 4;
        } else {
            dir = (dir + 1) % 4;
        }
    }

    return (x == 0 && y == 0) || dir != 0;
}

-----
bool isRobotBounded(string instructions) 
    // Your code here
}

************************************
Question ID: 1120

#include <vector>
#include <unordered_set>

std::vector<int> gardenNoAdj(int n, std::vector<std::vector<int>>& paths) {
    std::vector<std::unordered_set<int>> graph(n);
    for (const auto& path : paths) {
        graph[path[0] - 1].insert(path[1] - 1);
        graph[path[1] - 1].insert(path[0] - 1);
    }
    
    std::vector<int> result(n);
    for (int i = 0; i < n; ++i) {
        std::unordered_set<int> used_flowers;
        for (int neighbor : graph[i]) {
            used_flowers.insert(result[neighbor]);
        }
        for (int flower = 1; flower <= 4; ++flower) {
            if (used_flowers.count(flower) == 0) {
                result[i] = flower;
                break;
            }
        }
    }
    return result;
}


-----
#include <vector>
#include <unordered_set>

std::vector<int> gardenNoAdj(int n, std::vector<std::vector<int>>& paths) 
    // Your code here
}


************************************
Question ID: 1121

#include <vector>
#include <algorithm>
using namespace std;

int maxSumAfterPartitioning(vector<int>& arr, int k) {
    int n = arr.size();
    vector<int> dp(n + 1, 0);
    for (int i = 1; i <= n; ++i) {
        int current_max = 0;
        for (int j = 1; j <= k && i - j >= 0; ++j) {
            current_max = max(current_max, arr[i - j]);
            dp[i] = max(dp[i], dp[i - j] + current_max * j);
        }
    }
    return dp[n];
}

-----
#include <vector>
#include <algorithm>
using namespace std;

int maxSumAfterPartitioning(vector<int>& arr, int k) 
    // Your code here
}

************************************
Question ID: 1122

#include <string>

std::string longestDupSubstring(std::string s) {
    int n = s.length();
    std::string longest_duplicate;
    for (int length = n - 1; length > 0; --length) {
        for (int i = 0; i <= n - length; ++i) {
            std::string substring = s.substr(i, length);
            if (s.find(substring, i + 1) != std::string::npos) {
                longest_duplicate = substring;
                return longest_duplicate;
            }
        }
    }
    return longest_duplicate;
}


-----
#include <string>

std::string longestDupSubstring(std::string s) 
    // Your code here
}


************************************
Question ID: 1124

#include <vector>
#include <unordered_map>

int longestWellPerformingInterval(std::vector<int> &hours) {
    int sum = 0;
    int longest = 0;
    std::unordered_map<int, int> first_sum_index;

    for (int i = 0; i < hours.size(); ++i) {
        sum += (hours[i] > 8) ? 1 : -1;
        if (sum > 0) {
            longest = i + 1;
        } else {
            if (first_sum_index.find(sum - 1) != first_sum_index.end()) {
                longest = std::max(longest, i - first_sum_index[sum - 1]);
            }
            if (first_sum_index.find(sum) == first_sum_index.end()) {
                first_sum_index[sum] = i;
            }
        }
    }
    return longest;
}


-----
#include <vector>
#include <unordered_map>

int longestWellPerformingInterval(std::vector<int> &hours) 
    // Your code here
}


************************************
Question ID: 1125

#include <unordered_map>
#include <vector>
#include <bitset>
using namespace std;

vector<int> smallestSufficientTeam(vector<string>& req_skills, vector<vector<string>>& people) {
    unordered_map<int, string> id_to_skill;
    unordered_map<string, int> skill_to_id;
    int idx = 0;
    for (const auto& skill : req_skills) {
        skill_to_id[skill] = idx++;
        id_to_skill[idx - 1] = skill;
    }

    vector<int> res;
    vector<bitset<16>> dp(1 << idx, bitset<16>());
    vector<int> pre(1 << idx, -1);
    dp[0].set(31);

    int people_size = people.size();
    for (int i = 0; i < people_size; ++i) {
        int skill_mask = 0;
        for (const auto& skill : people[i]) {
            skill_mask |= 1 << skill_to_id[skill];
        }
        for (int j = (1 << idx) - 1; j >= 0; --j) {
            int next_mask = j | skill_mask;
            if (dp[next_mask].count() > dp[j].count() + 1) {
                dp[next_mask] = dp[j];
                dp[next_mask].set(i);
                pre[next_mask] = j;
            }
        }
    }

    int current_mask = (1 << idx) - 1;
    while (current_mask != 0) {
        int previous_mask = pre[current_mask];
        int mask = current_mask ^ previous_mask;
        int id = log2(mask);
        res.push_back(id);
        current_mask = previous_mask;
    }

    return res;
}


-----
#include <unordered_map>
#include <vector>
#include <bitset>
using namespace std;

vector<int> smallestSufficientTeam(vector<string>& req_skills, vector<vector<string>>& people) 
    // Your code here
}


************************************
Question ID: 1128

#include <string>
#include <stack>

std::string removeDuplicates(std::string s) {
    std::stack<char> st;
    for (char c : s) {
        if (!st.empty() && st.top() == c) {
            st.pop();
        } else {
            st.push(c);
        }
    }
    
    std::string result;
    while (!st.empty()) {
        result = st.top() + result;
        st.pop();
    }
    
    return result;
}

-----
#include <string>
#include <stack>

std::string removeDuplicates(std::string s) 
    // Your code here
}

************************************
Question ID: 1129

#include <vector>
#include <string>
#include <algorithm>
#include <unordered_map>
using namespace std;

int longestStrChain(vector<string>& words) {
    sort(words.begin(), words.end(), [](const string& a, const string& b) { return a.size() < b.size(); });

    unordered_map<string, int> dp;
    int max_len = 0;

    for (const string& word : words) {
        for (int i = 0; i < word.size(); ++i) {
            string pre = word.substr(0, i) + word.substr(i + 1);
            dp[word] = max(dp[word], dp[pre] + 1);
        }
        max_len = max(max_len, dp[word]);
    }

    return max_len;
}

-----
#include <vector>
#include <string>
#include <algorithm>
#include <unordered_map>
using namespace std;

int longestStrChain(vector<string>& words) 
    // Your code here
}

************************************
Question ID: 1130

int lastStoneWeight(vector<int>& stones) {
    priority_queue<int> pq(stones.begin(), stones.end());
    while (pq.size() > 1) {
        int x = pq.top(); pq.pop();
        int y = pq.top(); pq.pop();
        if (x != y) {
            pq.push(y - x);
        }
    }
    return pq.empty() ? 0 : pq.top();
}

-----
int lastStoneWeight(vector<int>& stones) 
    // Your code here
}

************************************
Question ID: 1131

int maxAbsValExpr(vector<int>& arr1, vector<int>& arr2) {
    int result = 0;
    int max_sum[4] = {INT_MIN, INT_MIN, INT_MIN, INT_MIN};

    for (int i = 0; i < arr1.size(); ++i) {
        max_sum[0] = max(max_sum[0], arr1[i] + arr2[i] + i);
        max_sum[1] = max(max_sum[1], arr1[i] - arr2[i] + i);
        max_sum[2] = max(max_sum[2], -arr1[i] + arr2[i] + i);
        max_sum[3] = max(max_sum[3], -arr1[i] - arr2[i] + i);
    }

    for (int i = 0; i < arr1.size(); ++i) {
        result = max(result, max_sum[0] - arr1[i] - arr2[i] - i);
        result = max(result, max_sum[1] - arr1[i] + arr2[i] - i);
        result = max(result, max_sum[2] + arr1[i] - arr2[i] - i);
        result = max(result, max_sum[3] + arr1[i] + arr2[i] - i);
    }

    return result;
}

-----
int maxAbsValExpr(vector<int>& arr1, vector<int>& arr2) 
    // Your code here
}

************************************
Question ID: 1133

std::string lastSubstring(std::string s) {
    int i = 0, j = 1, k = 0, n = s.length();
    while (j + k < n) {
        if (s[i + k] == s[j + k]) {
            k++;
        } else if (s[i + k] < s[j + k]) {
            i = j;
            j++;
            k = 0;
        } else {
            j++;
            k = 0;
        }
    }
    return s.substr(i);
}

-----
std::string lastSubstring(std::string s) 
    // Your code here
}

************************************
Question ID: 1134

bool isArmstrong(int n) {
    int power_sum = 0, original = n;
    int k = to_string(n).length();
    while (n > 0) {
        int digit = n % 10;
        power_sum += pow(digit, k);
        n /= 10;
    }
    return power_sum == original;
}

-----
bool isArmstrong(int n) 
    // Your code here
}

************************************
Question ID: 1135

#include <vector>
#include <algorithm>

int find(std::vector<int>& parent, int x) {
    if (parent[x] != x) {
        parent[x] = find(parent, parent[x]);
    }
    return parent[x];
}

int minimumCost(int n, std::vector<std::vector<int>>& connections) {
    std::sort(connections.begin(), connections.end(), [](const std::vector<int>& a, const std::vector<int>& b) {
        return a[2] < b[2];
    });

    std::vector<int> parent(n + 1);
    for (int i = 1; i <= n; ++i) {
        parent[i] = i;
    }

    int cost = 0;
    int edges = 0;
    for (const auto& connection : connections) {
        int root_x = find(parent, connection[0]);
        int root_y = find(parent, connection[1]);

        if (root_x != root_y) {
            parent[root_y] = root_x;
            cost += connection[2];
            edges += 1;
        }

        if (edges == n - 1) {
            break;
        }
    }

    return edges == n - 1 ? cost : -1;
}

-----
#include <vector>
#include <algorithm>

int find(std::vector<int>& parent, int x) 
    // Your code here
}

************************************
Question ID: 1136

int minimumSemesters(int n, vector<vector<int>>& relations) {
    vector<int> in_degree(n + 1, 0);
    vector<vector<int>> graph(n + 1);

    for (auto& relation : relations) {
        graph[relation[0]].push_back(relation[1]);
        in_degree[relation[1]]++;
    }

    queue<int> q;
    for (int i = 1; i <= n; i++) {
        if (in_degree[i] == 0) {
            q.push(i);
        }
    }

    int semesters = 0;
    while (!q.empty()) {
        int size = q.size();
        semesters++;
        while (size--) {
            int course = q.front();
            q.pop();
            n--;

            for (int next : graph[course]) {
                if (--in_degree[next] == 0) {
                    q.push(next);
                }
            }
        }
    }

    return n == 0 ? semesters : -1;
}

-----
int minimumSemesters(int n, vector<vector<int>>& relations) 
    // Your code here
}

************************************
Question ID: 1137

#include <algorithm>
#include <vector>

int heightChecker(std::vector<int>& heights) {
    std::vector<int> expected = heights;
    std::sort(expected.begin(), expected.end());
    int count = 0;
    for (size_t i = 0; i < heights.size(); i++) {
        if (heights[i] != expected[i]) {
            count++;
        }
    }
    return count;
}

-----
#include <algorithm>
#include <vector>

int heightChecker(std::vector<int>& heights) 
    // Your code here
}

************************************
Question ID: 1138

int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
    int total = 0, maxIncrease = 0, windowIncrease = 0;
    for (int i = 0, j = 0; i < customers.size(); ++i) {
        if (i - j == minutes) {
            windowIncrease -= customers[j] * grumpy[j];
            ++j;
        }
        windowIncrease += customers[i] * grumpy[i];
        total += customers[i] * (1 - grumpy[i]);
        maxIncrease = max(maxIncrease, windowIncrease);
    }
    return total + maxIncrease;
}

-----
int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) 
    // Your code here
}

************************************
Question ID: 1139

#include <vector>
#include <algorithm>

std::vector<int> prevPermOpt1(std::vector<int>& arr) {
    int n = arr.size();
    for(int i = n - 2; i >= 0; i--){
        if(arr[i] > arr[i + 1]){
            int j = i + 1;
            while(j < n && arr[j] < arr[i]) j++;
            std::swap(arr[i], arr[j - 1]);
            return arr;
        }
    }
    return arr;
}

-----
#include <vector>
#include <algorithm>

std::vector<int> prevPermOpt1(std::vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1140

#include<vector>
#include<queue>
using namespace std;

vector<int> rearrangeBarcodes(vector<int> &barcodes) {
    int n = barcodes.size();
    vector<int> count(10001, 0);
    for (int i = 0; i < n; ++i) {
        ++count[barcodes[i]];
    }

    auto comp = [](const pair<int, int>& a, const pair<int, int>& b) { return a.second < b.second; };
    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> pq(comp);
    for (int i = 1; i <= 10000; ++i) {
        if (count[i] > 0) {
            pq.push({i, count[i]});
        }
    }

    int idx = 0;
    while (!pq.empty()) {
        auto curr = pq.top();
        pq.pop();
        while (curr.second > 0) {
            barcodes[idx] = curr.first;
            curr.second--;
            idx += 2;
            if (idx >= n) {
                idx = 1;
            }
        }
    }
    return barcodes;
}

-----
#include<vector>
#include<queue>
using namespace std;

vector<int> rearrangeBarcodes(vector<int> &barcodes) 
    // Your code here
}

************************************
Question ID: 1143

int longestCommonSubsequence(string text1, string text2) {
    int m = text1.size();
    int n = text2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1[i - 1] == text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}

-----
int longestCommonSubsequence(string text1, string text2) 
    // Your code here
}

************************************
Question ID: 1144

int movesToMakeZigzag(std::vector<int>& nums) {
    int evenMoves = 0, oddMoves = 0;
    for (int i = 0; i < nums.size(); i++) {
        int left = i > 0 ? nums[i - 1] : 1001;
        int right = i < nums.size() - 1 ? nums[i + 1] : 1001;
        int minValue = std::min(left, right);
        if (nums[i] >= minValue) {
            if (i % 2 == 0) {
                evenMoves += nums[i] - minValue + 1;
            } else {
                oddMoves += nums[i] - minValue + 1;
            }
        }
    }
    return std::min(evenMoves, oddMoves);
}

-----
int movesToMakeZigzag(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1146

#include <string>
#include <algorithm>

std::string gcdOfStrings(std::string str1, std::string str2) {
    if (str1 + str2 != str2 + str1) {
        return "";
    }
    int gcd = std::__gcd(str1.size(), str2.size());
    return str1.substr(0, gcd);
}


-----
#include <string>
#include <algorithm>

std::string gcdOfStrings(std::string str1, std::string str2) 
    // Your code here
}


************************************
Question ID: 1147

int maxEqualRowsAfterFlips(vector<vector<int>>& matrix) {
    unordered_map<string, int> count;
    for (auto& row : matrix) {
        string row_str;
        if (row[0] == 1) {
            for (int val : row)
                row_str += '0' + 1 - val;
        } else {
            for (int val : row)
                row_str += '0' + val;
        }
        count[row_str]++;
    }
    int res = 0;
    for (auto& [key, value] : count)
        res = max(res, value);
    return res;
}

-----
int maxEqualRowsAfterFlips(vector<vector<int>>& matrix) 
    // Your code here
}

************************************
Question ID: 1150

bool isMajorityElement(vector<int>& nums, int target) {
    int count = 0;
    for (int num : nums) {
        if (num == target) count++;
        if (count > nums.size() / 2) return true;
    }
    return false;
}

-----
bool isMajorityElement(vector<int>& nums, int target) 
    // Your code here
}

************************************
Question ID: 1151

int minSwaps(vector<int>& data) {
    int ones = 0;
    for (int d : data) {
        ones += d;
    }
    int cur_ones = 0, max_ones = 0;
    for (int i = 0; i < data.size(); i++) {
        cur_ones += data[i];
        if (i >= ones) {
            cur_ones -= data[i - ones];
        }
        max_ones = max(max_ones, cur_ones);
    }
    return ones - max_ones;
}


-----
int minSwaps(vector<int>& data) 
    // Your code here
}


************************************
Question ID: 1152

#include <string>
#include <vector>
#include <unordered_map>
#include <algorithm>
#include <set>

using namespace std;

class Solution {
public:
    vector<string> mostVisitedPattern(vector<string>& username, vector<int>& timestamp, vector<string>& website) {
        int n = username.size();
        vector<vector<string>> visiting_order(n, vector<string>(3));
        unordered_map<string, vector<pair<int, int>>> user_visits;

        for (int i = 0; i < n; i++) {
            user_visits[username[i]].push_back({timestamp[i], i});
        }
        
        for (auto& p : user_visits) {
            sort(p.second.begin(), p.second.end());
            int m = p.second.size();
            for (int i = 0; i < m; i++) {
                for (int j = i + 1; j < m; j++) {
                    for (int k = j + 1; k < m; k++) {
                        visiting_order.push_back({website[p.second[i].second], website[p.second[j].second], website[p.second[k].second]});
                    }
                }
            }
        }
        
        sort(visiting_order.begin(), visiting_order.end());
        
        vector<string> ans = visiting_order[0];
        int max_score = 0, score = 1;

        for (int i = 1; i < visiting_order.size(); i++) {
            if (visiting_order[i] == visiting_order[i-1]) {
                score++;
            } else {
                score = 1;
            }
            
            if (score > max_score) {
                max_score = score;
                ans = visiting_order[i];
            }
        }
        
        return ans;
    }
};


-----
#include <string>
#include <vector>
#include <unordered_map>
#include <algorithm>
#include <set>

using namespace std;

class Solution 
    // Your code here
};


************************************
Question ID: 1153

bool canConvert(std::string str1, std::string str2) {
    if (str1 == str2) return true;
    std::unordered_map<char, char> conversion;
    for (int i = 0; i < str1.length(); ++i) {
        if (conversion.count(str1[i]) && conversion[str1[i]] != str2[i]) return false;
        conversion[str1[i]] = str2[i];
    }
    return std::unordered_set<char>(str2.begin(), str2.end()).size() < 26;
}


-----
bool canConvert(std::string str1, std::string str2) 
    // Your code here
}


************************************
Question ID: 1154

#include <vector>

bool is_leap_year(int year) {
    return ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);
}

int day_of_year(string date) {
    vector<int> days_in_month = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
    int year = stoi(date.substr(0, 4));
    int month = stoi(date.substr(5, 2));
    int day = stoi(date.substr(8, 2));
    
    if (is_leap_year(year)) {
        days_in_month[1] = 29;
    }

    int result = 0;
    for (int i = 0; i < month - 1; ++i) {
        result += days_in_month[i];
    }

    return result + day;
}


-----
#include <vector>

bool is_leap_year(int year) 
    // Your code here
}


************************************
Question ID: 1155

int numRollsToTarget(int n, int k, int target) {
    const int MOD = 1e9 + 7;
    vector<vector<int>> dp(n + 1, vector<int>(target + 1, 0));
    dp[0][0] = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = i; j <= target; ++j) {
            for (int d = 1; d <= k && j - d >= 0; ++d) {
                dp[i][j] = (dp[i][j] + dp[i - 1][j - d]) % MOD;
            }
        }
    }
    return dp[n][target];
}

-----
int numRollsToTarget(int n, int k, int target) 
    // Your code here
}

************************************
Question ID: 1156

#include <vector>
#include <string>
#include <sstream>

std::vector<std::string> find_third_words(const std::string &text, const std::string &first, const std::string &second) {
    std::vector<std::string> result;
    std::istringstream iss(text);
    std::string word, prev_word, prev_prev_word;

    while (iss >> word) {
        if (prev_prev_word == first && prev_word == second) {
            result.push_back(word);
        }
        prev_prev_word = prev_word;
        prev_word = word;
    }

    return result;
}

-----
#include <vector>
#include <string>
#include <sstream>

std::vector<std::string> find_third_words(const std::string &text, const std::string &first, const std::string &second) 
    // Your code here
}

************************************
Question ID: 1160

#include <string>
#include <vector>

int numTilePossibilities(std::string tiles) {
    std::vector<int> freq(26, 0);
    for (char c : tiles) {
        freq[c - 'A']++;
    }

    int result = 0;
    for (int i = 0; i < 26; i++) {
        if (freq[i]) {
            freq[i]--;
            result += 1 + numTilePossibilities(tiles);
            freq[i]++;
        }
    }
    return result;
}

-----
#include <string>
#include <vector>

int numTilePossibilities(std::string tiles) 
    // Your code here
}

************************************
Question ID: 1162

#include <queue>
#include <vector>

int maxDistance(std::vector<std::vector<int>>& grid) {
    int distance = -1;
    std::queue<std::pair<int, int>> waterCells;
    int n = grid.size();

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 1) {
                waterCells.push({i, j});
            }
        }
    }

    if (waterCells.size() == 0 || waterCells.size() == n * n) {
        return distance;
    }

    std::vector<std::vector<int>> directions{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    while (!waterCells.empty()) {
        int size = waterCells.size();
        while (size--) {
            auto [x, y] = waterCells.front();
            waterCells.pop();

            for (const auto& dir : directions) {
                int newX = x + dir[0], newY = y + dir[1];
                if (newX >= 0 && newX < n && newY >= 0 && newY < n && grid[newX][newY] == 0) {
                    grid[newX][newY] = 1;
                    waterCells.push({newX, newY});
                }
            }
        }
        distance++;
    }

    return distance - 1;
}


-----
#include <queue>
#include <vector>

int maxDistance(std::vector<std::vector<int>>& grid) 
    // Your code here
}


************************************
Question ID: 1163

std::string lastSubstring(std::string s) {
    int maxIndex = 0;
    int curIndex = 1;
    while (curIndex < s.length()) {
        int i = 0;
        while (curIndex + i < s.length() && s[maxIndex + i] == s[curIndex + i]) {
            i++;
        }
        if (curIndex + i == s.length()) break;
        if (s[maxIndex + i] < s[curIndex + i]) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    return s.substr(maxIndex);
}

-----
std::string lastSubstring(std::string s) 
    // Your code here
}

************************************
Question ID: 1165

int calculateTime(std::string keyboard, std::string word) {
    int time = 0;
    int prev_index = 0;
    std::unordered_map<char, int> char_to_index;

    for (int i = 0; i < keyboard.length(); i++) {
        char_to_index[keyboard[i]] = i;
    }

    for (char c : word) {
        time += std::abs(char_to_index[c] - prev_index);
        prev_index = char_to_index[c];
    }

    return time;
}

-----
int calculateTime(std::string keyboard, std::string word) 
    // Your code here
}

************************************
Question ID: 1167

#include <queue>
#include <vector>

int connectSticks(std::vector<int>& sticks) {
    std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;

    for (int stick : sticks) {
        min_heap.push(stick);
    }

    int cost = 0;
    while (min_heap.size() > 1) {
        int first = min_heap.top();
        min_heap.pop();
        int second = min_heap.top();
        min_heap.pop();
        cost += first + second;
        min_heap.push(first + second);
    }
    return cost;
}

-----
#include <queue>
#include <vector>

int connectSticks(std::vector<int>& sticks) 
    // Your code here
}

************************************
Question ID: 1168

void duplicateZeros(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; i++) {
        if (arr[i] == 0) {
            for (int j = n - 2; j > i; j--) {
                arr[j + 1] = arr[j];
            }
            arr[i + 1] = 0;
            i++;
        }
    }
}

-----
void duplicateZeros(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1169

#include <vector>
#include <algorithm>

int largestValsFromLabels(std::vector<int>& values, std::vector<int>& labels, int numWanted, int useLimit) {
    std::vector<std::pair<int, int>> items;
    for (int i = 0; i < values.size(); ++i) {
        items.emplace_back(values[i], labels[i]);
    }
    std::sort(items.rbegin(), items.rend());
    
    std::unordered_map<int, int> labelCount;
    int result = 0;
    for (const auto& [value, label] : items) {
        if (labelCount[label] < useLimit && numWanted > 0) {
            result += value;
            labelCount[label]++;
            numWanted--;
        }
    }
    
    return result;
}

-----
#include <vector>
#include <algorithm>

int largestValsFromLabels(std::vector<int>& values, std::vector<int>& labels, int numWanted, int useLimit) 
    // Your code here
}

************************************
Question ID: 1170

#include <iostream>
#include <vector>

std::string shortest_common_supersequence(std::string str1, std::string str2) {
    int m = str1.length();
    int n = str2.length();
    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1));

    for (int i = 0; i <= m; i++) {
        for (int j = 0; j <= n; j++) {
            if (i == 0) {
                dp[i][j] = j;
            }
            else if (j == 0) {
                dp[i][j] = i;
            }
            else if (str1[i - 1] == str2[j - 1]) {
                dp[i][j] = 1 + dp[i - 1][j - 1];
            }
            else {
                dp[i][j] = 1 + std::min(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    int i = m, j = n;
    std::string result;

    while (i > 0 && j > 0) {
        if (str1[i - 1] == str2[j - 1]) {
            result.push_back(str1[i - 1]);
            i--;
            j--;
        }
        else if (dp[i - 1][j] > dp[i][j - 1]) {
            j--;
            result.push_back(str2[j]);
        }
        else {
            i--;
            result.push_back(str1[i]);
        }
    }

    while (i > 0) {
        result.push_back(str1[i - 1]);
        i--;
    }

    while (j > 0) {
        result.push_back(str2[j - 1]);
        j--;
    }

    std::reverse(result.begin(), result.end());
    return result;
}

-----
#include <iostream>
#include <vector>

std::string shortest_common_supersequence(std::string str1, std::string str2) 
    // Your code here
}

************************************
Question ID: 1171

#include <vector>
#include <queue>

using namespace std;

int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
    int n = grid.size();
    if (grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;
    queue<pair<int, int>> q;
    vector<vector<int>> dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};
    q.push({0, 0});
    grid[0][0] = 1;
    int steps = 1;

    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; ++i) {
            int x = q.front().first;
            int y = q.front().second;
            q.pop();
            
            if (x == n - 1 && y == n - 1) return steps;
            
            for (vector<int> dir : dirs) {
                int newX = x + dir[0];
                int newY = y + dir[1];

                if (newX >= 0 && newX < n && newY >= 0 && newY < n && grid[newX][newY] == 0) {
                    q.push({newX, newY});
                    grid[newX][newY] = 1;
                }
            }
        }
        steps++;
    }

    return -1;
}

-----
#include <vector>
#include <queue>

using namespace std;

int shortestPathBinaryMatrix(vector<vector<int>>& grid) 
    // Your code here
}

************************************
Question ID: 1175

#include <vector>
using namespace std;
const int MOD = 1e9 + 7;

int numPrimeArrangements(int n) {
    vector<bool> is_prime(n + 1, true);
    is_prime[0] = false;
    is_prime[1] = false;
    for (int i = 2; i * i <= n; i++) {
        if (is_prime[i]) {
            for (int j = i * i; j <= n; j += i) {
                is_prime[j] = false;
            }
        }
    }
    
    int prime_count = 0;
    for (int i = 2; i <= n; i++) {
        if (is_prime[i]) prime_count++;
    }
    int composite_count = n - prime_count;
    
    long long res = 1;
    for (int i = 1; i <= prime_count; i++) {
        res = res * i % MOD;
    }
    for (int i = 1; i <= composite_count; i++) {
        res = res * i % MOD;
    }
    return res;
}

-----
#include <vector>
using namespace std;
const int MOD = 1e9 + 7;

int numPrimeArrangements(int n) 
    // Your code here
}

************************************
Question ID: 1176

int dietPlanPerformance(vector<int>& calories, int k, int lower, int upper) {
    int points = 0;
    int T = 0;

    for(int i = 0; i < calories.size(); i++) {
        T += calories[i];
        if(i >= k) {
            T -= calories[i-k];
        }
        if(i >= k-1) {
            if(T < lower) points--;
            if(T > upper) points++;
        }
    }

    return points;
}

-----
int dietPlanPerformance(vector<int>& calories, int k, int lower, int upper) 
    // Your code here
}

************************************
Question ID: 1177

#include <vector>
#include <string>

std::vector<bool> canMakePaliQueries(std::string s, std::vector<std::vector<int>>& queries) {
    std::vector<bool> answer;
    std::vector<int> prefixSum(s.length() + 1);

    for (int i = 0; i < s.length(); ++i) {
        prefixSum[i + 1] = prefixSum[i] ^ (1 << (s[i] - 'a'));
    }

    for (auto &query : queries) {
        int left = query[0], right = query[1], k = query[2];
        int diffCount = __builtin_popcount(prefixSum[right + 1] ^ prefixSum[left]);
        answer.push_back((diffCount / 2) <= k);
    }

    return answer;
}


-----
#include <vector>
#include <string>

std::vector<bool> canMakePaliQueries(std::string s, std::vector<std::vector<int>>& queries) 
    // Your code here
}


************************************
Question ID: 1178

#include <vector>
#include <string>
#include <unordered_set>

std::vector<int> findNumOfValidWords(std::vector<std::string>& words, std::vector<std::string>& puzzles) {
    std::vector<int> result;
    for (const std::string& puzzle : puzzles) {
        int count = 0;
        std::unordered_set<char> puzzleSet(puzzle.begin(), puzzle.end());
        for (const std::string& word : words) {
            if (word.find(puzzle[0]) != std::string::npos) {
                if (std::all_of(word.begin(), word.end(), [&](char c) { return puzzleSet.count(c) > 0; })) {
                    count++;
                }
            }
        }
        result.push_back(count);
    }
    return result;
}


-----
#include <vector>
#include <string>
#include <unordered_set>

std::vector<int> findNumOfValidWords(std::vector<std::string>& words, std::vector<std::string>& puzzles) 
    // Your code here
}


************************************
Question ID: 1180

int countLetters(string s) {
    int count = 0, current = 1;

    for (int i = 1; i < s.length(); i++) {
        if (s[i] == s[i - 1]) {
            current++;
        } else {
            count += (current * (current + 1)) / 2;
            current = 1;
        }
    }

    count += (current * (current + 1)) / 2;
    return count;
}

-----
int countLetters(string s) 
    // Your code here
}

************************************
Question ID: 1181

#include <vector>
#include <string>
#include <unordered_map>
#include <set>

std::vector<std::string> beforeAndAfterPuzzles(std::vector<std::string>& phrases) {
    std::unordered_map<std::string, std::set<std::string>> firstWordMap;
    std::set<std::string> result;

    for (const std::string& phrase : phrases) {
        std::string firstWord = phrase.substr(0, phrase.find(' '));
        if (firstWordMap.find(firstWord) != firstWordMap.end()) {
            firstWordMap[firstWord].insert(phrase);
        } else {
            firstWordMap[firstWord] = {phrase};
        }
    }

    for (const std::string& phrase : phrases) {
        std::string lastWord = phrase.substr(phrase.rfind(' ') + 1);
        if (firstWordMap.find(lastWord) != firstWordMap.end()) {
            for (const std::string& curPhrase : firstWordMap[lastWord]) {
                if (phrase != curPhrase) {
                    result.insert(phrase + curPhrase.substr(curPhrase.find(' ')));
                }
            }
        }
    }

    return std::vector<std::string>(result.begin(), result.end());
}

-----
#include <vector>
#include <string>
#include <unordered_map>
#include <set>

std::vector<std::string> beforeAndAfterPuzzles(std::vector<std::string>& phrases) 
    // Your code here
}

************************************
Question ID: 1182

#include<vector>

std::vector<int> shortestDistance(std::vector<int>& colors, std::vector<std::vector<int>>& queries) {
    std::vector<int> result;
    std::vector<std::vector<int>> positions(3);

    for(int i = 0; i < colors.size(); i++) {
        positions[colors[i] - 1].push_back(i);
    }

    for(auto &query : queries) {
        auto &index_positions = positions[query[1] - 1];

        if (index_positions.empty()) {
            result.push_back(-1);
        } else {
            int dist = INT_MAX;

            for (auto pos : index_positions) {
                dist = std::min(dist, std::abs(pos - query[0]));
            }

            result.push_back(dist);
        }
    }

    return result;
}

-----
#include<vector>

std::vector<int> shortestDistance(std::vector<int>& colors, std::vector<std::vector<int>>& queries) 
    // Your code here
}

************************************
Question ID: 1183

#include <vector>
#include <algorithm>

std::vector<double> sampleStats(std::vector<int>& count) {
    double minVal = -1, maxVal = -1, mode = 0, median = 0, mean = 0;
    long long totalCount = 0, modeCount = 0, curCount = 0;
    double sum = 0;

    for (int i = 0; i <= 255; i++) {
        if (count[i] > 0) {
            if (minVal == -1) minVal = i;
            maxVal = i;
            sum += static_cast<double>(i) * count[i];
            totalCount += count[i];
            if (count[i] > modeCount) {
                modeCount = count[i];
                mode = i;
            }
        }
    }

    mean = sum / totalCount;
    bool isEven = (totalCount % 2 == 0);
    long long mid1 = totalCount / 2, mid2 = mid1 - 1;
    if (isEven) mid2++;

    for (int i = 0; i <= 255; i++) {
        curCount += count[i];
        if (isEven && curCount >= mid2) {
            median += i;
            mid2 = totalCount;
            isEven = false;
        }

        if (curCount >= mid1) {
            median += i;
            break;
        }
    }

    if (!isEven) median /= 2;
    return {minVal, maxVal, mean, median, mode};
}

-----
#include <vector>
#include <algorithm>

std::vector<double> sampleStats(std::vector<int>& count) 
    // Your code here
}

************************************
Question ID: 1184

#include <vector>
#include <algorithm>

bool carPooling(std::vector<std::vector<int>>& trips, int capacity) {
    std::vector<int> stops(1001, 0);
    for (const std::vector<int>& t : trips) {
        stops[t[1]] += t[0];
        stops[t[2]] -= t[0];
    }
    for (int i = 0; i < stops.size(); ++i) {
        capacity -= stops[i];
        if (capacity < 0) {
            return false;
        }
    }
    return true;
}

-----
#include <vector>
#include <algorithm>

bool carPooling(std::vector<std::vector<int>>& trips, int capacity) 
    // Your code here
}

************************************
Question ID: 1185

#include <string>

std::string dayOfTheWeek(int day, int month, int year) {
    int days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    std::string week[] = {"Sunday ", "Monday ", "Tuesday ", "Wednesday ", "Thursday ", "Friday ", "Saturday "};
    if (year < 1971) year += (1971 - year) / 400 * 400;
    int sum = -1;
    for (int i = 1971; i < year; ++i) {
        sum += 365;
        if (i % 4 == 0 && (i % 100 != 0 || i % 400 == 0)) ++sum;
    }
    for (int i = 1; i < month; ++i) {
        sum += days[i];
        if (i == 2 && year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) ++sum;
    }
    return week[(sum + day) % 7];
}

-----
#include <string>

std::string dayOfTheWeek(int day, int month, int year) 
    // Your code here
}

************************************
Question ID: 1186

#include <semaphore.h>

class H2O {
public:
    sem_t hydrogenSemaphore;
    sem_t oxygenSemaphore;
    
    H2O() {
        sem_init(&hydrogenSemaphore, 0, 2);
        sem_init(&oxygenSemaphore, 0, 1);
    }

    void hydrogen(function<void()> releaseHydrogen) {
        sem_wait(&hydrogenSemaphore);
        releaseHydrogen();
        sem_post(&oxygenSemaphore);
    }

    void oxygen(function<void()> releaseOxygen) {
        sem_wait(&oxygenSemaphore);
        releaseOxygen();
        sem_post(&hydrogenSemaphore);
        sem_post(&hydrogenSemaphore);
    }
};

-----
#include <semaphore.h>

class H2O 
    // Your code here
};

************************************
Question ID: 1187

#include <mutex>
#include <condition_variable>

class FooBar {
private:
    int n;
    std::mutex mtx;
    std::condition_variable cv;
    bool foo_done = false;

public:
    FooBar(int n) {
        this->n = n;
    }

    void foo(function<void()> printFoo) {
        for (int i = 0; i < n; i++) {
            std::unique_lock<std::mutex> lock(mtx);
            cv.wait(lock, [this]() { return !foo_done; });
            printFoo();
            foo_done = true;
            cv.notify_all();
        }
    }

    void bar(function<void()> printBar) {
        for (int i = 0; i < n; i++) {
            std::unique_lock<std::mutex> lock(mtx);
            cv.wait(lock, [this]() { return foo_done; });
            printBar();
            foo_done = false;
            cv.notify_all();
        }
    }
};

-----
#include <mutex>
#include <condition_variable>

class FooBar 
    // Your code here
};

************************************
Question ID: 1189

int maxNumberOfBalloons(string text) {
    int letter_count[5] = {0};
    for (char c : text) {
        if (c == 'b') letter_count[0]++;
        if (c == 'a') letter_count[1]++;
        if (c == 'l') letter_count[2]++;
        if (c == 'o') letter_count[3]++;
        if (c == 'n') letter_count[4]++;
    }
    letter_count[2] /= 2;
    letter_count[3] /= 2;
    return *min_element(letter_count, letter_count + 5);
}

-----
int maxNumberOfBalloons(string text) 
    // Your code here
}

************************************
Question ID: 1190

#include<bits/stdc++.h>
using namespace std;
string reverseParentheses(string s) {
    
    stack<int> st; 
        for(int i = 0; i < s.length(); ++i){
            
            if(s[i] == '(')
                st.push(i);
            else if(s[i] == ')'){
                reverse(s.begin() + st.top() + 1,  s.begin() + i);
                st.pop();
            }
        }
        string result = "";
        for(int i = 0 ; i < s.length(); ++i){
            
            if(s[i] != '(' && s[i] != ')')
                result += s[i];
        }
        return result;
}

-----
#include<bits/stdc++.h>
using namespace std;
string reverseParentheses(string s) 
    // Your code here
}

************************************
Question ID: 1191

int kConcatenationMaxSum(vector<int>& arr, int k) {
    long long mod = 1e9 + 7, n = arr.size(), sum = 0, maxSum = 0, tempSum = 0, maxLeft = 0, maxRight = 0;
    for (int i = 0; i < n; ++i) {
        sum += arr[i];
        tempSum += arr[i];
        maxSum = max(maxSum, tempSum);
        tempSum = max(0LL, tempSum);
        maxLeft = max(maxLeft, sum);
    }
    long long temp = sum;
    for (int i = n - 1; i >= 0; --i) {
        temp -= arr[i];
        maxRight = max(maxRight, temp);
    }
    long long ans = max({maxSum, maxLeft + maxRight + sum * (k - 2), 0LL});
    return ans % mod;
}

-----
int kConcatenationMaxSum(vector<int>& arr, int k) 
    // Your code here
}

************************************
Question ID: 1192

#include <vector>
#include <unordered_map>

using namespace std;

void dfs(int node, int parent, int depth, vector<int>& rank, unordered_map<int, vector<int>>& graph, vector<vector<int>>& result) {
    rank[node] = depth;
    for (const int& neighbor : graph[node]) {
        if (neighbor == parent) {
            continue;
        }
        if (rank[neighbor] == -1) {
            dfs(neighbor, node, depth + 1, rank, graph, result);
        }
        rank[node] = min(rank[node], rank[neighbor]);
        if (rank[neighbor] == depth + 1) {
            result.push_back({node, neighbor});
        }
    }
}

vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {
    vector<vector<int>> result;
    unordered_map<int, vector<int>> graph;
    for (const vector<int>& connection : connections) {
        graph[connection[0]].push_back(connection[1]);
        graph[connection[1]].push_back(connection[0]);
    }
    vector<int> rank(n, -1);
    dfs(0, -1, 0, rank, graph, result);
    return result;
}


-----
#include <vector>
#include <unordered_map>

using namespace std;

void dfs(int node, int parent, int depth, vector<int>& rank, unordered_map<int, vector<int>>& graph, vector<vector<int>>& result) 
    // Your code here
}


************************************
Question ID: 1196

#include <vector>
#include <algorithm>

int minHeightShelves(std::vector<std::vector<int>>& books, int shelfWidth) {
    int n = books.size();
    std::vector<int> dp(n + 1, 1000000);
    dp[0] = 0;
    
    for (int i = 1; i <= n; ++i) {
        int width = 0, height = 0;
        for (int j = i; j >= 1; --j) {
            width += books[j - 1][0];
            height = std::max(height, books[j - 1][1]);
            
            if (width <= shelfWidth)
                dp[i] = std::min(dp[i], dp[j - 1] + height);
        }
    }
    
    return dp[n];
}

-----
#include <vector>
#include <algorithm>

int minHeightShelves(std::vector<std::vector<int>>& books, int shelfWidth) 
    // Your code here
}

************************************
Question ID: 1197

bool parseBoolExpr(string expression, int &pos) {
    switch (expression[pos++]) {
        case 't': return true;
        case 'f': return false;
        case '!': return !parseBoolExpr(expression, ++pos);
        case '&': {
            pos++; 
            bool result = true;
            while (expression[pos] != ')') {
                result &= parseBoolExpr(expression, pos);
                if(expression[pos] == ',') pos++;
            }
            pos++;
            return result;
        }
        case '|': {
            pos++;
            bool result = false;
            while (expression[pos] != ')') {
                result |= parseBoolExpr(expression, pos);
                if(expression[pos] == ',') pos++;
            }
            pos++;
            return result;
        }
    }
}

bool parseBoolExpr(string expression) {
    int pos = 0;
    return parseBoolExpr(expression, pos);
}

-----
bool parseBoolExpr(string expression, int &pos) 
    // Your code here
}

************************************
Question ID: 1198

int smallestCommonElement(vector<vector<int>>& mat) {
    unordered_map<int, int> counts;
    for (const auto& row : mat) {
        for (int num : row) {
            ++counts[num];
            if (counts[num] == mat.size()) {
                return num;
            }
        }
    }
    return -1;
}

-----
int smallestCommonElement(vector<vector<int>>& mat) 
    // Your code here
}

************************************
Question ID: 1199

#include <vector>
#include <queue>
#include <algorithm>

int minBuildTime(std::vector<int>& blocks, int split) {
    std::priority_queue<int, std::vector<int>, greater<int>> pq(blocks.begin(), blocks.end());
    
    while (pq.size() > 1) {
        int a = pq.top();
        pq.pop();
        int b = pq.top();
        pq.pop();
        pq.push(b + split);
    }
    
    return pq.top();
}

-----
#include <vector>
#include <queue>
#include <algorithm>

int minBuildTime(std::vector<int>& blocks, int split) 
    // Your code here
}

************************************
Question ID: 1200

#include <vector>
#include <algorithm>
using namespace std;

vector<vector<int>> minimumAbsDifference(vector<int>& arr) {
    sort(arr.begin(), arr.end());
    int minDiff = INT_MAX;
    for (int i = 1; i < arr.size(); i++) {
        minDiff = min(minDiff, arr[i] - arr[i - 1]);
    }

    vector<vector<int>> result;
    for (int i = 1; i < arr.size(); i++) {
        if (arr[i] - arr[i - 1] == minDiff) {
            result.push_back({arr[i - 1], arr[i]});
        }
    }

    return result;
}

-----
#include <vector>
#include <algorithm>
using namespace std;

vector<vector<int>> minimumAbsDifference(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1201

#include <algorithm>

int nthUglyNumber(int n, int a, int b, int c) {
    long long left = 1, right = 2 * 1e9, gcd_ab = std::__gcd(a, b), gcd_ac = std::__gcd(a, c), gcd_bc = std::__gcd(b, c);
    long long lcm_ab = a / gcd_ab * b, lcm_ac = a / gcd_ac * c, lcm_bc = b / gcd_bc * c, lcm_abc = a / gcd_ab * lcm_bc;
    
    while (left < right) {
        long long mid = left + (right - left) / 2;
        long long count = mid / a + mid / b + mid / c - mid / lcm_ab - mid / lcm_ac - mid / lcm_bc + mid / lcm_abc;
        if (count < n) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}

-----
#include <algorithm>

int nthUglyNumber(int n, int a, int b, int c) 
    // Your code here
}

************************************
Question ID: 1202

#include <vector>
#include <string>
#include <algorithm>
using namespace std;

class Solution {
public:
    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {
        int n = s.size();
        vector<int> p(n, 0);
        for (int i = 0; i < n; ++i) {
            p[i] = i;
        }
        
        // find the parent for each index
        function<int(int)> find = [&](int x) {
            if (p[x] != x) {
                p[x] = find(p[x]);
            }
            return p[x];
        };

        // union-find and create the connected groups
        for (const auto& pair : pairs) {
            int root1 = find(pair[0]);
            int root2 = find(pair[1]);
            if (root1 != root2) {
                p[root2] = root1;
            }
        }
        
        vector<string> groups(n);
        for (int i = 0; i < n; ++i) {
            groups[find(i)].push_back(s[i]);
        }
        
        // Sort each group
        for (string& group : groups) {
            sort(group.begin(), group.end(), greater<char>());
        }
        
        // Build the result string
        string res;
        for (int i = 0; i < n; ++i) {
            char smallest_char = groups[find(i)].back(); 
            res += smallest_char;
            groups[find(i)].pop_back();
        }
        
        return res;
    }
};


-----
#include <vector>
#include <string>
#include <algorithm>
using namespace std;

class Solution 
    // Your code here
};


************************************
Question ID: 1203

#include <mutex>
#include <condition_variable>

class Foo {
    std::mutex mtx;
    std::condition_variable cv;
    int order = 1;

public:
    Foo() {}

    void first() {
        std::unique_lock<std::mutex> lock(mtx);
        // PrintFirst() outputs "first". Do not change or remove this line.
        printFirst();
        order = 2;
        cv.notify_all();
    }

    void second() {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [&](){ return order == 2; });
        // PrintSecond() outputs "second". Do not change or remove this line.
        printSecond();
        order = 3;
        cv.notify_all();
    }

    void third() {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [&](){ return order == 3; });
        // PrintThird() outputs "third". Do not change or remove this line.
        printThird();
    }
};

-----
#include <mutex>
#include <condition_variable>

class Foo 
    // Your code here
};

************************************
Question ID: 1206

#include <vector>

std::vector<int> corpFlightBookings(std::vector<std::vector<int>>& bookings, int n) {
    std::vector<int> answer(n, 0);
    for (const auto& booking : bookings) {
        answer[booking[0] - 1] += booking[2];
        if (booking[1] < n) {
            answer[booking[1]] -= booking[2];
        }
    }
    for (int i = 1; i < n; ++i) {
        answer[i] += answer[i - 1];
    }
    return answer;
}

-----
#include <vector>

std::vector<int> corpFlightBookings(std::vector<std::vector<int>>& bookings, int n) 
    // Your code here
}

************************************
Question ID: 1208

#include <vector>
#include <string>

std::vector<int> splitString(const std::string& seq) {
    std::vector<int> result(seq.length());
    int count = 0;

    for (size_t i = 0; i < seq.length(); ++i) {
        if (seq[i] == '(') {
            result[i] = count % 2;
            count++;
        } else {
            count--;
            result[i] = count % 2;
        }
    }

    return result;
}


-----
#include <vector>
#include <string>

std::vector<int> splitString(const std::string& seq) 
    // Your code here
}


************************************
Question ID: 1209

std::string removeDuplicates(std::string s, int k) {
    std::vector<std::pair<char, int>> stack;
    for (char c : s) {
        if (stack.empty() || stack.back().first != c) {
            stack.push_back({c, 1});
        } else if (++stack.back().second == k) {
            stack.pop_back();
        }
    }
    std::string result;
    for (auto &pair : stack) {
        result.append(pair.second, pair.first);
    }
    return result;
}


-----
std::string removeDuplicates(std::string s, int k) 
    // Your code here
}


************************************
Question ID: 1210

#include <vector>
#include <algorithm>

double trimmedMean(std::vector<int>& arr) {
    int n = arr.size();
    int remove = n * 0.05;
    std::sort(arr.begin(), arr.end());
    double sum = 0.0;
    for (int i = remove; i < n - remove; i++) {
        sum += arr[i];
    }
    return sum / (n - 2 * remove);
}

-----
#include <vector>
#include <algorithm>

double trimmedMean(std::vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1213

#include <vector>
using namespace std;

vector<int> arraysIntersection(vector<int>& arr1, vector<int>& arr2, vector<int>& arr3) {
    int i = 0, j = 0, k = 0;
    vector<int> result;
    while (i < arr1.size() && j < arr2.size() && k < arr3.size()) {
        if (arr1[i] == arr2[j] && arr2[j] == arr3[k]) {
            result.push_back(arr1[i]);
            i++; j++; k++;
        } else {
            if (arr1[i] <= arr2[j] && arr1[i] <= arr3[k]) i++;
            else if (arr2[j] <= arr3[k]) j++;
            else k++;
        }
    }
    return result;
}

-----
#include <vector>
using namespace std;

vector<int> arraysIntersection(vector<int>& arr1, vector<int>& arr2, vector<int>& arr3) 
    // Your code here
}

************************************
Question ID: 1215

#include <vector>

std::vector<int> countSteppingNumbers(int low, int high) {
    std::vector<int> results;
    for (int i = low; i <= high; i++) {
        int prev = -1;
        int j = i;
        bool is_stepping = true;
        while (j > 0) {
            int digit = j % 10;
            if (prev != -1 && std::abs(prev - digit) != 1) {
                is_stepping = false;
                break;
            }
            prev = digit;
            j /= 10;
        }
        if (is_stepping) results.push_back(i);
    }
    return results;
}

-----
#include <vector>

std::vector<int> countSteppingNumbers(int low, int high) 
    // Your code here
}

************************************
Question ID: 1216

#include <functional>
#include <mutex>
#include <condition_variable>

class ZeroEvenOdd {
private:
    int n;
    int cnt;
    std::mutex mtx;
    std::condition_variable cv;

public:
    ZeroEvenOdd(int n) {
        this->n = n;
        cnt = 1;
    }

    void zero(function<void(int)> printNumber) {
        for(int i = 1; i <= n; i++) {
            unique_lock<mutex> lck(mtx);
            cv.wait(lck, [this](){ return cnt % 2 != 0; });
            printNumber(0);
            cnt++;
            cv.notify_all();
        }
    }

    void even(function<void(int)> printNumber) {
        for(int i = 2; i <= n; i+=2) {
            unique_lock<mutex> lck(mtx);
            cv.wait(lck, [this, i](){ return cnt == 2 * i; });
            printNumber(i);
            cnt++;
            cv.notify_all();
        }
    }

    void odd(function<void(int)> printNumber) {
        for(int i = 1; i <= n; i+=2) {
            unique_lock<mutex> lck(mtx);
            cv.wait(lck, [this, i](){ return cnt == 2 * i - 1; });
            printNumber(i);
            cnt++;
            cv.notify_all();
        }
    }
};

-----
#include <functional>
#include <mutex>
#include <condition_variable>

class ZeroEvenOdd 
    // Your code here
};

************************************
Question ID: 1217

#include <vector>
#include <map>
#include <algorithm>

void sortArray(vector<int>& arr1, vector<int>& arr2) {
    map<int, int> counts;

    for (int num : arr1) {
        counts[num]++;
    }
    int index = 0;
    for (int num : arr2) {
        while (counts[num]--) {
            arr1[index++] = num;
        }
    }
    for (auto &pair : counts) {
        while (pair.second--) {
            arr1[index++] = pair.first;
        }
    }
}

-----
#include <vector>
#include <map>
#include <algorithm>

void sortArray(vector<int>& arr1, vector<int>& arr2) 
    // Your code here
}

************************************
Question ID: 1219

#include <vector>
#include <unordered_map>

int longestWPI(std::vector<int>& hours) {
    int score = 0;
    int maxLength = 0;
    std::unordered_map<int, int> firstOccurrence;

    for (int i = 0; i < hours.size(); ++i) {
        score += hours[i] > 8 ? 1 : -1;
        if (score > 0) maxLength = i + 1;
        else {
             if (firstOccurrence.find(score) == firstOccurrence.end())
                firstOccurrence[score] = i;
             if (firstOccurrence.find(score - 1) != firstOccurrence.end())
                maxLength = std::max(maxLength, i - firstOccurrence[score - 1]);
        }
    }
    return maxLength;
}


-----
#include <vector>
#include <unordered_map>

int longestWPI(std::vector<int>& hours) 
    // Your code here
}


************************************
Question ID: 1220

#include <vector>
#include <bitset>
#include <algorithm>
using namespace std;

vector<int> smallestSufficientTeam(vector<string>& req_skills, vector<vector<string>>& people) {
    int n = req_skills.size(), m = people.size();
    vector<int> skill_to_int(128, -1);
    vector<vector<int>> people_int(m);
    vector<int> res(n);
    int cur_min = n + 1;

    for (int i = 0; i < n; ++i) skill_to_int[req_skills[i].front()] = i;

    for (int i = 0; i < m; ++i)
        for (const string& s : people[i]) people_int[i].push_back(skill_to_int[s.front()]);

    function<void(bitset<26>, int, int)> dfs = [&](bitset<26> s, int p, int count) {
        if (count >= cur_min) return;
        if (p == m && (s & ((1 << n) - 1)) != (1 << n) - 1) return;
        if (p == m) {
            cur_min = count;
            int idx = 0;
            for (int i = 0; i < m; ++i) if (s[26 - i - 1]) res[idx++] = i;
            return;
    }
        dfs(s | (s >> people_int[p]) | (s << n << people_int[p]), p + 1, count + 1);
        dfs(s, p + 1, count);
    };

    dfs(0, 0, 0);
    res.resize(cur_min);
    return res;
}

-----
#include <vector>
#include <bitset>
#include <algorithm>
using namespace std;

vector<int> smallestSufficientTeam(vector<string>& req_skills, vector<vector<string>>& people) 
    // Your code here
}

************************************
Question ID: 1221

int findSpecialInteger(const vector<int>& arr) {
    int n = arr.size(), requiredCount = n / 4;
    for (int i = 0; i < n; i++) {
        if (arr[i] == arr[i + requiredCount]) {
            return arr[i];
        }
    }
    return -1;
}

-----
int findSpecialInteger(const vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1222

int removeCoveredIntervals(vector<vector<int>>& intervals) {
    sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b) {
        if (a[0] == b[0]) return a[1] > b[1];
        return a[0] < b[0];
    });
    
    int count = 0, end = 0;
    for (const auto& i : intervals) {
        if (i[1] > end) {
            count++;
            end = i[1];
        }
    }
    return count;
}


-----
int removeCoveredIntervals(vector<vector<int>>& intervals) 
    // Your code here
}


************************************
Question ID: 1223

#include <vector>
using namespace std;

vector<bool> areConnected(int n, int threshold, vector<vector<int>>& queries) {
    vector<bool> answer(queries.size());
    vector<int> parent(n + 1), rank(n + 1, 0);

    for (int i = 1; i <= n; ++i)
        parent[i] = i;

    function<int(int)> find = [&](int x) {
        if (parent[x] != x)
            parent[x] = find(parent[x]);
        return parent[x];
    };

    auto unite = [&](int x, int y) {
        int rootx = find(x);
        int rooty = find(y);
        if (rootx != rooty) {
            if (rank[rootx] > rank[rooty])
                swap(rootx, rooty);
            parent[rootx] = rooty;
            if (rank[rootx] == rank[rooty])
                rank[rooty]++;
        }
    };

    for (int i = threshold + 1; i <= n; ++i)
        for (int j = 2 * i; j <= n; j += i)
            unite(i, j);

    for (int i = 0; i < queries.size(); ++i)
        answer[i] = find(queries[i][0]) == find(queries[i][1]);

    return answer;
}

-----
#include <vector>
using namespace std;

vector<bool> areConnected(int n, int threshold, vector<vector<int>>& queries) 
    // Your code here
}

************************************
Question ID: 1224

#include <vector>
#include <algorithm>
using namespace std;

int minFallingPathSum(vector<vector<int>>& grid) {
    int n = grid.size();
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            int minVal = INT_MAX;
            for (int k = 0; k < n; ++k) {
                if (k == j) continue;
                minVal = min(minVal, grid[i - 1][k]);
            }
            grid[i][j] += minVal;
        }
    }
    return *min_element(grid[n-1].begin(), grid[n-1].end());
}

-----
#include <vector>
#include <algorithm>
using namespace std;

int minFallingPathSum(vector<vector<int>>& grid) 
    // Your code here
}

************************************
Question ID: 1227

#include<vector>
#include<unordered_map>

int num_equiv_domino_pairs(std::vector<std::vector<int>>& dominoes) {
    std::unordered_map<int, int> freq;
    int result = 0;
    for (auto& domino : dominoes) {
        int key = (std::min(domino[0], domino[1]) << 4) | std::max(domino[0], domino[1]);
        result += freq[key]++;
    }
    return result;
}

-----
#include<vector>
#include<unordered_map>

int num_equiv_domino_pairs(std::vector<std::vector<int>>& dominoes) 
    // Your code here
}

************************************
Question ID: 1228

int mctFromLeafValues(vector<int>& arr) {
    int n = arr.size();
    vector<vector<int>> dp(n, vector<int>(n, 0));
    vector<vector<int>> maxs(n, vector<int>(n, 0));

    for (int i = 0; i < n; ++i) {
        for (int j = i; j < n; ++j) {
            maxs[i][j] = *max_element(arr.begin() + i, arr.begin() + j + 1);
        }
    }

    for (int len = 1; len < n; ++len) {
        for (int i = 0; i + len < n; ++i) {
            int j = i + len;
            dp[i][j] = INT_MAX;
            for (int k = i; k < j; ++k) {
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + maxs[i][k] * maxs[k + 1][j]);
            }
        }
    }
    return dp[0][n - 1];
}

-----
int mctFromLeafValues(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1229

#include <vector>
#include <queue>

using namespace std;

vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) {
    vector<vector<vector<int>>> adjList(n, vector<vector<int>>(2));
    
    for (const auto& edge : redEdges) {
        adjList[edge[0]][0].push_back(edge[1]);
    }
    
    for (const auto& edge : blueEdges) {
        adjList[edge[0]][1].push_back(edge[1]);
    }
    
    vector<vector<int>> dist(n, vector<int>(2, -1));
    dist[0] = {0, 0};
    
    queue<pair<int,int>> q;
    q.push({0, 0});
    q.push({0, 1});
    
    while (!q.empty()) {
        int node = q.front().first, color = q.front().second;
        q.pop();
        int next_color = color ^ 1;
        
        for (int neighbor : adjList[node][next_color]) {
            if (dist[neighbor][next_color] == -1) {
                dist[neighbor][next_color] = dist[node][color] + 1;
                q.push({neighbor, next_color});
            }
        }
    }
    
    vector<int> result(n);
    for (int i = 0; i < n; ++i) {
        result[i] = min(dist[i][0], dist[i][1]);
        if (dist[i][0] == -1 || dist[i][1] == -1) {
            result[i] = max(dist[i][0], dist[i][1]);
        }
    }
    return result;
}


-----
#include <vector>
#include <queue>

using namespace std;

vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) 
    // Your code here
}


************************************
Question ID: 1230

int max_value(int arr1[], int arr2[], int n) {
    int max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN, max4 = INT_MIN;
    int min1 = INT_MAX, min2 = INT_MAX, min3 = INT_MAX, min4 = INT_MAX;

    for (int i = 0; i < n; i++) {
        max1 = max(max1, arr1[i] - arr2[i] + i);
        max2 = max(max2, arr1[i] + arr2[i] + i);
        max3 = max(max3, -arr1[i] + arr2[i] + i);
        max4 = max(max4, -arr1[i] - arr2[i] + i);

        min1 = min(min1, arr1[i] - arr2[i] + i);
        min2 = min(min2, arr1[i] + arr2[i] + i);
        min3 = min(min3, -arr1[i] + arr2[i] + i);
        min4 = min(min4, -arr1[i] - arr2[i] + i);
    }
    return max({max1 - min1, max2 - min2, max3 - min3, max4 - min4});
}


-----
int max_value(int arr1[], int arr2[], int n) 
    // Your code here
}


************************************
Question ID: 1231

#include <vector>
using namespace std;

vector<int> replaceElements(vector<int>& arr) {
    int n = arr.size();
    int maxElement = -1;
    for (int i = n - 1; i >= 0; i--) {
        int temp = arr[i];
        arr[i] = maxElement;
        maxElement = max(maxElement, temp);
    }
    return arr;
}

-----
#include <vector>
using namespace std;

vector<int> replaceElements(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1232

int findBestValue(vector<int>& arr, int target) {
    int left = 0;
    int right = *max_element(arr.begin(), arr.end());
    int result, min_diff = INT_MAX;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        int sum = 0;
        for (int num : arr) {
            sum += min(num, mid);
        }
        if (sum == target) {
            return mid;
        }
        else if (sum > target) {
            right = mid - 1;
        }
        else {
            left = mid + 1;
        }
        if (abs(target - sum) < min_diff || abs(target - sum) == min_diff && mid < result) {
            min_diff = abs(target - sum);
            result = mid;
        }
    }
    return result;
}

-----
int findBestValue(vector<int>& arr, int target) 
    // Your code here
}

************************************
Question ID: 1233

#include <vector>
#include <string>
#include <algorithm>

std::vector<std::string> removeSubfolders(std::vector<std::string>& folder) {
    std::vector<std::string> result;
    std::sort(folder.begin(), folder.end());
    std::string prefix = "/";
    
    for (const auto& path : folder) {
        if (path.compare(0, prefix.size(), prefix) != 0) {
            result.push_back(path);
            prefix = path + "/";
        }
    }
    return result;
}

-----
#include <vector>
#include <string>
#include <algorithm>

std::vector<std::string> removeSubfolders(std::vector<std::string>& folder) 
    // Your code here
}

************************************
Question ID: 1234

#include <vector>
#include <string>
using namespace std;

vector<int> getMaxSumAndCount(vector<string>& board) {
    int mod = 1000000007;
    int n = board.size();
    vector<vector<pair<int, int>>> dp(n, vector<pair<int, int>>(n, {0, 0}));
    dp[n - 1][n - 1] = {0, 1};

    for (int i = n - 1; i >= 0; i--) {
        for (int j = n - 1; j >= 0; j--) {
            if (board[i][j] == 'X' || (i == n - 1 && j == n - 1)) continue;
            int currVal = board[i][j] == 'E' ? 0 : board[i][j] - '0';
            pair<int, int> up = i > 0 ? dp[i - 1][j] : make_pair(-1, 0);
            pair<int, int> left = j > 0 ? dp[i][j - 1] : make_pair(-1, 0);
            pair<int, int> diag = i > 0 && j > 0 ? dp[i - 1][j - 1] : make_pair(-1, 0);

            pair<int, int> maxPair = max({up, left, diag});
            if (maxPair.first == -1) continue;

            dp[i][j].first = maxPair.first + currVal;
            if (up == maxPair) dp[i][j].second = (dp[i][j].second + up.second % mod) % mod;
            if (left == maxPair) dp[i][j].second = (dp[i][j].second + left.second % mod) % mod;
            if (diag == maxPair) dp[i][j].second = (dp[i][j].second + diag.second % mod) % mod;
        }
    }
    return {dp[0][0].first, dp[0][0].second};
}


-----
#include <vector>
#include <string>
using namespace std;

vector<int> getMaxSumAndCount(vector<string>& board) 
    // Your code here
}


************************************
Question ID: 1235

#include <vector>
#include <algorithm>

int jobScheduling(std::vector<int>& startTime, std::vector<int>& endTime, std::vector<int>& profit) {
    int n = startTime.size();
    std::vector<std::tuple<int, int, int>> jobs(n);
    
    for (int i = 0; i < n; ++i) {
        jobs[i] = {endTime[i], startTime[i], profit[i]};
    }
    
    std::sort(jobs.begin(), jobs.end());

    std::vector<int> dp(n);
    dp[0] = std::get<2>(jobs[0]);

    for (int i = 1; i < n; ++i) {
        int L = -1;
        for (int j = i - 1; j >= 0; --j) {
            if (std::get<1>(jobs[j]) >= std::get<0>(jobs[L == -1 ? i : L])) {
                L = j;
            }
        }
        dp[i] = std::max(dp[i - 1], (L == -1 ? 0 : dp[L]) + std::get<2>(jobs[i]));
    }

    return dp[n - 1];
}

-----
#include <vector>
#include <algorithm>

int jobScheduling(std::vector<int>& startTime, std::vector<int>& endTime, std::vector<int>& profit) 
    // Your code here
}

************************************
Question ID: 1236

int tribonacci(int n) {
    if(n==0) return 0;
    if(n==1 || n==2) return 1;
    int a = 0, b = 1, c = 1, d;
    for(int i = 3; i <= n; ++i) {
        d = a + b + c;
        a = b;
        b = c;
        c = d;
    }
    return c;
}

-----
int tribonacci(int n) 
    // Your code here
}

************************************
Question ID: 1237

#include<vector>
#include "CustomFunction.h"

std::vector<std::vector<int>> findSolution(CustomFunction& customfunction, int z) {
    std::vector<std::vector<int>> results;
    for (int x = 1; x <= 1000; x++) {
        for (int y = 1; y <= 1000; y++) {
            if (customfunction.f(x, y) == z) {
                results.push_back({x, y});
            } else if (customfunction.f(x, y) > z) {
                break;
            }
        }
    }
    return results;
}

-----
#include<vector>
#include "CustomFunction.h"

std::vector<std::vector<int>> findSolution(CustomFunction& customfunction, int z) 
    // Your code here
}

************************************
Question ID: 1238

#include <string>
#include <utility>

std::string alphabetBoardPath(const std::string& target) {
    std::string result;
    std::pair<int, int> startPosition(0, 0);

    for (char t : target) {
        int r = (t - 'a') / 5;
        int c = (t - 'a') % 5;
        while (startPosition.first > r) {
            result.push_back('U');
            --startPosition.first;
        }
        while (startPosition.second > c) {
            result.push_back('L');
            --startPosition.second;
        }
        while (startPosition.first < r) {
            result.push_back('D');
            ++startPosition.first;
        }
        while (startPosition.second < c) {
            result.push_back('R');
            ++startPosition.second;
        }
        result.push_back('!');
    }
    return result;
}


-----
#include <string>
#include <utility>

std::string alphabetBoardPath(const std::string& target) 
    // Your code here
}


************************************
Question ID: 1239

int largest1BorderedSquare(vector<vector<int>>& grid) {
    int m = grid.size();
    int n = grid[0].size();
    vector<vector<int>> horizontal(m, vector<int>(n, 0));
    vector<vector<int>> vertical(m, vector<int>(n, 0));

    int max_square_size = 0;

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 1) {
                horizontal[i][j] = (j == 0) ? 1 : horizontal[i][j - 1] + 1;
                vertical[i][j] = (i == 0) ? 1 : vertical[i - 1][j] + 1;

                int min_size = min(horizontal[i][j], vertical[i][j]);
                while (min_size > max_square_size) {
                    if (horizontal[i - min_size + 1][j] >= min_size &&
                        vertical[i][j - min_size + 1] >= min_size) {
                        max_square_size = min_size;
                    }
                    min_size--;
                }
            }
        }
    }

    return max_square_size * max_square_size;
}

-----
int largest1BorderedSquare(vector<vector<int>>& grid) 
    // Your code here
}

************************************
Question ID: 1240

#include <vector>
#include <algorithm>

int stoneGameII(std::vector<int>& piles) {
    int n = piles.size();
    std::vector<std::vector<int>> memo(n, std::vector<int>(n + 1, 0));
    
    for (int i = n - 2; i >= 0; --i) {
        piles[i] += piles[i + 1];
    }

    function<int(int, int)> search = [&](int idx, int M) {
        if (idx + 2 * M >= n) {
            return piles[idx];
        }
        if (memo[idx][M] > 0) {
            return memo[idx][M];
        }
        memo[idx][M] = 0;
        for (int x = 1; x <= 2 * M; ++x) {
            memo[idx][M] = std::max(memo[idx][M], piles[idx] - search(idx + x, std::max(M, x)));
        }
        return memo[idx][M];
    };
    
    return search(0, 1);
}

-----
#include <vector>
#include <algorithm>

int stoneGameII(std::vector<int>& piles) 
    // Your code here
}

************************************
Question ID: 1243

int sumEvenGrandparent(TreeNode* root, TreeNode* parent = nullptr, TreeNode* grandparent = nullptr) {
    if (!root) return 0;
    int sum = 0;
    if (grandparent && grandparent->val % 2 == 0) {
        sum += root->val;
    }
    sum += sumEvenGrandparent(root->left, root, parent) + sumEvenGrandparent(root->right, root, parent);
    return sum;
}

-----
int sumEvenGrandparent(TreeNode* root, TreeNode* parent = nullptr, TreeNode* grandparent = nullptr) 
    // Your code here
}

************************************
Question ID: 1244

int numDistinctRepeatedSubstrings(const string& s) {
    unordered_set<string> seen;
    for (int len = s.length() / 2; len >= 1; len--) {
        for (int i = 0; i <= s.length() - 2 * len; i++) {
            string substr = s.substr(i, len);
            if (s.find(substr, i + len) != string::npos)
                seen.insert(substr);
        }
    }
    return seen.size();
}


-----
int numDistinctRepeatedSubstrings(const string& s) 
    // Your code here
}


************************************
Question ID: 1245

#include <vector>
#include <unordered_map>
#include <queue>
using namespace std;

int treeDiameter(vector<vector<int>>& edges) {
    unordered_map<int, vector<int>> tree;
    for (const auto& edge : edges) {
        tree[edge[0]].push_back(edge[1]);
        tree[edge[1]].push_back(edge[0]);
    }
    
    queue<pair<int, int>> q;
    q.push({0, 0});
    int furthest = 0;
    int max_distance = 0;
    while (!q.empty()) {
        int node = q.front().first;
        int distance = q.front().second;
        q.pop();
        if (distance > max_distance) {
            max_distance = distance;
            furthest = node;
        }
        for (int neighbor : tree[node]) {
            tree[neighbor].erase(remove(tree[neighbor].begin(), tree[neighbor].end(), node), tree[neighbor].end());
            q.push({neighbor, distance + 1});
        }
    }
    
    q.push({furthest, 0});
    max_distance = 0;
    while (!q.empty()) {
        int node = q.front().first;
        int distance = q.front().second;
        q.pop();
        if (distance > max_distance) {
            max_distance = distance;
        }
        for (int neighbor : tree[node]) {
            tree[neighbor].erase(remove(tree[neighbor].begin(), tree[neighbor].end(), node), tree[neighbor].end());
            q.push({neighbor, distance + 1});
        }
    }
    
    return max_distance;
}

-----
#include <vector>
#include <unordered_map>
#include <queue>
using namespace std;

int treeDiameter(vector<vector<int>>& edges) 
    // Your code here
}

************************************
Question ID: 1246

#include <vector>
#include <cstring>
using namespace std;

int dp[101][101];

bool isPalindrome(const vector<int>& arr, int i, int j) {
    while (i < j)
        if (arr[i++] != arr[j--]) return false;
    return true;
}

int minRemovals(vector<int>& arr, int i, int j) {
    if (i > j) return 0;
    if (i == j) return 1;
    if (dp[i][j] != -1) return dp[i][j];

    int ans = minRemovals(arr, i + 1, j) + 1;
    for (int k = i + 1; k <= j; k++)
        if (arr[i] == arr[k])
            ans = min(ans, minRemovals(arr, i + 1, k - 1) + minRemovals(arr, k + 1, j));
    return dp[i][j] = ans;
}

int minimumMoves(vector<int>& arr) {
    memset(dp, -1, sizeof(dp));
    return minRemovals(arr, 0, arr.size() - 1);
}

-----
#include <vector>
#include <cstring>
using namespace std;

int dp[101][101];

bool isPalindrome(const vector<int>& arr, int i, int j) 
    // Your code here
}

************************************
Question ID: 1247

int movesToMakeZigzag(std::vector<int>& nums) {
    int moves1 = 0, moves2 = 0;
    for (int i = 0; i < nums.size(); i++) {
        int left = i > 0 ? nums[i - 1] : INT_MAX;
        int right = i + 1 < nums.size() ? nums[i + 1] : INT_MAX;
        int diff1 = nums[i] - std::min(left, right) + 1;
        int diff2 = nums[i] - std::min(left, right) + 1;
        if (i % 2 == 0) {
            moves1 += std::max(0, diff1);
        } else {
            moves2 += std::max(0, diff2);
        }
    }
    return std::min(moves1, moves2);
}

-----
int movesToMakeZigzag(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1250

#include <vector>
using namespace std;

int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}

bool isGoodArray(vector<int>& nums) {
    int res = nums[0];
    for (int num : nums) {
        res = gcd(res, num);
    }
    return res == 1;
}

-----
#include <vector>
using namespace std;

int gcd(int a, int b) 
    // Your code here
}

************************************
Question ID: 1252

#include <string>

std::string breakPalindrome(std::string palindrome) {
    int n = palindrome.size();
    if (n < 2) return "";
    
    for (int i = 0; i < n / 2; i++) {
        if (palindrome[i] != 'a') {
            palindrome[i] = 'a';
            return palindrome;
        }
    }
    
    palindrome[n - 1] = 'b';
    return palindrome;
}

-----
#include <string>

std::string breakPalindrome(std::string palindrome) 
    // Your code here
}

************************************
Question ID: 1253

#include <vector>
#include <queue>

using namespace std;

vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {
    int m = mat.size(), n = mat[0].size();
    for (int i = 0; i < m; ++i) {
        priority_queue<int, vector<int>, greater<>> pq;
        int row = i, col = 0;
        while (row < m && col < n) {
            pq.push(mat[row++][col++]);
        }
        row = i, col = 0;
        while (row < m && col < n) {
            mat[row++][col++] = pq.top();
            pq.pop();
        }
    }
    for (int i = 1; i < n; ++i) {
        priority_queue<int, vector<int>, greater<>> pq;
        int row = 0, col = i;
        while (row < m && col < n) {
            pq.push(mat[row++][col++]);
        }
        row = 0, col = i;
        while (row < m && col < n) {
            mat[row++][col++] = pq.top();
            pq.pop();
        }
    }
    return mat;
}


-----
#include <vector>
#include <queue>

using namespace std;

vector<vector<int>> diagonalSort(vector<vector<int>>& mat) 
    // Your code here
}


************************************
Question ID: 1254

#include <vector>

bool dfs(std::vector<std::vector<int>>& grid, int i, int j) {
    if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size()) {
        return false;
    }

    if (grid[i][j] == 1) {
        return true;
    }

    grid[i][j] = 1;

    bool up = dfs(grid, i - 1, j);
    bool down = dfs(grid, i + 1, j);
    bool left = dfs(grid, i, j - 1);
    bool right = dfs(grid, i, j + 1);

    return up && down && left && right;
}

int closedIsland(std::vector<std::vector<int>>& grid) {
    int count = 0;

    for (int i = 0; i < grid.size(); ++i) {
        for (int j = 0; j < grid[0].size(); ++j) {
            if (grid[i][j] == 0 && dfs(grid, i, j)) {
                count++;
            }
        }
    }

    return count;
}


-----
#include <vector>

bool dfs(std::vector<std::vector<int>>& grid, int i, int j) 
    // Your code here
}


************************************
Question ID: 1255

int maxValueAfterReverse(vector<int>& nums) {
    int total = 0, diff = 0;
    int min2 = INT_MAX, max2 = INT_MIN;
    for (int i = 0; i < nums.size() - 1; ++i) {
        total += abs(nums[i] - nums[i + 1]);
        min2 = min(min2, max(nums[i], nums[i + 1]));
        max2 = max(max2, min(nums[i], nums[i + 1]));
        diff = max(diff, abs(nums[i + 1] - nums[0]) - abs(nums[i + 1] - nums[i]));
        diff = max(diff, abs(nums[i] - nums[nums.size() - 1]) - abs(nums[i] - nums[i + 1]));
    }
    return total + max(diff, 2 * (max2 - min2));
}

-----
int maxValueAfterReverse(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1256

#include <vector>
#include <algorithm>
#include <unordered_map>
using namespace std;

vector<int> arrayRankTransform(vector<int>& arr) {
    vector<int> sorted_arr = arr;
    sort(sorted_arr.begin(), sorted_arr.end());
    unordered_map<int, int> rank_map;
    int rank = 1;

    for(int num : sorted_arr) {
        if(rank_map.find(num) == rank_map.end()) {
            rank_map[num] = rank++;
        }
    }

    for(int i = 0; i < arr.size(); i++) {
        arr[i] = rank_map[arr[i]];
    }

    return arr;
}

-----
#include <vector>
#include <algorithm>
#include <unordered_map>
using namespace std;

vector<int> arrayRankTransform(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1257

#include <vector>
#include <queue>

std::vector<std::vector<int>> matrixRankTransform(std::vector<std::vector<int>>& matrix) {
    int m = matrix.size(), n = matrix[0].size();
    std::vector<std::vector<int>> rank(m, std::vector<int>(n));
    std::vector<int> sorted_row(m), sorted_col(n);

    auto neighbours = [&](int r, int c) {
        std::vector<std::pair<int, int>> res;
        for (int i=0; i<m; ++i) if (i != r) res.push_back({i, c});
        for (int i=0; i<n; ++i) if (i != c) res.push_back({r, i});
        return res;
    };

    for (int bound=0; bound<=2e5; bound++) {
        std::queue<std::pair<int, int>> q;
        for (int i = 0; i<m; ++i)
            for (int j = 0; j<n; ++j)
                if (matrix[i][j] == bound && rank[i][j] == 0) q.push({i, j});

        if (q.empty()) break;
        for (std::pair<int, int> rc; !q.empty(); q.pop()) {
            auto [r,c] = rc = q.front();
            int potential_rank = sorted_row[r] + 1;
            for (auto [row, col]: neighbours(r,c))
                if (matrix[row][col] <= matrix[r][c])
                    potential_rank = std::max(potential_rank, rank[row][col] + (matrix[row][col] < matrix[r][c] ? 0 : 1));
            if (potential_rank == sorted_col[c] + 1) {
                rank[r][c] = sorted_row[r] = sorted_col[c] = potential_rank;
            } else {
                q.push(rc);
            }
        }
    }
    return rank;
}

-----
#include <vector>
#include <queue>

std::vector<std::vector<int>> matrixRankTransform(std::vector<std::vector<int>>& matrix) 
    // Your code here
}

************************************
Question ID: 1258

#include <vector>
#include <string>
#include <set>
#include <map>

using namespace std;

void generateSentencesHelper(int index, vector<string>& words, map<string, set<string>>& synonyms, vector<string>& result, string curSentence) {
    if (index == words.size()) {
        result.push_back(curSentence);
    } else {
        set<string>& synSet = synonyms[words[index]];
        for (const auto& syn : synSet) {
            generateSentencesHelper(index + 1, words, synonyms, result, curSentence + (curSentence.empty() ? "" : " ") + syn);
        }
    }
}

vector<string> generateSentences(vector<vector<string>>& synonyms, string text) {
    map<string, set<string>> synonymMap;

    for (const auto& synPair : synonyms) {
        synonymMap[synPair[0]].insert(synPair[0]);
        synonymMap[synPair[0]].insert(synPair[1]);
        synonymMap[synPair[1]].insert(synPair[0]);
        synonymMap[synPair[1]].insert(synPair[1]);
    }

    vector<string> words;
    size_t start = 0, end = text.find(' ');

    while (end != string::npos) {
        words.push_back(text.substr(start, end - start));
        start = end + 1;
        end = text.find(' ', start);
    }

    words.push_back(text.substr(start));

    vector<string> result;
    generateSentencesHelper(0, words, synonymMap, result, "");

    return result;
}


-----
#include <vector>
#include <string>
#include <set>
#include <map>

using namespace std;

void generateSentencesHelper(int index, vector<string>& words, map<string, set<string>>& synonyms, vector<string>& result, string curSentence) 
    // Your code here
}


************************************
Question ID: 1259

int numberOfWays(int numPeople) {
    const int MOD = 1000000007;
    vector<int> dp(numPeople / 2 + 1);
    dp[0] = 1;
    for (int i = 1; i <= numPeople / 2; ++i) {
        for (int j = 1; j <= i; ++j) {
            dp[i] = (dp[i] + ((long long) dp[i - j] * dp[j - 1]) % MOD) % MOD;
        }
    }
    return dp[numPeople / 2];
}

-----
int numberOfWays(int numPeople) 
    // Your code here
}

************************************
Question ID: 1260

int dayOfYear(std::string date) {
    int year = stoi(date.substr(0, 4));
    int month = stoi(date.substr(5, 2));
    int day = stoi(date.substr(8, 2));

    int daysInMonth[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {
        daysInMonth[2] = 29;
    }

    int dayOfYear = 0;
    for (int i = 1; i < month; ++i) {
        dayOfYear += daysInMonth[i];
    }
    dayOfYear += day;

    return dayOfYear;
}

-----
int dayOfYear(std::string date) 
    // Your code here
}

************************************
Question ID: 1262

class MajorityChecker {
public:
    MajorityChecker(vector<int>& arr) {
        for(int i = 0; i < arr.size(); i++) {
            positions[arr[i]].push_back(i);
        }
    }
    
    int query(int left, int right, int threshold) {
        for(int i = 0; i < 20; i++) {
            int randomIndex = rand() % (right - left + 1) + left;
            int num = positions[arr[randomIndex]].size();
            if (num >= threshold) {
                auto lb = lower_bound(positions[arr[randomIndex]].begin(), positions[arr[randomIndex]].end(), left);
                auto ub = upper_bound(positions[arr[randomIndex]].begin(), positions[arr[randomIndex]].end(), right);
                if(ub - lb >= threshold) return arr[randomIndex];
            }
        }
        return -1;
    }
private:
    unordered_map<int, vector<int>> positions;
};

-----
class MajorityChecker 
    // Your code here
};

************************************
Question ID: 1263

int numRollsToTarget(int n, int k, int target) {
    const int MOD = 1e9 + 7;
    vector<vector<int>> dp(n + 1, vector<int>(target + 1, 0));
    dp[0][0] = 1;
    
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= target; ++j) {
            for (int l = 1; l <= k; ++l) {
                if (j >= l) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - l]) % MOD;
                }
            }
        }
    }
    return dp[n][target];
}

-----
int numRollsToTarget(int n, int k, int target) 
    // Your code here
}

************************************
Question ID: 1265

void printLinkedListInReverse(ImmutableListNode* head) {
    if (head != nullptr) {
        printLinkedListInReverse(head->getNext());
        head->printValue();
    }
}

-----
void printLinkedListInReverse(ImmutableListNode* head) 
    // Your code here
}

************************************
Question ID: 1266

int minTimeToVisitAllPoints(vector<vector<int>>& points) {
    int time = 0;
    for (int i = 1; i < points.size(); i++) {
        int dx = abs(points[i][0] - points[i - 1][0]);
        int dy = abs(points[i][1] - points[i - 1][1]);
        time += max(dx, dy);
    }
    return time;
}


-----
int minTimeToVisitAllPoints(vector<vector<int>>& points) 
    // Your code here
}


************************************
Question ID: 1267

ListNode* removeZeroSumSublists(ListNode* head) {
    ListNode dummy(0);
    dummy.next = head;
    ListNode* current = &dummy;

    while (current) {
        int sum = 0;
        while (head) {
            sum += head->val;
            if (sum == 0) {
                current->next = head->next;
            }
            head = head->next;
        }
        current = current->next;
        if (current) {
            head = current->next;
        }
    }

    return dummy.next;
}


-----
ListNode* removeZeroSumSublists(ListNode* head) 
    // Your code here
}


************************************
Question ID: 1268

#include <vector>
#include <string>
#include <algorithm>

std::vector<std::vector<std::string>> suggestedProducts(std::vector<std::string>& products, std::string searchWord) {
    std::vector<std::vector<std::string>> result;
    std::sort(products.begin(), products.end());
    
    for (int i = 0; i < searchWord.size(); ++i) {
        std::vector<std::string> suggestions;
        for (const auto& product : products) {
            if (product.size() > i && product[i] == searchWord[i]) {
                suggestions.push_back(product);
                if (suggestions.size() == 3) break;
            }
        }
        result.push_back(suggestions);
    }
    
    return result;
}


-----
#include <vector>
#include <string>
#include <algorithm>

std::vector<std::vector<std::string>> suggestedProducts(std::vector<std::string>& products, std::string searchWord) 
    // Your code here
}


************************************
Question ID: 1269

const int mod = 1e9 + 7;

int numOfWays(int steps, int arrLen) {
  int max_pos = min(steps / 2, arrLen - 1);
  vector<vector<int>> dp(2, vector<int>(max_pos + 1));
  dp[0][0] = 1;
  for (int s = 1; s <= steps; ++s) {
    for (int p = 0; p <= max_pos; ++p) {
      dp[s % 2][p] = dp[(s - 1) % 2][p];
      if (p > 0) {
        dp[s % 2][p] += dp[(s - 1) % 2][p - 1];
      }
      if (p < max_pos) {
        dp[s % 2][p] += dp[(s - 1) % 2][p + 1];
      }
      dp[s % 2][p] %= mod;
    }
  }
  return dp[steps % 2][0];
}


-----
const int mod = 1e9 + 7;

int numOfWays(int steps, int arrLen) 
    // Your code here
}


************************************
Question ID: 1271

#include <string>

std::string toHexspeak(std::string num) {
    long n = std::stol(num);
    std::string hex = "";
    while (n) {
        int rem = n % 16;
        if (rem == 1) hex = "I" + hex;
        else if (rem == 0) hex = "O" + hex;
        else if (rem > 9) hex = (char)(rem - 10 + 'A') + hex;
        else return "ERROR";
        n /= 16;
    }
    return hex;
}

-----
#include <string>

std::string toHexspeak(std::string num) 
    // Your code here
}

************************************
Question ID: 1272

#include <vector>
#include <string>
#include <sstream>
#include <unordered_map>

std::vector<std::string> invalidTransactions(std::vector<std::string>& transactions) {
    std::unordered_map<std::string, std::vector<std::vector<std::string>>> trans_map;
    
    for (const auto& trans : transactions) {
        std::stringstream ss(trans);
        std::vector<std::string> temp;
        std::string s;
        
        while (std::getline(ss, s, ','))
            temp.push_back(s);
        
        trans_map[temp[0]].push_back(temp);
    }
    
    std::vector<std::string> ans;
    
    for (const auto& trans : transactions) {
        std::stringstream ss(trans);
        std::vector<std::string> temp;
        std::string s;
        
        while (std::getline(ss, s, ','))
            temp.push_back(s);
        
        if (std::stoi(temp[2]) > 1000) {
            ans.push_back(trans);
            continue;
        }
        
        for (const auto& other : trans_map[temp[0]]) {
            if (other[3] != temp[3] && std::abs(std::stoi(other[1]) - std::stoi(temp[1])) <= 60) {
                ans.push_back(trans);
                break;
            }
        }
    }
    
    return ans;
}


-----
#include <vector>
#include <string>
#include <sstream>
#include <unordered_map>

std::vector<std::string> invalidTransactions(std::vector<std::string>& transactions) 
    // Your code here
}


************************************
Question ID: 1273

#include <vector>
#include <string>
#include <algorithm>

std::vector<int> countSmallerFrequencies(const std::vector<std::string>& words, const std::vector<std::string>& queries) {
    std::vector<int> freqWords(words.size(), 0);
    
    for (int i = 0; i < words.size(); ++i) {
        char minChar = *min_element(words[i].begin(), words[i].end());
        freqWords[i] = count(words[i].begin(), words[i].end(), minChar);
    }
    
    std::vector<int> ans(queries.size(), 0);
    for (int i = 0; i < queries.size(); ++i) {
        char minChar = *min_element(queries[i].begin(), queries[i].end());
        int freqQuery = count(queries[i].begin(), queries[i].end(), minChar);
        
        ans[i] = count_if(freqWords.begin(), freqWords.end(), [freqQuery](int f) { return f > freqQuery; });
    }

    return ans;
}

-----
#include <vector>
#include <string>
#include <algorithm>

std::vector<int> countSmallerFrequencies(const std::vector<std::string>& words, const std::vector<std::string>& queries) 
    // Your code here
}

************************************
Question ID: 1274

#include <ctime>
#include <iostream>
#include <sstream>

int countDaysBetweenDates(const std::string& date1, const std::string& date2) {
    std::tm tm1 = {}, tm2 = {};
    std::istringstream ss1(date1), ss2(date2);
    ss1 >> std::get_time(&tm1, "%Y-%m-%d");
    ss2 >> std::get_time(&tm2, "%Y-%m-%d");

    std::time_t time1 = std::mktime(&tm1);
    std::time_t time2 = std::mktime(&tm2);
    double difference = std::difftime(time2, time1);
    return difference / 86400;
}

-----
#include <ctime>
#include <iostream>
#include <sstream>

int countDaysBetweenDates(const std::string& date1, const std::string& date2) 
    // Your code here
}

************************************
Question ID: 1275

bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {
    vector<int> parent(n, -1);
    for (int i = 0; i < n; ++i) {
        if (leftChild[i] != -1) {
            if (parent[leftChild[i]] != -1) return false;
            parent[leftChild[i]] = i;
        }
        if (rightChild[i] != -1) {
            if (parent[rightChild[i]] != -1) return false;
            parent[rightChild[i]] = i;
        }
    }
    int root = -1;
    for (int i = 0; i < n; ++i) {
        if (parent[i] == -1) {
            if (root != -1) return false;
            root = i;
        }
    }
    return root != -1;
}

-----
bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) 
    // Your code here
}

************************************
Question ID: 1276

std::pair<int, int> closestFactors(int num) {
    int factor1 = std::sqrt(num + 2);
    while (true) {
        int factor2 = (num + 2) / factor1;
        if (factor1 * factor2 == num + 2) {
            return std::make_pair(factor1, factor2);
        }
        factor2 = (num + 1) / factor1;
        if (factor1 * factor2 == num + 1) {
            return std::make_pair(factor1, factor2);
        }
        factor1--;
    }
}

-----
std::pair<int, int> closestFactors(int num) 
    // Your code here
}

************************************
Question ID: 1277

#include <vector>
#include <algorithm>
#include <string>

std::string largestMultipleOfThree(std::vector<int>& digits) {
    int sum = 0, count[3] = {0};
    
    for (int d : digits) {
        sum += d;
        count[d % 3]++;
    }

    if (sum % 3 == 1) {
        if (count[1] >= 1) count[1]--; 
        else count[2] -= 2;
    }
    else if (sum % 3 == 2) {
        if (count[2] >= 1) count[2]--;
        else count[1] -= 2;
    }

    std::string res = "";
    for (int i = 0; i <= 9; ++i) {
        int n = count[i % 3];
        while (n--) res += std::to_string(i);
    }

    if (!res.empty() && res.back() == '0') return "0";
    std::reverse(res.begin(), res.end());
    return res;
}

-----
#include <vector>
#include <algorithm>
#include <string>

std::string largestMultipleOfThree(std::vector<int>& digits) 
    // Your code here
}

************************************
Question ID: 1278

#include <string>
#include <vector>

int palindromePartition(std::string s, int k) {
    int n = s.size();
    std::vector<std::vector<int>> dp(n, std::vector<int>(n, 0));

    for (int len = 2; len <= n; ++len) {
        for (int i = 0; i <= n - len; ++i) {
            int j = i + len - 1;
            dp[i][j] = dp[i + 1][j - 1] + (s[i] != s[j]);
        }
    }

    std::vector<int> memo(n, 1e9);
    for (int i = 0; i < n; ++i) {
        if (dp[0][i] == 0) {
            memo[i] = 0;
        } else {
            for (int j = 0; j < i; ++j) {
                memo[i] = std::min(memo[i], memo[j] + dp[j + 1][i]);
            }
        }
    }

    return memo.back() + k;
}

-----
#include <string>
#include <vector>

int palindromePartition(std::string s, int k) 
    // Your code here
}

************************************
Question ID: 1281

#include <vector>
#include <string>

std::vector<bool> canMakePaliQueries(std::string s, std::vector<std::vector<int>>& queries) {
    std::vector<bool> result;
    for (auto& query : queries) {
        int left = query[0], right = query[1], k = query[2];
        int count[26] = {0};
        for (int i = left; i <= right; i++) {
            count[s[i] - 'a']++;
        }
        int odd_count = 0;
        for (int i = 0; i < 26; i++) {
            odd_count += count[i] % 2;
        }
        result.push_back(odd_count / 2 <= k);
    }
    return result;
}

-----
#include <vector>
#include <string>

std::vector<bool> canMakePaliQueries(std::string s, std::vector<std::vector<int>>& queries) 
    // Your code here
}

************************************
Question ID: 1282

#include <vector>
#include <unordered_map>

std::vector<std::vector<int>> groupThePeople(std::vector<int>& groupSizes) {
    std::unordered_map<int, std::vector<int>> groups;
    std::vector<std::vector<int>> result;
    
    for (int i = 0; i < groupSizes.size(); i++) {
        groups[groupSizes[i]].push_back(i);
        if (groups[groupSizes[i]].size() == groupSizes[i]) {
            result.push_back(groups[groupSizes[i]]);
            groups[groupSizes[i]].clear();
        }
    }
    
    return result;
}

-----
#include <vector>
#include <unordered_map>

std::vector<std::vector<int>> groupThePeople(std::vector<int>& groupSizes) 
    // Your code here
}

************************************
Question ID: 1283

#include <iostream>
#include <sstream>
#include <unordered_map>

std::string format_date(const std::string &date) {
    std::unordered_map<std::string, std::string> months = {
        {"Jan", "01"},
        {"Feb", "02"},
        {"Mar", "03"},
        {"Apr", "04"},
        {"May", "05"},
        {"Jun", "06"},
        {"Jul", "07"},
        {"Aug", "08"},
        {"Sep", "09"},
        {"Oct", "10"},
        {"Nov", "11"},
        {"Dec", "12"},
    };

    std::stringstream ss(date);
    std::string day, month, year;
    ss >> day >> month >> year;
    return year + "-" + months[month] + "-" + day;
}

-----
#include <iostream>
#include <sstream>
#include <unordered_map>

std::string format_date(const std::string &date) 
    // Your code here
}

************************************
Question ID: 1284

int sum_of_divisors_with_four_divisors(const std::vector<int>& nums) {
    int sum = 0;
    for (int num : nums) {
        int div_count = 0;
        int div_sum = 0;

        for (int i = 1; i * i <= num; ++i) {
            if (num % i == 0) {
                div_sum += i;
                ++div_count;

                if (num / i != i) {
                    div_sum += (num / i);
                    ++div_count;
                }
            }

            if (div_count > 4) {
                break;
            }
        }

        if (div_count == 4) {
            sum += div_sum;
        }
    }

    return sum;
}

-----
int sum_of_divisors_with_four_divisors(const std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1286

int maxSumSubsequence(vector<int>& nums, int k) {
    int n = nums.size();
    vector<int> dp(n, 0);
    int result = 0;

    for (int i = 0; i < n; ++i) {
        dp[i] = nums[i];
        for (int j = max(0, i - k); j < i; ++j) {
            dp[i] = max(dp[i], dp[j] + nums[i]);
        }
        result = max(result, dp[i]);
    }

    return result;
}

-----
int maxSumSubsequence(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 1287

int shortestDistance(vector<int>& distance, int start, int destination) {
    int total_distance = 0, clockwise_distance = 0;
    
    for (int i = 0; i < distance.size(); ++i) {
        total_distance += distance[i];
        if (i >= start && i < destination) {
            clockwise_distance += distance[i];
        }
    }
    
    return min(clockwise_distance, total_distance - clockwise_distance);
}

-----
int shortestDistance(vector<int>& distance, int start, int destination) 
    // Your code here
}

************************************
Question ID: 1288

int maximumSum(vector<int>& arr) {
    int n = arr.size();
    vector<int> sum_without_deletion(n), sum_with_deletion(n);
    sum_without_deletion[0] = arr[0];
    sum_with_deletion[0] = 0;
    int max_sum = arr[0];

    for (int i = 1; i < n; i++) {
        sum_without_deletion[i] = max(arr[i], sum_without_deletion[i - 1] + arr[i]);
        sum_with_deletion[i] = max(sum_with_deletion[i - 1] + arr[i], sum_without_deletion[i - 1]);
        max_sum = max(max_sum, max(sum_without_deletion[i], sum_with_deletion[i]));
    }
    return max_sum;
}

-----
int maximumSum(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1289

#include <array>
#include <string>

std::string dayOfTheWeek(int day, int month, int year) {
    std::array<std::string, 7> days = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
    if (month < 3) {
        month += 12;
        year -= 1;
    }
    int k = year % 100;
    int j = year / 100;
    int dayOfWeek = (day + 13 * (month + 1) / 5 + k + k / 4 + 5 * j + j / 4) % 7;
    return days[dayOfWeek];
}

-----
#include <array>
#include <string>

std::string dayOfTheWeek(int day, int month, int year) 
    // Your code here
}

************************************
Question ID: 1290

#include <vector>
#include <limits>

int minOperations(std::vector<int>& arr1, std::vector<int>& arr2) {
    int n = arr1.size();
    std::vector<int> dp(n, std::numeric_limits<int>::max());
    for (int a : arr2) {
        std::vector<int> new_dp(n, std::numeric_limits<int>::max());
        int p = 0;
        for (int i = 0; i < n; ++i) {
            if (a < arr1[i]) new_dp[i] = p;
            if (i > 0 && dp[i - 1] < p) p = dp[i - 1];
            if (arr1[i] > arr1[i + 1]) return -1;
        }
        dp.swap(new_dp);
    }
    return dp.back();
}

-----
#include <vector>
#include <limits>

int minOperations(std::vector<int>& arr1, std::vector<int>& arr2) 
    // Your code here
}

************************************
Question ID: 1291

#include <vector>

std::vector<int> sequentialDigits(int low, int high) {
    std::vector<int> result;
    for (int i = 1; i <= 9; ++i) {
        int number = i;
        for (int j = i + 1; j <= 9; ++j) {
            number = number * 10 + j;
            if (number >= low && number <= high) {
                result.push_back(number);
            }
        }
    }
    std::sort(result.begin(), result.end());
    return result;
}

-----
#include <vector>

std::vector<int> sequentialDigits(int low, int high) 
    // Your code here
}

************************************
Question ID: 1292

int maxSideLength(vector<vector<int>>& mat, int threshold) {
    int m = mat.size(), n = mat[0].size();
    vector<vector<int>> preSum(m + 1, vector<int>(n + 1));
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            preSum[i][j] = mat[i-1][j-1] + preSum[i-1][j] + preSum[i][j-1] - preSum[i-1][j-1];
        }
    }

    int maxSide = 0;
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            for (int k = 1; k <= min(m, n); ++k) {
                int endX = i + k - 1, endY = j + k - 1;
                if (endX <= m && endY <= n) {
                    int sum = preSum[endX][endY] - preSum[endX][j - 1] - preSum[i - 1][endY] + preSum[i - 1][j - 1];
                    if (sum <= threshold) {
                        maxSide = max(maxSide, k);
                    }
                } else {
                    break;
                }
            }
        }
    }
    return maxSide;
}


-----
int maxSideLength(vector<vector<int>>& mat, int threshold) 
    // Your code here
}


************************************
Question ID: 1293

#include <vector>
#include <queue>

int shortestPath(std::vector<std::vector<int>>& grid, int k) {
    int m = grid.size();
    int n = grid[0].size();
    std::vector<std::vector<std::vector<int>>> visited(m, std::vector<std::vector<int>>(n, std::vector<int>(k + 1, 0)));
    std::queue<std::tuple<int, int, int, int>> q;
    int steps = 0;
    int moves[][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    q.push({0, 0, 0, k});

    while (!q.empty()) {
        int q_size = q.size();
        for (int i = 0; i < q_size; ++i) {
            int x, y, steps, k_remaining;
            std::tie(x, y, steps, k_remaining) = q.front();
            q.pop();
            if (x == m - 1 && y == n - 1) return steps;

            for (const auto& move : moves) {
                int new_x = x + move[0];
                int new_y = y + move[1];
                if (new_x >= 0 && new_x < m && new_y >= 0 && new_y < n) {
                    int new_k_remaining = k_remaining - grid[new_x][new_y];
                    if (new_k_remaining >= 0 && !visited[new_x][new_y][new_k_remaining]) {
                        visited[new_x][new_y][new_k_remaining] = 1;
                        q.push({new_x, new_y, steps + 1, new_k_remaining});
                    }
                }
            }
        }
    }

    return -1;
}

-----
#include <vector>
#include <queue>

int shortestPath(std::vector<std::vector<int>>& grid, int k) 
    // Your code here
}

************************************
Question ID: 1295

int min_perimeter(int neededApples) {
    int layer = 0;
    int apples = 0;

    while (apples < neededApples) {
        layer++;
        apples += 12 * layer;
    }

    return 8 * layer;
}

-----
int min_perimeter(int neededApples) 
    // Your code here
}

************************************
Question ID: 1297

int maxNumberOfBalloons(string text) {
    int freqs[26] = {0};
    for (char c : text) {
        freqs[c - 'a']++;
    }
    int subs[5] = {freqs['b' - 'a'], freqs['a' - 'a'], freqs['l' - 'a'] / 2, freqs['o' - 'a'] / 2, freqs['n' - 'a']};
    return *min_element(subs, subs + 5);
}


-----
int maxNumberOfBalloons(string text) 
    // Your code here
}


************************************
Question ID: 1298

#include <stack>
#include <string>

std::string reverseParentheses(std::string s) {
    std::stack<char> st;
    std::string result = "";

    for (char c : s) {
        if (c != ')') {
            st.push(c);
        } else {
            std::string temp = "";
            while (!st.empty() && st.top() != '(') {
                temp += st.top();
                st.pop();
            }
            if (!st.empty()) st.pop(); // Remove '('
            for (char t : temp) {
                st.push(t);
            }
        }
    }

    while (!st.empty()) {
        result = st.top() + result;
        st.pop();
    }

    return result;
}


-----
#include <stack>
#include <string>

std::string reverseParentheses(std::string s) 
    // Your code here
}


************************************
Question ID: 1299

int kConcatenationMaxSum(vector<int>& arr, int k) {
    int M = 1e9 + 7;
    long long sum = 0, maxSum = 0, curMax = 0;
    for (int i = 0; i < arr.size(); i++) {
        sum += arr[i];
        curMax = max(arr[i], curMax + arr[i]);
        maxSum = max(maxSum, curMax);
    }
    if (k == 1) return maxSum % M;
    long long twoConcatenation = 0, twoConcatenationMax = 0;
    for (int i = 0; i < 2 * arr.size(); i++) {
        twoConcatenation = max((long long)arr[i % arr.size()], twoConcatenation + arr[i % arr.size()]);
        twoConcatenationMax = max(twoConcatenationMax, twoConcatenation);
    }
    return max({maxSum, twoConcatenationMax + (k - 2) * max(0LL, sum)}) % M;
}

-----
int kConcatenationMaxSum(vector<int>& arr, int k) 
    // Your code here
}

************************************
Question ID: 1300

#include <vector>

using namespace std;

vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {
    vector<vector<int>> graph(n);
    for (const auto& conn : connections) {
        graph[conn[0]].push_back(conn[1]);
        graph[conn[1]].push_back(conn[0]);
    }

    vector<vector<int>> ans;
    vector<int> low(n, -1), disc(n, -1);
    int time = 0;

    function<void(int, int)> dfs = [&](int u, int parent) {
        low[u] = disc[u] = time++;
        for (int v : graph[u]) {
            if (v == parent) continue;
            if (disc[v] == -1) {
                dfs(v, u);
                low[u] = min(low[u], low[v]);
                if (low[v] > disc[u])
                    ans.push_back({u, v});
            } else {
                low[u] = min(low[u], disc[v]);
            }
        }
    };

    dfs(0, -1);
    return ans;
}

-----
#include <vector>

using namespace std;

vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) 
    // Your code here
}

************************************
Question ID: 1301

#include <vector>
#include <string>
using namespace std;
const int MOD = 1000000007;

vector<int> pathsWithMaxScore(vector<string>& board) {
    int n = board.size();
    vector<vector<int>> dp(n, vector<int>(n, 0)), cnt(n, vector<int>(n, 0));
    
    board[0][0] = '0';
    board[n-1][n-1] = '0';
    cnt[n-1][n-1] = 1;
    
    for (int i = n-1; i >= 0; i--) {
        for (int j = n-1; j >= 0; j--) {
            if (board[i][j] != 'X') {
                vector<pair<int, int>> neighbors = {{i-1, j}, {i, j-1}, {i-1, j-1}};
                for (auto neighbor : neighbors) {
                    int x = neighbor.first, y = neighbor.second;
                    if(x>=0 && y>=0) {
                        if (dp[i][j] < dp[x][y] + board[i][j] - '0') {
                            dp[i][j] = dp[x][y] + board[i][j] - '0';
                            cnt[i][j] = cnt[x][y];
                        } else if (dp[i][j] == dp[x][y] + board[i][j] - '0') {
                            cnt[i][j] = (cnt[i][j] + cnt[x][y]) % MOD;
                        }
                    }
                }
            }
        }
    }
    
    return {dp[0][0], cnt[0][0]};
}


-----
#include <vector>
#include <string>
using namespace std;
const int MOD = 1000000007;

vector<int> pathsWithMaxScore(vector<string>& board) 
    // Your code here
}


************************************
Question ID: 1302

#include <string>

std::string makeFancyString(const std::string& s) {
    std::string result;
    int count = 1;

    for (size_t i = 1; i < s.size(); ++i) {
        if (s[i] == s[i - 1]) {
            ++count;
        } else {
            count = 1;
        }
        if (count < 3) {
            result += s[i];
        }
    }

    return result;
}


-----
#include <string>

std::string makeFancyString(const std::string& s) 
    // Your code here
}


************************************
Question ID: 1304

#include <string>
#include <queue>

std::string longestHappyString(int a, int b, int c) {
    std::string res;
    using CharCount = std::pair<int, char>;
    std::priority_queue<CharCount> pq;
    
    if (a) pq.push({a, 'a'});
    if (b) pq.push({b, 'b'});
    if (c) pq.push({c, 'c'});

    while (!pq.empty()) {
        auto curr = pq.top(); pq.pop();
        if (res.size() >= 2 && res[res.size() - 1] == curr.second && res[res.size() - 2] == curr.second) {
            if (pq.empty()) break;
            auto next = pq.top(); pq.pop();
            res += next.second;
            if (--next.first > 0) pq.push(next);
            pq.push(curr);
        } else {
            res += curr.second;
            if (--curr.first > 0) pq.push(curr);
        }
    }

    return res;
}


-----
#include <string>
#include <queue>

std::string longestHappyString(int a, int b, int c) 
    // Your code here
}


************************************
Question ID: 1305

#include <vector>
#include <stack>

std::vector<int> peopleCanSee(std::vector<int>& heights) {
    int n = heights.size();
    std::vector<int> ans(n, 0);
    std::stack<int> st;

    for (int i = n - 1; i >= 0; --i) {
        while (!st.empty() && heights[st.top()] < heights[i]) {
            int idx = st.top();
            st.pop();
            ans[i]++;
            ans[i] += ans[idx];
        }
        st.push(i);
    }

    return ans;
}


-----
#include <vector>
#include <stack>

std::vector<int> peopleCanSee(std::vector<int>& heights) 
    // Your code here
}


************************************
Question ID: 1306

#include<vector>
#include<algorithm>
using namespace std;

vector<vector<int>> minimumAbsDifference(vector<int>& arr) {
    sort(arr.begin(), arr.end());
    int min_difference = INT_MAX;
    vector<vector<int>> result;

    for (int i = 1; i < arr.size(); ++i) {
        int difference = arr[i] - arr[i - 1];
        if (difference < min_difference) {
            min_difference = difference;
            result.clear();
            result.push_back({arr[i - 1], arr[i]});
        } else if (difference == min_difference) {
            result.push_back({arr[i - 1], arr[i]});
        }
    }

    return result;
}

-----
#include<vector>
#include<algorithm>
using namespace std;

vector<vector<int>> minimumAbsDifference(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1307

#include <algorithm>

int nthUglyNumber(int n, int a1, int a2, int a3) {
    long long a = a1, b = a2, c = a3;
    long long ab = a * b / std::__gcd(a, b);
    long long ac = a * c / std::__gcd(a, c);
    long long bc = b * c / std::__gcd(b, c);
    long long abc = a * bc / std::__gcd(a, bc);

    long long left = 0, right = 2e9;
    while (left < right) {
        long long mid = left + (right - left) / 2;
        long long cnt = mid / a + mid / b + mid / c - mid / ab - mid / ac - mid / bc + mid / abc;
        if (cnt < n) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}

-----
#include <algorithm>

int nthUglyNumber(int n, int a1, int a2, int a3) 
    // Your code here
}

************************************
Question ID: 1309

#include <vector>
#include <algorithm>

std::vector<int> sortItems(int n, int m, std::vector<int>& group, std::vector<std::vector<int>>& beforeItems) {
    // Calculate outdegrees and dependencies for groups and items
    std::vector<int> groupOutdegree(m, 0);
    std::vector<std::vector<int>> groupEdges(m);
    std::vector<int> itemOutdegree(n, 0);
    std::vector<std::vector<int>> itemEdges(n);

    for (int i = 0; i < group.size(); ++i) {
        for (const int dep : beforeItems[i]) {
            int a = group[i], b = group[dep];
            if (a != -1 && a != b && !groupEdges[b].empty() && groupEdges[b].back() == a) {
                groupEdges[b].push_back(a);
                ++groupOutdegree[a];
            }
            if (a != b) {
                itemEdges[dep].push_back(i);
                ++itemOutdegree[i];
            }
        }
    }

    // Topological sort
    auto topologicalSort = [](const std::vector<int>& outdegree, const std::vector<std::vector<int>>& edges) {
        std::vector<int> res, q;
        for (int i = 0; i < outdegree.size(); ++i)
            if (outdegree[i] == 0)
                q.push_back(i);

        while (!q.empty()) {
            int u = q.back();
            q.pop_back();
            res.push_back(u);

            for (const int v : edges[u])
                if (--const_cast<int&>(outdegree[v]) == 0)
                    q.push_back(v);
        }
        return res;
    };

    std::vector<int> groupOrder = topologicalSort(groupOutdegree, groupEdges);
    if (groupOrder.size() < m)
        return {};

    std::vector<int> itemOrder = topologicalSort(itemOutdegree, itemEdges);
    if (itemOrder.size() < n)
        return {};

    // Combine orders
    std::vector<int> res;
    for (const int gi : groupOrder)
        for (const int idx : itemOrder)
            if (group[idx] == gi)
                res.push_back(idx);

    return res;
}


-----
#include <vector>
#include <algorithm>

std::vector<int> sortItems(int n, int m, std::vector<int>& group, std::vector<std::vector<int>>& beforeItems) 
    // Your code here
}


************************************
Question ID: 1310

int waterPlants(vector<int> &plants, int capacity) {
    int steps = 0;
    int water_left = 0;
    for (int i = 0; i < plants.size(); ++i) {
        if (water_left < plants[i]) {
            steps += 2 * i + 1; // Refill the watering can
            water_left = capacity;
        }
        water_left -= plants[i];
        steps++; // Move to the next plant
    }
    return steps;
}


-----
int waterPlants(vector<int> &plants, int capacity) 
    // Your code here
}


************************************
Question ID: 1311

int largestMagicSquare(vector<vector<int>>& grid) {
    int m = grid.size(), n = grid[0].size();
    vector<vector<int>> row(m, vector<int>(n + 1, 0));
    vector<vector<int>> col(m + 1, vector<int>(n, 0));
    
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            row[i][j + 1] = row[i][j] + grid[i][j];
            col[i + 1][j] = col[i][j] + grid[i][j];
        }
    }
    
    for (int k = min(m, n); k > 1; --k) {
        for (int i = 0; i + k - 1 < m; ++i) {
            for (int j = 0; j + k - 1 < n; ++j) {
                int sum = row[i][j + k] - row[i][j];
                bool ok = true;
                for (int t = 1; t < k; ++t) {
                    if (row[i + t][j + k] - row[i + t][j] != sum) {
                        ok = false;
                        break;
                    }
                    if (col[i + k][j + t] - col[i][j + t] != sum) {
                        ok = false;
                        break;
                    }
                }
                if (!ok) continue;
                
                int diag1 = 0, diag2 = 0;
                for (int t = 0; t < k; ++t) {
                    diag1 += grid[i + t][j + t];
                    diag2 += grid[i + t][j + k - 1 - t];
                }
                if (diag1 == sum && diag2 == sum) return k;
            }
        }
    }
    
    return 1;
}


-----
int largestMagicSquare(vector<vector<int>>& grid) 
    // Your code here
}


************************************
Question ID: 1312

int extractArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {
    unordered_map<int, set<pair<int, int>>> artifact_cells;
    unordered_map<int, int> artifact_count;
    for (int i = 0; i < artifacts.size(); i++) {
        for (int r = artifacts[i][0]; r <= artifacts[i][2]; r++) {
            for (int c = artifacts[i][1]; c <= artifacts[i][3]; c++) {
                artifact_cells[r * n + c].insert({i, r * n + c});
                artifact_count[i]++;
            }
        }
    }
    
    int ans = 0;
    for (const auto& d : dig) {
        int cell = d[0] * n + d[1];
        for (const auto& p : artifact_cells[cell]) {
            artifact_count[p.first]--;
            if (artifact_count[p.first] == 0) ans++;
        }
        artifact_cells.erase(cell);
    }
    return ans;
}

-----
int extractArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) 
    // Your code here
}

************************************
Question ID: 1313

#include <vector>
using namespace std;

const int MOD = 1e9 + 7;

int addRooms(int idx, const vector<vector<int>>& children, vector<int>& memo) {
    if (children[idx].empty()) return 1;
    
    if (memo[idx] != -1) return memo[idx];
    
    long long res = 1;
    int cnt = 0;
    for (int child : children[idx]) {
        cnt++;
        res = (res * addRooms(child, children, memo)) % MOD;
    }
    
    for (int i = 2; i <= cnt; i++) {
        res = (res * i) % MOD;
    }
    
    return memo[idx] = res;
}

int numOfWays(vector<int>& prevRoom) {
    int n = prevRoom.size();
    vector<vector<int>> children(n);
    for (int i = 1; i < n; i++) {
        children[prevRoom[i]].push_back(i);
    }
    
    vector<int> memo(n, -1);
    return addRooms(0, children, memo);
}

-----
#include <vector>
using namespace std;

const int MOD = 1e9 + 7;

int addRooms(int idx, const vector<vector<int>>& children, vector<int>& memo) 
    // Your code here
}

************************************
Question ID: 1314

#include <vector>
using namespace std;

vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {
    int m = mat.size();
    int n = mat[0].size();
    vector<vector<int>> answer(m, vector<int>(n, 0));

    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            for (int r = max(0, i - k); r <= min(m - 1, i + k); ++r) {
                for (int c = max(0, j - k); c <= min(n - 1, j + k); ++c) {
                    answer[i][j] += mat[r][c];
                }
            }
        }
    }

    return answer;
}

-----
#include <vector>
using namespace std;

vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) 
    // Your code here
}

************************************
Question ID: 1317

std::vector<int> noZeroIntegers(int n) {
    for (int a = 1; a < n; ++a) {
        if (std::to_string(a).find('0') == std::string::npos &&
            std::to_string(n - a).find('0') == std::string::npos) {
            return {a, n - a};
        }
    }
    return {0, 0}; // never gets here
}

-----
std::vector<int> noZeroIntegers(int n) 
    // Your code here
}

************************************
Question ID: 1318

int minFlips(int a, int b, int c) {
    int count = 0;
    for (int i = 0; i < 32; ++i) {
        int bitA = (a >> i) & 1;
        int bitB = (b >> i) & 1;
        int bitC = (c >> i) & 1;
        if (bitC == 0) {
            count += bitA + bitB;
        } else {
            count += 1 - (bitA | bitB);
        }
    }
    return count;
}

-----
int minFlips(int a, int b, int c) 
    // Your code here
}

************************************
Question ID: 1319

#include <map>
#include <unordered_set>
using namespace std;

bool uniqueOccurrences(vector<int>& arr) {
    map<int, int> counts;
    for (int num : arr) {
        counts[num]++;
    }
    
    unordered_set<int> unique_counts;
    for (auto& count : counts) {
        if (unique_counts.count(count.second) > 0) {
            return false;
        }
        unique_counts.insert(count.second);
    }
    
    return true;
}

-----
#include <map>
#include <unordered_set>
using namespace std;

bool uniqueOccurrences(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1320

#include <string>
#include <stack>

std::string removeDuplicates(std::string s, int k) {
    std::stack<std::pair<char, int>> st;
    for (char c : s) {
        if (!st.empty() && st.top().first == c) {
            st.top().second++;
            if (st.top().second == k) st.pop();
        } else {
            st.push({c, 1});
        }
    }
    std::string result = "";
    while (!st.empty()) {
        result = std::string(st.top().second, st.top().first) + result;
        st.pop();
    }
    return result;
}

-----
#include <string>
#include <stack>

std::string removeDuplicates(std::string s, int k) 
    // Your code here
}

************************************
Question ID: 1323

int maximum69Number (int num) {
    string numStr = to_string(num);
    for (char &c : numStr) {
        if (c == '6') {
            c = '9';
            break;
        }
    }
    return stoi(numStr);
}

-----
int maximum69Number (int num) 
    // Your code here
}

************************************
Question ID: 1324

vector<int> findBall(vector<vector<int>>& grid) {
    int m = grid.size();
    int n = grid[0].size();
    vector<int> result(n, -1);

    for (int i = 0; i < n; i++) {
        int x = 0, y = i;

        while (x < m) {
            int nx = x + 1, ny = y + grid[x][y];
            if (ny < 0 || ny >= n || grid[x][ny] != grid[x][y]) break;
            x = nx;
            y = ny;
        }

        if (x == m) {
            result[i] = y;
        }
    }

    return result;
}


-----
vector<int> findBall(vector<vector<int>>& grid) 
    // Your code here
}


************************************
Question ID: 1325

#include <vector>
#include <queue>
using namespace std;

double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {
    vector<vector<pair<int, double>>> graph(n);
    for (int i = 0; i < edges.size(); ++i) {
        graph[edges[i][0]].emplace_back(edges[i][1], succProb[i]);
        graph[edges[i][1]].emplace_back(edges[i][0], succProb[i]);
    }

    vector<double> maxProb(n, 0);
    maxProb[start] = 1;

    priority_queue<pair<double, int>> pq;
    pq.emplace(1, start);

    while (!pq.empty()) {
        double prob = pq.top().first;
        int node = pq.top().second;
        pq.pop();

        if (node == end) {
            return prob;
        }

        if (prob < maxProb[node]) {
            continue;
        }

        for (auto& edge : graph[node]) {
            double newProb = prob * edge.second;
            if (newProb > maxProb[edge.first]) {
                maxProb[edge.first] = newProb;
                pq.emplace(newProb, edge.first);
            }
        }
    }

    return 0;
}


-----
#include <vector>
#include <queue>
using namespace std;

double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) 
    // Your code here
}


************************************
Question ID: 1326

#include <vector>

int sumOfFlooredPairs(std::vector<int>& nums) {
    int mod = 1e9 + 7;
    int maxVal = *max_element(nums.begin(), nums.end());
    std::vector<int> count(maxVal + 1, 0);
    std::vector<long long> prefSum(maxVal + 1, 0);

    for (int num : nums) {
        count[num]++;
    }

    for (int i = 1; i <= maxVal; i++) {
        prefSum[i] = (prefSum[i - 1] + count[i]) % mod;
    }

    long long res = 0;
    for (int x = 1; x <= maxVal; x++) {
        for (int k = 1, nx = x; nx <= maxVal; k++, nx += x) {
            res = (res + ((prefSum[nx] - prefSum[nx - x] + mod) % mod) * k % mod * count[x] % mod) % mod;
        }
    }
    return res;
}

-----
#include <vector>

int sumOfFlooredPairs(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1328

#include <string>

std::string breakPalindrome(std::string palindrome) {
    int length = palindrome.length();
    if (length == 1) return "";
    
    for (int i = 0; i < length / 2; i++) {
        if (palindrome[i] != 'a') {
            palindrome[i] = 'a';
            return palindrome;
        }
    }
    
    palindrome[length - 1] = 'b';
    return palindrome;
}

-----
#include <string>

std::string breakPalindrome(std::string palindrome) 
    // Your code here
}

************************************
Question ID: 1329

int minCostToMoveChips(vector<int>& position) {
    int evenCount = 0, oddCount = 0;
    for (int i : position) {
        if (i % 2 == 0)
            evenCount++;
        else
            oddCount++;
    }
    return min(evenCount, oddCount);
}

-----
int minCostToMoveChips(vector<int>& position) 
    // Your code here
}

************************************
Question ID: 1330

int longestSubsequence(vector<int>& arr, int difference) {
    unordered_map<int, int> dp;
    int maxLength = 0;
    for (int num : arr) {
        dp[num] = dp[num - difference] + 1;
        maxLength = max(maxLength, dp[num]);
    }
    return maxLength;
}


-----
int longestSubsequence(vector<int>& arr, int difference) 
    // Your code here
}


************************************
Question ID: 1331

#include <vector>
#include <algorithm>
using namespace std;

int getMaximumGoldHelper(vector<vector<int>> &grid, int x, int y, int m, int n) {
    if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0) return 0;

    int originalGold = grid[x][y];
    grid[x][y] = 0;

    int maxGold = 0;
    maxGold = max(maxGold, getMaximumGoldHelper(grid, x + 1, y, m, n));
    maxGold = max(maxGold, getMaximumGoldHelper(grid, x - 1, y, m, n));
    maxGold = max(maxGold, getMaximumGoldHelper(grid, x, y + 1, m, n));
    maxGold = max(maxGold, getMaximumGoldHelper(grid, x, y - 1, m, n));

    grid[x][y] = originalGold;
    return maxGold + originalGold;
}

int getMaximumGold(vector<vector<int>>& grid) {
    int m = grid.size(), n = grid[0].size(), maxGold = 0;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] != 0) {
                maxGold = max(maxGold, getMaximumGoldHelper(grid, i, j, m, n));
            }
        }
    }
    return maxGold;
}


-----
#include <vector>
#include <algorithm>
using namespace std;

int getMaximumGoldHelper(vector<vector<int>> &grid, int x, int y, int m, int n) 
    // Your code here
}


************************************
Question ID: 1332

int countStrings(int n) {
    const int mod = 1e9 + 7;
    long long a = 1, b = 1;
    for (int i = 0; i < n; ++i) {
        a = (a * 2) % mod;
        b = (b * 3) % mod;
    }
    return (b - a + mod) % mod;
}


-----
int countStrings(int n) 
    // Your code here
}


************************************
Question ID: 1333

#include <vector>
#include <algorithm>

std::vector<int> sortBasedOnMapping(std::vector<int>& mapping, std::vector<int>& nums) {
    std::sort(nums.begin(), nums.end(), [&](int a, int b) {
        std::string aStr = std::to_string(a);
        std::string bStr = std::to_string(b);
        for (char &c : aStr) c = '0' + mapping[c - '0'];
        for (char &c : bStr) c = '0' + mapping[c - '0'];
        return aStr < bStr;
    });
    return nums;
}

-----
#include <vector>
#include <algorithm>

std::vector<int> sortBasedOnMapping(std::vector<int>& mapping, std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1334

#include <vector>
#include <limits>

int findTheCity(int n, std::vector<std::vector<int>>& edges, int distanceThreshold) {
    std::vector<std::vector<int>> distance(n, std::vector<int>(n, 1e5));
    for (const auto& edge : edges) {
        distance[edge[0]][edge[1]] = edge[2];
        distance[edge[1]][edge[0]] = edge[2];
    }

    for (int i = 0; i < n; i++) distance[i][i] = 0;

    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                distance[i][j] = std::min(distance[i][j], distance[i][k] + distance[k][j]);
            }
        }
    }

    int res = 0, minReachable = n;
    for (int i = 0; i < n; i++) {
        int reachable = 0;
        for (int j = 0; j < n; j++) {
            if (distance[i][j] <= distanceThreshold) reachable++;
        }
        if (reachable <= minReachable) {
            minReachable = reachable;
            res = i;
        }
    }
    return res;
}


-----
#include <vector>
#include <limits>

int findTheCity(int n, std::vector<std::vector<int>>& edges, int distanceThreshold) 
    // Your code here
}


************************************
Question ID: 1335

#include <vector>
#include <algorithm>

int maxCandies(const std::vector<int>& candies, int k) {
    int left = 1;
    int right = *std::max_element(candies.begin(), candies.end());
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        int count = 0;
        for (int candy : candies) {
            count += candy / mid;
        }
        if (count >= k) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return right;
}

-----
#include <vector>
#include <algorithm>

int maxCandies(const std::vector<int>& candies, int k) 
    // Your code here
}

************************************
Question ID: 1337

#include <vector>
#include <algorithm>

using namespace std;

vector<int> kWeakestRows(vector<vector<int>>& mat, int k) {
    vector<pair<int, int>> soldiersCount;

    for (int i = 0; i < mat.size(); ++i) {
        int cnt = count(mat[i].begin(), mat[i].end(), 1);
        soldiersCount.push_back({cnt, i});
    }
    
    sort(soldiersCount.begin(), soldiersCount.end());
    vector<int> result(k);
    for (int i = 0; i < k; ++i) {
        result[i] = soldiersCount[i].second;
    }
    return result;
}

-----
#include <vector>
#include <algorithm>

using namespace std;

vector<int> kWeakestRows(vector<vector<int>>& mat, int k) 
    // Your code here
}

************************************
Question ID: 1338

#include <vector>
#include <unordered_map>
#include <queue>
using namespace std;

int minSetSize(vector<int>& arr) {
    unordered_map<int, int> freq_map;
    priority_queue<int> max_heap;
    for (int x : arr)
        freq_map[x]++;
    for (auto &[_, cnt] : freq_map)
        max_heap.push(cnt);
    int half = arr.size() / 2;
    int cnt = 0;
    int size = 0;
    while (size < half) {
        size += max_heap.top();
        max_heap.pop();
        cnt++;
    }
    return cnt;
}

-----
#include <vector>
#include <unordered_map>
#include <queue>
using namespace std;

int minSetSize(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1340

#include <mutex>
#include <condition_variable>

class DiningPhilosophers {
    std::mutex forks[5];
    std::condition_variable not_busy[5];

public:
    void wantsToEat(int philosopher,
                    std::function<void()> pickLeftFork,
                    std::function<void()> pickRightFork,
                    std::function<void()> eat,
                    std::function<void()> putLeftFork,
                    std::function<void()> putRightFork) {
        int left_fork = philosopher;
        int right_fork = (philosopher + 1) % 5;

        {
            std::unique_lock<std::mutex> lock(forks[left_fork]);
            not_busy[left_fork].wait(lock, [&] { return !forks[right_fork].try_lock(); });
            pickLeftFork();

            std::unique_lock<std::mutex> right_lock(forks[right_fork], std::adopt_lock);
            pickRightFork();
            eat();

            putRightFork();
            right_lock.unlock();
            not_busy[right_fork].notify_all();
        }

        putLeftFork();
        not_busy[left_fork].notify_all();
    }
};

-----
#include <mutex>
#include <condition_variable>

class DiningPhilosophers 
    // Your code here
};

************************************
Question ID: 1342

#include <vector>

std::vector<std::vector<int>> queensAttacktheKing(std::vector<std::vector<int>>& queens, std::vector<int>& king) {
    std::vector<std::vector<int>> result;
    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            if (x == 0 && y == 0) continue;
            int posX = king[0] + x;
            int posY = king[1] + y;
            while (posX >= 0 && posY >= 0 && posX < 8 && posY < 8) {
                for (std::vector<int>& queen : queens) {
                    if (posX == queen[0] && posY == queen[1]) {
                        result.push_back({queen[0], queen[1]});
                        break;
                    }
                }
                posX += x;
                posY += y;
            }
        }
    }
    return result;
}

-----
#include <vector>

std::vector<std::vector<int>> queensAttacktheKing(std::vector<std::vector<int>>& queens, std::vector<int>& king) 
    // Your code here
}

************************************
Question ID: 1343

#include <vector>

const int MOD = 1000000007;

int dieSimulator(int n, std::vector<int>& rollMax) {
    std::vector<std::vector<int>> dp(6, std::vector<int>(n + 1, 0));
    std::vector<int> sum(n + 1, 0);

    for (int i = 0; i < 6; i++) dp[i][1] = 1;
    sum[1] = 6;

    for (int j = 2; j <= n; j++) {
        int cur_sum = 0;
        for (int i = 0; i < 6; i++) {
            dp[i][j] = sum[j - 1];
            if (j - rollMax[i] - 1 >= 0) {
                dp[i][j] = (dp[i][j] - sum[j - rollMax[i] - 1] + MOD) % MOD;
                if (j - rollMax[i] - 1 >= 1) {
                    dp[i][j] = (dp[i][j] + dp[i][j - rollMax[i] - 1]) % MOD;
                }
            }
            cur_sum = (cur_sum + dp[i][j]) % MOD;
        }
        sum[j] = cur_sum;
    }

    return sum[n];
}

-----
#include <vector>

const int MOD = 1000000007;

int dieSimulator(int n, std::vector<int>& rollMax) 
    // Your code here
}

************************************
Question ID: 1344

int maxEqualFreq(vector<int>& nums) {
    unordered_map<int, int> count, freq;
    int max_len = 0, max_freq = 0;
    for (int i = 0; i < nums.size(); i++) {
        count[nums[i]]++;
        freq[count[nums[i]] - 1]--;
        freq[count[nums[i]]]++;

        max_freq = max(max_freq, count[nums[i]]);
        if (max_freq * (i + 1) == i || max_freq * (freq[max_freq - 1] + 1) + (max_freq - 1) * freq[max_freq - 1] == i) {
            max_len = i + 1;
        }
    }
    return max_len;
}


-----
int maxEqualFreq(vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 1345

#include <vector>
#include <queue>
#include <unordered_map>

int minJumps(std::vector<int>& arr) {
    int n = arr.size();
    if (n <= 1) return 0;
    
    std::unordered_map<int, std::vector<int>> value_indices;
    for (int i = 0; i < n; ++i) {
        value_indices[arr[i]].push_back(i);
    }
    
    std::queue<int> q;
    std::vector<bool> visited(n, false);
    
    q.push(0);
    visited[0] = true;
    int steps = 0;
    
    while (!q.empty()) {
        int size = q.size();
        
        for (int i = 0; i < size; ++i) {
            int index = q.front();
            q.pop();
            
            if (index == n - 1) return steps;
            
            if (index > 0 && !visited[index - 1]) {
                q.push(index - 1);
                visited[index - 1] = true;
            }
            
            if (index < n - 1 && !visited[index + 1]) {
                q.push(index + 1);
                visited[index + 1] = true;
            }
            
            for (int neighbor : value_indices[arr[index]]) {
                if (!visited[neighbor]) {
                    q.push(neighbor);
                    visited[neighbor] = true;
                }
            }
            
            value_indices[arr[index]].clear();
        }
        
        ++steps;
    }
    
    return -1;
}

-----
#include <vector>
#include <queue>
#include <unordered_map>

int minJumps(std::vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1346

int maxValueInStack(vector<int>& nums, int k) {
    int n = nums.size();
    if (k >= n) return -1;

    int max_val = INT_MIN;
    for (int i = 0; i <= k; ++i) {
        max_val = max(max_val, nums[i]);
    }
    return max_val;
}

-----
int maxValueInStack(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 1347

int minSteps(string s, string t) {
    vector<int> s_Count(26, 0);
    vector<int> t_Count(26, 0);
    for(char c : s) s_Count[c - 'a']++;
    for(char c : t) t_Count[c - 'a']++;
    int res = 0;
    for(int i = 0; i < 26; i++) {
        res += abs(s_Count[i] - t_Count[i]);
    }
    return res / 2;
}

-----
int minSteps(string s, string t) 
    // Your code here
}

************************************
Question ID: 1348

#include <unordered_map>
#include <map>
#include <vector>
#include <string>

using namespace std;

class TweetCounts {
public:
    TweetCounts() {}

    void recordTweet(string tweetName, int time) {
        data[tweetName][time]++;
    }

    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {
        int step = (freq == "minute") ? 60 : (freq == "hour") ? 3600 : 86400;
        vector<int> chunks((endTime - startTime) / step + 1, 0);

        if (data.count(tweetName)) {
            for (auto kvp : data[tweetName]) {
                int chunk_index = (kvp.first - startTime) / step;
                if (chunk_index >= 0 && chunk_index < chunks.size()) {
                    chunks[chunk_index] += kvp.second;
                }
            }
        }

        return chunks;
    }

private:
    unordered_map<string, map<int, int>> data;
};

-----
#include <unordered_map>
#include <map>
#include <vector>
#include <string>

using namespace std;

class TweetCounts 
    // Your code here
};

************************************
Question ID: 1349

#include <vector>
using namespace std;

bool checkStraightLine(vector<vector<int>>& coordinates) {
    int dx = coordinates[1][0] - coordinates[0][0];
    int dy = coordinates[1][1] - coordinates[0][1];

    for(int i = 2; i < coordinates.size(); ++i) {
        int x = coordinates[i][0] - coordinates[0][0];
        int y = coordinates[i][1] - coordinates[0][1];
        if(dx * y != dy * x) return false;
    }

    return true;
}

-----
#include <vector>
using namespace std;

bool checkStraightLine(vector<vector<int>>& coordinates) 
    // Your code here
}

************************************
Question ID: 1351

#include <string>
#include <unordered_map>
#include <algorithm>
using namespace std;

int balancedString(string s) {
    int n = s.size();
    unordered_map<char, int> freq_map;
    for (char c : s)
        freq_map[c]++;
    
    int i = 0, result = n;
    for (int j = 0; j < n; j++) {
        freq_map[s[j]]--;
        while (i < n && freq_map['Q'] <= n / 4 && freq_map['W'] <= n / 4 && freq_map['E'] <= n / 4 && freq_map['R'] <= n / 4) {
            result = min(result, j - i + 1);
            freq_map[s[i]]++;
            i++;
        }
    }
    return result;
}

-----
#include <string>
#include <unordered_map>
#include <algorithm>
using namespace std;

int balancedString(string s) 
    // Your code here
}

************************************
Question ID: 1352

#include <vector>
#include <algorithm>

using namespace std;

struct Job {
    int start;
    int end;
    int profit;
};

int findNextJob(vector<Job>& jobs, int i) {
    for (int j = i + 1; j < jobs.size(); j++) {
        if (jobs[j].start >= jobs[i].end) {
            return j;
        }
    }
    return -1;
}

int maxProfitHelper(vector<Job>& jobs, vector<int>& memo, int i) {
    if (i == -1) return 0;
    if (memo[i] != -1) return memo[i];
    
    int nextJob = findNextJob(jobs, i);
    int inclCurrJob = jobs[i].profit + maxProfitHelper(jobs, memo, nextJob);
    int exclCurrJob = maxProfitHelper(jobs, memo, i - 1);
    
    memo[i] = max(inclCurrJob, exclCurrJob);
    return memo[i];
}

int maxProfit(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {
    int n = startTime.size();
    vector<Job> jobs(n);

    for (int i = 0; i < n; i++) {
        jobs[i] = {startTime[i], endTime[i], profit[i]};
    }

    sort(jobs.begin(), jobs.end(), [](const Job& a, const Job& b) {
        return a.end < b.end;
    });
    
    vector<int> memo(n, -1);
    return maxProfitHelper(jobs, memo, n - 1);
}

-----
#include <vector>
#include <algorithm>

using namespace std;

struct Job 
    // Your code here
}

************************************
Question ID: 1353

#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

bool compareEvents(const vector<int> &event1, const vector<int> &event2) {
    return event1[0] < event2[0];
}

int maxEvents(vector<vector<int>> &events) {
    sort(events.begin(), events.end(), compareEvents);
    priority_queue<int, vector<int>, greater<int>> minHeap;
    int eventCount = 0, day = 0;

    for (auto &event : events) {
        while (!minHeap.empty() && minHeap.top() < event[0]) {
            minHeap.pop();
        }
        minHeap.push(event[1]);
        eventCount++;
        day++;
    }

    return eventCount;
}


-----
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

bool compareEvents(const vector<int> &event1, const vector<int> &event2) 
    // Your code here
}


************************************
Question ID: 1354

#include <vector>
#include <set>
using namespace std;

vector<vector<int>> winnersAndLosers(vector<vector<int>>& matches) {
    set<int> winners, losers;
    for (vector<int> &match : matches) {
        winners.insert(match[0]);
        losers.insert(match[1]);
    }
    return {vector<int>(winners.begin(), winners.end()), vector<int>(losers.begin(), losers.end())};
}

-----
#include <vector>
#include <set>
using namespace std;

vector<vector<int>> winnersAndLosers(vector<vector<int>>& matches) 
    // Your code here
}

************************************
Question ID: 1356

#include <string>
using namespace std;

int min_moves_to_palindrome(string s) {
    int moves = 0;
    int left = 0, right = s.length() - 1;

    while (left < right) {
        if (s[left] != s[right]) {
            int temp_right = right;

            while (s[left] != s[temp_right]) {
                temp_right--;
            }
            s.erase(s.begin() + temp_right);
            s.insert(s.begin() + right, s[left]);
            moves += right - temp_right;
        }
        left++;
        right--;
    }

    return moves;
}

-----
#include <string>
using namespace std;

int min_moves_to_palindrome(string s) 
    // Your code here
}

************************************
Question ID: 1358

#include <vector>
#include <utility>

std::vector<std::pair<int, int>> find_pairs(int z) {
    std::vector<std::pair<int, int>> pairs;

    int f(int x, int y) {
        return x + y;
    }
    
    for (int x = 1; x <= z; x++) {
        for (int y = 1; y <= z; y++) {
            if (f(x, y) == z) {
                pairs.push_back(std::make_pair(x, y));
            }
        }
    }
    return pairs;
}

-----
#include <vector>
#include <utility>

std::vector<std::pair<int, int>> find_pairs(int z) 
    // Your code here
}

************************************
Question ID: 1359

#include <vector>

std::vector<int> circularPermutation(int n, int start) {
    std::vector<int> result(1 << n);
    for (int i = 0; i < (1 << n); ++i) {
        result[i] = start ^ (i ^ (i >> 1));
    }
    return result;
}


-----
#include <vector>

std::vector<int> circularPermutation(int n, int start) 
    // Your code here
}


************************************
Question ID: 1360

#include <vector>
#include <string>
#include <algorithm>

int maxLength(std::vector<std::string>& arr) {
    std::vector<std::string> dp = {""};

    int maxLen = 0;
    for (std::string s : arr) {
        if (std::unordered_set<char>(s.begin(), s.end()).size() < s.size()) continue;
        for (int i = dp.size() - 1; i >= 0; --i) {
            std::string tmp = dp[i] + s;
            if (std::unordered_set<char>(tmp.begin(), tmp.end()).size() == tmp.size()) {
                dp.push_back(tmp);
                maxLen = std::max(maxLen, (int)tmp.size());
            }
        }
    }
    
    return maxLen;
}

-----
#include <vector>
#include <string>
#include <algorithm>

int maxLength(std::vector<std::string>& arr) 
    // Your code here
}

************************************
Question ID: 1361

int tilingRectangle(int n, int m) {
    if (n > m) std::swap(n, m);
    if (n == 1) return m;
    if (n == m) return 1;

    int res = INT_MAX;
    for (int a = 1; a <= n/2; ++a) {
        res = std::min(res, tilingRectangle(a, m) + tilingRectangle(n - a, m));
    }
    for (int b = 1; b <= m/2; ++b) {
        res = std::min(res, tilingRectangle(n, b) + tilingRectangle(n, m - b));
    }
    return res;
}


-----
int tilingRectangle(int n, int m) 
    // Your code here
}


************************************
Question ID: 1362

#include <vector>
#include <cmath>
std::vector<int> findClosestDivisors(int num) {
    for (int i = int(std::sqrt(num + 2)); i >= 1; i--) {
        if ((num + 1) % i == 0) return {i, (num + 1) / i};
        if ((num + 2) % i == 0) return {i, (num + 2) / i};
    }
    return {};
}

-----
#include <vector>
#include <cmath>
std::vector<int> findClosestDivisors(int num) 
    // Your code here
}

************************************
Question ID: 1363

#include <vector>
#include <string>
#include <algorithm>

std::string largestMultipleOfThree(std::vector<int>& digits) {
    std::sort(digits.rbegin(), digits.rend());
    int sum = 0;
    for (int digit : digits) {
        sum += digit;
    }

    if (sum % 3 == 0) {
        if (digits.back() == 0) return "0";
        std::string result(digits.begin(), digits.end());
        return result;
    }

    std::vector<int> mod[3];
    for (int digit : digits) {
        mod[digit % 3].push_back(digit);
    }

    if (sum % 3 == 1) {
        if (!mod[1].empty()) {
            mod[1].pop_back();
        } else {
            mod[2].pop_back();
            mod[2].pop_back();
        }
    } else {
        if (!mod[2].empty()) {
            mod[2].pop_back();
        } else {
            mod[1].pop_back();
            mod[1].pop_back();
        }
    }

    std::string result;
    for (int i = 0; i < 3; ++i) {
        for (int digit : mod[i]) {
            result += std::to_string(digit);
        }
    }

    std::sort(result.rbegin(), result.rend());
    if (result.empty() || result[0] == '0') {
        return "0";
    }
    
    return result;
}


-----
#include <vector>
#include <string>
#include <algorithm>

std::string largestMultipleOfThree(std::vector<int>& digits) 
    // Your code here
}


************************************
Question ID: 1365

#include <vector>
using namespace std;

vector<int> smallerNumbersThanCurrent(vector<int>& nums) {
    vector<int> result(nums.size());
    for (int i = 0; i < nums.size(); i++) {
        int count = 0;
        for (int j = 0; j < nums.size(); j++) {
            if (i != j && nums[j] < nums[i]) {
                count++;
            }
        }
        result[i] = count;
    }
    return result;
}

-----
#include <vector>
using namespace std;

vector<int> smallerNumbersThanCurrent(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1366

#include <algorithm>
#include <string>
#include <vector>

std::string rankTeams(std::vector<std::string>& votes) {
    int n = votes.size(), m = votes[0].size();
    std::vector<std::vector<int>> count(26, std::vector<int>(m, 0));
    std::string res = votes[0];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            count[votes[i][j] - 'A'][j]++;
        }
    }
    std::sort(res.begin(), res.end(), [&](char a, char b) {
        for (int i = 0; i < m; i++) {
            if (count[a - 'A'][i] != count[b - 'A'][i]) {
                return count[a - 'A'][i] > count[b - 'A'][i];
            }
        }
        return a < b;
    });

    return res;
}


-----
#include <algorithm>
#include <string>
#include <vector>

std::string rankTeams(std::vector<std::string>& votes) 
    // Your code here
}


************************************
Question ID: 1367

#include <vector>
#include <algorithm>

int maxHeight(std::vector<std::vector<int>>& cuboids) {
    for (auto& cuboid : cuboids)
        std::sort(cuboid.begin(), cuboid.end());

    std::sort(cuboids.begin(), cuboids.end());

    int n = cuboids.size();
    std::vector<int> dp(n);
    int ans = 0;

    for (int i = 0; i < n; i++) {
        dp[i] = cuboids[i][2];
        for (int j = 0; j < i; j++) {
            if (cuboids[j][0] <= cuboids[i][0] && cuboids[j][1] <= cuboids[i][1] && cuboids[j][2] <= cuboids[i][2]) {
                dp[i] = std::max(dp[i], dp[j] + cuboids[i][2]);
            }
        }
        ans = std::max(ans, dp[i]);
    }
    return ans;
}


-----
#include <vector>
#include <algorithm>

int maxHeight(std::vector<std::vector<int>>& cuboids) 
    // Your code here
}


************************************
Question ID: 1368

#include <vector>
#include <queue>
#include <utility>

using namespace std;

int minCost(vector<vector<int>>& grid) {
    int m = grid.size(), n = grid[0].size(), cost = 0;

    vector<vector<int>> visited(m, vector<int>(n, 1000000));
    queue<pair<int, int>> q;
    q.push({0, 0});
    visited[0][0] = 0;

    while (!q.empty()) {
        pair<int, int> curr = q.front();
        q.pop();
        int y = curr.first, x = curr.second;
        if (y == m - 1 && x == n - 1) {
            cost = visited[y][x];
            break;
        }

        int dx[4] = {1, 0, -1, 0};
        int dy[4] = {0, 1, 0, -1};

        for (int dir = 0; dir < 4; ++dir) {
            int newY = y + dy[dir], newX = x + dx[dir];
            if (0 <= newY && newY < m && 0 <= newX && newX < n) {
                int newCost = visited[y][x] + (dir + 1 != grid[y][x]);
                if (newCost < visited[newY][newX]) {
                    visited[newY][newX] = newCost;
                    q.push({newY, newX});
                }
            }
        }
    }
    return cost;
}

-----
#include <vector>
#include <queue>
#include <utility>

using namespace std;

int minCost(vector<vector<int>>& grid) 
    // Your code here
}

************************************
Question ID: 1370

int numberOfSubarrays(vector<int>& nums, int k) {
    int n = nums.size(), result = 0, count = 0;
    vector<int> oddCount(n + 1, 0);

    oddCount[0] = 1;
    for (int i = 0; i < n; i++) {
        count += nums[i] % 2;
        if (count >= k) result += oddCount[count - k];
        oddCount[count]++;
    }

    return result;
}

-----
int numberOfSubarrays(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 1371

#include <string>
#include <stack>

std::string minRemoveToMakeValid(const std::string &s) {
    std::stack<int> stk;
    std::string result = s;

    for (int i = 0; i < s.size(); i++) {
        if (s[i] == '(') {
            stk.push(i);
        } else if (s[i] == ')') {
            if (!stk.empty()) {
                stk.pop();
            } else {
                result[i] = '-';
            }
        }
    }

    while (!stk.empty()) {
        result[stk.top()] = '-';
        stk.pop();
    }

    result.erase(std::remove(result.begin(), result.end(), '-'), result.end());
    return result;
}


-----
#include <string>
#include <stack>

std::string minRemoveToMakeValid(const std::string &s) 
    // Your code here
}


************************************
Question ID: 1372

#include <vector>
using namespace std;

bool isGoodArray(vector<int>& nums) {
    int gcd = nums[0];
    for (int num : nums) {
        gcd = __gcd(gcd, num);
        if (gcd == 1) {
            return true;
        }
    }
    return gcd == 1;
}


-----
#include <vector>
using namespace std;

bool isGoodArray(vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 1374

#include <string>
using namespace std;

string generateTheString(int n) {
    string result(n, 'a');
    if (n % 2 == 0)
        result[n - 1] = 'b';
    return result;
}

-----
#include <string>
using namespace std;

string generateTheString(int n) 
    // Your code here
}

************************************
Question ID: 1375

#include <string>
#include <vector>

int findKthPalindrome(int k, int intLength) {
    int mid = (intLength + 1) / 2;
    int limit = pow(10, mid) - 1;

    for (int i = 0; i <= limit; i++) {
        std::string num = std::to_string(i);
        std::string rev(num.rbegin(), num.rend());
        if (intLength % 2 != 0)
            rev = rev.substr(1);
        num += rev;
        int palindrome = stoi(num);
        if (palindrome > 0)
            k--;
        if (k == 0)
            return palindrome;
    }
    return -1;
}

std::vector<int> palindromeQueries(std::vector<int> queries, int intLength) {
    std::vector<int> answer;
    for (int query : queries) {
        answer.push_back(findKthPalindrome(query, intLength));
    }
    return answer;
}


-----
#include <string>
#include <vector>

int findKthPalindrome(int k, int intLength) 
    // Your code here
}


************************************
Question ID: 1376

int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {
    vector<vector<int>> subordinates(n);
    for (int i = 0; i < n; ++i) {
        if (manager[i] != -1) {
            subordinates[manager[i]].push_back(i);
        }
    }
    return dfs(headID, subordinates, informTime);
}

int dfs(int employee, vector<vector<int>>& subordinates, vector<int>& informTime) {
    if (informTime[employee] == 0) {
        return 0;
    }
    int max_time = 0;
    for (int i : subordinates[employee]) {
        max_time = max(max_time, dfs(i, subordinates, informTime));
    }
    return max_time + informTime[employee];
}


-----
int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) 
    // Your code here
}


************************************
Question ID: 1377

#include <vector>
using namespace std;

void dfs(int node, int parent, int t, int target, vector<vector<int>>& graph, double prob, vector<double>& ans) {
    if (t == 0) {
        if(node == target) ans[0] += prob;
        return;
    }
    
    bool has_child = false;
    for(int i = 0; i < graph[node].size(); ++i) {
        if(graph[node][i] != parent) {
            has_child = true;
            dfs(graph[node][i], node, t - 1, target, graph, prob / (graph[node].size() - (node != 1)), ans);
        }
    }
    
    if(!has_child && node == target) ans[0] += prob;
}

double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {
    vector<vector<int>> graph(n + 1);
    for (int i = 0; i < n - 1; ++i) {
        int a = edges[i][0], b = edges[i][1];
        graph[a].push_back(b);
        graph[b].push_back(a);
    }
    
    vector<double> ans(1, 0.0);
    dfs(1, -1, t, target, graph, 1.0, ans);
    return ans[0];
}


-----
#include <vector>
using namespace std;

void dfs(int node, int parent, int t, int target, vector<vector<int>>& graph, double prob, vector<double>& ans) 
    // Your code here
}


************************************
Question ID: 1379

#include <vector>
using namespace std;

vector<vector<int>> reconstructMatrix(int upper, int lower, vector<int>& colsum) {
    vector<vector<int>> result(2, vector<int>(colsum.size(), 0));
    
    for (int i = 0; i < colsum.size(); i++) {
        if (colsum[i] == 2) {
            result[0][i] = 1;
            result[1][i] = 1;
            upper--;
            lower--;
        } else if (colsum[i] == 1) {
            if (upper > lower) {
                result[0][i] = 1;
                upper--;
            } else {
                result[1][i] = 1;
                lower--;
            }
        }
        
        if (upper < 0 || lower < 0) {
            return {};
        }
    }
    
    if (upper > 0 || lower > 0) {
        return {};
    }
    
    return result;
}

-----
#include <vector>
using namespace std;

vector<vector<int>> reconstructMatrix(int upper, int lower, vector<int>& colsum) 
    // Your code here
}

************************************
Question ID: 1380

int dx[] = {-1, 1, 0, 0};
int dy[] = {0, 0, -1, 1};

void dfs(vector<vector<int>>& grid, int x, int y) {
    int n = grid.size(), m = grid[0].size();
    grid[x][y] = 1;
    for (int i = 0; i < 4; i++) {
        int nx = x + dx[i], ny = y + dy[i];
        if (nx >= 0 && nx < n && ny >= 0 && ny < m && grid[nx][ny] == 0) {
            dfs(grid, nx, ny);
        }
    }
}

int closedIsland(vector<vector<int>>& grid) {
    int n = grid.size(), m = grid[0].size();
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (i == 0 || i == n - 1 || j == 0 || j == m - 1) {
                if (grid[i][j] == 0) {
                    dfs(grid, i, j);
                }
            }
        }
    }
    int res = 0;
    for (int i = 1; i < n - 1; i++) {
        for (int j = 1; j < m - 1; j++) {
            if (grid[i][j] == 0) {
                dfs(grid, i, j);
                res++;
            }
        }
    }
    return res;
}


-----
int dx[] = 
    // Your code here
}


************************************
Question ID: 1381

#include <vector>
#include <string>

int getMaxScore(const std::string& word, const std::vector<int>& score) {
    int sum = 0;
    for (char c : word) {
        sum += score[c - 'a'];
    }
    return sum;
}

int getMaxScoreHelper(const std::vector<std::string>& words, const std::vector<int>& score,
                      std::string letters, int i) {
    if (i == words.size()) {
        return 0;
    }
    int withoutCurrentWord = getMaxScoreHelper(words, score, letters, i + 1);
    for (char c : words[i]) {
        if (--letters[c - 'a'] < 0) {
            break;
        }
    }
    int withCurrentWord = getMaxScore(words[i], score) + getMaxScoreHelper(words, score, letters, i + 1);
    return std::max(withCurrentWord, withoutCurrentWord);
}

int maxScoreWords(std::vector<std::string>& words, std::string letters,
                  std::vector<int>& score) {
    return getMaxScoreHelper(words, score, letters, 0);
}
```
-----
#include <vector>
#include <string>

int getMaxScore(const std::string& word, const std::vector<int>& score) 
    // Your code here
}
```
************************************
Question ID: 1383

#include <vector>
#include <queue>
#include <algorithm>

int maxPerformance(int n, int k, std::vector<int>& speed, std::vector<int>& efficiency) {
    std::vector<std::pair<int, int>> engineers(n);
    for (int i = 0; i < n; ++i) {
        engineers[i] = {efficiency[i], speed[i]};
    }
    
    std::sort(engineers.rbegin(), engineers.rend());
    
    std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;
    
    long long speed_sum = 0;
    long long max_performance = 0;
    
    for (auto& engineer : engineers) {
        speed_sum += engineer.second;
        min_heap.push(engineer.second);
        
        if (min_heap.size() > k) {
            speed_sum -= min_heap.top();
            min_heap.pop();
        }
        
        max_performance = std::max(max_performance, speed_sum * engineer.first);
    }
    
    return max_performance % 1000000007;
}

-----
#include <vector>
#include <queue>
#include <algorithm>

int maxPerformance(int n, int k, std::vector<int>& speed, std::vector<int>& efficiency) 
    // Your code here
}

************************************
Question ID: 1385

int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {
    int distance = 0;
    for (int a : arr1) {
        bool found = true;
        for (int b : arr2) {
            if (abs(a - b) <= d) {
                found = false;
                break;
            }
        }
        if (found) distance++;
    }
    return distance;
}

-----
int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) 
    // Your code here
}

************************************
Question ID: 1386

#include <vector>
using namespace std;

vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {
    int m = grid.size(), n = grid[0].size();
    k %= (m * n);
    vector<vector<int>> res(m, vector<int>(n));
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            int idx = (i * n + j + k) % (m * n);
            res[idx / n][idx % n] = grid[i][j];
        }
    }
    return res;
}


-----
#include <vector>
using namespace std;

vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) 
    // Your code here
}


************************************
Question ID: 1388

int maxSumDivThree(vector<int>& nums) {
    vector<int> dp(3, 0);
    for (int num : nums) {
        vector<int> temp(dp);
        for (int s : temp) {
            dp[(s + num) % 3] = max(dp[(s + num) % 3], s + num);
        }
    }
    return dp[0];
}

-----
int maxSumDivThree(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1390

int sumOfFourDivisors(std::vector<int>& nums) {
    int sum = 0;
    for (int num : nums) {
        int count = 0;
        int div_sum = 0;
        for (int i = 1; i * i <= num; ++i) {
            if (num % i == 0) {
                count += (i * i == num) ? 1 : 2;
                div_sum += i + (num / i);
                if (count > 4) break;
            }
        }
        if (count == 4) sum += div_sum;
    }
    return sum;
}

-----
int sumOfFourDivisors(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1391

bool hasValidPath(vector<vector<int>>& grid) {
    int m = grid.size();
    int n = grid[0].size();

    vector<vector<int>> directions = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};
    vector<vector<int>> allowed = {{}, {0, 2}, {1, 3}, {0, 1}, {0, 3}, {1, 2}, {1, 0}};

    vector<vector<bool>> visited(m, vector<bool>(n, false));

    function<bool(int, int)> dfs = [&](int i, int j) -> bool {
        if (i == m - 1 && j == n - 1) return true;
        visited[i][j] = true;
        for (int dir : allowed[grid[i][j]]) {
            int x = i + directions[dir][0];
            int y = j + directions[dir][1];
            if (x >= 0 && y >= 0 && x < m && y < n && !visited[x][y] && find(allowed[grid[x][y]].begin(), allowed[grid[x][y]].end(), (dir + 2) % 4) != allowed[grid[x][y]].end()) {
                if (dfs(x, y)) return true;
            }
        }
        return false;
    };
    
    return dfs(0, 0);
}

-----
bool hasValidPath(vector<vector<int>>& grid) 
    // Your code here
}

************************************
Question ID: 1394

int findLucky(vector<int>& arr) {
    unordered_map<int, int> freq;
    for (int num : arr) {
        freq[num]++;
    }
    int maxLucky = -1;
    for (auto& pair : freq) {
        if (pair.first == pair.second) {
            maxLucky = max(maxLucky, pair.first);
        }
    }
    return maxLucky;
}

-----
int findLucky(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1395

#include <vector>
#include <cmath>

int minTimeToVisitAllPoints(std::vector<std::vector<int>>& points) {
    int time = 0;
    for(int i = 1; i < points.size(); ++i) {
        int dx = abs(points[i][0] - points[i-1][0]);
        int dy = abs(points[i][1] - points[i-1][1]);
        time += std::max(dx, dy);
    }
    return time;
}


-----
#include <vector>
#include <cmath>

int minTimeToVisitAllPoints(std::vector<std::vector<int>>& points) 
    // Your code here
}


************************************
Question ID: 1397

#include <vector>
#include <string>
#include <algorithm>

std::vector<std::vector<std::string>> suggestedProducts(std::vector<std::string>& products, std::string searchWord) {
    std::sort(products.begin(), products.end());
    
    std::vector<std::vector<std::string>> result;
    std::string currentPrefix;
    
    for (char letter : searchWord) {
        currentPrefix += letter;
        
        auto it = std::lower_bound(products.begin(), products.end(), currentPrefix);
        std::vector<std::string> suggestions;
        
        for (int i = 0; i < 3 && it != products.end() && it->substr(0, currentPrefix.size()) == currentPrefix; ++i) {
            suggestions.push_back(*it);
            ++it;
        }
        
        result.push_back(suggestions);
    }
    
    return result;
}

-----
#include <vector>
#include <string>
#include <algorithm>

std::vector<std::vector<std::string>> suggestedProducts(std::vector<std::string>& products, std::string searchWord) 
    // Your code here
}

************************************
Question ID: 1399

int countLargestGroup(int n) {
    std::vector<int> groups(37, 0);
    int largest_group_size = 0;
    int count_largest_groups = 0;
    
    for (int i = 1; i <= n; i++) {
        int sum = 0, num = i;
        while (num) {
            sum += num % 10;
            num /= 10;
        }
        groups[sum]++;
        if (groups[sum] > largest_group_size) {
            largest_group_size = groups[sum];
            count_largest_groups = 1;
        } else if (groups[sum] == largest_group_size) {
            count_largest_groups++;
        }
    }
    return count_largest_groups;
}

-----
int countLargestGroup(int n) 
    // Your code here
}

************************************
Question ID: 1400

#include <vector>
#include <string>

std::string tictactoe(std::vector<std::vector<int>>& moves) {
    int grid[3][3] = {0};
    int player = 1;
    for (const auto& move : moves) {
        grid[move[0]][move[1]] = player;
        if ((grid[0][move[1]] == player && grid[1][move[1]] == player && grid[2][move[1]] == player) ||
            (grid[move[0]][0] == player && grid[move[0]][1] == player && grid[move[0]][2] == player) ||
            (move[0] == move[1] && grid[0][0] == player && grid[1][1] == player && grid[2][2] == player) ||
            (move[0] + move[1] == 2 && grid[0][2] == player && grid[1][1] == player && grid[2][0] == player)) {
            return player == 1 ? "A" : "B";
        }
        player = 3 - player;
    }
    return moves.size() == 9 ? "Draw" : "Pending";
}


-----
#include <vector>
#include <string>

std::string tictactoe(std::vector<std::vector<int>>& moves) 
    // Your code here
}


************************************
Question ID: 1401

bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {
    int xClosest = std::max(x1, std::min(xCenter, x2));
    int yClosest = std::max(y1, std::min(yCenter, y2));
    return (xCenter - xClosest) * (xCenter - xClosest) + (yCenter - yClosest) * (yCenter - yClosest) <= radius * radius;
}

-----
bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) 
    // Your code here
}

************************************
Question ID: 1402

int countSquares(vector<vector<int>>& matrix) {
    int m = matrix.size(), n = matrix[0].size(), ans = 0;
    vector<vector<int>> dp(m, vector<int>(n, 0));
    for(int i = 0; i < m; i++) {
        for(int j = 0; j < n; j++) {
            if(i == 0 || j == 0) dp[i][j] = matrix[i][j];
            else if(matrix[i][j]) dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1;
            ans += dp[i][j];
        }
    }
    return ans;
}

-----
int countSquares(vector<vector<int>>& matrix) 
    // Your code here
}

************************************
Question ID: 1403

int min_changes_to_divide_string(const std::string& s, int k) {
    int n = s.length();
    if (n % k != 0) return -1;
    int chunk_count = n / k;
    int res = 0;
    for (int i = 0; i < k; ++i) {
        int counts[26] = {0};
        for (int j = i; j < n; j += k) {
            ++counts[s[j] - 'a'];
        }
        int max_count = *std::max_element(counts, counts + 26);
        res += chunk_count - max_count;
    }
    return res;
}

-----
int min_changes_to_divide_string(const std::string& s, int k) 
    // Your code here
}

************************************
Question ID: 1404

int num_steps(const std::string& s) {
    int steps = 0, carry = 0;
    for (int i = s.length() - 1; i > 0; --i) {
        int bit = s[i] - '0';
        if (bit && carry) {
            carry = 1;
            steps += 2;
        } else if (bit || carry) {
            carry ^= 1;
            steps += 2;
        } else {
            steps++;
        }
    }

    return steps + carry;
}

-----
int num_steps(const std::string& s) 
    // Your code here
}

************************************
Question ID: 1405

#include <algorithm>
#include <queue>
using namespace std;

string longestDiverseString(int a, int b, int c) {
    string result = "";
    using T = pair<int, char>;
    priority_queue<T> pq;
    if (a) pq.push({a, 'a'});
    if (b) pq.push({b, 'b'});
    if (c) pq.push({c, 'c'});
    
    while (!pq.empty()) {
        T first = pq.top(); pq.pop();
        if (!result.empty() && result.back() == first.second) {
            if (pq.empty()) break;
            T second = pq.top(); pq.pop();
            result += second.second;
            second.first--;
            if (second.first) pq.push(second);
            pq.push(first);
        } else {
            result += first.second;
            first.first--;
            if (first.first) pq.push(first);
        }
    }
    return result;
}

-----
#include <algorithm>
#include <queue>
using namespace std;

string longestDiverseString(int a, int b, int c) 
    // Your code here
}

************************************
Question ID: 1406

#include <vector>
#include <string>
using namespace std;

string stoneGameIII(vector<int>& stoneValue) {
    int n = stoneValue.size();
    vector<int> dp(n + 1, INT_MIN);
    dp[n] = 0;
    
    for (int i = n - 1; i >= 0; --i) {
        int curr = 0;
        for (int j = 0; j < 3 && i + j < n; ++j) {
            curr += stoneValue[i + j];
            dp[i] = max(dp[i], curr - dp[i + j + 1]);
        }
    }
    
    return dp[0] == 0 ? "Tie " : dp[0] > 0 ? "Alice " : "Bob ";
}


-----
#include <vector>
#include <string>
using namespace std;

string stoneGameIII(vector<int>& stoneValue) 
    // Your code here
}


************************************
Question ID: 1408

#include <cmath>
#include <vector>

int smallestDivisor(std::vector<int>& nums, int threshold) {
    int left = 1, right = 1e6;
    while (left < right) {
        int mid = (left + right) / 2;
        int sum = 0;
        for (int n : nums) {
            sum += std::ceil(1.0 * n / mid);
        }
        if (sum > threshold) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}

-----
#include <cmath>
#include <vector>

int smallestDivisor(std::vector<int>& nums, int threshold) 
    // Your code here
}

************************************
Question ID: 1409

#include <vector>
#include <queue>

int minNumberOfFlips(std::vector<std::vector<int>>& mat) {
    int m = mat.size(), n = mat[0].size();
    int steps = 0;
    int dirs[][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}, {0, 0}};

    auto encode = [&](int i, int j) { return i * n + j; };

    while (true) {
        int flipped = 0;
        std::queue<int> que;

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (mat[i][j] == 1) {
                    que.push(encode(i, j));
                }
            }
        }

        while (!que.empty()) {
            int cur = que.front(), cur_i = cur / n, cur_j = cur % n;
            que.pop();

            for (auto dir : dirs) {
                int ni = cur_i + dir[0], nj = cur_j + dir[1];
                if (ni >= 0 && ni < m && nj >= 0 && nj < n) {
                    mat[ni][nj] ^= 1;
                    ++flipped;
                }
            }
        }

        if (flipped == 0) {
            break;
        }
        steps += flipped;
    }

    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (mat[i][j] == 1) {
                return -1;
            }
        }
    }

    return steps;
}

-----
#include <vector>
#include <queue>

int minNumberOfFlips(std::vector<std::vector<int>>& mat) 
    // Your code here
}

************************************
Question ID: 1410

#include <string>
#include <unordered_map>

std::string entityParser(std::string text) {
    std::unordered_map<std::string, std::string> entities = {
        {"&quot;", "\""},
        {"&apos;", "'"},
        {"&amp;", "&"},
        {"&gt;", ">"},
        {"&lt;", "<"},
        {"&frasl;", "/"},
    };
    
    std::string result;
    std::string current_entity;
    bool in_entity = false;
    
    for (char c : text) {
        if (in_entity) {
            current_entity.push_back(c);
            if (c == ';') {
                if (entities.find(current_entity) != entities.end()) {
                    result += entities[current_entity];
                } else {
                    result += current_entity;
                }
                in_entity = false;
                current_entity.clear();
            }
        } else {
            if (c == '&') {
                in_entity = true;
                current_entity.push_back(c);
            } else {
                result.push_back(c);
            }
        }
    }
    
    return result;
}

-----
#include <string>
#include <unordered_map>

std::string entityParser(std::string text) 
    // Your code here
}

************************************
Question ID: 1413

int maxSideLength(vector<vector<int>>& mat, int threshold) {
    int m = mat.size();
    int n = mat[0].size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    int ans = 0;

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            dp[i][j] = mat[i-1][j-1] + dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1];
            int k = ans + 1;
            if (i >= k && j >= k && dp[i][j] - dp[i][j-k] - dp[i-k][j] + dp[i-k][j-k] <= threshold) {
                ans++;
            }
        }
    }
    return ans;
}

-----
int maxSideLength(vector<vector<int>>& mat, int threshold) 
    // Your code here
}

************************************
Question ID: 1414

#include <queue>
#include <vector>

int shortestPath(std::vector<std::vector<int>>& grid, int k) {
    int m = grid.size();
    int n = grid[0].size();
    std::queue<std::tuple<int, int, int, int>> q;
    q.push({0, 0, 0, k});
    std::vector<std::vector<std::vector<int>>> visited(m, std::vector<std::vector<int>>(n, std::vector<int>(k + 1, false)));

    while (!q.empty()) {
        auto [x, y, step, remain_k] = q.front();
        q.pop();

        if (x == m - 1 && y == n - 1) return step;
        if (visited[x][y][remain_k]) continue;
        visited[x][y][remain_k] = true;

        std::vector<std::vector<int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

        for (const auto &dir : directions) {
            int nx = x + dir[0];
            int ny = y + dir[1];

            if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                if (grid[nx][ny] == 1 && remain_k > 0) {
                    q.push({nx, ny, step + 1, remain_k - 1});
                } else if (grid[nx][ny] == 0) {
                    q.push({nx, ny, step + 1, remain_k});
                }
            }
        }
    }

    return -1;
}

-----
#include <queue>
#include <vector>

int shortestPath(std::vector<std::vector<int>>& grid, int k) 
    // Your code here
}

************************************
Question ID: 1416

#include <vector>
#include <string>

const int MOD = 1e9 + 7;

int numDecodings(std::string s, int k) {
    int n = s.size();
    std::vector<int> dp(n + 1, 0);
    dp[n] = 1;

    for (int i = n - 1; i >= 0; i--) {
        long num = 0;
        for (int j = i; j < n && num <= k; j++) {
            num = num * 10 + s[j] - '0';
            if (num >= 1 && num <= k) {
                dp[i] = (dp[i] + dp[j + 1]) % MOD;
            }
        }
    }
    return dp[0];
}

-----
#include <vector>
#include <string>

const int MOD = 1e9 + 7;

int numDecodings(std::string s, int k) 
    // Your code here
}

************************************
Question ID: 1417

#include <string>
#include <queue>

std::string reformat(std::string s) {
    std::queue<char> letters, digits;

    for (char c : s) {
        if (isalpha(c)) letters.push(c);
        else digits.push(c);
    }

    if (abs((int)(letters.size() - digits.size())) > 1) return "";

    std::string result = "";
    bool use_letter = letters.size() > digits.size();

    while (!letters.empty() || !digits.empty()) {
        if (use_letter) {
            result += letters.front();
            letters.pop();
        } else {
            result += digits.front();
            digits.pop();
        }
        use_letter = !use_letter;
    }

    return result;
}

-----
#include <string>
#include <queue>

std::string reformat(std::string s) 
    // Your code here
}

************************************
Question ID: 1418

#include <vector>
#include <string>
#include <map>
#include <set>
#include <algorithm>

std::vector<std::vector<std::string>> displayTable(std::vector<std::vector<std::string>>& orders) {
    std::map<int, std::map<std::string, int>> tables;
    std::set<std::string> foodSet;
    
    for (auto& order : orders) {
        int tableNumber = std::stoi(order[1]);
        std::string foodItem = order[2];
        tables[tableNumber][foodItem]++;
        foodSet.insert(foodItem);
    }

    std::vector<std::vector<std::string>> result;
    std::vector<std::string> header = {"Table"};
    header.insert(header.end(), foodSet.begin(), foodSet.end());
    result.push_back(header);

    for (auto& table : tables) {
        std::vector<std::string> row = {std::to_string(table.first)};
        for (const auto& foodItem : foodSet) {
            row.push_back(std::to_string(table.second[foodItem]));
        }
        result.push_back(row);
    }

    return result;
}

-----
#include <vector>
#include <string>
#include <map>
#include <set>
#include <algorithm>

std::vector<std::vector<std::string>> displayTable(std::vector<std::vector<std::string>>& orders) 
    // Your code here
}

************************************
Question ID: 1419

int minNumberOfFrogs(string croakOfFrogs) {
    int counter[5] = {0};
    int frogs = 0, max_frogs = 0;
    for (char ch : croakOfFrogs) {
        int idx = string("croak").find(ch);
        counter[idx]++;
        if (idx == 0) {
            max_frogs = max(max_frogs, ++frogs);
        } else if (--counter[idx - 1] < 0) {
            return -1;
        } else if (idx == 4) {
            frogs--;
        }
    }
    return (counter[0] == counter[1] && counter[1] == counter[2] && counter[2] == counter[3] && counter[3] == counter[4]) ? max_frogs : -1;
}

-----
int minNumberOfFrogs(string croakOfFrogs) 
    // Your code here
}

************************************
Question ID: 1420

#include <vector>
using namespace std;

int waysToBuildArray(int n, int m, int k) {
    const int mod = 1e9 + 7;
    vector<vector<int>> dp(n+1, vector<int>(k+1, 0));
    dp[0][0] = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= k; ++j) {
            for (int x = 1; x <= m; ++x) {
                if (j < i * (x-1)) {
                    dp[i][j] = (dp[i][j] + dp[i-1][j-(i-1)*(x-1)]) % mod;
                }
            }
        }
    }
    return dp[n][k];
}

-----
#include <vector>
using namespace std;

int waysToBuildArray(int n, int m, int k) 
    // Your code here
}

************************************
Question ID: 1422

#include <map>

bool isPossibleDivide(std::vector<int>& nums, int k) {
    std::map<int, int> counts;
    for (int num : nums) counts[num]++;
    
    for (auto it = counts.begin(); it != counts.end(); ++it) {
        if (it->second > 0) {
            for (int i = k - 1; i >= 0; --i) {
                if ((counts[it->first + i] -= it->second) < 0) return false;
            }
        }
    }
    
    return true;
}

-----
#include <map>

bool isPossibleDivide(std::vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 1423

#include <string>
#include <unordered_map>
#include <algorithm>
using namespace std;

int maxSubstringOccurrences(const string &s, int k) {
    int n = s.length(), res = 0;
    unordered_map<char, int> freq;
    for (int i = 0; i < n; ++i) {
        freq[s[i]]++;
        if (freq.size() <= k) {
            res = max(res, freq[s[i]]);
        }
    }
    return (freq.size() > k) ? 0 : res;
}


-----
#include <string>
#include <unordered_map>
#include <algorithm>
using namespace std;

int maxSubstringOccurrences(const string &s, int k) 
    // Your code here
}


************************************
Question ID: 1424

#include <vector>
#include <queue>
#include <unordered_set>

int maxCandies(std::vector<int>& status, std::vector<int>& candies, std::vector<std::vector<int>>& keys, std::vector<std::vector<int>>& containedBoxes, std::vector<int>& initialBoxes) {
    int max_candies = 0;
    std::unordered_set<int> visited;
    std::queue<int> to_process;
    
    for (int box : initialBoxes) {
        to_process.push(box);
    }
    
    while (!to_process.empty()) {
        int box = to_process.front();
        to_process.pop();
        
        if (visited.count(box)) {
            continue;
        }
        
        visited.insert(box);
        
        if (status[box] == 1) {
            max_candies += candies[box];
            for (int key : keys[box]) {
                status[key] = 1;
                if (visited.count(key)) {
                    to_process.push(key);
                }
            }
            for (int contained : containedBoxes[box]) {
                to_process.push(contained);
            }
        } else {
            to_process.push(box);
        }
    }

    return max_candies;
}

-----
#include <vector>
#include <queue>
#include <unordered_set>

int maxCandies(std::vector<int>& status, std::vector<int>& candies, std::vector<std::vector<int>>& keys, std::vector<std::vector<int>>& containedBoxes, std::vector<int>& initialBoxes) 
    // Your code here
}

************************************
Question ID: 1425

int maxSum(vector<int>& nums, int k) {
    int n = nums.size();
    priority_queue<int> pq;
    vector<long long> dp(n + 1, 0);
    long long sum = 0;

    for (int i = 0; i < n; ++i) {
        if (i >= k) pq.pop(); // Maintain the maximum size of k
        pq.push(dp[i] - nums[i]);
        dp[i + 1] = max(dp[i], nums[i] + pq.top());
        sum = max(sum, dp[i + 1]);
    }

    return sum;
}

-----
int maxSum(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 1426

#include <vector>

std::vector<int> sumZero(int n) {
    std::vector<int> res;
    for (int i = 1; i <= n / 2; i++) {
        res.push_back(i);
        res.push_back(-i);
    }
    if (n % 2 != 0) {
        res.push_back(0);
    }
    return res;
}

-----
#include <vector>

std::vector<int> sumZero(int n) 
    // Your code here
}

************************************
Question ID: 1428

bool canReach(vector<int> &arr, int start) {
    if (start >= 0 && start < arr.size() && arr[start] >= 0) {
        if (arr[start] == 0)
            return true;

        arr[start] = -arr[start];
        return canReach(arr, start + arr[start]) || canReach(arr, start - arr[start]);
    }
    return false;
}

-----
bool canReach(vector<int> &arr, int start) 
    // Your code here
}

************************************
Question ID: 1429

#include <map>
#include <string>

bool isSolvable(std::map<char, int> words, int result) {
    int sum = 0;
    for (auto const& word : words) {
        sum += word.second;
    }
    return sum % 10 == result % 10;
}

-----
#include <map>
#include <string>

bool isSolvable(std::map<char, int> words, int result) 
    // Your code here
}

************************************
Question ID: 1431

#include <vector>
#include <algorithm>
using namespace std;

void findAncestors(int node, vector<vector<int>>& adj_list, vector<bool>& visited, vector<int>& ans) {
    if (visited[node]) return;
    visited[node] = true;
    for (int ancestor : adj_list[node]) {
        ans.push_back(ancestor);
        findAncestors(ancestor, adj_list, visited, ans);
    }
}

vector<vector<int>> findAncestorsInDAG(int n, vector<vector<int>>& edges) {
    vector<vector<int>> adj_list(n), ans(n);
    for (vector<int>& edge : edges) {
        adj_list[edge[1]].push_back(edge[0]);
    }
    for (int i = 0; i < n; ++i) {
        vector<bool> visited(n, false);
        findAncestors(i, adj_list, visited, ans[i]);
        sort(ans[i].begin(), ans[i].end());
    }
    return ans;
}


-----
#include <vector>
#include <algorithm>
using namespace std;

void findAncestors(int node, vector<vector<int>>& adj_list, vector<bool>& visited, vector<int>& ans) 
    // Your code here
}


************************************
Question ID: 1432

int maxDiff(int num) {
    int a = -1, b = -1;
    string s = to_string(num);
    for (char c : s) {
        if (a == -1 && c != '9') {
            a = c - '0';
        }
        if (b == -1 && c > '1') {
            b = c - '0';
        }
        if (a != -1 && b != -1) {
            break;
        }
    }
    for (char& c : s) {
        if (c - '0' == a) {
            c = '9';
        } else if (c - '0' == b) {
            c = (s.front() == c) ? '1' : '0';
        }
    }
    return stoi(s) - num;
}


-----
int maxDiff(int num) 
    // Your code here
}


************************************
Question ID: 1434

#include <string>
using namespace std;

string freqAlphabets(string s) {
    string result = "";
    for (int i = 0; i < s.length(); i++) {
        if (i + 2 < s.length() && s[i + 2] == '#') {
            result += ('a' + (s[i] - '0') * 10 + (s[i + 1] - '0') - 10);
            i += 2;
        } else {
            result += ('a' + s[i] - '1');
        }
    }
    return result;
}

-----
#include <string>
using namespace std;

string freqAlphabets(string s) 
    // Your code here
}

************************************
Question ID: 1436

#include <vector>
#include <unordered_set>
#include <unordered_map>
#include <queue>
#include <algorithm>
#include <string>

using namespace std;

vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {
    unordered_set<int> visited;
    queue<pair<int, int>> q;
    unordered_map<string, int> video_freq;

    q.push({id, 0});
    visited.insert(id);

    while (!q.empty()) {
        int current_id = q.front().first;
        int current_level = q.front().second;
        q.pop();

        if (current_level == level) {
            for (const string& video : watchedVideos[current_id]) {
                video_freq[video]++;
            }
        } else if (current_level < level) {
            for (int friend_id : friends[current_id]) {
                if (visited.find(friend_id) == visited.end()) {
                    visited.insert(friend_id);
                    q.push({friend_id, current_level + 1});
                }
            }
        }
    }

    vector<string> result;
    for (const auto& p : video_freq) {
        result.push_back(p.first);
    }

    sort(result.begin(), result.end(), [&video_freq](const string& a, const string& b) {
        if (video_freq[a] == video_freq[b]) {
            return a < b;
        } else {
            return video_freq[a] < video_freq[b];
        }
    });

    return result;
}

-----
#include <vector>
#include <unordered_set>
#include <unordered_map>
#include <queue>
#include <algorithm>
#include <string>

using namespace std;

vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) 
    // Your code here
}

************************************
Question ID: 1437

int minStepsToMakePalindrome(std::string s) {
    int n = s.size();
    std::vector<std::vector<int>> dp(n, std::vector<int>(n, 0));

    for (int i = n - 2; i >= 0; i--) {
        for (int j = i + 1; j < n; j++) {
            if (s[i] == s[j]) {
                dp[i][j] = dp[i + 1][j - 1];
            } else {
                dp[i][j] = 1 + std::min(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }

    return dp[0][n - 1];
}

-----
int minStepsToMakePalindrome(std::string s) 
    // Your code here
}

************************************
Question ID: 1438

#include <deque>
int longestSubarray(vector<int>& nums, int limit) {
    deque<int> max_deque, min_deque;
    int left = 0, right = 0, longest = 0;
    while (right < nums.size()) {
        while (!max_deque.empty() && nums[right] > max_deque.back()) max_deque.pop_back();
        while (!min_deque.empty() && nums[right] < min_deque.back()) min_deque.pop_back();
        
        max_deque.push_back(nums[right]);
        min_deque.push_back(nums[right]);
        
        while (max_deque.front() - min_deque.front() > limit) {
            if (max_deque.front() == nums[left]) max_deque.pop_front();
            if (min_deque.front() == nums[left]) min_deque.pop_front();
            left++;
        }
        
        longest = max(longest, right - left + 1);
        right++;
    }
    return longest;
}

-----
#include <deque>
int longestSubarray(vector<int>& nums, int limit) 
    // Your code here
}

************************************
Question ID: 1439

#include <vector>
#include <queue>
using namespace std;

int kthSmallest(vector<vector<int>>& mat, int k) {
    int m = mat.size(), n = mat[0].size();
    priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> minHeap;
    minHeap.push({mat[0][0], 0, 0});

    vector<vector<bool>> visited(m, vector<bool>(n, false));
    visited[0][0] = true;
    int count = 0;

    while (!minHeap.empty()) {
        auto cur = minHeap.top();
        minHeap.pop();
        int sum = cur[0], row = cur[1], col = cur[2];

        count++;
        if (count == k) {
            return sum;
        }

        if (row + 1 < m && !visited[row + 1][col]) {
            visited[row + 1][col] = true;
            minHeap.push({sum - mat[row][col] + mat[row + 1][col], row + 1, col});
        }
        
        if (col + 1 < n && !visited[row][col + 1]) {
            visited[row][col + 1] = true;
            minHeap.push({sum - mat[row][col] + mat[row][col + 1], row, col + 1});
        }
    }
    
    return -1;
}

-----
#include <vector>
#include <queue>
using namespace std;

int kthSmallest(vector<vector<int>>& mat, int k) 
    // Your code here
}

************************************
Question ID: 1441

#include <vector>
#include <string>

std::vector<std::string> buildArray(std::vector<int>& target, int n) {
    std::vector<std::string> result;
    int current = 1;
    for (int num : target) {
        while (current < num) {
            result.push_back("Push ");
            result.push_back("Pop ");
            current++;
        }
        result.push_back("Push ");
        current++;
    }
    return result;
}

-----
#include <vector>
#include <string>

std::vector<std::string> buildArray(std::vector<int>& target, int n) 
    // Your code here
}

************************************
Question ID: 1442

#include <vector>

int makeConnected(int n, std::vector<std::vector<int>>& connections) {
    std::vector<std::vector<int>> adj_list(n);
    std::vector<bool> visited(n, false);
    int components = 0, extra_edges = 0;

    for (auto& connection : connections) {
        adj_list[connection[0]].push_back(connection[1]);
        adj_list[connection[1]].push_back(connection[0]);
    }

    for (int i = 0; i < n; ++i) {
        if (!visited[i]) {
            components++;
            std::vector<int> stack = {i};

            while (!stack.empty()) {
                int current = stack.back();
                stack.pop_back();

                if (!visited[current]) {
                    visited[current] = true;
                    for (int neighbor : adj_list[current]) {
                        if (!visited[neighbor]) {
                            stack.push_back(neighbor);
                        } else {
                            extra_edges++;
                        }
                    }
                }
            }
        }
    }

    int extra_needed = components - 1;

    if (extra_edges >= extra_needed) {
        return extra_needed;
    }

    return -1;
}


-----
#include <vector>

int makeConnected(int n, std::vector<std::vector<int>>& connections) 
    // Your code here
}


************************************
Question ID: 1443

#include<cstring>

int dp(int first, int second, int pos, const std::string& word) {
    if (pos == word.size()) return 0;
    
    int ans = 1e9;
    for (int i : { first, second }) {
        if (i != -1) {
            int dx = abs(word[pos] - word[i]) % 6, dy = abs(word[pos] - word[i]) / 6;
            ans = std::min(ans, min(dx, dy) * 2 + max(dx, dy));
        }
    }
    ans += dp(first, second, pos + 1, word);

    if (first == -1 || second == -1) {
        ans = std::min(ans, dp(first == -1 ? pos : first, word[pos], pos + 1, word));
    }

    return ans;
}

int minimum_distance(const std::string& word) {
    return dp(-1, -1, 0, word);
}


-----
#include<cstring>

int dp(int first, int second, int pos, const std::string& word) 
    // Your code here
}


************************************
Question ID: 1444

int numberOfSteps(int num) {
    int steps = 0;
    while (num) {
        steps += (num % 2 == 0) ? 1 : 2;
        num >>= 1;
    }
    return steps - 1;
}

-----
int numberOfSteps(int num) 
    // Your code here
}

************************************
Question ID: 1446

double angleClock(int hour, int minutes) {
    double minuteAngle = 6 * minutes;
    double hourAngle = 30 * hour + 0.5 * minutes;
    double angle = abs(hourAngle - minuteAngle);
    return min(angle, 360 - angle);
}

-----
double angleClock(int hour, int minutes) 
    // Your code here
}

************************************
Question ID: 1447

int minJumps(vector<int>& arr) {
    int n = arr.size();
    int maxReach = arr[0];
    int step = arr[0];
    int jumps = 1;

    if(n == 1) return 0;

    for(int i = 1; i < n; i++) {
        if(i == n - 1) return jumps;

        maxReach = max(maxReach, i + arr[i]);

        step--;

        if(step == 0) {
            jumps++;
            step = maxReach - i;
        }
    }
    return -1;
}

-----
int minJumps(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1448

int maximum69Number(int num) {
    string num_str = to_string(num);
    for (char &c : num_str) {
        if (c == '6') {
            c = '9';
            break;
        }
    }
    return stoi(num_str);
}

-----
int maximum69Number(int num) 
    // Your code here
}

************************************
Question ID: 1449

#include <string>
#include <vector>

std::string largestNumber(std::vector<int>& cost, int target) {
    std::vector<std::string> dp(target + 1, "");

    for (int i = 0; i < 9; ++i) {
        for (int j = cost[i]; j <= target; ++j) {
            if (dp[j - cost[i]].size() < j - cost[i] && dp[j - cost[i]].size() + 1 > dp[j].size()) {
                dp[j] = dp[j - cost[i]] + std::to_string(i + 1);
            }
        }
    }

    return dp[target].empty() ? "0" : dp[target];
}

-----
#include <string>
#include <vector>

std::string largestNumber(std::vector<int>& cost, int target) 
    // Your code here
}

************************************
Question ID: 1450

TreeNode* removeLeafNodes(TreeNode* root, int target) {
    if (!root) return nullptr;
    root->left = removeLeafNodes(root->left, target);
    root->right = removeLeafNodes(root->right, target);
    if (!root->left && !root->right && root->val == target) {
        return nullptr;
    }
    return root;
}


-----
TreeNode* removeLeafNodes(TreeNode* root, int target) 
    // Your code here
}


************************************
Question ID: 1451

#include <vector>
#include <algorithm>

int minTaps(int n, std::vector<int>& ranges) {
    std::vector<int> intervals(n + 1, 0);
    for (int i = 0; i <= n; ++i) {
        int left = std::max(0, i - ranges[i]);
        int right = std::min(n, i + ranges[i]);
        intervals[left] = std::max(intervals[left], right - left);
    }

    int position = 0, total_taps = 0, max_reach = 0;
    while (position < n) {
        max_reach = std::max(max_reach, position + intervals[position]);
        if (max_reach == position) return -1;
        position = max_reach;
        ++total_taps;
    }
    return total_taps;
}

-----
#include <vector>
#include <algorithm>

int minTaps(int n, std::vector<int>& ranges) 
    // Your code here
}

************************************
Question ID: 1452

#include <vector>
#include <string>
#include <set>
using namespace std;

vector<int> peopleIndexes(vector<vector<string>>& favoriteCompanies) {
    vector<int> result;
    vector<set<string>> companySets;
    
    for (const auto& companies : favoriteCompanies) {
        companySets.push_back(set<string>(companies.begin(), companies.end()));
    }
    
    for (int i = 0; i < companySets.size(); ++i) {
        bool isSubset = false;
        for (int j = 0; j < companySets.size(); ++j) {
            if (i != j && includes(companySets[j].begin(), companySets[j].end(),
                                    companySets[i].begin(), companySets[i].end())) {
                isSubset = true;
                break;
            }
        }
        if (!isSubset) result.push_back(i);
    }
    
    return result;
}

-----
#include <vector>
#include <string>
#include <set>
using namespace std;

vector<int> peopleIndexes(vector<vector<string>>& favoriteCompanies) 
    // Your code here
}

************************************
Question ID: 1453

#include <vector>
#include <cmath>

int numPoints(std::vector<std::vector<int>>& darts, int r) {
    int n = darts.size();
    int result = 1;
    
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            int cnt = 0;
            for (int k = 0; k < n; ++k) {
                int dx = darts[i][0] - darts[k][0];
                int dy = darts[i][1] - darts[k][1];
                if (sqrt(dx * dx + dy * dy) <= r) cnt++;
            }
            
            if (cnt > result) result = cnt;
        }
    }
    return result;
}

-----
#include <vector>
#include <cmath>

int numPoints(std::vector<std::vector<int>>& darts, int r) 
    // Your code here
}

************************************
Question ID: 1455

#include <vector>
#include <algorithm>

using namespace std;

bool customCompare(vector<int>& a, vector<int>& b) {
    if (a[1] == b[1]) return a[0] > b[0];
    return a[1] > b[1];
}

vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {
    vector<vector<int>> filteredRestaurants;
    for (auto& r : restaurants) {
        if ((veganFriendly == 0 || r[2] == veganFriendly) && r[3] <= maxPrice && r[4] <= maxDistance) {
            filteredRestaurants.push_back(r);
        }
    }
    sort(filteredRestaurants.begin(), filteredRestaurants.end(), customCompare);
    vector<int> ids;
    for (auto& r : filteredRestaurants) {
        ids.push_back(r[0]);
    }
    return ids;
}

-----
#include <vector>
#include <algorithm>

using namespace std;

bool customCompare(vector<int>& a, vector<int>& b) 
    // Your code here
}

************************************
Question ID: 1456

#include <vector>
#include <algorithm>
#include <limits>

int findTheCity(int n, std::vector<std::vector<int>>& edges, int distanceThreshold) {
    const int INF = std::numeric_limits<int>::max();
    std::vector<std::vector<int>> dist(n, std::vector<int>(n, INF));

    for (int i = 0; i < n; ++i) dist[i][i] = 0;

    for (const auto& edge : edges) {
        dist[edge[0]][edge[1]] = dist[edge[1]][edge[0]] = edge[2];
    }

    for (int k = 0; k < n; ++k) {
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                dist[i][j] = std::min(dist[i][j], dist[i][k] + dist[k][j]);
            }
        }
    }

    int res = -1, minReachable = n + 1;
    for (int i = 0; i < n; ++i) {
        int cnt = 0;
        for (const auto& d : dist[i]) {
            if (d <= distanceThreshold) ++cnt;
        }
        if (cnt <= minReachable) {
            minReachable = cnt;
            res = i;
        }
    }
    return res;
}


-----
#include <vector>
#include <algorithm>
#include <limits>

int findTheCity(int n, std::vector<std::vector<int>>& edges, int distanceThreshold) 
    // Your code here
}


************************************
Question ID: 1457

#include <vector>
#include <algorithm>
#include <limits.h>

int minDifficulty(std::vector<int>& jobDifficulty, int d) {
    int n = jobDifficulty.size();
    if (n < d) return -1;
    std::vector<std::vector<int>> dp(d, std::vector<int>(n, INT_MAX));
    
    dp[0][0] = jobDifficulty[0];
    for (int i = 1; i < n; ++i) {
        dp[0][i] = std::max(dp[0][i-1], jobDifficulty[i]);
    }

    for (int i = 1; i < d; ++i) {
        for (int j = i; j < n; ++j) {
            int maxD = jobDifficulty[j];
            for (int k = j; k >= i; --k) {
                maxD = std::max(maxD, jobDifficulty[k]);
                dp[i][j] = std::min(dp[i][j], dp[i-1][k-1] + maxD);
            }
        }
    }
    return dp[d-1][n-1];
}


-----
#include <vector>
#include <algorithm>
#include <limits.h>

int minDifficulty(std::vector<int>& jobDifficulty, int d) 
    // Your code here
}


************************************
Question ID: 1458

#include <algorithm>

bool compare(int a, int b) {
    int count_a = __builtin_popcount(a);
    int count_b = __builtin_popcount(b);
    
    if (count_a == count_b) {
        return a < b;
    }
    return count_a < count_b;
}

vector<int> sortByBits(vector<int>& arr) {
    sort(arr.begin(), arr.end(), compare);
    return arr;
}


-----
#include <algorithm>

bool compare(int a, int b) 
    // Your code here
}


************************************
Question ID: 1460

int numberOfSubstrings(string s) {
    int res = 0, i = 0;
    vector<int> count(3, 0);
    
    for (int j = 0; j < s.length(); j++) {
        count[s[j] - 'a']++;
        
        while(count[0] > 0 && count[1] > 0 && count[2] > 0) {
            count[s[i++] - 'a']--;
        }
        
        res += i;
    }
    
    return res;
}

-----
int numberOfSubstrings(string s) 
    // Your code here
}

************************************
Question ID: 1461

int countOrders(int n) {
    long long MOD = 1e9 + 7;
    long long ans = 1;
    for (int i = 1; i <= n; ++i) {
        ans = ans * (2 * i - 1) * i % MOD;
    }
    return ans;
}

-----
int countOrders(int n) 
    // Your code here
}

************************************
Question ID: 1462

#include <vector>
using namespace std;

vector<bool> checkIfPrerequisite(int numCourses, vector<vector<int>>& prerequisites, vector<vector<int>>& queries) {
    vector<vector<bool>> adj_matrix(numCourses, vector<bool>(numCourses, false));
    for (const auto& pre : prerequisites) {
        adj_matrix[pre[0]][pre[1]] = true;
    }
    
    for (int k = 0; k < numCourses; ++k) {
        for (int i = 0; i < numCourses; ++i) {
            for (int j = 0; j < numCourses; ++j) {
                adj_matrix[i][j] = adj_matrix[i][j] || (adj_matrix[i][k] && adj_matrix[k][j]);
            }
        }
    }

    vector<bool> answer;
    for (const auto& query : queries) {
        answer.push_back(adj_matrix[query[0]][query[1]]);
    }
    return answer;
}


-----
#include <vector>
using namespace std;

vector<bool> checkIfPrerequisite(int numCourses, vector<vector<int>>& prerequisites, vector<vector<int>>& queries) 
    // Your code here
}


************************************
Question ID: 1463

#include <vector>
#include <algorithm>
#include <utility>

using namespace std;

vector<int> kWeakestRows(vector<vector<int>>& mat, int k) {
    vector<pair<int, int>> soldier_row;
    for (int i = 0; i < mat.size(); ++i) {
        int soldiers = count(mat[i].begin(), mat[i].end(), 1);
        soldier_row.push_back({soldiers, i});
    }

    sort(soldier_row.begin(), soldier_row.end());
    
    vector<int> result;
    for (int i = 0; i < k; ++i) {
        result.push_back(soldier_row[i].second);
    }
    return result;
}


-----
#include <vector>
#include <algorithm>
#include <utility>

using namespace std;

vector<int> kWeakestRows(vector<vector<int>>& mat, int k) 
    // Your code here
}


************************************
Question ID: 1464

#include <unordered_map>
#include <vector>
#include <algorithm>

int minSetSize(std::vector<int>& arr) {
    std::unordered_map<int, int> count;
    for (auto value : arr)
        count[value]++;

    std::vector<int> freq;
    for (auto& entry : count)
        freq.push_back(entry.second);

    std::sort(freq.rbegin(), freq.rend());

    int removed = 0, setSize = 0;
    for (auto f : freq) {
        removed += f;
        setSize++;
        if (removed * 2 >= arr.size())
            return setSize;
    }

    return 0;
}


-----
#include <unordered_map>
#include <vector>
#include <algorithm>

int minSetSize(std::vector<int>& arr) 
    // Your code here
}


************************************
Question ID: 1466

#include <vector>

int maxJumps(std::vector<int>& arr, int d) {
    int n = arr.size();
    std::vector<int> dp(n, 1);
    
    auto helper = [&](auto &&self, int idx) -> int {
        if(dp[idx] > 1) return dp[idx];
        int maximum = 1;
        for(int i = 1; i <= d; i++) {
            if(idx + i < n && arr[idx] <= arr[idx + i]) break;
            if(idx + i < n)
                maximum = std::max(maximum, 1 + self(self, idx + i));

            if(idx - i >= 0 && arr[idx] <= arr[idx - i]) break;
            if(idx - i >= 0)
                maximum = std::max(maximum, 1 + self(self, idx - i));
        }
        return dp[idx] = maximum;
    };
    
    for(int i = 0; i < n; i++)
        helper(helper, i);
    
    return *std::max_element(dp.begin(), dp.end());
}


-----
#include <vector>

int maxJumps(std::vector<int>& arr, int d) 
    // Your code here
}


************************************
Question ID: 1467

#include <vector>

double factorial(int num) {
    double result = 1;
    for (int i = 1; i <= num; i++)
        result *= i;
    return result;
}

double countCombinations(std::vector<int>& balls, std::vector<int>& combinations, int currBall) {
    double totalCombinations = 1;
    for (int i = 0; i < currBall; i++)
        totalCombinations *= factorial(balls[i] + combinations[i]) / (factorial(balls[i]) * factorial(combinations[i]));

    return totalCombinations;
}

double dfs(std::vector<int>& balls, std::vector<int>& combinations, int currBall) {
    if (currBall == balls.size()) {
        if (combinations.back() == combinations.front())
            return countCombinations(balls, combinations, currBall);
        else
            return 0;
    }

    double result = 0;
    for (int i = 0; i <= balls[currBall]; i++) {
        combinations.push_back(i);
        result += dfs(balls, combinations, currBall + 1);
        combinations.pop_back();
    }

    return result;
}

double getProbability(std::vector<int>& balls) {
    int sumBalls = 0;
    for (int ball : balls)
        sumBalls += ball;

    double totalCombinations = 1;
    for (int ball : balls)
        totalCombinations *= factorial(ball);

    std::vector<int> combinations;
    return dfs(balls, combinations, 0) / totalCombinations;
}

-----
#include <vector>

double factorial(int num) 
    // Your code here
}

************************************
Question ID: 1469

#include <string>
#include <vector>
using namespace std;

int minSteps(string s, string t) {
    vector<int> countS(26, 0);
    vector<int> countT(26, 0);
    int steps = 0;

    for (char c : s) countS[c - 'a']++;
    for (char c : t) countT[c - 'a']++;

    for (int i = 0; i < 26; i++) {
        steps += abs(countS[i] - countT[i]);
    }

    return steps / 2;
}

-----
#include <string>
#include <vector>
using namespace std;

int minSteps(string s, string t) 
    // Your code here
}

************************************
Question ID: 1470

#include <unordered_map>
#include <vector>
#include <map>

class TweetCounts {
public:
    void recordTweet(string tweetName, int time) {
        tweetRecords[tweetName][time]++;
    }

    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {
        int interval;
        if(freq == "minute") interval = 60;
        else if(freq == "hour") interval = 3600;
        else interval = 86400;

        vector<int> result((endTime - startTime) / interval + 1);
        for(const auto &timeCount : tweetRecords[tweetName]) {
            int time = timeCount.first, count = timeCount.second;
            if(time >= startTime && time <= endTime) {
                result[(time - startTime) / interval] += count;
            }
        }

        return result;
    }

private:
    unordered_map<string, map<int, int>> tweetRecords;
};


-----
#include <unordered_map>
#include <vector>
#include <map>

class TweetCounts 
    // Your code here
};


************************************
Question ID: 1471

int maxStudents(vector<vector<char>>& seats) {
    int m = seats.size();
    int n = seats[0].size();
    vector<int> validRows(m);
    int max_valid = (1 << n) - 1;
    for (int i = 0; i < m; i++) {
        int state = 0;
        for (int j = 0; j < n; j++) {
            state |= (seats[i][j] == '.') << j;
        }
        validRows[i] = state;
    }

    vector<vector<int>> dp(m, vector<int>(1<<n, -1));
    function<int(int, int)> dfs = [&](int rowIndex, int prevState) {
        if (rowIndex >= m) return 0;
        if (dp[rowIndex][prevState] != -1) return dp[rowIndex][prevState];

        int maxStudents = 0;
        for (int curState = 0; curState <= max_valid; curState++) {
            if ((curState & validRows[rowIndex]) != curState) continue;
            if (curState & (curState << 1)) continue;
            if (curState & (prevState << 1) || prevState & (curState << 1)) continue;

            maxStudents = max(maxStudents, dfs(rowIndex + 1, curState) + __builtin_popcount(curState));
        }

        dp[rowIndex][prevState] = maxStudents;
        return maxStudents;
    };

    return dfs(0, 0);
}

-----
int maxStudents(vector<vector<char>>& seats) 
    // Your code here
}

************************************
Question ID: 1472

#include <string>
#include <map>

std::string sortString(std::string s) {
    std::string result;
    std::map<char, int> freq_map;
    
    for (char c : s) {
        freq_map[c]++;
    }
    
    while (!freq_map.empty()) {
        for (auto it = freq_map.begin(); it != freq_map.end();) {
            result += it->first;
            it->second--;

            if (it->second == 0) {
                it = freq_map.erase(it);
            } else {
                ++it;
            }
        }

        for (auto it = freq_map.rbegin(); it != freq_map.rend();) {
            auto next = std::next(it).base();
            result += it->first;
            it->second--;

            if (it->second == 0) {
                freq_map.erase(next);
            }
            it = std::reverse_iterator(next);
        }
    }
    
    return result;
}

-----
#include <string>
#include <map>

std::string sortString(std::string s) 
    // Your code here
}

************************************
Question ID: 1473

#include <string>
#include <unordered_map>
using namespace std;

int findTheLongestSubstring(string s) {
    unordered_map<int, int> mp;
    mp[0] = -1;
    int res = 0, n = s.length(), i, j = 0;
    for (i = 0; i < n; ++i) {
        if (s[i] == 'a') j ^= 1;
        else if (s[i] == 'e') j ^= 2;
        else if (s[i] == 'i') j ^= 4;
        else if (s[i] == 'o') j ^= 8;
        else if (s[i] == 'u') j ^= 16;
        if(!mp.count(j)) mp[j] = i;
        res = max(res, i - mp[j]);
    }
    return res;
}

-----
#include <string>
#include <unordered_map>
using namespace std;

int findTheLongestSubstring(string s) 
    // Your code here
}

************************************
Question ID: 1476

int countNegatives(vector<vector<int>>& grid) {
    int m = grid.size(), n = grid[0].size(), count = 0, i = 0, j = n - 1;
    while (i < m && j >= 0) {
        if (grid[i][j] < 0) {
            count += j + 1;
            i++;
        } else {
            j--;
        }
    }
    return count;
}

-----
int countNegatives(vector<vector<int>>& grid) 
    // Your code here
}

************************************
Question ID: 1478

#include <vector>
#include <algorithm>

int maxEvents(std::vector<std::vector<int>>& events) {
    std::sort(events.begin(), events.end(), [](const std::vector<int>& a, const std::vector<int>& b) {
        return a[1] < b[1];
    });

    int count = 0;
    int lastDay = -1;

    for (const auto& event : events) {
        if (event[0] > lastDay) {
            ++count;
            lastDay = event[1];
        }
    }

    return count;
}

-----
#include <vector>
#include <algorithm>

int maxEvents(std::vector<std::vector<int>>& events) 
    // Your code here
}

************************************
Question ID: 1480

#include <vector>
std::vector<int> runningSum(std::vector<int>& nums) {
    for(int i = 1; i < nums.size(); i++) {
        nums[i] += nums[i - 1];
    }
    return nums;
}

-----
#include <vector>
std::vector<int> runningSum(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1481

#include <unordered_map>
#include <queue>
int findLeastNumOfUniqueInts(vector<int>& arr, int k) {
    unordered_map<int, int> count;
    for (int n : arr) {
        count[n]++;
    }
    priority_queue<int, vector<int>, greater<int>> pq;
    for (auto &p : count) {
        pq.push(p.second);
    }
    while (k > 0) {
        k -= pq.top();
        pq.pop();
    }
    return k == 0 ? pq.size() : pq.size() + 1;
}

-----
#include <unordered_map>
#include <queue>
int findLeastNumOfUniqueInts(vector<int>& arr, int k) 
    // Your code here
}

************************************
Question ID: 1482

#include <vector>
using namespace std;

vector<int> smallerNumbersThanCurrent(vector<int>& nums) {
    vector<int> result(nums.size(), 0);
    for (int i = 0; i < nums.size(); ++i) {
        for (int j = 0; j < nums.size(); ++j) {
            if (nums[j] < nums[i]) {
                ++result[i];
            }
        }
    }
    return result;
}

-----
#include <vector>
using namespace std;

vector<int> smallerNumbersThanCurrent(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1483

#include <algorithm>
#include <string>
#include <vector>

std::string rankTeams(std::vector<std::string>& votes) {
    int teams = votes[0].size();
    std::vector<std::vector<int>> ranks(26, std::vector<int>(teams, 0));

    for (const std::string& vote : votes) {
        for (int i = 0; i < teams; ++i) {
            ranks[vote[i] - 'A'][i]++;
        }
    }

    std::string result = votes[0];
    std::sort(result.begin(), result.end(), [&](char a, char b) {
        for (int i = 0; i < teams; ++i) {
            if (ranks[a - 'A'][i] != ranks[b - 'A'][i]) {
                return ranks[a - 'A'][i] > ranks[b - 'A'][i];
            }
        }
        return a < b;
    });

    return result;
}


-----
#include <algorithm>
#include <string>
#include <vector>

std::string rankTeams(std::vector<std::string>& votes) 
    // Your code here
}


************************************
Question ID: 1485

#include <vector>
#include <queue>

int minCost(std::vector<std::vector<int>>& grid) {
    int m = grid.size();
    int n = grid[0].size();
    std::vector<std::vector<int>> cost(m, std::vector<int>(n, 1e6));
    std::queue<std::pair<int, int>> q;

    auto dfs = [&](int r, int c, int d) {
        if (r >= 0 && c >= 0 && r < m && c < n && (d < cost[r][c])) {
            cost[r][c] = d;
            q.push({r, c});
        }
    };

    dfs(0, 0, 0);
    const std::vector<std::pair<int, int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    while (!q.empty()) {
        int r = q.front().first;
        int c = q.front().second;
        q.pop();
        for (int i = 0; i < 4; ++i) {
            int nr = r + directions[i].first;
            int nc = c + directions[i].second;
            dfs(nr, nc, cost[r][c] + (grid[r][c] != i + 1));
        }
    }
    return cost.back().back();
}

-----
#include <vector>
#include <queue>

int minCost(std::vector<std::vector<int>>& grid) 
    // Your code here
}

************************************
Question ID: 1486

int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {
    int count = 0;
    for (int i = 0; i < arr1.size(); i++) {
        bool valid = true;
        for (int j = 0; j < arr2.size(); j++) {
            if (abs(arr1[i] - arr2[j]) <= d) {
                valid = false;
                break;
            }
        }
        if (valid) count++;
    }
    return count;
}

-----
int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) 
    // Your code here
}

************************************
Question ID: 1487

#include <vector>
#include <unordered_map>

int maxNumberOfFamilies(int n, std::vector<std::vector<int>>& reservedSeats) {
    std::unordered_map<int, int> rows;
    for (const auto& seat : reservedSeats) {
        rows[seat[0]] |= 1 << (seat[1] - 1);
    }
    
    int max_groups = (n - rows.size()) * 2;
    for (const auto& row : rows) {
        int seats = ~(row.second | (row.second >> 1) | (row.second >> 2) | (row.second >> 3)) & 0x3FF;        
        max_groups += (seats & (seats >> 1) & (seats >> 2) & (seats >> 3)) != 0;
    }
    
    return max_groups;
}

-----
#include <vector>
#include <unordered_map>

int maxNumberOfFamilies(int n, std::vector<std::vector<int>>& reservedSeats) 
    // Your code here
}

************************************
Question ID: 1488

int getPower(int x) {
    int steps = 0;
    while (x != 1) {
        if (x % 2 == 0) x /= 2;
        else x = 3 * x + 1;
        steps++;
    }
    return steps;
}

int sort_by_power(int lo, int hi, int k) {
    vector<pair<int, int>> nums;
    for (int i = lo; i <= hi; i++) {
        nums.push_back({getPower(i), i});
    }
    sort(nums.begin(), nums.end());
    return nums[k - 1].second;
}

-----
int getPower(int x) 
    // Your code here
}

************************************
Question ID: 1489

#include <vector>
#include <algorithm>
using namespace std;

int maxSum(vector<int>& slices, int start, int end, int n, vector<vector<int>>& memo) {
    if (n == 0) return 0;
    if (end - start + 1 < n * 2) return INT_MIN;
    if (memo[start][n] != -1) return memo[start][n];

    int pick = maxSum(slices, start + 2, end, n - 1, memo) + slices[start];
    int notPick = maxSum(slices, start + 1, end, n, memo);

    memo[start][n] = max(pick, notPick);
    return memo[start][n];
}

int maxSizeSlices(vector<int>& slices) {
    int n = slices.size() / 3;
    vector<vector<int>> memo1(slices.size(), vector<int>(n + 1, -1));
    vector<vector<int>> memo2(slices.size(), vector<int>(n + 1, -1));

    return max(maxSum(slices, 0, slices.size() - 1, n, memo1),
               maxSum(slices, 1, slices.size(), n, memo2));
}


-----
#include <vector>
#include <algorithm>
using namespace std;

int maxSum(vector<int>& slices, int start, int end, int n, vector<vector<int>>& memo) 
    // Your code here
}


************************************
Question ID: 1490

#include <string>

std::string generateTheString(int n) {
    std::string result(n, 'a');
    if (n % 2 == 0) {
        result[n - 1] = 'b';
    }
    return result;
}

-----
#include <string>

std::string generateTheString(int n) 
    // Your code here
}

************************************
Question ID: 1491

int countPrefixAligned(const vector<int>& flips) {
    int count = 0;
    for (int i = 0; i < flips.size(); i++) {
        if (flips[i] == i + 1) {
            count++;
        }
    }
    return count;
}

-----
int countPrefixAligned(const vector<int>& flips) 
    // Your code here
}

************************************
Question ID: 1492

#include <vector>
#include <queue>
#include <algorithm>

int numOfMinutes(int n, int headID, std::vector<int>& manager, std::vector<int>& informTime) {
    std::vector<std::vector<int>> subordinates(n);
    for (int i = 0; i < n; ++i) {
        if (manager[i] != -1) {
            subordinates[manager[i]].push_back(i);
        }
    }

    std::queue<std::pair<int, int>> q;
    q.push({headID, 0});
    int totalTime = 0;

    while (!q.empty()) {
        auto [current, time] = q.front();
        q.pop();
        totalTime = std::max(totalTime, time);
        for (int sub : subordinates[current]) {
            q.push({sub, time + informTime[current]});
        }
    }
    return totalTime;
}


-----
#include <vector>
#include <queue>
#include <algorithm>

int numOfMinutes(int n, int headID, std::vector<int>& manager, std::vector<int>& informTime) 
    // Your code here
}


************************************
Question ID: 1493

#include <vector>
using namespace std;

double dfs(int node, int parent, int t, int target, vector<vector<int>>& graph) {
    if (t == 0) {
        return node == target ? 1.0 : 0.0;
    }
    double probability = 0.0;
    for (int neighbor : graph[node]) {
        if (neighbor != parent) {
            probability += dfs(neighbor, node, t - 1, target, graph);
        }
    }
    return probability / (graph[node].size() - (parent == -1 ? 0 : 1));
}

double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {
    vector<vector<int>> graph(n + 1);
    for (vector<int>& edge : edges) {
        graph[edge[0]].push_back(edge[1]);
        graph[edge[1]].push_back(edge[0]);
    }
    return dfs(1, -1, t, target, graph);
}


-----
#include <vector>
using namespace std;

double dfs(int node, int parent, int t, int target, vector<vector<int>>& graph) 
    // Your code here
}


************************************
Question ID: 1494

#include <vector>
#include <queue>
using namespace std;

int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {
    vector<int> indegree(n + 1, 0);
    vector<vector<int>> graph(n + 1);

    for (const auto& relation : relations) {
        graph[relation[0]].push_back(relation[1]);
        indegree[relation[1]]++;
    }

    int semesters = 0;
    while (n > 0) {
        queue<int> zero_indegree;
        for (int i = 1; i < indegree.size(); ++i) {
            if (indegree[i] == 0) {
                zero_indegree.push(i);
                indegree[i] = -1;
            }
        }

        int courses = 0;
        while (!zero_indegree.empty() && courses < k) {
            int curr_course = zero_indegree.front();
            zero_indegree.pop();
            n--;

            for (int next_course : graph[curr_course]) {
                indegree[next_course]--;
            }
            courses++;
        }
        semesters++;
    }
    return semesters;
}

-----
#include <vector>
#include <queue>
using namespace std;

int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) 
    // Your code here
}

************************************
Question ID: 1496

#include <vector>
using namespace std;

vector<int> luckyNumbers(vector<vector<int>>& matrix) {
    int m = matrix.size(), n = matrix[0].size();
    vector<int> lucky_numbers;
    for (int i = 0; i < m; ++i) {
        int min_row = matrix[i][0], min_row_idx = 0;
        for (int j = 0; j < n; ++j) {
            if (matrix[i][j] < min_row) {
                min_row = matrix[i][j];
                min_row_idx = j;
            }
        }
        bool is_lucky = true;
        for (int k = 0; k < m; ++k) {
            if (matrix[k][min_row_idx] > min_row) {
                is_lucky = false;
                break;
            }
        }
        if (is_lucky)
            lucky_numbers.push_back(min_row);
    }
    return lucky_numbers;
}

-----
#include <vector>
using namespace std;

vector<int> luckyNumbers(vector<vector<int>>& matrix) 
    // Your code here
}

************************************
Question ID: 1498

TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {
    if (original == nullptr)
        return nullptr;
    if (original == target)
        return cloned;

    TreeNode* left = getTargetCopy(original->left, cloned->left, target);
    return left ? left : getTargetCopy(original->right, cloned->right, target);
}

-----
TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) 
    // Your code here
}

************************************
Question ID: 1499

#include <vector>
#include <algorithm>

int maxPerformance(int n, int k, std::vector<int>& speed, std::vector<int>& efficiency) {
    std::vector<std::pair<int, int>> engineers;
    for (int i = 0; i < n; ++i) {
        engineers.emplace_back(efficiency[i], speed[i]);
    }
    std::sort(engineers.rbegin(), engineers.rend());

    long long sum = 0;
    long long result = 0;
    std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;
    for (const auto& engineer : engineers) {
        if (min_heap.size() >= k) {
            sum -= min_heap.top();
            min_heap.pop();
        }
        min_heap.push(engineer.second);
        sum += engineer.second;
        result = std::max(result, engineer.first * sum);
    }
    return result % 1000000007;
}

-----
#include <vector>
#include <algorithm>

int maxPerformance(int n, int k, std::vector<int>& speed, std::vector<int>& efficiency) 
    // Your code here
}

************************************
Question ID: 1500

#include <iostream>
using namespace std;

int countLargestGroup(int n) {
    int freq[37] = {0}, maxGroupSize = 0, maxGroupCount = 0;
    
    for(int i = 1; i <= n; i++) {
        int sum = 0, num = i;
        while(num) {
            sum += num % 10;
            num /= 10;
        }
        freq[sum]++;
        maxGroupSize = max(maxGroupSize, freq[sum]);
    }

    for(int i = 0; i < 37; i++)
        if(freq[i] == maxGroupSize)
            maxGroupCount++;
    
    return maxGroupCount;
}


-----
#include <iostream>
using namespace std;

int countLargestGroup(int n) 
    // Your code here
}


************************************
Question ID: 1502

bool canConstruct(std::string s, int k) {
    int char_counts[26] = {0};

    for (char c : s) 
        char_counts[c - 'a']++;

    int odd_count = 0;
    for (int count : char_counts) 
        odd_count += count % 2;

    return odd_count <= k && k <= s.length();
}


-----
bool canConstruct(std::string s, int k) 
    // Your code here
}


************************************
Question ID: 1503

#include <vector>
#include <algorithm>

int maxSatisfaction(std::vector<int>& satisfaction) {
    std::sort(satisfaction.begin(), satisfaction.end(), std::greater<int>());
    int ans = 0, total = 0, sum = 0;
    for (int i : satisfaction) {
        total += i;
        if (total > 0) {
            sum += total;
            ans = std::max(ans, sum);
        }
    }
    return ans;
}

-----
#include <vector>
#include <algorithm>

int maxSatisfaction(std::vector<int>& satisfaction) 
    // Your code here
}

************************************
Question ID: 1504

int numSubmat(vector<vector<int>>& mat) {
    int m = mat.size(), n = mat[0].size();
    vector<vector<int>> dp(m, vector<int>(n));
    int ans = 0;

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (mat[i][j]) {
                dp[i][j] = j == 0 ? 1 : dp[i][j-1] + 1;
                int width = dp[i][j];
                for (int k = i; k >= 0; k--) {
                    width = min(width, dp[k][j]);
                    ans += width;
                }
            }
        }
    }
    return ans;
}

-----
int numSubmat(vector<vector<int>>& mat) 
    // Your code here
}

************************************
Question ID: 1505

#include <vector>

std::vector<int> createTargetArray(std::vector<int>& nums, std::vector<int>& index) {
    std::vector<int> target;
    for (int i = 0; i < nums.size(); ++i) {
        target.insert(target.begin() + index[i], nums[i]);
    }
    return target;
}

-----
#include <vector>

std::vector<int> createTargetArray(std::vector<int>& nums, std::vector<int>& index) 
    // Your code here
}

************************************
Question ID: 1507

#include <vector>

bool hasValidPath(std::vector<std::vector<int>>& grid) {
    int m = grid.size();
    int n = grid[0].size();
    std::vector<std::vector<bool>> visited(m, std::vector<bool>(n, false));

    return dfs(grid, 0, 0, m, n, visited);
}

bool dfs(std::vector<std::vector<int>>& grid, int x, int y, int m, int n, std::vector<std::vector<bool>>& visited) {
    if (x < 0 || y < 0 || x >= m || y >= n || visited[x][y]) return false;
    if (x == m - 1 && y == n - 1) return true;
    
    visited[x][y] = true;

    int next_x[4] = {-1, 0, 1, 0};
    int next_y[4] = {0, 1, 0, -1};

    for (int i = 0; i < 4; i++) {
        int dx = x + next_x[i];
        int dy = y + next_y[i];

        if (dfs(grid, dx, dy, m, n, visited)) return true;
    }

    return false;
}

-----
#include <vector>

bool hasValidPath(std::vector<std::vector<int>>& grid) 
    // Your code here
}

************************************
Question ID: 1508

std::string longestHappyPrefix(std::string s) {
    int n = s.length();
    std::vector<int> lps(n, 0);
    int len = 0;
    int i = 1;
    while (i < n) {
        if (s[i] == s[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    return s.substr(0, lps[n - 1]);
}

-----
std::string longestHappyPrefix(std::string s) 
    // Your code here
}

************************************
Question ID: 1509

int minDifference(vector<int>& nums) {
    int n = nums.size();
    if (n <= 4) return 0;
    sort(nums.begin(), nums.end());
    int res = INT_MAX;
    for (int i = 0; i <= 3; ++i)
        res = min(res, nums[n - 4 + i] - nums[i]);
    return res;
}

-----
int minDifference(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1510

#include <unordered_map>

int findLucky(std::vector<int>& arr) {
    std::unordered_map<int, int> freq;

    for (int n : arr) {
        freq[n]++;
    }

    int lucky = -1;
    for (auto &pair : freq) {
        if (pair.first == pair.second) {
            lucky = std::max(lucky, pair.first);
        }
    }

    return lucky;
}

-----
#include <unordered_map>

int findLucky(std::vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1513

#include <string>
#include <vector>

using namespace std;

const int MOD = 1e9 + 7;

int countGoodStrings(string s1, string s2, string evil) {
    int n = s1.size();
    int m = evil.size();
    vector<vector<int>> dp(n + 1, vector<int>(m, 0));

    // Preprocess the KMP prefix function for the evil string
    vector<int> lps(m);
    int len = 0;
    for (int i = 1; i < m;) {
        if (evil[i] == evil[len]) {
            lps[i++] = ++len;
        } else if (len) {
            len = lps[len - 1];
        } else {
            ++i;
        }
    }

    vector<vector<int>> count(s1.size() + 1, vector<int>(2, 0));
    dp[0][0] = 1;

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            for (int k = 0; k < 2; ++k) {
                for (char c = 'a'; c <= (k ? s2[i] : 'z'); ++c) {
                    int e = j;
                    while (e && (c != evil[e])) {
                        e = lps[e - 1];
                    }

                    if ((c != evil[e])) {
                        e++;
                    }

                    if (e != m) {
                        dp[i + 1][k | (c < s2[i])] += dp[i][k];
                        dp[i + 1][k | (c < s2[i])] %= MOD;
                    }
                }
            }
        }
    }

    return (dp[n][1] - dp[n][0] + MOD) % MOD;
}


-----
#include <string>
#include <vector>

using namespace std;

const int MOD = 1e9 + 7;

int countGoodStrings(string s1, string s2, string evil) 
    // Your code here
}


************************************
Question ID: 1514

int minStartValue(std::vector<int>& nums) {
    int min_sum = 0, sum = 0;
    for (int num : nums) {
        sum += num;
        min_sum = std::min(min_sum, sum);
    }
    return 1 - min_sum;
}

-----
int minStartValue(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1515

int findMinFibonacciNumbers(int k) {
    if (k == 0) return 0;
    int a = 0, b = 1;
    while (b <= k) {
        swap(a, b);
        b += a;
    }
    return 1 + findMinFibonacciNumbers(k - a);
}

-----
int findMinFibonacciNumbers(int k) 
    // Your code here
}

************************************
Question ID: 1516

#include <string>
#include <vector>

std::string getHappyString(int n, int k) {
    std::vector<std::string> happyStrings;
    std::function<void(std::string, char)> dfs = [&](std::string s, char prev) {
        if (s.length() == n) {
            happyStrings.push_back(s);
            return;
        }
        for (char c = 'a'; c <= 'c'; c++) {
            if (c != prev) {
                dfs(s + c, c);
            }
        }
    };
    dfs("", ' ');
    return k <= happyStrings.size() ? happyStrings[k - 1] : "";
}

-----
#include <string>
#include <vector>

std::string getHappyString(int n, int k) 
    // Your code here
}

************************************
Question ID: 1518

int numWaterBottles(int numBottles, int numExchange) {
    int totalBottles = numBottles;
    while (numBottles >= numExchange) {
        int newBottles = numBottles / numExchange;
        totalBottles += newBottles;
        numBottles = newBottles + numBottles % numExchange;
    }
    return totalBottles;
}

-----
int numWaterBottles(int numBottles, int numExchange) 
    // Your code here
}

************************************
Question ID: 1519

#include <vector>
#include <algorithm>

std::vector<int> minSubsequence(std::vector<int>& nums) {
    std::sort(nums.begin(), nums.end(), std::greater<int>());
    int totalSum = 0, currentSum = 0;
    for (int num : nums) {
        totalSum += num;
    }
    std::vector<int> result;
    for (int num : nums) {
        currentSum += num;
        result.push_back(num);
        if (currentSum > totalSum - currentSum) {
            break;
        }
    }
    return result;
}

-----
#include <vector>
#include <algorithm>

std::vector<int> minSubsequence(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1520

int num_steps(const std::string& s) {
    int steps = 0, carry = 0;
    for (int i = s.size() - 1; i > 0; --i) {
        if (s[i] - '0' + carry == 1) {
            steps += 2;
            carry = 1;
        } else {
            steps += carry;
            carry = s[i] - '0';
        }
    }

    return steps + carry;
}

-----
int num_steps(const std::string& s) 
    // Your code here
}

************************************
Question ID: 1521

int closestToTarget(vector<int>& arr, int target) {
    int min_diff = INT_MAX;
    unordered_set<int> prefix;
    
    for (int n : arr) {
        unordered_set<int> next_prefix;
        for (int p : prefix) {
            next_prefix.insert(p & n);
        }
        next_prefix.insert(n);

        for (int p : next_prefix) {
            min_diff = min(min_diff, abs(p - target));
        }
        swap(prefix, next_prefix);
    }
    return min_diff;
}

-----
int closestToTarget(vector<int>& arr, int target) 
    // Your code here
}

************************************
Question ID: 1522

#include <vector>
#include <string>
using namespace std;

string stoneGameIII(const vector<int>& stoneValue) {
    int n = stoneValue.size();
    vector<int> dp(n + 1, 0);
    dp[n - 1] = stoneValue[n - 1];
    for (int i = n - 2; i >= 0; --i) {
        dp[i] = stoneValue[i] - dp[i + 1];
        for (int j = 1; j < 3; ++j) {
            if (i + j < n)
                dp[i] = max(dp[i], stoneValue[i + j] - dp[i + j + 1]);
        }
    }
    if (dp[0] > 0) return "Alice";
    if (dp[0] < 0) return "Bob";
    return "Tie";
}

-----
#include <vector>
#include <string>
using namespace std;

string stoneGameIII(const vector<int>& stoneValue) 
    // Your code here
}

************************************
Question ID: 1523

int count_odds(int low, int high) {
    return (high - low) / 2 + ((low % 2 == 1 || high % 2 == 1) ? 1 : 0);
}

-----
int count_odds(int low, int high) 
    // Your code here
}

************************************
Question ID: 1524

#include <vector>
#include<string>

std::vector<std::string> stringMatching(std::vector<std::string>& words) {
    std::vector<std::string> result;
    for (const auto& word1 : words) {
        for (const auto& word2 : words) {
            if (word1 != word2 && word2.find(word1) != std::string::npos) {
                result.push_back(word1);
                break;
            }
        }
    }
    return result;
}

-----
#include <vector>
#include<string>

std::vector<std::string> stringMatching(std::vector<std::string>& words) 
    // Your code here
}

************************************
Question ID: 1525

#include <vector>
#include <algorithm>

std::vector<int> processQueries(std::vector<int> &queries, int m) {
    std::vector<int> nums(m), result;
    for (int i = 0; i < m; ++i) {
        nums[i] = i + 1;
    }
    for (int q : queries) {
        int pos = std::find(nums.begin(), nums.end(), q) - nums.begin();
        result.push_back(pos);
        nums.erase(nums.begin() + pos);
        nums.insert(nums.begin(), q);
    }
    return result;
}

-----
#include <vector>
#include <algorithm>

std::vector<int> processQueries(std::vector<int> &queries, int m) 
    // Your code here
}

************************************
Question ID: 1526

#include <string>
#include <unordered_map>
using namespace std;

string entityParser(string text) {
    unordered_map<string, char> entities{
        {"&quot;", '\"'},
        {"&apos;", '\''},
        {"&amp;", '&'},
        {"&gt;", '>'},
        {"&lt;", '<'},
        {"&frasl;", '/'}
    };
    string result;
    for (int i = 0; i < text.size(); ++i) {
        if (text[i] == '&') {
            string temp;
            for (int j = i; j < text.size() && j < i + 7; ++j) {
                temp.push_back(text[j]);
                if (entities.find(temp) != entities.end()) {
                    result.push_back(entities[temp]);
                    i = j;
                    break;
                }
            }
            if (temp.back() != ';') result.push_back(text[i]);
        } else {
            result.push_back(text[i]);
        }
    }
    return result;
}


-----
#include <string>
#include <unordered_map>
using namespace std;

string entityParser(string text) 
    // Your code here
}


************************************
Question ID: 1528

#include <vector>
using namespace std;

vector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) {
    int max_candies = *max_element(candies.begin(), candies.end());
    vector<bool> result(candies.size());

    for (int i = 0; i < candies.size(); i++) {
        result[i] = (candies[i] + extraCandies >= max_candies);
    }

    return result;
}

-----
#include <vector>
using namespace std;

vector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) 
    // Your code here
}

************************************
Question ID: 1529

int maxDifference(int num) {
    int a = num + 9 - (num % 10);
    int b = num - (num / 1000 % 10) * 111;

    return a - b;
}

-----
int maxDifference(int num) 
    // Your code here
}

************************************
Question ID: 1530

#include <algorithm>
#include <string>

bool checkIfCanBreak(std::string s1, std::string s2) {
    std::sort(s1.begin(), s1.end());
    std::sort(s2.begin(), s2.end());
    
    bool can_break_1 = true, can_break_2 = true;
    for(int i = 0; i < s1.size(); i++) {
        if(s1[i] < s2[i]) can_break_1 = false;
        if(s2[i] < s1[i]) can_break_2 = false;
    }
    return can_break_1 || can_break_2;
}


-----
#include <algorithm>
#include <string>

bool checkIfCanBreak(std::string s1, std::string s2) 
    // Your code here
}


************************************
Question ID: 1531

#include<vector>

int numberWays(std::vector<std::vector<int>>& hats) {
    const int kMod = 1000000007;
    const int kMaxHats = 40;
    
    int num_people = hats.size();
    std::vector<std::vector<int>> people_with_hat(kMaxHats);
    std::vector<std::vector<int>> dp(1<<num_people, std::vector<int>(kMaxHats+1, 0));
    
    for(int i = 0; i < num_people; ++i) {
        for(int hat : hats[i]) {
            people_with_hat[hat - 1].push_back(i);
        }
    }
    
    dp[0][0] = 1;
    
    for(int hat = 0; hat < kMaxHats; ++hat) {
        for(int mask = (1<<num_people) - 1; mask >= 0; --mask) {
            dp[mask][hat + 1] = (dp[mask][hat + 1] + dp[mask][hat]) % kMod;
            for(int person : people_with_hat[hat]) {
                if((mask & (1<<person)) == 0) {
                    dp[mask | (1<<person)][hat + 1] = (dp[mask | (1<<person)][hat + 1] + dp[mask][hat]) % kMod;
                }
            }
        }
    }
    
    return dp[(1<<num_people) - 1][kMaxHats];
}

-----
#include<vector>

int numberWays(std::vector<std::vector<int>>& hats) 
    // Your code here
}

************************************
Question ID: 1533

#include <vector>
#include <string>
#include <map>
#include <set>
#include <algorithm>

using namespace std;

vector<vector<string>> displayTable(vector<vector<string>>& orders) {
    set<string> foodItems;
    map<int, map<string, int>> tableOrders;
    
    for (const auto& order : orders) {
        foodItems.insert(order[2]);
        tableOrders[stoi(order[1])][order[2]]++;
    }

    vector<vector<string>> result;
    vector<string> header;
    header.push_back("Table");
    header.insert(header.end(), foodItems.begin(), foodItems.end());
    result.push_back(header);
    
    for (const auto& entry : tableOrders) {
        vector<string> row;
        row.push_back(to_string(entry.first));
        for (const auto& food : foodItems) {
            row.push_back(to_string(entry.second[food]));
        }
        result.push_back(row);
    }

    return result;
}


-----
#include <vector>
#include <string>
#include <map>
#include <set>
#include <algorithm>

using namespace std;

vector<vector<string>> displayTable(vector<vector<string>>& orders) 
    // Your code here
}


************************************
Question ID: 1534

#include <string>

int minNumberOfFrogs(std::string croakOfFrogs) {
    int counts[5] = {0}, max_frogs = 0;

    for (char c : croakOfFrogs) {
        int index = std::string("croak").find(c);
        if (index == 0) {
            counts[0]++;
            max_frogs = std::max(max_frogs, counts[0]);
        } else if (counts[index - 1] > 0) {
            counts[index - 1]--;
            counts[index]++;
        } else {
            return -1;
        }
    }

    if (counts[0] == counts[4]) {
        return max_frogs;
    } else {
        return -1;
    }
}

-----
#include <string>

int minNumberOfFrogs(std::string croakOfFrogs) 
    // Your code here
}

************************************
Question ID: 1535

int numberOfWays(int n, int m, int k, int mod = 1'000'000'007) {
    if (k > 1) {
        long long result = 1;
        for (int i = 0; i < n; ++i) {
            result = (result * m) % mod;
        }
        return result;
    }
    return n % 2 == 0 ? 1 : m;
}

-----
int numberOfWays(int n, int m, int k, int mod = 1'000'000'007) 
    // Your code here
}

************************************
Question ID: 1536

int minSwaps(vector<vector<int>>& grid) {
    int n = grid.size();
    int steps = 0;

    for (int i = 0; i < n; ++i) {
        int row = -1;
        for (int j = i; j < n; ++j) {
            if (grid[j][i] == 0) {
                row = j;
                break;
            }
        }
        if (row == -1) {
            return -1;
        }

        while (row > i) {
            swap(grid[row], grid[row - 1]);
            steps++;
            row--;
        }
    }
    return steps;
}


-----
int minSwaps(vector<vector<int>>& grid) 
    // Your code here
}


************************************
Question ID: 1537

int maxScore(string s) {
    int left_zeros = 0, right_ones = 0, max_score = 0;
    for(char c : s) if(c == '1') right_ones++;
        
    for(int i = 0; i < s.size() - 1; i++) {
        if(s[i] == '0') left_zeros++;
        else right_ones--;
        max_score = max(max_score, left_zeros + right_ones);
    }
    return max_score;
}

-----
int maxScore(string s) 
    // Your code here
}

************************************
Question ID: 1538

#include <vector>
using namespace std;

int maxScore(vector<int>& cardPoints, int k) {
    int n = cardPoints.size();
    int total = 0;
    for (int i = 0; i < k; ++i) {
        total += cardPoints[i];
    }

    int maxScore = total;
    for (int i = k - 1, j = n - 1; i >= 0; --i, --j) {
        total += cardPoints[j] - cardPoints[i];
        maxScore = max(maxScore, total);
    }

    return maxScore;
}


-----
#include <vector>
using namespace std;

int maxScore(vector<int>& cardPoints, int k) 
    // Your code here
}


************************************
Question ID: 1539

#include <vector>

std::vector<int> findDiagonalOrder(std::vector<std::vector<int>>& nums) {
    std::vector<int> res;
    int m = nums.size();
    std::map<int, std::vector<int>> diagonals;

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < nums[i].size(); j++) {
            diagonals[i + j].push_back(nums[i][j]);
        }
    }

    for (auto& diag : diagonals) {
        std::reverse(diag.second.begin(), diag.second.end());
        res.insert(res.end(), diag.second.begin(), diag.second.end());
    }

    return res;
}

-----
#include <vector>

std::vector<int> findDiagonalOrder(std::vector<std::vector<int>>& nums) 
    // Your code here
}

************************************
Question ID: 1540

bool canConvertString(string s, string t, int k) {
    if (s.length() != t.length()) return false;
    vector<int> count(26, 0);
    for (int i = 0; i < s.length(); i++) {
        int diff = (t[i] - s[i] + 26) % 26;
        if (diff > 0) {
            count[diff]++;
        }
    }
    for (int i = 1; i < 26; i++) {
        if (count[i] > 0) {
            if (count[i] * 26 - 26 + i > k) {
                return false;
            }
        }
    }
    return true;
}

-----
bool canConvertString(string s, string t, int k) 
    // Your code here
}

************************************
Question ID: 1541

int minInsertions(string s) {
    int left = 0, res = 0;
    int n = s.length();
    for (int i = 0; i < n; i++) {
        if (s[i] == '(') {
            left++;
        } else {
            if (left == 0) res++;
            else left--;
            if (i == n - 1 || s[i + 1] != ')') {
                res++;
                i++;
            }
        }
    }
    return res + left * 2;
}

-----
int minInsertions(string s) 
    // Your code here
}

************************************
Question ID: 1542

int maxPower(const std::string& s) {
    int maxPower = 0, currentPower = 1;

    for (int i = 1; i < s.length(); ++i) {
        if (s[i] == s[i-1]) {
            currentPower++;
        } else {
            maxPower = std::max(maxPower, currentPower);
            currentPower = 1;
        }
    }

    return std::max(maxPower, currentPower);
}

-----
int maxPower(const std::string& s) 
    // Your code here
}

************************************
Question ID: 1544

int goodNodes(TreeNode* root, int maxVal = INT_MIN) {
    if (!root) return 0;
    int result = 0;
    if (root->val >= maxVal) {
        result = 1;
        maxVal = root->val;
    }
    return result + goodNodes(root->left, maxVal) + goodNodes(root->right, maxVal);
}

-----
int goodNodes(TreeNode* root, int maxVal = INT_MIN) 
    // Your code here
}

************************************
Question ID: 1545

#include <vector>
#include <string>

std::string largestNumber(std::vector<int>& cost, int target) {
    std::vector<std::string> dp(target + 1, "");
    dp[0] = "";
    
    for (int t = 1; t <= target; ++t) {
        for (int i = 1; i <= 9; ++i) {
            if (t >= cost[i - 1]) {
                std::string temp = dp[t - cost[i - 1]] + char('0' + i);
                if (dp[t].length() <= temp.length()) {
                    dp[t] = temp;
                }
            }
        }
    }

    return dp[target].empty() ? "0" : dp[target];
}


-----
#include <vector>
#include <string>

std::string largestNumber(std::vector<int>& cost, int target) 
    // Your code here
}


************************************
Question ID: 1546

int maxNonOverlapping(vector<int>& nums, int target) {
    unordered_map<int, int> prefix_sum;
    int sum = 0, count = 0;
    prefix_sum[0] = 0;
    for (const int& num : nums) {
        sum += num;
        if (prefix_sum.find(sum - target) != prefix_sum.end()) {
            count = max(count, 1 + prefix_sum[sum - target]);
        }
        prefix_sum[sum] = count;
    }
    return count;
}

-----
int maxNonOverlapping(vector<int>& nums, int target) 
    // Your code here
}

************************************
Question ID: 1547

#include <string>
#include <vector>
#include <unordered_set>

std::string destCity(std::vector<std::vector<std::string>>& paths) {
    std::unordered_set<std::string> starting_cities;
    for (const auto& path : paths)
        starting_cities.insert(path[0]);

    for (const auto& path : paths) {
        if (starting_cities.find(path[1]) == starting_cities.end())
            return path[1];
    }

    return "";
}

-----
#include <string>
#include <vector>
#include <unordered_set>

std::string destCity(std::vector<std::vector<std::string>>& paths) 
    // Your code here
}

************************************
Question ID: 1548

bool kLengthApart(vector<int>& nums, int k) {
    int last_one = -1;
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] == 1) {
            if (last_one != -1 && i - last_one <= k) {
                return false;
            }
            last_one = i;
        }
    }
    return true;
}

-----
bool kLengthApart(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 1550

#include <vector>
#include <queue>

int kthSmallest(const std::vector<std::vector<int>>& mat, int k) {
    int m = mat.size(), n = mat[0].size();
    
    auto comp = [&](const std::vector<int>& a, const std::vector<int>& b) {
        return a[0] > b[0];
    };
    
    std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, decltype(comp)> minHeap(comp);
    minHeap.push({mat[0][0], 0, 0});
    
    std::vector<std::vector<bool>> visited(m, std::vector<bool>(n, false));
    visited[0][0] = true;
    
    int res;
    while (k--) {
        auto cur = minHeap.top(); minHeap.pop();
        res = cur[0];
        int i = cur[1], j = cur[2];
        
        if (i < m - 1 && !visited[i+1][j]) {
            minHeap.push({res - mat[i][j] + mat[i + 1][j], i + 1, j});
            visited[i+1][j] = true;
        }
        if (j < n - 1 && !visited[i][j+1]) {
            minHeap.push({res - mat[i][j] + mat[i][j + 1], i, j + 1});
            visited[i][j+1] = true;
        }
    }
    
    return res;
}

-----
#include <vector>
#include <queue>

int kthSmallest(const std::vector<std::vector<int>>& mat, int k) 
    // Your code here
}

************************************
Question ID: 1551

int minOperations(int n) {
    return n * n / 4;
}

-----
int minOperations(int n) 
    // Your code here
}

************************************
Question ID: 1552

#include <vector>
#include <string>

std::vector<std::string> buildArray(std::vector<int>& target, int n) {
    std::vector<std::string> result;
    int current = 1;
    for (int num : target) {
        while (current < num) {
            result.push_back("Push");
            result.push_back("Pop");
            current++;
        }
        result.push_back("Push");
        current++;
    }
    return result;
}

-----
#include <vector>
#include <string>

std::vector<std::string> buildArray(std::vector<int>& target, int n) 
    // Your code here
}

************************************
Question ID: 1553

int countTriplets(vector<int>& arr) {
    int n = arr.size();
    vector<int> XOR(n+1, 0);
    
    for (int i = 0; i < n; i++) {
        XOR[i+1] = XOR[i] ^ arr[i];
    }
    
    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int k = i+1; k < n; k++) {
            if(XOR[i] == XOR[k+1]) count += k-i;
        }
    }
    return count;
}

-----
int countTriplets(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1554

#include <vector>
#include <unordered_map>

int minTime(int n, std::vector<std::vector<int>>& edges, std::vector<bool>& hasApple) {
    std::unordered_map<int, std::unordered_map<int, int>> graph;

    for (const auto& edge : edges) {
        graph[edge[0]][edge[1]] = 0;
        graph[edge[1]][edge[0]] = 0;
    }

    std::function<int(int, int)> dfs = [&](int v, int parent) {
        int ans = 0;
        for (auto& [u, _] : graph[v]) {
            if (u == parent) continue;
            ans += dfs(u, v) * 2;
        }
        return ans + (hasApple[v] || ans);
    };

    return dfs(0, -1);
}

-----
#include <vector>
#include <unordered_map>

int minTime(int n, std::vector<std::vector<int>>& edges, std::vector<bool>& hasApple) 
    // Your code here
}

************************************
Question ID: 1556

#include <vector>
#include <algorithm>

bool canBeEqual(std::vector<int>& target, std::vector<int>& arr) {
    std::sort(target.begin(), target.end());
    std::sort(arr.begin(), arr.end());
    return target == arr;
}


-----
#include <vector>
#include <algorithm>

bool canBeEqual(std::vector<int>& target, std::vector<int>& arr) 
    // Your code here
}


************************************
Question ID: 1557

bool hasAllCodes(std::string s, int k) {
    int need = 1 << k;
    std::unordered_set<std::string> got;
    
    for (int i = 0; i <= s.size() - k; i++) {
        got.insert(s.substr(i, k));
    }
    
    return got.size() == need;
}

-----
bool hasAllCodes(std::string s, int k) 
    // Your code here
}

************************************
Question ID: 1558

#include<vector>
#include<unordered_map>

using namespace std;

void DFS(int src, unordered_map<int, vector<int>> &graph, vector<bool> &visited, vector<bool> &transitiveClosure, int dest) {
    if (src == dest) {
        transitiveClosure[dest] = true;
        return;
    }
    if (visited[src]) return;
    visited[src] = true;
    for (int neighbor : graph[src]) {
        DFS(neighbor, graph, visited, transitiveClosure, dest);
        if (transitiveClosure[dest]) return;
    }
}

vector<bool> checkIfPrerequisite(int numCourses, vector<vector<int>>& prerequisites, vector<vector<int>>& queries) {
    unordered_map<int, vector<int>> graph;

    for (auto &pre : prerequisites) {
        graph[pre[0]].push_back(pre[1]);
    }

    vector<bool> result(queries.size());

    for (int i = 0; i < queries.size(); ++i) {
        vector<bool> visited(numCourses, false);
        vector<bool> transitiveClosure(numCourses, false);
        DFS(queries[i][0], graph, visited, transitiveClosure, queries[i][1]);
        result[i] = transitiveClosure[queries[i][1]];
    }

    return result;
}

-----
#include<vector>
#include<unordered_map>

using namespace std;

void DFS(int src, unordered_map<int, vector<int>> &graph, vector<bool> &visited, vector<bool> &transitiveClosure, int dest) 
    // Your code here
}

************************************
Question ID: 1559

int cherryPickup(vector<vector<int>>& grid) {
    int rows = grid.size();
    int cols = grid[0].size();
    vector<vector<vector<int>>> dp(rows, vector<vector<int>>(cols, vector<int>(cols, 0)));

    for (int row = rows - 1; row >= 0; --row) {
        for (int col1 = 0; col1 < cols; ++col1) {
            for (int col2 = 0; col2 < cols; ++col2) {
                int currentCell = row < rows - 1 ? dp[row + 1][col1][col2] : 0;
                currentCell += grid[row][col1] + (col1 != col2 ? grid[row][col2] : 0);

                int maxVal = 0;
                for (int move1 = -1; move1 <= 1; ++move1) {
                    for (int move2 = -1; move2 <= 1; ++move2) {
                        int newCol1 = col1 + move1;
                        int newCol2 = col2 + move2;
                        if (newCol1 >= 0 && newCol1 < cols && newCol2 >= 0 && newCol2 < cols) {
                            maxVal = max(maxVal, dp[row][newCol1][newCol2]);
                        }
                    }
                }

                dp[row][col1][col2] = currentCell + maxVal;
            }
        }
    }

    return dp[0][0][cols - 1];
}


-----
int cherryPickup(vector<vector<int>>& grid) 
    // Your code here
}


************************************
Question ID: 1560

int busyStudent(vector<int>& startTime, vector<int>& endTime, int queryTime) {
    int count = 0;
    for (int i = 0; i < startTime.size(); i++) {
        if (startTime[i] <= queryTime && endTime[i] >= queryTime) {
            count++;
        }
    }
    return count;
}

-----
int busyStudent(vector<int>& startTime, vector<int>& endTime, int queryTime) 
    // Your code here
}

************************************
Question ID: 1561

#include <algorithm>
#include <sstream>
#include <string>
#include <vector>

std::string arrangeWords(std::string text) {
    text[0] = tolower(text[0]);
    std::istringstream iss(text);
    std::vector<std::pair<std::string, int>> words;
    std::string word;
    int i = 0;
    while (iss >> word) {
        words.emplace_back(word, i++);
    }
    std::stable_sort(words.begin(), words.end(), [](const auto &a, const auto &b) {
        return a.first.length() < b.first.length();
    });
    std::ostringstream oss;
    for (const auto &w : words) {
        if (&w != &words[0]) oss << ' ';
        oss << w.first;
    }
    auto result = oss.str();
    result[0] = toupper(result[0]);
    return result;
}

-----
#include <algorithm>
#include <sstream>
#include <string>
#include <vector>

std::string arrangeWords(std::string text) 
    // Your code here
}

************************************
Question ID: 1562

#include <vector>
#include <algorithm>
using namespace std;

vector<int> peopleIndexes(vector<vector<string>>& favoriteCompanies) {
    vector<int> result;
    for (int i = 0; i < favoriteCompanies.size(); i++) {
        bool isSubset = false;
        for (int j = 0; j < favoriteCompanies.size() && !isSubset; j++) {
            if (i != j && includes(favoriteCompanies[j].begin(), favoriteCompanies[j].end(),
                                   favoriteCompanies[i].begin(), favoriteCompanies[i].end())) {
                isSubset = true;
            }
        }
        if (!isSubset) result.push_back(i);
    }
    return result;
}

-----
#include <vector>
#include <algorithm>
using namespace std;

vector<int> peopleIndexes(vector<vector<string>>& favoriteCompanies) 
    // Your code here
}

************************************
Question ID: 1563

#include <cmath>
#include <vector>

int maxNumberOfDarts(vector<vector<int>>& darts, int r) {
    int n = darts.size();
    int max_darts = 1;

    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            double dist = hypot(darts[j][0] - darts[i][0], darts[j][1] - darts[i][1]);
            if (dist > 2.0 * r) continue;

            double angle = acos(dist / (2.0 * r));
            for (int k = 0; k < 2; k++) {
                double loc_angle = angle * (k == 0 ? 1 : -1);
                double cx = darts[i][0] + r * (darts[j][0] - darts[i][0]) / dist * cos(loc_angle) - r * (darts[j][1] - darts[i][1]) / dist * sin(loc_angle);
                double cy = darts[i][1] + r * (darts[j][0] - darts[i][0]) / dist * sin(loc_angle) + r * (darts[j][1] - darts[i][1]) / dist * cos(loc_angle);

                int cnt = 0;
                for (int l = 0; l < n; l++) {
                    double new_dist = hypot(darts[l][0] - cx, darts[l][1] - cy);
                    if (new_dist <= r + 1e-5) cnt++;
                }

                max_darts = max(max_darts, cnt);
            }
        }
    }

    return max_darts;
}

-----
#include <cmath>
#include <vector>

int maxNumberOfDarts(vector<vector<int>>& darts, int r) 
    // Your code here
}

************************************
Question ID: 1564

int maxBoxesInWarehouse(vector<int>& boxes, vector<int>& warehouse) {
    int n = warehouse.size();
    for (int i = 1; i < n; i++)
        warehouse[i] = min(warehouse[i], warehouse[i - 1]);
    sort(boxes.rbegin(), boxes.rend());
    int boxIndex = 0;
    int boxesCount = 0;
    for (int i = 0; i < n && boxIndex < boxes.size(); i++) {
        if (boxes[boxIndex] <= warehouse[i]) {
            boxesCount++;
            boxIndex++;
        }
    }
    return boxesCount;
}


-----
int maxBoxesInWarehouse(vector<int>& boxes, vector<int>& warehouse) 
    // Your code here
}


************************************
Question ID: 1566

#include <string>
#include <sstream>

int isPrefixOfWord(std::string sentence, std::string searchWord) {
    std::istringstream iss(sentence);
    std::string word;
    int index = 1;
    while (iss >> word) {
        if (word.substr(0, searchWord.size()) == searchWord) {
            return index;
        }
        index++;
    }
    return -1;
}

-----
#include <string>
#include <sstream>

int isPrefixOfWord(std::string sentence, std::string searchWord) 
    // Your code here
}

************************************
Question ID: 1567

#include <string>
#include <algorithm>

int maxVowels(std::string s, int k) {
    int max_count = 0, count = 0;
    for (int i = 0; i < s.length(); i++) {
        count += (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u');
        if (i >= k)
            count -= (s[i - k] == 'a' || s[i - k] == 'e' || s[i - k] == 'i' || s[i - k] == 'o' || s[i - k] == 'u');
        max_count = std::max(max_count, count);
    }
    return max_count;
}


-----
#include <string>
#include <algorithm>

int maxVowels(std::string s, int k) 
    // Your code here
}


************************************
Question ID: 1568

int pseudoPalindromicPaths(TreeNode* root, int cnt = 0) {
    if (!root) return 0;
    cnt ^= 1 << (root->val - 1);
    if (!root->left && !root->right)
        return (cnt & (cnt - 1)) == 0; 
    return pseudoPalindromicPaths(root->left, cnt) + pseudoPalindromicPaths(root->right, cnt);
}

-----
int pseudoPalindromicPaths(TreeNode* root, int cnt = 0) 
    // Your code here
}

************************************
Question ID: 1569

int maxDotProduct(vector<int>& nums1, vector<int>& nums2) {
    int n = nums1.size(), m = nums2.size();
    vector<vector<int>> dp(n + 1, vector<int>(m + 1, INT_MIN));
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            dp[i][j] = max({dp[i][j], dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1], nums1[i - 1] * nums2[j - 1]});
        }
    }
    return dp[n][m];
}

-----
int maxDotProduct(vector<int>& nums1, vector<int>& nums2) 
    // Your code here
}

************************************
Question ID: 1570

#include <vector>
using namespace std;

vector<int> finalPrices(vector<int>& prices) {
    for(int i = 0; i < prices.size(); i++) {
        for(int j = i + 1; j < prices.size(); j++) {
            if(prices[j] <= prices[i]) {
                prices[i] -= prices[j];
                break;
            }
        }
    }
    return prices;
}

-----
#include <vector>
using namespace std;

vector<int> finalPrices(vector<int>& prices) 
    // Your code here
}

************************************
Question ID: 1573

#include <vector>
#include <unordered_map>
#include <limits>

int min_sum_of_lengths(std::vector<int> &arr, int target) {
    int n = arr.size(), sum = 0, min_len = std::numeric_limits<int>::max();
    int result = std::numeric_limits<int>::max();
    std::unordered_map<int, int> mp;
    mp.reserve(n + 1);
    mp[0] = -1;

    for (int i = 0; i < n; ++i) {
        sum += arr[i];
        if (sum >= target && mp.count(sum - target) > 0) {
            if (mp[sum - target] > -1 && min_len != std::numeric_limits<int>::max()) {
                result = std::min(result, i - mp[sum - target] + min_len);
            }
            min_len = std::min(min_len, i - mp[sum - target]);
        }
        mp[sum] = i;
    }
    return result == std::numeric_limits<int>::max() ? -1 : result;
}

-----
#include <vector>
#include <unordered_map>
#include <limits>

int min_sum_of_lengths(std::vector<int> &arr, int target) 
    // Your code here
}

************************************
Question ID: 1574

int findLengthOfShortestSubarray(vector<int>& arr) {
    int n = arr.size(), left = 0, right = n - 1;
    while (left < n - 1 && arr[left] <= arr[left + 1]) left++;
    if (left == n - 1) return 0;
    while (right > 0 && arr[right] >= arr[right - 1]) right--;
    int result = min(n - left - 1, right);
    for (int i = 0, j = right; i <= left && j < n;) {
        if (arr[i] <= arr[j]) {
            result = min(result, j - i - 1);
            i++;
        } else {
            j++;
        }
    }
    return result;
}

-----
int findLengthOfShortestSubarray(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1575

#include <vector>
#include <algorithm>
using namespace std;

int maxArea(int h, int w, vector<int>& horizontalCuts, vector<int>& verticalCuts) {
    sort(horizontalCuts.begin(), horizontalCuts.end());
    sort(verticalCuts.begin(), verticalCuts.end());
    
    int maxH = max(horizontalCuts[0], h - horizontalCuts.back());
    int maxV = max(verticalCuts[0], w - verticalCuts.back());
    
    for (int i = 1; i < horizontalCuts.size(); ++i) {
        maxH = max(maxH, horizontalCuts[i] - horizontalCuts[i - 1]);
    }
    
    for (int i = 1; i < verticalCuts.size(); ++i) {
        maxV = max(maxV, verticalCuts[i] - verticalCuts[i - 1]);
    }
    
    return (long long)maxH * maxV % 1000000007;
}

-----
#include <vector>
#include <algorithm>
using namespace std;

int maxArea(int h, int w, vector<int>& horizontalCuts, vector<int>& verticalCuts) 
    // Your code here
}

************************************
Question ID: 1576

#include <vector>
using namespace std;

void dfs(int node, int parent, vector<vector<int>> &graph, int &count) {
    if (node != 0 && parent == 0) count++;

    for (int neighbor : graph[node]) {
        if (neighbor != parent) {
            dfs(neighbor, node, graph, count);
        }
    }
}

int minReorder(int n, vector<vector<int>> &connections) {
    vector<vector<int>> graph(n);
    for (auto &c : connections) {
        graph[c[0]].push_back(c[1]);
        graph[c[1]].push_back(c[0]);
    }

    int count = 0;
    dfs(0, -1, graph, count);
    return count;
}

-----
#include <vector>
using namespace std;

void dfs(int node, int parent, vector<vector<int>> &graph, int &count) 
    // Your code here
}

************************************
Question ID: 1578

int minTime(string colors, vector<int>& neededTime) {
    int res = 0, prev = -1;
    for (int i = 0; i < colors.length() - 1; i++) {
        if (colors[i] == colors[i + 1]) {
            if (prev == -1 || neededTime[i] < neededTime[prev]) prev = i;
            if (neededTime[i + 1] < neededTime[prev]) prev = i + 1;
            res += neededTime[prev];
            neededTime[prev] = 1000000;
            prev = -1;
        }
    }
    return res;
}

-----
int minTime(string colors, vector<int>& neededTime) 
    // Your code here
}

************************************
Question ID: 1580

#include<vector>
using namespace std;

vector<int> shuffle(vector<int>& nums, int n) {
    vector<int> shuffled;
    for(int i = 0; i < n; ++i) {
        shuffled.push_back(nums[i]);
        shuffled.push_back(nums[i+n]);
    }
    return shuffled;
}


-----
#include<vector>
using namespace std;

vector<int> shuffle(vector<int>& nums, int n) 
    // Your code here
}


************************************
Question ID: 1583

int minCost(vector<int>& houses, vector<vector<int>>& cost, int m, int n, int target) {
    int dp[m][n][target + 1];
    memset(dp, 0x3f, sizeof(dp));

    if (houses[0] != 0) {
        dp[0][houses[0] - 1][1] = 0;
    } else {
        for (int j = 0; j < n; j++) {
            dp[0][j][1] = cost[0][j];
        }
    }

    for (int i = 1; i < m; i++)
        for (int j = 0; j < n; j++)
            for (int k = 1; k <= target; k++) {
                if (houses[i] != 0 && houses[i] != j + 1) {
                    continue;
                }
                int paint_cost = (houses[i] != 0) ? 0 : cost[i][j];

                for (int l = 0; l < n; l++) {
                    if (l == j) {
                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][l][k] + paint_cost);
                    } else {
                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][l][k - 1] + paint_cost);
                    }
                }
            }

    int ans = 1e9;
    for (int j = 0; j < n; j++) {
        ans = min(ans, dp[m - 1][j][target]);
    }
    return (ans == 1e9) ? -1 : ans;
}


-----
int minCost(vector<int>& houses, vector<vector<int>>& cost, int m, int n, int target) 
    // Your code here
}


************************************
Question ID: 1584

#include <vector>
#include <algorithm>
using namespace std;

double average(vector<int>& salary) {
    double sum = 0;
    int min_salary = *min_element(salary.begin(), salary.end());
    int max_salary = *max_element(salary.begin(), salary.end());
    for (int s : salary) {
        sum += s;
    }
    sum -= (min_salary + max_salary);
    return sum / (salary.size() - 2);
}

-----
#include <vector>
#include <algorithm>
using namespace std;

double average(vector<int>& salary) 
    // Your code here
}

************************************
Question ID: 1585

int kthFactor(int n, int k) {
    for (int i = 1; i <= n; ++i) {
        if (n % i == 0) {
            --k;
            if (k == 0) return i;
        }
    }
    return -1;
}


-----
int kthFactor(int n, int k) 
    // Your code here
}


************************************
Question ID: 1586

int findMaxLength(vector<int>& nums) {
    int max_length = 0, zeroes = 0, ones = 0;
    unordered_map<int, int> count_map;
    count_map[0] = -1;

    for(int i = 0; i < nums.size(); ++i) {
        if(nums[i] == 0)
            zeroes++;
        else
            ones++;

        if(count_map.count(zeroes - ones) == 0)
            count_map[zeroes - ones] = i;
        else
            max_length = max(max_length, i - count_map[zeroes - ones]);
    }
    return max_length;
}

-----
int findMaxLength(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1588

int sumOddLengthSubarrays(vector<int>& arr) {
    int sum = 0, n = arr.size();
    for (int i = 0; i < n; i++) {
        int oddSubarrays = ((i + 1) * (n - i) + 1) / 2;
        sum += arr[i] * oddSubarrays;
    }
    return sum;
}

-----
int sumOddLengthSubarrays(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1589

#include <algorithm>
#include <vector>
using namespace std;

const int MOD = 1000000007;

int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {
    int n = nums.size();
    vector<int> count(n, 0);
    for (auto& request : requests) {
        count[request[0]]++;
        if (request[1] + 1 < n) 
            count[request[1] + 1]--;
    }
    for (int i = 1; i < n; i++) {
        count[i] += count[i - 1];
    }
    sort(nums.begin(), nums.end());
    sort(count.begin(), count.end());
    
    long long ans = 0;
    for (int i = 0; i < n; i++) {
        ans = (ans + (long long)nums[i] * count[i]) % MOD;
    }
    return ans;
}

-----
#include <algorithm>
#include <vector>
using namespace std;

const int MOD = 1000000007;

int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) 
    // Your code here
}

************************************
Question ID: 1590

#include <vector>
#include <unordered_map>
using namespace std;

int minSubarray(vector<int>& nums, int p) {
    int n = nums.size(), res = n, need = 0, cur = 0;
    for (int num : nums)
        need = (need + num) % p;
    if (need == 0) return 0;
    unordered_map<int, int> last_seen;
    last_seen[0] = -1;
    for (int i = 0; i < n; i++) {
        cur = (cur + nums[i]) % p;
        last_seen[cur] = i;
        res = min(res, i - last_seen[(cur - need + p) % p]);
    }
    return res < n ? res : -1;
}

-----
#include <vector>
#include <unordered_map>
using namespace std;

int minSubarray(vector<int>& nums, int p) 
    // Your code here
}

************************************
Question ID: 1591

bool isPrintable(vector<vector<int>>& targetGrid) {
    unordered_map<int, vector<int>> color_bounds;
    int m = targetGrid.size(), n = targetGrid[0].size();
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            int color = targetGrid[i][j];
            if (!color_bounds.count(color)) color_bounds[color] = {i, j, i, j};
            else {
                color_bounds[color][0] = min(color_bounds[color][0], i);
                color_bounds[color][1] = min(color_bounds[color][1], j);
                color_bounds[color][2] = max(color_bounds[color][2], i);
                color_bounds[color][3] = max(color_bounds[color][3], j);
            }
        }
    }

    set<int> remaining_colors;
    for (const auto& p : color_bounds) {
        remaining_colors.insert(p.first);
    }
    while (!remaining_colors.empty()) {
        bool progress = false;
        for (auto it = remaining_colors.begin(); it != remaining_colors.end();) {
            int color = *it;
            const auto& bounds = color_bounds[color];
            bool contained = true;
            for (int i = bounds[0]; i <= bounds[2] && contained; ++i) {
                for (int j = bounds[1]; j <= bounds[3]; ++j) {
                    if (targetGrid[i][j] != color && targetGrid[i][j] != -1) {
                        contained = false;
                        break;
                    }
                }
            }
            if (contained) {
                for (int i = bounds[0]; i <= bounds[2]; ++i) {
                    for (int j = bounds[1]; j <= bounds[3]; ++j) {
                        targetGrid[i][j] = -1;
                    }
                }
                it = remaining_colors.erase(it);
                progress = true;
            } else {
                ++it;
            }
        }
        if (!progress) return false;
    }
    return true;
}

-----
bool isPrintable(vector<vector<int>>& targetGrid) 
    // Your code here
}

************************************
Question ID: 1592

#include <string>
#include <vector>
#include <sstream>

std::string reorderSpaces(std::string text) {
    int spaces = 0, words = 0;

    for (char c : text) {
        if (c == ' ') spaces++;
    }
    
    std::istringstream iss(text);
    std::vector<std::string> wordList;
    std::string word;

    while (iss >> word) {
        wordList.push_back(word);
        words++;
    }
    
    int spacesBetweenWords = words == 1 ? 0 : spaces / (words - 1);
    int extraSpaces = words == 1 ? spaces : spaces % (words - 1);
    
    std::string result;

    for (int i = 0; i < words; i++) {
        result += wordList[i];
        if (i != words - 1) {
            result.append(spacesBetweenWords, ' ');
        } else {
            result.append(extraSpaces, ' ');
        }
    }
    
    return result;
}

-----
#include <string>
#include <vector>
#include <sstream>

std::string reorderSpaces(std::string text) 
    // Your code here
}

************************************
Question ID: 1593

#include <string>
#include <unordered_set>

int maxUniqueSplit(const std::string& s, int start = 0, std::unordered_set<std::string>& seen = std::unordered_set<std::string>()) {
    if (start == s.size())
        return 0;
    int maxUnique = -1;
    for (int i = start + 1; i <= s.size(); ++i) {
        std::string sub = s.substr(start, i - start);
        if (seen.find(sub) == seen.end()) {
            seen.insert(sub);
            int unique = maxUniqueSplit(s, i, seen);
            if (unique != -1)
                maxUnique = std::max(maxUnique, unique + 1);
            seen.erase(sub);
        }
    }
    return maxUnique;
}

-----
#include <string>
#include <unordered_set>

int maxUniqueSplit(const std::string& s, int start = 0, std::unordered_set<std::string>& seen = std::unordered_set<std::string>()) 
    // Your code here
}

************************************
Question ID: 1594

int maxProductPath(vector<vector<int>>& grid) {
    int m = grid.size(), n = grid[0].size(), mod = 1e9 + 7;
    vector<vector<vector<long long>>> dp(m, vector<vector<long long>>(n, vector<long long>(2, 0)));
    dp[0][0][0] = dp[0][0][1] = grid[0][0];
    for (int i = 1; i < m; ++i) dp[i][0][0] = dp[i][0][1] = grid[i][0] * dp[i - 1][0][0];
    for (int j = 1; j < n; ++j) dp[0][j][0] = dp[0][j][1] = grid[0][j] * dp[0][j - 1][0];
    for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
            if (grid[i][j] < 0) {
                dp[i][j][0] = min(grid[i][j] * dp[i - 1][j][1], grid[i][j] * dp[i][j - 1][1]);
                dp[i][j][1] = max(grid[i][j] * dp[i - 1][j][0], grid[i][j] * dp[i][j - 1][0]);
            } else {
                dp[i][j][0] = min(grid[i][j] * dp[i - 1][j][0], grid[i][j] * dp[i][j - 1][0]);
                dp[i][j][1] = max(grid[i][j] * dp[i - 1][j][1], grid[i][j] * dp[i][j - 1][1]);
            }
        }
    }
    return dp.back().back()[1] < 0 ? -1 : dp.back().back()[1] % mod;
}

-----
int maxProductPath(vector<vector<int>>& grid) 
    // Your code here
}

************************************
Question ID: 1595

#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int connectTwoGroups(vector<vector<int>>& cost) {
    int size1 = cost.size(), size2 = cost[0].size();
    vector<int> min_cost(size2, INT_MAX);

    for (int i = 0; i < size1; i++) {
        for (int j = 0; j < size2; j++) {
            min_cost[j] = min(min_cost[j], cost[i][j]);
        }
    }

    int total_cost = 0;
    for (int i = 0; i < size1; i++) {
        total_cost += *min_element(cost[i].begin(), cost[i].end());
    }

    for (int j = 0; j < size2; j++) {
        total_cost += min_cost[j];
    }

    return total_cost;
}


-----
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int connectTwoGroups(vector<vector<int>>& cost) 
    // Your code here
}


************************************
Question ID: 1598

int minOperations(vector<string>& logs) {
    int depth = 0;
    for (const string& log : logs) {
        if (log == "../") {
            depth = max(0, depth - 1);
        } else if (log != "./") {
            depth += 1;
        }
    }
    return depth;
}

-----
int minOperations(vector<string>& logs) 
    // Your code here
}

************************************
Question ID: 1599

int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {
    int waiting = 0;
    int profit = 0;
    int max_profit = 0;
    int rotations = 0;
    int result = -1;

    for (int i = 0; i < customers.size() || waiting > 0; ++i) {
        if (i < customers.size()) {
            waiting += customers[i];
        }
        int boarding = min(waiting, 4);
        waiting -= boarding;
        profit += boarding * boardingCost - runningCost;

        if (profit > max_profit) {
            max_profit = profit;
            result = rotations + 1;
        }
        rotations++;
    }
    return result;
}


-----
int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) 
    // Your code here
}


************************************
Question ID: 1601

#include <vector>

int maximumRequests(int n, std::vector<std::vector<int>>& requests) {
    int req_size = requests.size();
    int max_requests = 0;

    for (int i = 0; i < (1 << req_size); ++i) {
        std::vector<int> net_transfers(n, 0);
        int count = 0;

        for (int j = 0; j < req_size; ++j) {
            if (i & (1 << j)) {
                net_transfers[requests[j][0]]--;
                net_transfers[requests[j][1]]++;
                count++;
            }
        }

        bool valid = true;
        for (int val : net_transfers) {
            if (val) {
                valid = false;
                break;
            }
        }

        if (valid)
            max_requests = std::max(max_requests, count);
    }

    return max_requests;
}

-----
#include <vector>

int maximumRequests(int n, std::vector<std::vector<int>>& requests) 
    // Your code here
}

************************************
Question ID: 1603

vector<int> runningSum(vector<int>& nums) {
    for (int i = 1; i < nums.size(); i++) {
        nums[i] += nums[i - 1];
    }
    return nums;
}

-----
vector<int> runningSum(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1604

#include <vector>
#include <unordered_map>
#include <queue>
#include <algorithm>

int findLeastNumOfUniqueInts(std::vector<int> &arr, int k) {
    std::unordered_map<int, int> freqMap;
    for(int n : arr) {
        freqMap[n]++;
    }

    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;
    for (const auto &it : freqMap) {
        minHeap.push(it.second);
    }
    
    while (k > 0) {
        k -= minHeap.top();
        minHeap.pop();
    }

    return k == 0 ? minHeap.size() : minHeap.size() + 1;
}

-----
#include <vector>
#include <unordered_map>
#include <queue>
#include <algorithm>

int findLeastNumOfUniqueInts(std::vector<int> &arr, int k) 
    // Your code here
}

************************************
Question ID: 1605

int minDays(vector<int>& bloomDay, int m, int k) {
    int left = *min_element(bloomDay.begin(), bloomDay.end());
    int right = *max_element(bloomDay.begin(), bloomDay.end());

    while (left < right) {
        int mid = left + (right - left) / 2;
        int bouquets = 0, flowers = 0;
        for (int day : bloomDay) {
            if (day > mid) {
                flowers = 0;
            } else {
                flowers++;
                if (flowers == k) {
                    bouquets++;
                    flowers = 0;
                }
            }
        }
        if (bouquets >= m) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return m == 0 ? -1 : left;
}

-----
int minDays(vector<int>& bloomDay, int m, int k) 
    // Your code here
}

************************************
Question ID: 1606

#include <vector>
using namespace std;

vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {
    vector<int> server_status(k, -1); // -1 means available
    vector<int> server_request_count(k, 0);

    for (int i = 0; i < arrival.size(); i++) {
        int index = i % k;
        for (int j = 0; j < k; j++) {
            if (server_status[index] <= arrival[i]) {
                server_status[index] = arrival[i] + load[i];
                server_request_count[index]++;
                break;
            }
            index = (index + 1) % k;
        }
    }

    int max_requests = *max_element(server_request_count.begin(), server_request_count.end());
    vector<int> busiest_servers;
    for (int i = 0; i < k; i++) {
        if (server_request_count[i] == max_requests) {
            busiest_servers.push_back(i);
        }
    }
    return busiest_servers;
}

-----
#include <vector>
using namespace std;

vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) 
    // Your code here
}

************************************
Question ID: 1608

int specialArray(vector<int>& nums) {
    int max_val = *max_element(nums.begin(), nums.end());
    for (int x = 1; x <= max_val; ++x) {
        int count = 0;
        for (int num : nums) {
            if (num >= x) count++;
        }
        if (count == x) return x;
    }
    return -1;
}

-----
int specialArray(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1609

#include <queue>

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
};

bool isEvenOddTree(TreeNode* root) {
    if (!root) return false;
    
    queue<TreeNode*> q;
    q.push(root);
    int level = 0;
    
    while (!q.empty()) {
        int size = q.size();
        int prevVal = (level % 2 == 0) ? 0 : 1e6 + 1;
        
        for (int i = 0; i < size; ++i) {
            TreeNode* curr = q.front();
            q.pop();
            
            if ((level % 2 == 0 && (curr->val % 2 == 0 || curr->val <= prevVal)) || 
                (level % 2 != 0 && (curr->val % 2 != 0 || curr->val >= prevVal))) {
                return false;
            }
            
            prevVal = curr->val;
            
            if (curr->left) q.push(curr->left);
            if (curr->right) q.push(curr->right);
        }
        
        level++;
    }
    
    return true;
}

-----
#include <queue>

struct TreeNode 
    // Your code here
}

************************************
Question ID: 1610

int xorOperation(int n, int start) {
    int xor_result = 0;
    for (int i = 0; i < n; ++i) {
        xor_result ^= (start + 2 * i);
    }
    return xor_result;
}

-----
int xorOperation(int n, int start) 
    // Your code here
}

************************************
Question ID: 1611

#include <vector>
#include <string>
#include <unordered_map>

std::vector<std::string> getFolderNames(std::vector<std::string> &names) {
    std::unordered_map<std::string, int> nameCount;
    std::vector<std::string> ans;

    for (const auto &name : names) {
        if (nameCount[name] == 0) {
            ans.push_back(name);
            nameCount[name] = 1;
        } else {
            int k = nameCount[name];
            while (nameCount[name + "(" + std::to_string(k) + ")"] != 0) {
                k++;
            }
            ans.push_back(name + "(" + std::to_string(k) + ")");
            nameCount[name + "(" + std::to_string(k) + ")"] = 1;
            nameCount[name] = k + 1;
        }
    }

    return ans;
}

-----
#include <vector>
#include <string>
#include <unordered_map>

std::vector<std::string> getFolderNames(std::vector<std::string> &names) 
    // Your code here
}

************************************
Question ID: 1612

#include <vector>
#include <set>
#include <unordered_map>

std::vector<int> avoidFlood(std::vector<int>& rains) {
    std::vector<int> res(rains.size(), -1);
    std::unordered_map<int, int> filled_lakes;
    std::set<int> dry_days;

    for (int i = 0; i < rains.size(); ++i) {
        if (rains[i] == 0) {
            dry_days.insert(i);
        } else {
            int lake = rains[i];
            if (filled_lakes.count(lake)) {
                auto it = dry_days.lower_bound(filled_lakes[lake]);
                if (it == dry_days.end()) return {};
                res[*it] = lake;
                dry_days.erase(it);
            }
            filled_lakes[lake] = i;
        }
    }
    
    for (int day : dry_days) {
        res[day] = 1;
    }

    return res;
}


-----
#include <vector>
#include <set>
#include <unordered_map>

std::vector<int> avoidFlood(std::vector<int>& rains) 
    // Your code here
}


************************************
Question ID: 1614

int maxDepth(std::string s) {
    int depth = 0, max_depth = 0;

    for (char c : s) {
        if (c == '(') {
            depth++;
            max_depth = std::max(depth, max_depth);
        } else if (c == ')') {
            depth--;
        }
    }

    return max_depth;
}

-----
int maxDepth(std::string s) 
    // Your code here
}

************************************
Question ID: 1615

int rangeSum(vector<int>& nums, int n, int left, int right) {
    const int MOD = 1e9 + 7;
    vector<int> sums(n * (n + 1) / 2);
    int index = 0;
    for (int i = 0; i < n; ++i) {
        int sum = 0;
        for (int j = i; j < n; ++j) {
            sum += nums[j];
            sums[index++] = sum;
        }
    }
    sort(sums.begin(), sums.end());
    int result = 0;
    for (int i = left - 1; i < right; ++i) {
        result = (result + sums[i]) % MOD;
    }
    return result;
}

-----
int rangeSum(vector<int>& nums, int n, int left, int right) 
    // Your code here
}

************************************
Question ID: 1616

#include <algorithm>
#include <vector>

int min_difference(std::vector<int>& nums) {
    int size = nums.size();
    if (size < 5) return 0;

    std::sort(nums.begin(), nums.end());

    return std::min({nums[size-1] - nums[3], nums[size-2] - nums[2], nums[size-3] - nums[1], nums[size-4] - nums[0]});
}

-----
#include <algorithm>
#include <vector>

int min_difference(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1617

bool winnerSquareGame(int n) {
    vector<bool> dp(n + 1, false);
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j * j <= i; ++j) {
            if (!dp[i - j * j]) {
                dp[i] = true;
                break;
            }
        }
    }
    return dp[n];
}

-----
bool winnerSquareGame(int n) 
    // Your code here
}

************************************
Question ID: 1618

int maxFontSize(string text, int w, int h, vector<int>& fonts, FontInfo fontInfo) {
    int left = 0, right = fonts.size() - 1, mid, ans = -1;
    while (left <= right) {
        mid = left + (right - left) / 2;
        int fontSize = fonts[mid];
        int width = 0, height = fontInfo.getHeight(fontSize);
        for (char ch : text)
            width += fontInfo.getWidth(fontSize, ch);
        if (width <= w && height <= h) {
            ans = fontSize;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return ans;
}

-----
int maxFontSize(string text, int w, int h, vector<int>& fonts, FontInfo fontInfo) 
    // Your code here
}

************************************
Question ID: 1619

bool isPathCrossing(string path) {
    set<pair<int, int>> visited;
    int x = 0, y = 0;
    visited.insert({x, y});
    for (char dir : path) {
        if (dir == 'N') y++;
        else if (dir == 'S') y--;
        else if (dir == 'E') x++;
        else if (dir == 'W') x--;
        if (visited.count({x, y})) return true;
        visited.insert({x, y});
    }
    return false;
}

-----
bool isPathCrossing(string path) 
    // Your code here
}

************************************
Question ID: 1620

bool canArrange(vector<int>& arr, int k) {
    vector<int> counts(k, 0);
    for (int num : arr) {
        counts[(num % k + k) % k]++;
    }
    if (counts[0] % 2 != 0) {
        return false;
    }
    for (int i = 1; i <= k / 2; i++) {
        if (counts[i] != counts[k - i]) {
            return false;
        }
    }
    return true;
}

-----
bool canArrange(vector<int>& arr, int k) 
    // Your code here
}

************************************
Question ID: 1621

#include <algorithm>
#include <vector>

int numSubseq(std::vector<int>& nums, int target) {
    int n = nums.size();
    int mod = 1e9 + 7;

    std::sort(nums.begin(), nums.end());

    std::vector<long long> power(n, 1);
    for (int i = 1; i < n; ++i) {
        power[i] = (power[i - 1] * 2) % mod;
    }

    int ans = 0;
    int r = n;
    for (int l = 0; l < n; ++l) {
        while (r > l && nums[l] + nums[r - 1] > target) {
            --r;
        }

        ans = (ans + power[r - l]) % mod;
    }

    return ans;
}


-----
#include <algorithm>
#include <vector>

int numSubseq(std::vector<int>& nums, int target) 
    // Your code here
}


************************************
Question ID: 1622

#include <vector>
using namespace std;

int findMaxValueOfEquation(vector<vector<int>>& points, int k) {
    int res = INT_MIN, left = 0;
    vector<pair<int, int>> q;
    
    for (auto& p : points) {
        while (!q.empty() && p[0] - q.front().second > k)
            q.erase(q.begin());
        
        if (!q.empty())
            res = max(res, p[1] + p[0] + q.front().first);
        
        while (!q.empty() && p[1] - p[0] >= q.back().first)
            q.pop_back();

        q.emplace_back(p[1] - p[0], p[0]);
    }
    
    return res;
}

-----
#include <vector>
using namespace std;

int findMaxValueOfEquation(vector<vector<int>>& points, int k) 
    // Your code here
}

************************************
Question ID: 1624

int maxLengthBetweenEqualCharacters(std::string s) {
    int result = -1;
    std::unordered_map<char, int> char_map;

    for (int i = 0; i < s.length(); ++i) {
        if (char_map.find(s[i]) == char_map.end()) {
            char_map[s[i]] = i;
        } else {
            result = std::max(result, i - char_map[s[i]] - 1);
        }
    }
    return result;
}

-----
int maxLengthBetweenEqualCharacters(std::string s) 
    // Your code here
}

************************************
Question ID: 1625

#include <string>
#include <algorithm>

std::string findLexSmallestString(std::string s, int a, int b) {
    std::string smallest = s;
    int len = s.length();
    std::string rotated;

    for (int i = 0; i < len; i += 2) {
        for (int j = 0; j < 10; ++j) {
            rotated = s.substr(len - b) + s.substr(0, len - b);
            std::string tmp = rotated;

            for (int k = 1; k < len; k += 2)
                tmp[k] = '0' + (tmp[k] - '0' + a) % 10;

            smallest = std::min(smallest, tmp);
            s = rotated;
        }
        s[len - i - 1] = '0' + (s[len - i - 1] - '0' + a) % 10;
    }

    return smallest;
}

-----
#include <string>
#include <algorithm>

std::string findLexSmallestString(std::string s, int a, int b) 
    // Your code here
}

************************************
Question ID: 1626

#include <algorithm>
#include <vector>
using namespace std;

bool canMakeArithmeticProgression(vector<int>& arr) {
    sort(arr.begin(), arr.end());
    int difference = arr[1] - arr[0];
    for (int i = 2; i < arr.size(); i++) {
        if (arr[i] - arr[i - 1] != difference) {
            return false;
        }
    }
    return true;
}

-----
#include <algorithm>
#include <vector>
using namespace std;

bool canMakeArithmeticProgression(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1627

int lastMoment(int n, vector<int>& left, vector<int>& right) {
    int max_left = 0;
    int min_right = n;

    for(int position : left) {
        max_left = max(max_left, position);
    }

    for(int position : right) {
        min_right = min(min_right, position);
    }

    return max(max_left, n - min_right);
}

-----
int lastMoment(int n, vector<int>& left, vector<int>& right) 
    // Your code here
}

************************************
Question ID: 1628

int numSubmat(vector<vector<int>>& mat) {
    int m = mat.size(), n = mat[0].size();
    vector<vector<int>> dp(m, vector<int>(n));
    int count = 0;

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (mat[i][j] == 1) {
                dp[i][j] = (j == 0) ? 1 : dp[i][j - 1] + 1;
                int minWidth = dp[i][j];
                for (int k = i; k >= 0; k--) {
                    minWidth = min(minWidth, dp[k][j]);
                    count += minWidth;
                }
            }
        }
    }
    return count;
}

-----
int numSubmat(vector<vector<int>>& mat) 
    // Your code here
}

************************************
Question ID: 1629

#include <string>
using namespace std;

string minInteger(string num, int k) {
    if (k == 0) return num;
    int n = num.size();
    for (int i = 0; i < n; ++i) {
        int idx = i;
        for (int j = i + 1; j < n && j - i <= k; ++j) {
            if (num[j] < num[idx]) {
                idx = j;
            }
        }
        char minDigit = num[idx];
        for (int j = idx; j > i; --j) {
            num[j] = num[j - 1];
        }
        num[i] = minDigit;
        k -= idx - i;
    }
    return num;
}

-----
#include <string>
using namespace std;

string minInteger(string num, int k) 
    // Your code here
}

************************************
Question ID: 1630

int countOdds(int low, int high) {
    return (high + 1) / 2 - low / 2;
}

-----
int countOdds(int low, int high) 
    // Your code here
}

************************************
Question ID: 1631

int numOfSubarrays(vector<int>& arr) {
    int odd = 0, even = 1, sum = 0, result = 0;
    int mod = 1e9 + 7;
    for (int x : arr) {
        sum = (sum + x) % 2;
        if (sum % 2 == 0) {
            even++;
        } else {
            odd++;
        }
        result = (result + odd) % mod;
    }
    return result;
}

-----
int numOfSubarrays(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1632

#include <unordered_set>
#include <string>
using namespace std;

int numSplits(string s) {
    unordered_set<char> left_set, right_set;
    vector<int> left(s.size()), right(s.size());
    int count = 0;

    for (int i = 0; i < s.size(); ++i) {
        left_set.insert(s[i]);
        left[i] = left_set.size();
    }

    for (int i = s.size() - 1; i > 0; --i) {
        right_set.insert(s[i]);
        right[i] = right_set.size();
    }

    for (int i = 0; i < s.size() - 1; ++i) {
        if (left[i] == right[i + 1]) {
            ++count;
        }
    }

    return count;
}

-----
#include <unordered_set>
#include <string>
using namespace std;

int numSplits(string s) 
    // Your code here
}

************************************
Question ID: 1636

int numSub(string s) {
    int mod = 1000000007;
    long long result = 0;
    int count = 0;
    for (char c : s) {
        count = (c == '1') ? count + 1 : 0;
        result = (result + count) % mod;
    }
    return result;
}

-----
int numSub(string s) 
    // Your code here
}

************************************
Question ID: 1637

#include <vector>
#include <string>

int min_length_encoded(const std::string& s, int k) {
    int n = s.length();
    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(k + 1, 0));

    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= k; ++j) {
            int cnt = 1;
            dp[i][j] = i - j;
            for (int l = i - 2; l >= 0 && i - 2 - l <= j; --l) {
                if (s[l] == s[i - 1]) cnt++;
                else cnt = 1;
                int used = i - 2 - l;
                int new_aposition = i - 1 - cnt - used + 1;
                if (cnt >= 100) new_aposition += 4;
                else if (cnt >= 10) new_aposition += 3;
                else if (cnt >= 2) new_aposition += 2;
                else new_aposition++;
                dp[i][j] = std::min(dp[i][j], new_aposition + dp[l][j - used]);
            }
        }
    }
    return dp[n][k];
}

-----
#include <vector>
#include <string>

int min_length_encoded(const std::string& s, int k) 
    // Your code here
}

************************************
Question ID: 1638

#include <vector>
#include <algorithm>
#include <cmath>

double getMinDistSum(std::vector<std::vector<int>>& positions) {
    double x = 0;
    double y = 0;
    for (const auto& pos : positions) {
        x += pos[0];
        y += pos[1];
    }
    int n = positions.size();
    x /= n;
    y /= n;
    return x;
}

-----
#include <vector>
#include <algorithm>
#include <cmath>

double getMinDistSum(std::vector<std::vector<int>>& positions) 
    // Your code here
}

************************************
Question ID: 1639

#include <vector>
#include <string>
#include <unordered_map>

using namespace std;

int numWays(vector<string>& words, string target) {
    int n = words.size(), m = target.size();
    vector<vector<int>> count(n, vector<int>(26, 0));
    vector<vector<int>> dp(m, vector<int>(n, 0));
    const int mod = 1e9 + 7;

    for(int i = 0; i < n; i++) {
        for(char c : words[i]) {
            count[i][c - 'a']++;
        }
    }

    for(int i = 0; i < n; i++) {
        dp[0][i] = count[i][target[0] - 'a'];
    }

    for(int i = 1; i < m; i++) {
        for(int j = 0; j < n; j++) {
            for(int k = 0; k < n; k++) {
                dp[i][j] = (dp[i][j] + (long long)dp[i-1][k] * count[j][target[i] - 'a']) % mod;
            }
        }
    }

    int res = 0;
    for(int i = 0; i < n; i++) {
        res = (res + dp[m-1][i]) % mod;
    }
    return res;
}

-----
#include <vector>
#include <string>
#include <unordered_map>

using namespace std;

int numWays(vector<string>& words, string target) 
    // Your code here
}

************************************
Question ID: 1640

#include <vector>
#include <unordered_map>

bool canFormArray(std::vector<int>& arr, std::vector<std::vector<int>>& pieces) {
    std::unordered_map<int, std::vector<int>> map;
    for (auto& piece : pieces) {
        map[piece[0]] = piece;
    }

    int i = 0;
    while (i < arr.size()) {
        if (map.find(arr[i]) == map.end()) {
            return false;
        }
        std::vector<int>& piece = map[arr[i]];
        for (int j = 0; j < piece.size(); ++j) {
            if (piece[j] != arr[i]) {
                return false;
            }
            ++i;
        }
    }
    return true;
}


-----
#include <vector>
#include <unordered_map>

bool canFormArray(std::vector<int>& arr, std::vector<std::vector<int>>& pieces) 
    // Your code here
}


************************************
Question ID: 1641

int countVowelStrings(int n) {
    vector<int> dp = {1, 1, 1, 1, 1};
    for (int i = 2; i <= n; i++) {
        for (int j = 3; j >= 0; j--) {
            dp[j] = dp[j] + dp[j + 1];
        }
    }
    return accumulate(dp.begin(), dp.end(), 0);
}

-----
int countVowelStrings(int n) 
    // Your code here
}

************************************
Question ID: 1642

int maxWaterBottles(int numBottles, int numExchange) {
    int total = numBottles;
    while (numBottles >= numExchange) {
        int newBottles = numBottles / numExchange;
        total += newBottles;
        numBottles = newBottles + numBottles % numExchange;
    }
    return total;
}

-----
int maxWaterBottles(int numBottles, int numExchange) 
    // Your code here
}

************************************
Question ID: 1643

#include <vector>
#include <string>

using namespace std;

void dfs(int node, const vector<vector<int>>& g, const string& labels, vector<int>& ans, vector<int> &count) {
    int pre = count[labels[node] - 'a'];
    count[labels[node] - 'a']++;
    ans[node] = count[labels[node] - 'a'] - pre;
    
    for (auto child : g[node]) {
        dfs(child, g, labels, ans, count);
    }
    
    count[labels[node] - 'a'] = pre;
}

vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {
    vector<vector<int>> g(n);
    for (const auto& edge : edges) {
        g[edge[1]].push_back(edge[0]);
    }
    vector<int> ans(n);
    vector<int> count(26);
    dfs(0, g, labels, ans, count);
    
    return ans;
}

-----
#include <vector>
#include <string>

using namespace std;

void dfs(int node, const vector<vector<int>>& g, const string& labels, vector<int>& ans, vector<int> &count) 
    // Your code here
}

************************************
Question ID: 1644

std::vector<std::string> maxNumOfSubstrings(std::string s) {
    std::vector<int> last(26, -1);
    for (int i = 0; i < (int)s.size(); ++i) {
        last[s[i] - 'a'] = i;
    }
    
    std::vector<std::string> res;
    int pre = -1, maxRight = -1;
    for (int i = 0; i < (int)s.size(); ++i) {
        maxRight = std::max(maxRight, last[s[i] - 'a']);
        if (maxRight == i) {
            res.push_back(s.substr(pre + 1, maxRight - pre));
            pre = i;
        }
    }
    
    return res;
}

-----
std::vector<std::string> maxNumOfSubstrings(std::string s) 
    // Your code here
}

************************************
Question ID: 1646

int findKthPositive(vector<int>& arr, int k) {
    int i = 0, num = 1;
    while (k > 0) {
        if (i < arr.size() && arr[i] == num) {
            i++;
        } else {
            k--;
        }
        num++;
    }
    return num - 1;
}

-----
int findKthPositive(vector<int>& arr, int k) 
    // Your code here
}

************************************
Question ID: 1647

#include <cmath>

bool canConvert(std::string s, std::string t, int k) {
    int diff = 0;
    for (int i = 0; i < s.length(); i++) {
        int curr_diff = (t[i] - s[i] + 26) % 26;
        if (curr_diff > 0) {
            diff += curr_diff;
            k -= curr_diff;
        }
    }
    return k >= 0 && k >= diff - s.length() && k % 26 == 0;
}

-----
#include <cmath>

bool canConvert(std::string s, std::string t, int k) 
    // Your code here
}

************************************
Question ID: 1648

int minInsertions(string s) {
    int ans = 0, depth = 0;
    for (int i = 0; i < s.size(); ++i) {
        if (s[i] == '(') {
            depth += 2;
        } else {
            if (s[i-1] == '(') {
                --depth;
            } else {
                depth -= 2;
            }
            if (depth < 0) {
                ans -= depth;
                depth = 0;
            }
        }
    }
    return ans + depth;
}

-----
int minInsertions(string s) 
    // Your code here
}

************************************
Question ID: 1649

#include <vector>
#include <unordered_map>

int maxNonOverlapping(std::vector<int>& nums, int target) {
    int sum = 0, count = 0;
    std::unordered_map<int, int> umap;
    umap[0] = 1;
    for (int num : nums) {
        sum += num;
        if (umap[sum - target]) {
            count++;
            umap.clear();
            umap[0] = 1;
            sum = 0;
        } else {
            umap[sum]++;
        }
    }
    return count;
}


-----
#include <vector>
#include <unordered_map>

int maxNonOverlapping(std::vector<int>& nums, int target) 
    // Your code here
}


************************************
Question ID: 1652

int minOperations(string target) {
    int operations = 0;
    char current_bit = '0';
    for (char bit : target) {
        if (bit != current_bit) {
            operations++;
            current_bit = bit;
        }
    }
    return operations;
}

-----
int minOperations(string target) 
    // Your code here
}

************************************
Question ID: 1653

int dfs(TreeNode* root, int distance, vector<int>& depths) {
    if (!root) return 0;
    if (!root->left && !root->right) {
        depths.push_back(0);
        return 1;
    }
    vector<int> left, right;
    int count = dfs(root->left, distance, left) + dfs(root->right, distance, right);
    for (int l : left) {
        for (int r : right) {
            if (l + r + 2 <= distance) count++;
        }
    }
    for (int l : left) depths.push_back(l + 1);
    for (int r : right) depths.push_back(r + 1);
    return count;
}

int countPairs(TreeNode* root, int distance) {
    vector<int> depths;
    return dfs(root, distance, depths);
}

-----
int dfs(TreeNode* root, int distance, vector<int>& depths) 
    // Your code here
}

************************************
Question ID: 1654

#include <vector>
#include <set>
#include <queue>
#include <utility>

int minimumJumps(std::vector<int>& forbidden, int a, int b, int x) {
    std::set<std::pair<int, int>> visited;
    std::set<int> forbidden_positions(forbidden.begin(), forbidden.end());
    std::queue<std::pair<int, std::pair<int, int>>> q;
    q.push({0, {0, 0}});
    visited.insert({0, 0});
    while (!q.empty()) {
        auto [pos, step_status] = q.front(); q.pop();
        int steps = step_status.first;
        int backward = step_status.second;
        if (pos == x) return steps;
        int forward_pos = pos + a;
        int backward_pos = pos - b;
        if (forward_pos <= 6000 && !forbidden_positions.count(forward_pos) && !visited.count({forward_pos, 0})) {
            visited.insert({forward_pos, 0});
            q.push({forward_pos, {steps + 1, 0}});
        }
        if (backward == 0 && backward_pos > 0 && !forbidden_positions.count(backward_pos) && !visited.count({backward_pos, 1})) {
            visited.insert({backward_pos, 1});
            q.push({backward_pos, {steps + 1, 1}});
        }
    }
    return -1;
}

-----
#include <vector>
#include <set>
#include <queue>
#include <utility>

int minimumJumps(std::vector<int>& forbidden, int a, int b, int x) 
    // Your code here
}

************************************
Question ID: 1655

#include <vector>
#include <unordered_map>
#include <algorithm>

bool canDistribute(std::vector<int>& nums, std::vector<int>& quantity) {
    std::unordered_map<int, int> counts;
    for (int num : nums) {
        counts[num]++;
    }

    std::vector<int> values;
    for (auto& p : counts) {
        values.push_back(p.second);
    }
    
    std::sort(quantity.begin(), quantity.end(), std::greater<int>());

    function<bool(int, vector<int>&)> dfs = [&](int index, vector<int>& values) {
        if (index == quantity.size()) {
            return true;
        }
        for (int i = 0; i < values.size(); ++i) {
            if (values[i] >= quantity[index]) {
                values[i] -= quantity[index];
                if (dfs(index + 1, values)) return true;
                values[i] += quantity[index];
            }
        }
        return false;
    };

    return dfs(0, values);
}


-----
#include <vector>
#include <unordered_map>
#include <algorithm>

bool canDistribute(std::vector<int>& nums, std::vector<int>& quantity) 
    // Your code here
}


************************************
Question ID: 1656

int countGoodTriplets(vector<int>& arr, int a, int b, int c) {
    int count = 0;
    for (int i = 0; i < arr.size(); i++) {
        for (int j = i + 1; j < arr.size(); j++) {
            if (abs(arr[i] - arr[j]) <= a) {
                for (int k = j + 1; k < arr.size(); k++) {
                    if (abs(arr[j] - arr[k]) <= b && abs(arr[i] - arr[k]) <= c) {
                        count++;
                    }
                }
            }
        }
    }
    return count;
}


-----
int countGoodTriplets(vector<int>& arr, int a, int b, int c) 
    // Your code here
}


************************************
Question ID: 1657

int getWinner(vector<int>& arr, int k) {
    int winner = arr[0];
    int consecutive_wins = 0;

    for (int i = 1; i < arr.size(); ++i) {
        if (arr[i] > winner) {
            winner = arr[i];
            consecutive_wins = 0;
        }
        if (++consecutive_wins == k) {
            break;
        }
    }
    return winner;
}

-----
int getWinner(vector<int>& arr, int k) 
    // Your code here
}

************************************
Question ID: 1658

int minSwaps(std::vector<std::vector<int>>& grid) {
    int n = grid.size();
    std::vector<int> row_zeros(n, 0);
    
    for (int i = 0; i < n; ++i) {
        for (int j = n - 1; j >= 0; --j) {
            if (grid[i][j] == 0) {
                row_zeros[i]++;
            } else {
                break;
            }
        }
    }
    
    int steps = 0;
    for (int i = 0; i < n; ++i) {
        int target = n - i - 1;
        int current_row = i;
        while (current_row < n && row_zeros[current_row] < target) {
            current_row++;
        }
        if (current_row == n) {
            return -1;
        }
        steps += current_row - i;
        row_zeros.erase(row_zeros.begin() + current_row);
        row_zeros.insert(row_zeros.begin() + i, target);
    }
    return steps;
}

-----
int minSwaps(std::vector<std::vector<int>>& grid) 
    // Your code here
}

************************************
Question ID: 1659

#include <vector>
#include <set>
using namespace std;

int maxSum(vector<int>& nums1, vector<int>& nums2) {
    int mod = 1e9 + 7;
    int m = nums1.size(), n = nums2.size();
    long dp1[m + 1] = {0}, dp2[n + 1] = {0};
    int i = m - 1, j = n - 1;
    while (i >= 0 || j >= 0) {
        long a = i >= 0 ? dp1[i] + nums1[i] : LONG_MIN;
        long b = j >= 0 ? dp2[j] + nums2[j] : LONG_MIN;
        set<int> seen;
        if (a > b) {
            dp1[i--] = a % mod;
            seen.insert(nums1[i + 1]);
        } else {
            dp2[j--] = b % mod;
            seen.insert(nums2[j + 1]);
        }
    }
    return max(dp1[0], dp2[0]) % mod;
}

-----
#include <vector>
#include <set>
using namespace std;

int maxSum(vector<int>& nums1, vector<int>& nums2) 
    // Your code here
}

************************************
Question ID: 1660

#include <string>

std::string thousandSeparator(int n) {
    std::string result = std::to_string(n);
    int count = 0;
    for (int i = result.size() - 1; i > 0; --i) {
        count++;
        if (count % 3 == 0) {
            result.insert(i, ".");
        }
    }
    return result;
}

-----
#include <string>

std::string thousandSeparator(int n) 
    // Your code here
}

************************************
Question ID: 1662

int minNumOperations(vector<int>& nums) {
    int result = 0;
    int highestBit[32] = {0};
    for (int num : nums) {
        for (int j = 0; j < 32; ++j) {
            if (num & (1 << j)) {
                highestBit[j]++;
            }
        }
    }
    for (int count : highestBit) {
        result = max(result, count);
    }
    return result + 31;
}

-----
int minNumOperations(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1663

#include <vector>
using namespace std;

bool dfs(vector<vector<char>>& grid, int x, int y, int startX, int startY, int depth) {
    if (x < 0 || y < 0 || x >= grid.size() || y >= grid[0].size() || grid[x][y] != grid[startX][startY])
        return false;

    grid[x][y] = '*';

    static vector<vector<int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    for (auto& direction : directions) {
        int newX = x + direction[0];
        int newY = y + direction[1];

        if (newX == startX && newY == startY && depth >= 4) return true;

        if (dfs(grid, newX, newY, startX, startY, depth + 1)) return true;
    }

    grid[x][y] = grid[startX][startY];

    return false;
}

bool containsCycle(vector<vector<char>>& grid) {
    for (int i = 0; i < grid.size(); ++i) {
        for (int j = 0; j < grid[0].size(); ++j) {
            if (dfs(grid, i, j, i, j, 0)) return true;
        }
    }
    return false;
}

-----
#include <vector>
using namespace std;

bool dfs(vector<vector<char>>& grid, int x, int y, int startX, int startY, int depth) 
    // Your code here
}

************************************
Question ID: 1664

int numberOfFairs(int* nums, int numsSize) {
    int even_sum = 0, odd_sum = 0, l_even = 0, l_odd = 0, count = 0;
    for (int i = 0; i < numsSize; ++i) {
        if (i % 2 == 0) even_sum += nums[i];
        else odd_sum += nums[i];
    }
    for (int i = 0; i < numsSize; ++i) {
        if (i % 2 == 0) {
            even_sum -= nums[i];
            if (l_even + odd_sum == l_odd + even_sum) ++count;
            l_even += nums[i];
        } else {
            odd_sum -= nums[i];
            if (l_even + odd_sum == l_odd + even_sum) ++count;
            l_odd += nums[i];
        }
    }
    return count;
}

-----
int numberOfFairs(int* nums, int numsSize) 
    // Your code here
}

************************************
Question ID: 1665

int minimumEffort(vector<vector<int>>& tasks) {
    sort(tasks.begin(), tasks.end(), [](vector<int>& a, vector<int>& b) {
        return a[1] - a[0] > b[1] - b[0];
    });
    int ans = 0, sum = 0;
    for (auto& task : tasks) {
        ans = max(ans, sum + task[1]);
        sum += task[0];
    }
    return ans;
}

-----
int minimumEffort(vector<vector<int>>& tasks) 
    // Your code here
}

************************************
Question ID: 1666

#include <string>

std::string makeGood(std::string s) {
    std::string result;
    for (char c : s) {
        if (!result.empty() && abs(result.back() - c) == 32) {
            result.pop_back();
        } else {
            result.push_back(c);
        }
    }
    return result;
}


-----
#include <string>

std::string makeGood(std::string s) 
    // Your code here
}


************************************
Question ID: 1668

int longestAwesomeSubstring(std::string s) {
    int n = s.length();
    int maxLen = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j <= n; ++j) {
            std::string substr = s.substr(i, j - i);
            if (isAwesome(substr)) {
                maxLen = std::max(maxLen, j - i);
            }
        }
    }
    return maxLen;
}

bool isAwesome(std::string s) {
    int odd_count = 0;
    int freq[26] = {0};
    for (char c : s) {
        freq[c - 'a']++;
    }
    for (int i = 0; i < 26; i++) {
        if (freq[i] % 2 == 1) {
            odd_count++;
        }
    }
    return (odd_count <= 1);
}

-----
int longestAwesomeSubstring(std::string s) 
    // Your code here
}

************************************
Question ID: 1669

#include <vector>
#include <algorithm>
#include <limits.h>

int minCost(int n, std::vector<int>& cuts) {
    cuts.push_back(0);
    cuts.push_back(n);
    std::sort(cuts.begin(), cuts.end());
    int size = cuts.size();
    std::vector<std::vector<int>> dp(size, std::vector<int>(size, 0));

    for (int len = 2; len < size; ++len) {
        for (int i = 0; i < size - len; ++i) {
            int j = i + len;
            dp[i][j] = INT_MAX;
            for (int k = i + 1; k < j; ++k) {
                dp[i][j] = std::min(dp[i][j], dp[i][k] + dp[k][j] + cuts[j] - cuts[i]);
            }
        }
    }

    return dp[0][size - 1];
}

-----
#include <vector>
#include <algorithm>
#include <limits.h>

int minCost(int n, std::vector<int>& cuts) 
    // Your code here
}

************************************
Question ID: 1670

#include <deque>
using namespace std;

class FrontMiddleBackQueue {
    deque<int> first, second;
public:
    FrontMiddleBackQueue() {
        
    }
    
    void pushFront(int val) {
        first.push_front(val);
        if (first.size() > second.size() + 1) {
            second.push_front(first.back());
            first.pop_back();
        }
    }
    
    void pushMiddle(int val) {
        if (first.size() < second.size()) {
            first.push_back(val);
        } else {
            second.push_front(val);
        }
    }
    
    void pushBack(int val) {
        second.push_back(val);
        if (second.size() > first.size()) {
            first.push_back(second.front());
            second.pop_front();
        }
    }
    
    int popFront() {
        if (first.empty() && second.empty()) return -1;
        int val = first.front();
        first.pop_front();
        if (first.size() + 1 < second.size()) {
            first.push_back(second.front());
            second.pop_front();
        }
        return val;
    }
    
    int popMiddle() {
        if (first.empty() && second.empty()) return -1;
        int val;
        if (first.size() < second.size()) {
            val = second.front();
            second.pop_front();
        } else {
            val = first.back();
            first.pop_back();
        }
        if (second.size() > first.size()) {
            first.push_back(second.front());
            second.pop_front();
        }
        return val;
    }
    
    int popBack() {
        if (first.empty() && second.empty()) return -1;
        int val = second.back();
        second.pop_back();
        if (first.size() > second.size() + 1) {
            second.push_front(first.back());
            first.pop_back();
        }
        return val;
    }
};

-----
#include <deque>
using namespace std;

class FrontMiddleBackQueue 
    // Your code here
};

************************************
Question ID: 1671

int minimumMountainRemovals(vector<int>& nums) {
    int n = nums.size();
    vector<int> left(n), right(n);
    for (int i = 1; i < n; ++i) {
        left[i] = left[i - 1] + (nums[i] > nums[i - 1]);
        right[n - i - 1] = right[n - i] + (nums[n - i - 1] > nums[n - i]);
    }
    int ans = n - 3;
    for (int i = 1; i < n - 1; ++i) {
        ans = min(ans, n - 1 - left[i] - right[i]);
    }
    return ans;
}

-----
int minimumMountainRemovals(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1672

int maximumWealth(vector<vector<int>>& accounts) {
    int max_wealth = 0;
    for (auto& customer : accounts) {
        int wealth = 0;
        for (int account : customer) {
            wealth += account;
        }
        max_wealth = max(max_wealth, wealth);
    }
    return max_wealth;
}

-----
int maximumWealth(vector<vector<int>>& accounts) 
    // Your code here
}

************************************
Question ID: 1673

#include <vector>
#include <stack>

std::vector<int> mostCompetitive(std::vector<int>& nums, int k) {
    std::stack<int> stk;
    int n = nums.size();
    for (int i = 0; i < n; i++) {
        while (!stk.empty() && stk.top() > nums[i] && stk.size() + n - i > k) {
            stk.pop();
        }
        if (stk.size() < k) {
            stk.push(nums[i]);
        }
    }
    std::vector<int> result(k);
    for (int i = k - 1; i >= 0; i--) {
        result[i] = stk.top();
        stk.pop();
    }
    return result;
}


-----
#include <vector>
#include <stack>

std::vector<int> mostCompetitive(std::vector<int>& nums, int k) 
    // Your code here
}


************************************
Question ID: 1674

```c++
int minOperations(int n) {
    return n * (n - 1) / 2;
}


-----
```c++
int minOperations(int n) 
    // Your code here
}


************************************
Question ID: 1675

#include <algorithm>
#include <vector>

bool canPlaceBalls(int force, const std::vector<int>& position, int m) {
    int last_position = position[0];
    int placed_balls = 1;

    for (int i = 1; i < position.size(); i++) {
        if (position[i] - last_position >= force) {
            placed_balls++;
            last_position = position[i];

            if (placed_balls == m) {
                return true;
            }
        }
    }

    return false;
}

int maxDistance(std::vector<int>& position, int m) {
    std::sort(position.begin(), position.end());

    int left = 1;
    int right = position.back() - position[0];
    int ans = 0;

    while (left <= right) {
        int mid = (left + right) / 2;
        if (canPlaceBalls(mid, position, m)) {
            ans = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return ans;
}

-----
#include <algorithm>
#include <vector>

bool canPlaceBalls(int force, const std::vector<int>& position, int m) 
    // Your code here
}

************************************
Question ID: 1678

#include <string>
using namespace std;

int numWays(string s) {
    int numberOfOnes = 0;
    for (char c : s) {
        if (c == '1') numberOfOnes++;
    }
    if (numberOfOnes % 3 != 0) return 0;

    int target = numberOfOnes / 3;
    if (target == 0) {
        long n = s.length();
        return ((n - 1) * (n - 2) / 2) % 1000000007;
    }

    int onesSoFar1 = 0, onesSoFar2 = 0;
    long way1 = 0, way2 = 0;
    for (char c : s) {
        if (c == '1') {
            onesSoFar1++;
            if (onesSoFar1 == target) {
                way1++;
                onesSoFar1 = 0;
            }

            onesSoFar2++;
            if (onesSoFar2 == target * 2) {
                way2++;
                onesSoFar2 = 0;
            }
        }
    }

    return (way1 * way2) % 1000000007;
}


-----
#include <string>
using namespace std;

int numWays(string s) 
    // Your code here
}


************************************
Question ID: 1679

int findLengthOfShortestSubarray(vector<int>& arr) {
    int n = arr.size();
    int left = 0, right = n - 1;

    while (left < n - 1 && arr[left] <= arr[left + 1]) left++;
    if (left == n - 1) return 0;

    while (right > 0 && arr[right] >= arr[right - 1]) right--;

    int result = min(right, n - left - 1);

    int i = 0, j = right;

    while (i <= left && j < n) {
        if (arr[i] <= arr[j]) {
            result = min(result, j - i - 1);
            i++;
        } else {
            j++;
        }
    }

    return result;
}


-----
int findLengthOfShortestSubarray(vector<int>& arr) 
    // Your code here
}


************************************
Question ID: 1680

#include <vector>
using namespace std;

int countRoutes(vector<int>& locations, int start, int finish, int fuel, int curr = -1, int remainingFuel = -1, vector<vector<int>>& memo = vector<vector<int>>(100, vector<int>(201, -1))) {
    if (curr == -1) {
        curr = start;
        remainingFuel = fuel;
    }
    
    if (remainingFuel < 0)
        return 0;
    
    if (memo[curr][remainingFuel] != -1)
        return memo[curr][remainingFuel];
    
    int ans = (curr == finish);
    for (int next = 0; next < locations.size(); next++) {
        if (next != curr) {
            ans += countRoutes(locations, start, finish, fuel, next, remainingFuel - abs(locations[curr] - locations[next]), memo);
            ans %= 1000000007;
        }
    }
    memo[curr][remainingFuel] = ans;
    return ans;
}

-----
#include <vector>
using namespace std;

int countRoutes(vector<int>& locations, int start, int finish, int fuel, int curr = -1, int remainingFuel = -1, vector<vector<int>>& memo = vector<vector<int>>(100, vector<int>(201, -1))) 
    // Your code here
}

************************************
Question ID: 1682

#include <vector>
#include <algorithm>
using namespace std;

vector<int> mostVisited(int n, vector<int>& rounds) {
    vector<int> visited(n + 1, 0);
    
    for (int i = 1; i < rounds.size(); i++) {
        int start = rounds[i - 1], end = rounds[i];
        while (start != end) {
            visited[start]++;
            start = start % n + 1;
        }
    }
    visited[rounds.back()]++;
    
    int maxVisits = *max_element(visited.begin(), visited.end());
    vector<int> result;
    
    for (int i = 1; i <= n; i++) {
        if (visited[i] == maxVisits)
            result.push_back(i);
    }
    
    return result;
}

-----
#include <vector>
#include <algorithm>
using namespace std;

vector<int> mostVisited(int n, vector<int>& rounds) 
    // Your code here
}

************************************
Question ID: 1684

int findLatestStep(vector<int>& arr, int m) {
    int n = arr.size();
    vector<int> lengthLeft(n + 2, 0), lengthRight(n + 2, 0);
    int count = 0, result = -1;

    for (int i = 0; i < n; ++i) {
        int pos = arr[i];
        int leftLength = lengthRight[pos - 1];
        int rightLength = lengthLeft[pos + 1];
        int newLength = leftLength + rightLength + 1;

        if (leftLength == m || rightLength == m) {
            count--;
        }
        
        if (newLength == m) {
            count++;
        }
        
        if (newLength > 0) {
            lengthLeft[pos - leftLength] = newLength;
            lengthRight[pos + rightLength] = newLength;
            result = i + 1;
        }
    }

    return count > 0 ? result : -1;
}


-----
int findLatestStep(vector<int>& arr, int m) 
    // Your code here
}


************************************
Question ID: 1685

#include <vector>
#include <algorithm>
using namespace std;

int maxScore(const vector<int>& stoneValue, int start, int end, vector<vector<int>>& memo) {
    if (start == end) return 0;
    if (memo[start][end] != -1) return memo[start][end];

    int leftSum = 0, rightSum = 0;
    for (int i = start; i < end; ++i) {
        leftSum += stoneValue[i];
        rightSum = 0;
        for (int j = i + 1; j <= end; ++j)
            rightSum += stoneValue[j];

        if (leftSum > rightSum)
            memo[start][end] = max(memo[start][end], rightSum + maxScore(stoneValue, i + 1, end, memo));
        else if (leftSum < rightSum)
            memo[start][end] = max(memo[start][end], leftSum + maxScore(stoneValue, start, i, memo));
        else
            memo[start][end] = max(memo[start][end], leftSum + max(maxScore(stoneValue, start, i, memo), maxScore(stoneValue, i + 1, end, memo)));
    }
    return memo[start][end];
}

int stoneGameV(vector<int>& stoneValue) {
    int n = stoneValue.size();
    vector<vector<int>> memo(n, vector<int>(n, -1));
    return maxScore(stoneValue, 0, n - 1, memo);
}


-----
#include <vector>
#include <algorithm>
using namespace std;

int maxScore(const vector<int>& stoneValue, int start, int end, vector<vector<int>>& memo) 
    // Your code here
}


************************************
Question ID: 1686

#include <vector>
#include <algorithm>

int stoneGameVI(std::vector<int>& aliceValues, std::vector<int>& bobValues) {
    int n = aliceValues.size();
    std::vector<std::pair<int, int>> diff;
    for (int i = 0; i < n; ++i) {
        diff.push_back({aliceValues[i] + bobValues[i], i});
    }
    
    std::sort(diff.rbegin(), diff.rend());
    int aliceSum = 0, bobSum = 0;
    for (int i = 0; i < n; ++i) {
        if (i % 2 == 0) {
            aliceSum += aliceValues[diff[i].second];
        } else {
            bobSum += bobValues[diff[i].second];
        }
    }

    return (aliceSum == bobSum) ? 0 : ((aliceSum > bobSum) ? 1 : -1);
}


-----
#include <vector>
#include <algorithm>

int stoneGameVI(std::vector<int>& aliceValues, std::vector<int>& bobValues) 
    // Your code here
}


************************************
Question ID: 1687

int min_trips(vector<vector<int>> &boxes, int portsCount, int maxBoxes, int maxWeight) {
    int trips = 0, idx = 0, n = boxes.size();
    while (idx < n) {
        int curr_limit = maxWeight, prev_port = 0;
        for (int count = 0; count < maxBoxes && idx < n; ++idx) {
            if (boxes[idx][1] <= curr_limit) {
                if (prev_port != boxes[idx][0]) {
                    prev_port = boxes[idx][0];
                    ++trips;
                }
                curr_limit -= boxes[idx][1];
                ++count;
            }
        }
        ++trips;
    }
    return trips;
}

-----
int min_trips(vector<vector<int>> &boxes, int portsCount, int maxBoxes, int maxWeight) 
    // Your code here
}

************************************
Question ID: 1688

int numberOfMatches(int n) {
    int matches = 0;
    while (n > 1) {
        matches += n / 2;
        n = (n + 1) / 2;
    }
    return matches;
}

-----
int numberOfMatches(int n) 
    // Your code here
}

************************************
Question ID: 1689

bool containsPattern(vector<int>& arr, int m, int k) {
    int n = arr.size();
    if (m * k > n) return false;

    for (int i = 0; i + m * k <= n; i++) {
        bool patternFound = true;
        for (int j = 0; j < m; j++) {
            for (int l = 1; l < k; l++) {
                if (arr[i + j] != arr[i + j + l * m]) {
                    patternFound = false;
                    break;
                }
            }
            if (!patternFound) break;
        }
        if (patternFound) return true;
    }
    return false;
}

-----
bool containsPattern(vector<int>& arr, int m, int k) 
    // Your code here
}

************************************
Question ID: 1690

int getMaxLen(vector<int>& nums) {
    int maxLength = 0, currentLen = 0, currentNegLen = 0;
    
    for (int num : nums) {
        if (num > 0) {
            ++currentLen;
            if (currentNegLen > 0) ++currentNegLen;
        } else if (num < 0) {
            int tmp = currentLen;
            currentLen = currentNegLen;
            currentNegLen = tmp + 1;
        } else {
            currentLen = 0;
            currentNegLen = 0;
        }
        maxLength = max(maxLength, currentLen);
    }
    
    return maxLength;
}

-----
int getMaxLen(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1692

#include <vector>

int numTrees(int n) {
    std::vector<int> dp(n + 1, 0);
    dp[0] = 1;
    dp[1] = 1;

    for (int i = 2; i <= n; ++i) {
        for (int j = 0; j < i; ++j) {
            dp[i] += dp[j] * dp[i - 1 - j];
            dp[i] %= 1000000007;
        }
    }

    return dp[n];
}

-----
#include <vector>

int numTrees(int n) 
    // Your code here
}

************************************
Question ID: 1694

#include <vector>
#include <unordered_map>
using namespace std;

int minSubarray(vector<int>& nums, int p) {
    int n = nums.size(), need = 0, cur = 0, res = n;
    for (int num : nums) need = (need + num) % p;
    if (need == 0) return 0;
    unordered_map<int, int> last_seen;
    last_seen[cur] = -1;
    for (int i = 0; i < n; ++i) {
        cur = (cur + nums[i]) % p;
        last_seen[cur] = i;
        int want = (cur - need + p) % p;
        if (last_seen.count(want)) {
            res = min(res, i-last_seen[want]);
        }
    }
    return res == n ? -1 : res;
}


-----
#include <vector>
#include <unordered_map>
using namespace std;

int minSubarray(vector<int>& nums, int p) 
    // Your code here
}


************************************
Question ID: 1695

#include <vector>
#include <algorithm>
using namespace std;

const int mod = 1e9 + 7;
int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {
    vector<int> cnt(nums.size());
    for (auto &req : requests) {
        cnt[req[0]]++;
        if (req[1] + 1 < nums.size()) cnt[req[1] + 1]--;
    }
    
    for (int i = 1; i < nums.size(); i++) {
        cnt[i] += cnt[i - 1];
    }
    
    sort(nums.begin(), nums.end());
    sort(cnt.begin(), cnt.end());
    
    long long ans = 0;
    for (int i = 0; i < nums.size(); i++) {
        ans += (long long)nums[i] * cnt[i];
        ans %= mod;
    }
    
    return ans;
}

-----
#include <vector>
#include <algorithm>
using namespace std;

const int mod = 1e9 + 7;
int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) 
    // Your code here
}

************************************
Question ID: 1696

#include <vector>
using namespace std;

bool isPrintable(vector<vector<int>>& targetGrid) {
    int m = targetGrid.size(), n = targetGrid[0].size();
    vector<int> top(61, m), bottom(61, -1), left(61, n), right(61, -1);
    vector<vector<bool>> vis(m, vector<bool>(n, false));

    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            int c = targetGrid[i][j];
            top[c] = min(top[c], i);
            bottom[c] = max(bottom[c], i);
            left[c] = min(left[c], j);
            right[c] = max(right[c], j);
        }
    }

    function<bool(int)> dfs = [&](int x) {
        int i = x / n, j = x % n;
        if (vis[i][j]) return true;
        int c = targetGrid[i][j];
        if (i < top[c] || i > bottom[c] || j < left[c] || j > right[c]) return false;
        vis[i][j] = true;
        for (int k = 1; k <= 60; ++k) {
            if (k == c) continue;
            if (i >= top[k] && i <= bottom[k] && j >= left[k] && j <= right[k]) return false;
            if (!dfs(((i-top[k])*(right[k]-left[k]+1)) + j - left[k])) return false;
        }
        return true;
    };

    for (int color = 1; color <= 60; ++color) {
        for (int i = top[color]; i <= bottom[color]; ++i) {
            for (int j = left[color]; j <= right[color]; ++j) {
                if (!vis[i][j] && !dfs(i * n + j)) return false;
            }
        }
    }

    return true;
}


-----
#include <vector>
using namespace std;

bool isPrintable(vector<vector<int>>& targetGrid) 
    // Your code here
}


************************************
Question ID: 1697

#include <vector>
#include <queue>
#include <unordered_map>

using namespace std;

vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {
    unordered_map<int, vector<pair<int, int>>> graph;
    for (auto& edge : edgeList) {
        graph[edge[0]].emplace_back(edge[1], edge[2]);
        graph[edge[1]].emplace_back(edge[0], edge[2]);
    }

    vector<bool> answer(queries.size());
    for (int i = 0; i < queries.size(); i++) {
        int pj = queries[i][0], qj = queries[i][1], limitj = queries[i][2];

        queue<pair<int, int>> q;
        q.push({pj, 0});
        vector<bool> visited(n, false);
        visited[pj] = true;

        while (!q.empty()) {
            auto curr = q.front();
            q.pop();

            for (auto& next : graph[curr.first]) {
                if (curr.second + next.second < limitj) {
                    if (next.first == qj) {
                        answer[i] = true;
                        break;
                    }
                    if (!visited[next.first]) {
                        visited[next.first] = true;
                        q.push({next.first, curr.second + next.second});
                    }
                }
            }
            if (answer[i]) 
                break;
        }
    }
    return answer;
}

-----
#include <vector>
#include <queue>
#include <unordered_map>

using namespace std;

vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) 
    // Your code here
}

************************************
Question ID: 1698

#include <string>

std::string modifyString(std::string s) {
    for (int i = 0; i < s.size(); i++) {
        if (s[i] == '?') {
            for (char c = 'a'; c <= 'z'; c++) {
                if ((i - 1 < 0 || s[i - 1] != c) && (i + 1 >= s.size() || s[i + 1] != c)) {
                    s[i] = c;
                    break;
                }
            }
        }
    }
    return s;
}


-----
#include <string>

std::string modifyString(std::string s) 
    // Your code here
}


************************************
Question ID: 1700

#include <vector>
#include <string>

int min_time_to_remove_balloons(const std::string& colors, const std::vector<int>& neededTime) {
    int n = colors.size();
    int dp[n][26];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < 26; j++) {
            dp[i][j] = 1e9; 
        }
    }

    for (int color = 0; color < 26; color++) {
        if (colors[0] != 'A' + color) dp[0][color] = neededTime[0];
    }

    for (int i = 1; i < n; i++) {
        for (int color1 = 0; color1 < 26; color1++) {
            for (int color2 = 0; color2 < 26; color2++) {
                if (color1 != color2 && colors[i] != 'A' + color1) {
                    dp[i][color1] = std::min(dp[i][color1], dp[i-1][color2] + neededTime[i]);
                }
            }
        }
    }

    int ans = 1e9;
    for (int color = 0; color < 26; color++) {
        ans = std::min(ans, dp[n-1][color]);
    }
    return ans;
}


-----
#include <vector>
#include <string>

int min_time_to_remove_balloons(const std::string& colors, const std::vector<int>& neededTime) 
    // Your code here
}


************************************
Question ID: 1701

int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {
    vector<int> parent(2 * n + 1);
    iota(parent.begin(), parent.end(), 0);
    function<int(int)> find = [&](int x) { return x == parent[x] ? x : parent[x] = find(parent[x]); };
    auto unite = [&](int x, int y) { x = find(x); y = find(y); if (x != y) return parent[x] = y, true; return false; };
    sort(edges.begin(), edges.end(), greater<vector<int>>());
    int ans = 0, both = n - 1;
    for (auto &edge : edges) {
        int type, u, v; tie(type, u, v) = make_tuple(edge[0], edge[1], edge[2] + n);
        if (type == 3) if (unite(u, v)) --both;
        if (!both) break;
    }
    for (int type = 1; type < 3; ++type) {
        int ct = 0;
        for (auto &edge : edges) {
            int a, u, v; tie(a, u, v) = make_tuple(edge[0], edge[1], edge[2] + n);
            if (a == type) if (unite(u, v)) ++ct;
        }
        if (both + ct < n - 1) return -1;
        ans += ct;
    }
    return ans;
}


-----
int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) 
    // Your code here
}


************************************
Question ID: 1702

#include <string>

std::string maximumBinaryString(std::string binary) {
    int zeroCount = 0;
    int oneCount = 0;
    
    for (char c : binary) {
        if (c == '0') {
            zeroCount++;
        } else {
            oneCount++;
        }
    }
    
    if (zeroCount <= 1) {
        return binary;
    }
    
    std::string result = "";
    for (int i = 0; i < oneCount; ++i) {
        result += '1';
    }
    for (int i = 0; i < zeroCount - 1; ++i) {
        result += '0';
    }
    result += "1####1";
    return result.substr(0, binary.length());
}

-----
#include <string>

std::string maximumBinaryString(std::string binary) 
    // Your code here
}

************************************
Question ID: 1703

int minMoves(vector<int>& nums, int k) {
    vector<int> ones_pos;
    int moves = 0;
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] == 1) {
            ones_pos.push_back(i);
        }
    }
    for (int i = 0; i + k <= ones_pos.size(); i++) {
        int pos = ones_pos[i + k / 2];
        for (int j = i; j < i + k; j++) {
            moves += abs(ones_pos[j] - pos);
        }
    }
    return moves;
}

-----
int minMoves(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 1704

int numSpecial(vector<vector<int>>& mat) {
    int m = mat.size(), n = mat[0].size();
    vector<int> row(m, 0), col(n, 0);

    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (mat[i][j] == 1) {
                ++row[i];
                ++col[j];
            }
        }
    }

    int special_positions = 0;
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (mat[i][j] == 1 && row[i] == 1 && col[j] == 1) {
                ++special_positions;
            }
        }
    }

    return special_positions;
}

-----
int numSpecial(vector<vector<int>>& mat) 
    // Your code here
}

************************************
Question ID: 1705

#include <vector>
#include <unordered_map>
using namespace std;

int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {
    vector<int> pair_mapping(n);
    for (vector<int>& pair : pairs) {
        pair_mapping[pair[0]] = pair[1];
        pair_mapping[pair[1]] = pair[0];
    }
    
    int unhappy_count = 0;
    for (int x = 0; x < n; x++) {
        int y = pair_mapping[x];
        vector<int>& pref_x = preferences[x];
        int idx_y = -1;
        for (int i = 0; i < pref_x.size(); i++) {
            if (pref_x[i] == y) {
                idx_y = i;
                break;
            }
        }
        
        for (int i = 0; i < idx_y; i++) {
            int u = pref_x[i];
            int v = pair_mapping[u];
            vector<int>& pref_u = preferences[u];
            for (int j = 0; j < pref_u.size(); j++) {
                if (pref_u[j] == x) {
                    unhappy_count++;
                    break;
                } else if (pref_u[j] == v) {
                    break;
                }
            }
        }
    }
    
    return unhappy_count / 2;
}


-----
#include <vector>
#include <unordered_map>
using namespace std;

int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) 
    // Your code here
}


************************************
Question ID: 1706

#include <vector>
#include <algorithm>

int minCostConnectPoints(std::vector<std::vector<int>>& points) {
    int n = points.size();
    std::vector<int> cost(n);
    std::vector<bool> visited(n, false);
    std::fill(cost.begin(), cost.end(), INT_MAX);
    cost[0] = 0;

    int ans = 0;

    for (int i = 0; i < n; ++i) {
        int min_cost = INT_MAX;
        int cur_point = -1;
        for (int j = 0; j < n; ++j) {
            if (!visited[j] && cost[j] < min_cost) {
                min_cost = cost[j];
                cur_point = j;
            }
        }

        visited[cur_point] = true;
        ans += min_cost;

        for (int j = 0; j < n; ++j) {
            if (!visited[j]) {
                int new_cost = std::abs(points[cur_point][0] - points[j][0]) + std::abs(points[cur_point][1] - points[j][1]);
                cost[j] = std::min(cost[j], new_cost);
            }
        }
    }

    return ans;
}

-----
#include <vector>
#include <algorithm>

int minCostConnectPoints(std::vector<std::vector<int>>& points) 
    // Your code here
}

************************************
Question ID: 1707

bool canTransform(string s, string t) {
    int i = 0, j = 0;
    while (i < s.size() && j < t.size()) {
        if (s[i] == t[j]) {
            i++;
            j++;
        } else {
            i++;
        }
    }
    return j == t.size();
}


-----
bool canTransform(string s, string t) 
    // Your code here
}


************************************
Question ID: 1710

#include <vector>
#include <queue>

std::vector<int> busiestServers(int k, std::vector<int>& arrival, std::vector<int>& load) {
    std::vector<int> serverRequests(k, 0);
    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> pq;
    std::queue<int> availableServers;

    for (int i = 0; i < k; ++i) {
        availableServers.push(i);
    }

    for (int i = 0; i < arrival.size(); ++i) {
        while (!pq.empty() && pq.top().first <= arrival[i]) {
            availableServers.push(pq.top().second);
            pq.pop();
        }

        if (!availableServers.empty()) {
            int serverId = availableServers.front();
            availableServers.pop();
            serverRequests[serverId]++;
            pq.push({arrival[i] + load[i], serverId});
        }
    }

    int maxRequests = 0;
    for (int requests : serverRequests) {
        maxRequests = std::max(maxRequests, requests);
    }

    std::vector<int> result;
    for (int i = 0; i < k; ++i) {
        if (serverRequests[i] == maxRequests) {
            result.push_back(i);
        }
    }

    return result;
}


-----
#include <vector>
#include <queue>

std::vector<int> busiestServers(int k, std::vector<int>& arrival, std::vector<int>& load) 
    // Your code here
}


************************************
Question ID: 1711

#include <vector>

std::vector<std::vector<int>> restoreMatrix(std::vector<int>& rowSum, std::vector<int>& colSum) {
    int m = rowSum.size();
    int n = colSum.size();
    std::vector<std::vector<int>> result(m, std::vector<int>(n, 0));

    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            int value = std::min(rowSum[i], colSum[j]);
            result[i][j] = value;
            rowSum[i] -= value;
            colSum[j] -= value;
        }
    }

    return result;
}

-----
#include <vector>

std::vector<std::vector<int>> restoreMatrix(std::vector<int>& rowSum, std::vector<int>& colSum) 
    // Your code here
}

************************************
Question ID: 1712

int waysToSplit(vector<int>& nums) {
    int MOD = 1e9 + 7;
    int n = nums.size();
    vector<long long> prefixSum(n + 1, 0);
    for (int i = 0; i < n; i++) {
        prefixSum[i + 1] = prefixSum[i] + nums[i];
    }
    int ans = 0;
    int left = 0, right = 0;
    for (int mid = 1; mid < n - 1; mid++) {
        while (left + 1 < mid && prefixSum[left + 1] * 2 <= prefixSum[mid]) {
            left++;
        }
        while (right < mid || (right + 1 < n && prefixSum[right + 1] - prefixSum[mid] <= prefixSum[n] - prefixSum[right + 1])) {
            right++;
        }
        if (right >= mid && prefixSum[mid] - prefixSum[left] <= prefixSum[right] - prefixSum[mid]) {
            ans = (ans + right - mid + 1) % MOD;
        }
    }
    return ans;
}

-----
int waysToSplit(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1713

#include <vector>
#include <unordered_map>
using namespace std;

int minOperations(vector<int>& target, vector<int>& arr) {
    unordered_map<int, int> pos;
    for (int i = 0; i < target.size(); ++i) {
        pos[target[i]] = i;
    }

    vector<int> dp;
    for (const int& a : arr) {
        if (pos.find(a) != pos.end()) {
            auto idx = lower_bound(dp.begin(), dp.end(), pos[a]);
            if (idx == dp.end()) {
                dp.push_back(pos[a]);
            } else {
                *idx = pos[a];
            }
        }
    }
    return target.size() - dp.size();
}

-----
#include <vector>
#include <unordered_map>
using namespace std;

int minOperations(vector<int>& target, vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1714

#include <string>
#include <sstream>
#include <vector>

std::string reorderSpaces(const std::string& text) {
    int spaces = 0;
    std::vector<std::string> words;
    
    std::stringstream ss(text);
    std::string word;
    while (ss >> word) {
        words.push_back(word);
        spaces += std::count(word.begin(), word.end(), ' ');
    }
    
    if (words.size() == 1) {
        return words[0] + std::string(spaces, ' ');
    }

    int space_between_words = spaces / (words.size() - 1);
    int extra_spaces = spaces % (words.size() - 1);
    std::string result;
    
    for (size_t i = 0; i < words.size(); i++) {
        result += words[i];
        if (i < words.size() - 1) {
            result += std::string(space_between_words, ' ');
        }
    }
    
    result += std::string(extra_spaces, ' ');

    return result;
}

-----
#include <string>
#include <sstream>
#include <vector>

std::string reorderSpaces(const std::string& text) 
    // Your code here
}

************************************
Question ID: 1716

#include <vector>
using namespace std;

int maxProductPath(vector<vector<int>>& grid) {
    int m = grid.size(), n = grid[0].size(), mod = 1e9 + 7;
    vector<vector<vector<long long>>> dp(m, vector<vector<long long>>(n, vector<long long>(2)));
    
    dp[0][0] = {grid[0][0], grid[0][0]};
    
    for(int i = 1; i < m; i++) {
        dp[i][0][0] = dp[i][0][1] = dp[i-1][0][0] * grid[i][0];
    }
    for(int j = 1; j < n; j++) {
        dp[0][j][0] = dp[0][j][1] = dp[0][j-1][0] * grid[0][j];
    }
    
    for(int i = 1; i < m; i++) {
        for(int j = 1; j < n; j++) {
            if(grid[i][j] < 0) {
                dp[i][j][0] = min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j];
                dp[i][j][1] = max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j];
            } else {
                dp[i][j][0] = max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j];
                dp[i][j][1] = min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j];
            }
        }
    }
    
    return dp[m - 1][n - 1][0] >= 0 ? dp[m - 1][n - 1][0] % mod : -1;
}


-----
#include <vector>
using namespace std;

int maxProductPath(vector<vector<int>>& grid) 
    // Your code here
}


************************************
Question ID: 1717

#include <vector>
#include <algorithm>
using namespace std;

int min_cost(vector<vector<int>>& cost, int size1, int size2) {
    vector<int> dp(size2 + 1, INT_MAX);
    dp[0] = 0;

    for (int i = 0; i < size1; ++i) {
        for (int j = size2; j >= 0; --j) {
            int min_cost = INT_MAX;
            for (int k = 0; k < size2; ++k) {
                if (((1 << k) & j) == 0) {
                    min_cost = min(min_cost, cost[i][k] + dp[j | (1 << k)]);
                }
            }
            dp[j] = min(dp[j], min_cost);
        }
    }

    return dp[(1 << size2) - 1];
}

-----
#include <vector>
#include <algorithm>
using namespace std;

int min_cost(vector<vector<int>>& cost, int size1, int size2) 
    // Your code here
}

************************************
Question ID: 1719

#include <vector>
#include <unordered_map>

int checkWays(std::vector<std::vector<int>>& pairs) {
    std::unordered_map<int, int> candidates;
    for (const auto& pair : pairs) {
        ++candidates[pair[0]];
        ++candidates[pair[1]];
    }

    int rootCount = 0;
    for (const auto& candidate : candidates) {
        if (candidate.second == 1) {
            ++rootCount;
            if (rootCount > 1) {
                return 2;
            }
        }
    }

    return rootCount;
}

-----
#include <vector>
#include <unordered_map>

int checkWays(std::vector<std::vector<int>>& pairs) 
    // Your code here
}

************************************
Question ID: 1720

int minOperations(vector<string>& logs) {
    int depth = 0;
    for (const string& log : logs) {
        if (log == "../") {
            if (depth > 0) {
                depth--;
            }
        } else if (log != "./") {
            depth++;
        }
    }
    return depth;
}


-----
int minOperations(vector<string>& logs) 
    // Your code here
}


************************************
Question ID: 1721

#include <algorithm>
#include <vector>
using namespace std;

int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {
    int rotations = 0, waiting = 0, onBoard = 0, profit = 0, maxProfit = 0, maxRotations = 0;
    while (!customers.empty() || waiting > 0) {
        if (!customers.empty()) {
            waiting += customers.front();
            customers.erase(customers.begin());
        }
        
        onBoard = min(waiting, 4);
        waiting -= onBoard;
        profit += onBoard * boardingCost - runningCost;
        rotations++;
        
        if (profit > maxProfit) {
            maxProfit = profit;
            maxRotations = rotations;
        }
    }
    return maxProfit > 0 ? maxRotations : -1;
}


-----
#include <algorithm>
#include <vector>
using namespace std;

int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) 
    // Your code here
}


************************************
Question ID: 1723

#include <vector>

int maxAchievableRequests(int n, std::vector<std::vector<int>>& requests, int idx = 0, std::vector<int> counts = {}) {
    if (counts.empty()) {
        counts.resize(n, 0);
    }
    if (idx == requests.size()) {
        for (int count : counts) {
            if (count != 0) return 0;
        }
        return 0;
    }
    int ignored = maxAchievableRequests(n, requests, idx + 1, counts);
    counts[requests[idx][0]]++;
    counts[requests[idx][1]]--;

    int accepted = 1 + maxAchievableRequests(n, requests, idx + 1, counts);

    return std::max(ignored, accepted);
}

-----
#include <vector>

int maxAchievableRequests(int n, std::vector<std::vector<int>>& requests, int idx = 0, std::vector<int> counts = 
    // Your code here
}

************************************
Question ID: 1725

int numberOfSets(int n, int k) {
    long long mod = 1e9 + 7;
    vector<vector<long long>> dp(n, vector<long long>(k + 1, 0));
    vector<long long> presum(n, 1);
    
    for (int j = 1; j <= k; ++j) {
        for (int i = 0; i < n; ++i) {
            dp[i][j] = presum[i];
            if (i) {
                dp[i][j] += dp[i - 1][j];
            }
            dp[i][j] %= mod;
            presum[i] = (presum[i] + dp[i][j - 1]) % mod;
        }
    }
    
    return dp[n - 1][k];
}

-----
int numberOfSets(int n, int k) 
    // Your code here
}

************************************
Question ID: 1726

#include <vector>
#include <cmath>
#include <algorithm>

std::vector<int> bestCoordinate(std::vector<std::vector<int>>& towers, int radius) {
    int max_quality = 0, best_x = 0, best_y = 0;

    for (int x = 0; x <= 50; ++x) {
        for (int y = 0; y <= 50; ++y) {
            int sum_quality = 0;
            for (const auto& tower : towers) {
                double dist = std::sqrt(std::pow(x - tower[0], 2) + std::pow(y - tower[1], 2));
                if (dist <= radius) {
                    sum_quality += tower[2] / (1 + dist);
                }
            }
            if (sum_quality > max_quality) {
                max_quality = sum_quality;
                best_x = x;
                best_y = y;
            }
        }
    }

    return {best_x, best_y};
}

-----
#include <vector>
#include <cmath>
#include <algorithm>

std::vector<int> bestCoordinate(std::vector<std::vector<int>>& towers, int radius) 
    // Your code here
}

************************************
Question ID: 1727

bool canMouseWin(vector<vector<char>>& grid, int catJump, int mouseJump) {
    int rows = grid.size();
    int cols = grid[0].size();
    int cat_r, cat_c, mouse_r, mouse_c, steps = 0;

    for (int r = 0; r < rows; ++r)
        for (int c = 0; c < cols; ++c) {
            if (grid[r][c] == 'C') {
                cat_r = r;
                cat_c = c;
            } else if (grid[r][c] == 'M') {
                mouse_r = r;
                mouse_c = c;
            }
        }

    vector<int> dirs = {-1, 0, 1, 0, -1};
    function<bool(int, int, int, int, int, int)> dfs = [&](int r_m, int c_m, int r_c, int c_c, int cnt, int dst_m_c) {
        if (cnt >= 100) // The game is taking more than 100 steps
            return false;
        if (r_m < 0 || r_m >= rows || c_m < 0 || c_m >= cols) // Mouse out of bounds
            return false;
        if (r_c < 0 || r_c >= rows || c_c < 0 || c_c >= cols) // Cat out of bounds
            return true;
        if (grid[r_m][c_m] == 'F' || cnt != dst_m_c) { // Mouse reached food or cell is odd steps away from food
            return true;
        } else if (grid[r_m][c_m] == '#' || cnt + 1 == dst_m_c) { // Wall or cell is even steps away from food
            return false;
        }
        
        bool res = false;
        for(int i = 0; i < 4; i++){
            int jump = (dst_m_c == cnt) ? catJump : mouseJump;
            res |= !dfs(r_m + jump * dirs[i], c_m + jump * dirs[i+1], r_c + dirs[i] * dirs[(i + 2) % 4], c_c + dirs[i+1] * dirs[(i + 3) % 4], cnt + 1, dst_m_c);
            if(jump == 1) break;
        }
        return res;
    };

    return dfs(mouse_r, mouse_c, cat_r, cat_c, 0, abs(cat_r - mouse_r) + abs(cat_c - mouse_c));
}

-----
bool canMouseWin(vector<vector<char>>& grid, int catJump, int mouseJump) 
    // Your code here
}

************************************
Question ID: 1730

int findSpecialInteger(const std::vector<int>& nums) {
    for (int x = 1; x <= nums.size(); ++x) {
        int count = 0;
        for (int num : nums) {
            if (num >= x) {
                ++count;
            }
        }
        if (count == x) {
            return x;
        }
    }
    return -1;
}

-----
int findSpecialInteger(const std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1732

int min_operations(int n) {
    int operations = 0;
    while (n > 0) {
        if (n % 2 == 0) {
            n /= 2;
        } else {
            n--;
        }
        operations++;
    }
    return operations;
}

-----
int min_operations(int n) 
    // Your code here
}

************************************
Question ID: 1733

#include <vector>
#include <cmath>
#include <algorithm>

using namespace std;

double getAngle(int x, int y, int px, int py) {
    return atan2(y - py, x - px) * 180 / M_PI;
}

int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {
    vector<double> angles;
    for (const auto& point : points) {
        if (point != location) {
            angles.push_back(getAngle(point[0], point[1], location[0], location[1]));
        }
    } 
    sort(angles.begin(), angles.end());
    int n = angles.size();
    for (int i = 0; i < n; i++) {
        angles.push_back(angles[i] + 360);
    }
    int max_points = 0;
    int j = 0;
    for (int i = 0; i < 2 * n; i++) {
        while (angles[i] - angles[j] > angle) {
            j++;
        }
        max_points = max(max_points, i - j + 1);
    }
    return max_points + count(points.begin(), points.end(), location);
}


-----
#include <vector>
#include <cmath>
#include <algorithm>

using namespace std;

double getAngle(int x, int y, int px, int py) 
    // Your code here
}


************************************
Question ID: 1734

#include <vector>

std::vector<int> decode(std::vector<int>& encoded) {
    int n = encoded.size() + 1;
    int totalXor = 0;
    for (int i = 1; i <= n; i++) {
        totalXor ^= i;
    }
    
    int nonFirstXor = 0;
    for (int i = 1; i < n - 1; i += 2) {
        nonFirstXor ^= encoded[i];
    }
    
    std::vector<int> perm(n);
    perm[0] = totalXor ^ nonFirstXor;
    
    for (int i = 1; i < n; i++) {
        perm[i] = perm[i - 1] ^ encoded[i - 1];
    }
    
    return perm;
}


-----
#include <vector>

std::vector<int> decode(std::vector<int>& encoded) 
    // Your code here
}


************************************
Question ID: 1735

#include <vector>
#include <unordered_map>
using namespace std;

const int MOD = 1e9 + 7;

int mul(int a, int b) {
    return (1LL * a * b) % MOD;
}

int powMod(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) res = mul(res, a);
        a = mul(a, a);
        b >>= 1;
    }
    return res;
}

int ways(int n, int k, unordered_map<int, int>& mem) {
    if (n == 1) return k;
    int& res = mem[n * 50000 + k];
    if (res) return res;

    if (k == 1) {
        return res = 1;
    }
    if (n > k) {
        return res = 0;
    }

    res = mul(ways(n, k - 1, mem), n);
    res = (res - mul(n - 1, ways(n - 1, k - 1, mem)) + MOD) % MOD;

    return res;
}

vector<int> waysToFillArray(vector<vector<int>>& queries) {
    unordered_map<int, int> mem;
    vector<int> ans;
    for (auto& q : queries) {
        ans.push_back(ways(q[0], q[1], mem));
    }
    return ans;
}

-----
#include <vector>
#include <unordered_map>
using namespace std;

const int MOD = 1e9 + 7;

int mul(int a, int b) 
    // Your code here
}

************************************
Question ID: 1736

#include <string>

std::string maximumTime(std::string time) {
    if (time[0] == '?') {
        time[0] = (time[1] <= '3' || time[1] == '?') ? '2' : '1';
    }
    if (time[1] == '?') {
        time[1] = (time[0] == '2') ? '3' : '9';
    }
    if (time[3] == '?') {
        time[3] = '5';
    }
    if (time[4] == '?') {
        time[4] = '9';
    }
    return time;
}

-----
#include <string>

std::string maximumTime(std::string time) 
    // Your code here
}

************************************
Question ID: 1737

int maxDepth(string s) {
    int depth = 0, maxDepth = 0;
    for (const char ch : s) {
        if (ch == '(') ++depth;
        else if (ch == ')') --depth;
        maxDepth = max(maxDepth, depth);
    }
    return maxDepth;
}

-----
int maxDepth(string s) 
    // Your code here
}

************************************
Question ID: 1738

int maximalNetworkRank(int n, vector<vector<int>>& roads) {
    vector<int> degree(n, 0);
    set<pair<int, int>> s;
    
    for (auto& road : roads) {
        degree[road[0]]++;
        degree[road[1]]++;
        s.insert({min(road[0], road[1]), max(road[0], road[1])});
    }
    
    int ans = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            ans = max(ans, degree[i] + degree[j] - (s.count({i, j}) ? 1 : 0));
        }
    }
    return ans;
}


-----
int maximalNetworkRank(int n, vector<vector<int>>& roads) 
    // Your code here
}


************************************
Question ID: 1739

#include <string>

bool checkPalindromeFormation(std::string a, std::string b) {
    auto isPalindrome = [](const std::string& s, int left, int right) {
        while (left < right) {
            if (s[left++] != s[right--]) return false;
        }
        return true;
    };

    for (int i = 0, j = a.size() - 1; i < j; ++i, --j) {
        if (a[i] != b[j]) return isPalindrome(a, i, j) || isPalindrome(b, i, j);
    }
    return true;
}

-----
#include <string>

bool checkPalindromeFormation(std::string a, std::string b) 
    // Your code here
}

************************************
Question ID: 1740

#include <vector>
#include <utility>
using namespace std;

vector<int> countSubgraphsForEachD(int n, vector<pair<int, int>>& edges) {
    vector<vector<int>> tree(n + 1);
    for (auto &edge : edges) {
        tree[edge.first].push_back(edge.second);
        tree[edge.second].push_back(edge.first);
    }
    
    function<int(int, int)> dfs = [&](int node, int parent) {
        int depth = 0;
        for (int child : tree[node]) {
            if (child != parent) depth = max(depth, 1 + dfs(child, node));
        }
        return depth;
    };
    
    vector<int> ans(n - 1);
    for (int i = 1; i <= n; ++i) {
        int maxD = dfs(i, 0);
        if (maxD > 0) ans[maxD - 1]++;
    }
    return ans;
}

-----
#include <vector>
#include <utility>
using namespace std;

vector<int> countSubgraphsForEachD(int n, vector<pair<int, int>>& edges) 
    // Your code here
}

************************************
Question ID: 1742

#include <vector>
#include <algorithm>

int maxWidthOfVerticalArea(std::vector<std::vector<int>>& points) {
    std::vector<int> xs;
    for (const auto& point : points) {
        xs.push_back(point[0]);
    }
    std::sort(xs.begin(), xs.end());
    
    int max_width = 0;
    for (size_t i = 1; i < xs.size(); ++i) {
        max_width = std::max(max_width, xs[i] - xs[i - 1]);
    }
    
    return max_width;
}


-----
#include <vector>
#include <algorithm>

int maxWidthOfVerticalArea(std::vector<std::vector<int>>& points) 
    // Your code here
}


************************************
Question ID: 1743

int countSubstringsWithOneDifference(const std::string& s, const std::string& t) {
    int count = 0;
    for (int i = 0; i < s.size(); i++) {
        for (int j = 0; j < t.size(); j++) {
            int differences = 0;
            for (int k = 0; i + k < s.size() && j + k < t.size(); k++) {
                if (s[i + k] != t[j + k]) {
                    differences++;
                }
                if (differences == 2) {
                    break;
                }
                if (differences == 1) {
                    count++;
                }
            }
        }
    }
    return count;
}

-----
int countSubstringsWithOneDifference(const std::string& s, const std::string& t) 
    // Your code here
}

************************************
Question ID: 1744

#include <vector>
#include <string>

const int MOD = 1e9 + 7;

int numWays(std::vector<std::string>& words, std::string& target) {
    int n = words.size(), m = target.size();
    std::vector<int> cnt(26);
    for (const std::string& word : words) {
        for (char ch : word) {
            cnt[ch - 'a']++;
        }
    }
    std::vector<long long> dp(m + 1);
    dp[0] = 1;
    for (char ch : target) {
        for (int i = m - 1; i >= 0; i--) {
            dp[i + 1] += dp[i] * cnt[ch - 'a'];
            dp[i + 1] %= MOD;
        }
    }
    return dp[m];
}

-----
#include <vector>
#include <string>

const int MOD = 1e9 + 7;

int numWays(std::vector<std::string>& words, std::string& target) 
    // Your code here
}

************************************
Question ID: 1745

#include <string>
using namespace std;

bool isPalindrome(const string& s, int start, int end) {
    while (start < end) {
        if (s[start] != s[end]) return false;
        start++;
        end--;
    }
    return true;
}

bool checkPartitioning(const string& s) {
    int n = s.length();
    for (int i = 0; i < n - 2; ++i) {
        if (isPalindrome(s, 0, i)) {
            for (int j = i + 1; j < n - 1; ++j) {
                if (isPalindrome(s, i + 1, j) && isPalindrome(s, j + 1, n - 1)) return true;
            }
        }
    }
    return false;
}

-----
#include <string>
using namespace std;

bool isPalindrome(const string& s, int start, int end) 
    // Your code here
}

************************************
Question ID: 1746

int maxLengthBetweenEqualCharacters(std::string s) {
    int maxLength = -1;
    std::unordered_map<char, int> charIndexMap;

    for (int i = 0; i < s.length(); i++) {
        if (charIndexMap.count(s[i])) {
            maxLength = std::max(maxLength, i - charIndexMap[s[i]] - 1);
        } else {
            charIndexMap[s[i]] = i;
        }
    }

    return maxLength;
}

-----
int maxLengthBetweenEqualCharacters(std::string s) 
    // Your code here
}

************************************
Question ID: 1748

#include <vector>
#include <algorithm>

using namespace std;

int bestTeamScore(vector<int>& scores, vector<int>& ages) {
    int n = scores.size();
    vector<pair<int, int>> players(n);
    
    for (int i = 0; i < n; ++i) {
        players[i] = {ages[i], scores[i]};
    }
    
    sort(players.begin(), players.end());
    
    vector<int> dp(n);
    int best_score = 0;
    
    for (int i = 0; i < n; ++i) {
        dp[i] = players[i].second;
        for (int j = 0; j < i; ++j) {
            if (players[i].second >= players[j].second) {
                dp[i] = max(dp[i], dp[j] + players[i].second);
            }
        }
        best_score = max(best_score, dp[i]);
    }
    
    return best_score;
}


-----
#include <vector>
#include <algorithm>

using namespace std;

int bestTeamScore(vector<int>& scores, vector<int>& ages) 
    // Your code here
}


************************************
Question ID: 1749

int maxAbsoluteSum(vector<int>& nums) {
    int max_sum = 0, min_sum = 0, max_end = 0, min_end = 0;
    for (int num : nums) {
        max_end = max(max_end + num, num);
        min_end = min(min_end + num, num);
        max_sum = max(max_sum, max_end);
        min_sum = min(min_sum, min_end);
    }
    return max(max_sum, -min_sum);
}

-----
int maxAbsoluteSum(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1750

int minimumLength(string s) {
    if(s.empty()) return 0;
    int i = 0, j = s.length() - 1;
    while(i < j){
        if(s[i] != s[j]) break;
        char remove_char = s[i];
        while(i < s.length() && s[i] == remove_char) i++;
        while(j >= 0 && s[j] == remove_char) j--;
    }
    return max(0, j - i + 1);
}

-----
int minimumLength(string s) 
    // Your code here
}

************************************
Question ID: 1751

#include <string>
#include <vector>
using namespace std;

char slowestKey(vector<int>& releaseTimes, string keysPressed) {
    char max_key = keysPressed[0];
    int max_duration = releaseTimes[0];
    for (int i = 1; i < releaseTimes.size(); i++) {
        int duration = releaseTimes[i] - releaseTimes[i - 1];
        if (duration > max_duration || (duration == max_duration && keysPressed[i] > max_key)) {
            max_key = keysPressed[i];
            max_duration = duration;
        }
    }
    return max_key;
}


-----
#include <string>
#include <vector>
using namespace std;

char slowestKey(vector<int>& releaseTimes, string keysPressed) 
    // Your code here
}


************************************
Question ID: 1752

#include <vector>
#include <algorithm>
using namespace std;

vector<bool> checkArithmeticSubarrays(vector<int>& nums, vector<int>& l, vector<int>& r) {
    vector<bool> results;
    for(int i = 0; i < l.size(); i++) {
        vector<int> subarray(nums.begin() + l[i], nums.begin() + r[i] + 1);
        sort(subarray.begin(), subarray.end());
        bool is_arithmetic = true;
        int diff = subarray[1] - subarray[0];
        for(int j = 1; j < subarray.size() - 1; j++) {
            if(subarray[j + 1] - subarray[j] != diff) {
                is_arithmetic = false;
                break;
            }
        }
        results.push_back(is_arithmetic);
    }
    return results;
}


-----
#include <vector>
#include <algorithm>
using namespace std;

vector<bool> checkArithmeticSubarrays(vector<int>& nums, vector<int>& l, vector<int>& r) 
    // Your code here
}


************************************
Question ID: 1753

#include <vector>
#include <queue>
#include <utility>

using std::vector;
using std::pair;
using std::priority_queue;

int minimumEffortPath(vector<vector<int>>& heights) {
    const vector<pair<int, int>> directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    int rows = heights.size();
    int cols = heights[0].size();
    vector<vector<int>> efforts(rows, vector<int>(cols, INT_MAX));
    priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, std::greater<>> pq;
    
    efforts[0][0] = 0;
    pq.push({0, {0, 0}});
    
    while (!pq.empty()) {
        auto [effort, pos] = pq.top();
        pq.pop();
        int x = pos.first, y = pos.second;
        
        if (x == rows - 1 && y == cols - 1) {
            return effort;
        }
        
        for (const auto& dir : directions) {
            int nx = x + dir.first;
            int ny = y + dir.second;
            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols) {
                int new_effort = std::max(effort, std::abs(heights[nx][ny] - heights[x][y]));
                if (new_effort < efforts[nx][ny]) {
                    efforts[nx][ny] = new_effort;
                    pq.push({new_effort, {nx, ny}});
                }
            }
        }
    }
    
    return -1;
}


-----
#include <vector>
#include <queue>
#include <utility>

using std::vector;
using std::pair;
using std::priority_queue;

int minimumEffortPath(vector<vector<int>>& heights) 
    // Your code here
}


************************************
Question ID: 1754

std::string largestMerge(std::string word1, std::string word2) {
    std::string result;
    while (!word1.empty() || !word2.empty()) {
        if (word1 > word2) {
            result += word1[0];
            word1.erase(word1.begin());
        } else {
            result += word2[0];
            word2.erase(word2.begin());
        }
    }
    return result;
}

-----
std::string largestMerge(std::string word1, std::string word2) 
    // Your code here
}

************************************
Question ID: 1755

#include <vector>
using namespace std;

vector<int> decrypt(vector<int>& code, int k) {
    int n = code.size();
    vector<int> result(n);
    if (k == 0) return vector<int>(n, 0);
    
    for (int i = 0; i < n; i++) {
        int sum = 0;
        for (int j = 1; j <= abs(k); j++) {
            sum += k > 0 ? code[(i + j) % n] : code[(i - j + n) % n];
        }
        result[i] = sum;
    }
    return result;
}

-----
#include <vector>
using namespace std;

vector<int> decrypt(vector<int>& code, int k) 
    // Your code here
}

************************************
Question ID: 1756

int minDeletions(string s) {
    int aCount = 0, bCount = 0, deletions = 0;
    for (char c : s) {
        if (c == 'a') {
            aCount++;
        } else {
            if (aCount > 0) {
                aCount--;
            } else {
                deletions++;
            }
        }
    }
    return deletions;
}

-----
int minDeletions(string s) 
    // Your code here
}

************************************
Question ID: 1758

#include <vector>
#include <algorithm>
using namespace std;

bool canDistribute(vector<int>& nums, vector<int>& quantity) {
    vector<int> counts(51, 0);
    for (int num : nums) {
        counts[num]++;
    }

    sort(quantity.rbegin(), quantity.rend());
    
    function<bool(int)> dfs = [&](int idx) {
        if (idx == quantity.size()) {
            return true;
        }
        for (int i = 1; i <= 50; ++i) {
            if (counts[i] >= quantity[idx]) {
                counts[i] -= quantity[idx];
                if (dfs(idx + 1)) {
                    return true;
                }
                counts[i] += quantity[idx];
            }
        }
        return false;
    };

    return dfs(0);
}


-----
#include <vector>
#include <algorithm>
using namespace std;

bool canDistribute(vector<int>& nums, vector<int>& quantity) 
    // Your code here
}


************************************
Question ID: 1759

int countHomogenous(string s) {
    const int MOD = 1e9 + 7;
    long long count = 1, total = 0;
    for (int i = 1; i < s.size(); ++i) {
        count = (s[i] == s[i - 1]) ? count + 1 : 1;
        total = (total + count) % MOD;
    }
    return total + count;
}

-----
int countHomogenous(string s) 
    // Your code here
}

************************************
Question ID: 1760

#include <vector>
#include <unordered_map>

bool canFormArray(std::vector<int>& arr, std::vector<std::vector<int>>& pieces) {
    std::unordered_map<int, std::vector<int>> piece_map;
    for (auto & piece : pieces)
        piece_map[piece[0]] = piece;
    
    int i = 0;
    while (i < arr.size()) {
        if (!piece_map.count(arr[i]))
            return false;
        
        for (int num : piece_map[arr[i]]) {
            if (arr[i++] != num)
                return false;
        }
    }
    
    return true;
}

-----
#include <vector>
#include <unordered_map>

bool canFormArray(std::vector<int>& arr, std::vector<std::vector<int>>& pieces) 
    // Your code here
}

************************************
Question ID: 1761

int countVowelStrings(int n) {
    int dp[5] = {1, 1, 1, 1, 1};

    for (int i = 1; i < n; i++) {
        for (int j = 3; j >= 0; j--) {
            dp[j] += dp[j + 1];
        }
    }

    return dp[0] + dp[1] + dp[2] + dp[3] + dp[4];
}

-----
int countVowelStrings(int n) 
    // Your code here
}

************************************
Question ID: 1762

#include <vector>
#include <queue>

int furthestBuilding(std::vector<int>& heights, int bricks, int ladders) {
    std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;
    for (int i = 0; i < heights.size() - 1; ++i) {
        int diff = heights[i + 1] - heights[i];
        if (diff > 0) {
            min_heap.push(diff);
            if (min_heap.size() > ladders) {
                bricks -= min_heap.top();
                min_heap.pop();
                if (bricks < 0) {
                    return i;
                }
            }
        }
    }
    return heights.size() - 1;
}


-----
#include <vector>
#include <queue>

int furthestBuilding(std::vector<int>& heights, int bricks, int ladders) 
    // Your code here
}


************************************
Question ID: 1763

#include <string>
using namespace std;

string longestNiceSubstring(string s) {
    int n = s.length();
    string result = "";
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; ++j) {
            bool isNice = true;
            for (char ch = 'A'; ch <= 'Z'; ++ch) {
                bool upper = false, lower = false;
                for (int k = i; k <= j; ++k) {
                    if (s[k] == ch) upper = true;
                    if (s[k] == (ch + 32)) lower = true;
                }
                if ((upper && !lower) || (!upper && lower)) {
                    isNice = false;
                    break;
                }
            }
            if (isNice && j - i + 1 > result.length()) {
                result = s.substr(i, j - i + 1);
            }
        }
    }
    return result;
}

-----
#include <string>
using namespace std;

string longestNiceSubstring(string s) 
    // Your code here
}

************************************
Question ID: 1764

#include <string>

int maxKRepeating(std::string sequence, std::string word) {
    int maxK = 0;
    int seqLength = sequence.length();
    int wordLength = word.length();
    for (int i = 0; i <= seqLength - wordLength; i++) {
        int k = 0;
        while (sequence.compare(i, wordLength * (k + 1), word.repeat(k + 1)) == 0) {
            k++;
        }
        if (k > maxK) {
            maxK = k;
        }
    }
    return maxK;
}

-----
#include <string>

int maxKRepeating(std::string sequence, std::string word) 
    // Your code here
}

************************************
Question ID: 1766

int minimumMountainRemovals(vector<int>& nums) {
    int n = nums.size();
    vector<int> left(n), right(n);
    for (int i = 0; i < n; ++i) {
        left[i] = lower_bound(left.begin(), left.begin() + i, nums[i]) - left.begin();
        right[n - 1 - i] = lower_bound(right.rbegin(), right.rend() - i, nums[n - 1 - i]) - right.rbegin();
    }
    int result = n;
    for (int i = 1; i < n - 1; ++i)
        result = min(result, n - (left[i] + 1) - (right[i] + 1));

    return result;
}

-----
int minimumMountainRemovals(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1768

std::string mergeAlternately(std::string word1, std::string word2) {
    std::string result = "";
    int i = 0, j = 0;
    while (i < word1.length() && j < word2.length()) {
        result += word1[i++];
        result += word2[j++];
    }
    while (i < word1.length()) result += word1[i++];
    while (j < word2.length()) result += word2[j++];
    return result;
}

-----
std::string mergeAlternately(std::string word1, std::string word2) 
    // Your code here
}

************************************
Question ID: 1769

#include <vector>
using namespace std;

int maximumGenerated(int n) {
    if (n == 0) {
        return 0;
    }
    vector<int> nums(n + 1);
    nums[1] = 1;
    for (int i = 2; i <= n; ++i) {
        nums[i] = i % 2 == 0 ? nums[i / 2] : nums[i / 2] + nums[i / 2 + 1];
    }
    return *max_element(nums.begin(), nums.end());
}

-----
#include <vector>
using namespace std;

int maximumGenerated(int n) 
    // Your code here
}

************************************
Question ID: 1770

int minDeletions(string s) {
    unordered_map<char, int> freq;
    unordered_set<int> used;
    int deletions = 0;

    for (char c : s) {
        freq[c]++;
    }

    for (auto const& [char, count] : freq) {
        while (used.find(count) != used.end() && count > 0) {
            deletions++;
            count--;
        }
        used.insert(count);
    }

    return deletions;
}

-----
int minDeletions(string s) 
    // Your code here
}

************************************
Question ID: 1771

#include <vector>
#include <algorithm>

int maxProfit(std::vector<int>& inventory, int orders) {
    long long mod = 1e9 + 7;
    std::sort(inventory.begin(), inventory.end(), std::greater<>());
    inventory.push_back(0);
    long long n = inventory.size(), ans = 0, count = 1;
    for (int i = 0; i < n - 1; ++i, ++count) {
        long long diff = inventory[i] - inventory[i + 1];
        if (count * diff < orders) {
            orders -= count * diff;
            ans = (ans + (((inventory[i] + inventory[i + 1] + 1) * diff) / 2) % mod * count) % mod;
        } else {
            long long q = orders / count;
            long long r = orders % count;
            ans = (ans + (((inventory[i] + inventory[i] - q + 1) * q) / 2) % mod * count) % mod;
            ans = (ans + r * (inventory[i] - q)) % mod;
            break;
        }
    }
    return ans;
}

-----
#include <vector>
#include <algorithm>

int maxProfit(std::vector<int>& inventory, int orders) 
    // Your code here
}

************************************
Question ID: 1772

#include <set>

const int MOD = 1e9 + 7;

int createSortedArray(vector<int>& instructions) {
    multiset<int> s;
    int cost = 0;

    for (int i : instructions) {
        s.insert(i);
        int less_than = distance(s.begin(), s.lower_bound(i));
        int greater_than = distance(s.upper_bound(i), s.end());
        cost = (cost + min(less_than, greater_than)) % MOD;
    }

    return cost;
}

-----
#include <set>

const int MOD = 1e9 + 7;

int createSortedArray(vector<int>& instructions) 
    // Your code here
}

************************************
Question ID: 1773

#include <vector>
#include <string>
using namespace std;

int countMatches(vector<vector<string>>& items, string ruleKey, string ruleValue) {
    int count = 0;
    int index = (ruleKey == "type" ? 0 : (ruleKey == "color" ? 1 : 2));
    for (const auto& item : items) {
        if (item[index] == ruleValue)
            count++;
    }
    return count;
}

-----
#include <vector>
#include <string>
using namespace std;

int countMatches(vector<vector<string>>& items, string ruleKey, string ruleValue) 
    // Your code here
}

************************************
Question ID: 1774

#include <vector>
#include <algorithm>
#include <limits>

int closestCost(std::vector<int>& baseCosts, std::vector<int>& toppingCosts, int target) {
    int closest = std::numeric_limits<int>::max();
    std::sort(toppingCosts.begin(), toppingCosts.end());

    for (const int& base : baseCosts) {
        int diff = abs(target - base);
        if (diff < closest) {
            closest = diff;
        }
        if (diff == 0) {
            return target;
        }
        for (int t0 = 0; t0 <= 2; ++t0) {
            int x1 = base + t0 * toppingCosts[0];
            int diff1 = abs(target - x1);
            if (diff1 < closest) {
                closest = diff1;
            }
            if (diff1 == 0) {
                return target;
            }
            for (int t1 = 0; t1 <= 2; ++t1) {
                int x2 = x1 + t1 * toppingCosts[1];
                int diff2 = abs(target - x2);
                if (diff2 < closest) {
                    closest = diff2;
                }
                if (diff2 == 0) {
                    return target;
                }
            }
        }
    }
    return target - closest;
}

-----
#include <vector>
#include <algorithm>
#include <limits>

int closestCost(std::vector<int>& baseCosts, std::vector<int>& toppingCosts, int target) 
    // Your code here
}

************************************
Question ID: 1776

int minOperations(vector<int>& nums, int x) {
    int total = accumulate(nums.begin(), nums.end(), 0);
    int target = total - x;
    if (target < 0) return -1;

    int maxLength = -1;
    int left = 0, sum = 0;
    for (int right = 0; right < nums.size(); ++right) {
      sum += nums[right];

      while (sum > target) {
        sum -= nums[left++];
      }

      if (sum == target) {
        maxLength = max(maxLength, right - left + 1);
      }
    }

    return maxLength == -1 ? -1 : nums.size() - maxLength;
}


-----
int minOperations(vector<int>& nums, int x) 
    // Your code here
}


************************************
Question ID: 1778

int maxHappy(int m, int n, int introvertsCount, int extrovertsCount, int y = 0, int mask = 0) {
    if (y == n)
        return 0;

    static int dp[6][6][6 * 6][1 << 6];
    static bool seen[6][6][6 * 6][1 << 6] = {};
    if (seen[m][n][introvertsCount][mask])
        return dp[m][n][introvertsCount][mask];
    seen[m][n][introvertsCount][mask] = true;

    int cur = y * m, ans = 0;
    for (int x = 0; x <= m; ++x) {
        int happiness = 0;
        if ((mask >> x) & 1) {
            happiness -= 30;
            if (x > 0 && (mask & 1))
                happiness -= 30;
            else
                happiness += 20;
        }
        ans = max(ans, happiness + maxHappy(m, n, introvertsCount, extrovertsCount, y + 1, (mask | (1 << x)) >> 1));
    }

    return dp[m][n][introvertsCount][mask] = ans;
}

int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {
    return maxHappy(m, n, introvertsCount, extrovertsCount);
}


-----
int maxHappy(int m, int n, int introvertsCount, int extrovertsCount, int y = 0, int mask = 0) 
    // Your code here
}


************************************
Question ID: 1779

int nearestValidPoint(int x, int y, vector<vector<int>>& points) {
    int min_distance = INT_MAX, index = -1;
    for (int i = 0; i < points.size(); i++) {
        if (x == points[i][0] || y == points[i][1]) {
            int distance = abs(x - points[i][0]) + abs(y - points[i][1]);
            if (distance < min_distance) {
                min_distance = distance;
                index = i;
            }
        }
    }
    return index;
}

-----
int nearestValidPoint(int x, int y, vector<vector<int>>& points) 
    // Your code here
}

************************************
Question ID: 1780

bool checkPowersOfThree(int n) {
    while (n > 0) {
        if (n % 3 == 2) return false;
        n /= 3;
    }
    return true;
}

-----
bool checkPowersOfThree(int n) 
    // Your code here
}

************************************
Question ID: 1781

bool arrayStringsAreEqual(std::vector<std::string>& word1, std::vector<std::string>& word2) {
    std::string s1, s2;
    for (auto& w : word1) s1 += w;
    for (auto& w : word2) s2 += w;
    return s1 == s2;
}

-----
bool arrayStringsAreEqual(std::vector<std::string>& word1, std::vector<std::string>& word2) 
    // Your code here
}

************************************
Question ID: 1782

#include <string>
using namespace std;

string getSmallestString(int n, int k) {
    string result(n, 'a');
    k -= n;
    for (int i = n - 1; i >= 0; --i) {
        int value = min(k, 25);
        result[i] += value;
        k -= value;
        if (k == 0) break;
    }
    return result;
}

-----
#include <string>
using namespace std;

string getSmallestString(int n, int k) 
    // Your code here
}

************************************
Question ID: 1784

#include <vector>
#include <algorithm>

int minimumEnergy(std::vector<std::vector<int>>& tasks) {
    std::sort(tasks.begin(), tasks.end(), [](const std::vector<int>& a, const std::vector<int>& b) {
        return a[1] - a[0] > b[1] - b[0];
    });

    int energy = 0;
    for (const auto& task : tasks) {
        energy = std::max(energy + task[0], task[1]);
    }
    return energy;
}

-----
#include <vector>
#include <algorithm>

int minimumEnergy(std::vector<std::vector<int>>& tasks) 
    // Your code here
}

************************************
Question ID: 1785

int minElements(vector<int>& nums, int limit, int goal) {
    long long sum = 0;
    for (int num : nums) sum += num;
    long long diff = abs(goal - sum);
    
    return (diff + limit - 1) / limit;
}


-----
int minElements(vector<int>& nums, int limit, int goal) 
    // Your code here
}


************************************
Question ID: 1786

int countConsistentStrings(string allowed, vector<string>& words) {
    unordered_set<char> allowedSet(allowed.begin(), allowed.end());
    int count = 0;
    for (const string& word : words) {
        bool isValid = true;
        for (char c : word) {
            if (allowedSet.count(c) == 0) {
                isValid = false;
                break;
            }
        }
        if (isValid) {
            count++;
        }
    }
    return count;
}

-----
int countConsistentStrings(string allowed, vector<string>& words) 
    // Your code here
}

************************************
Question ID: 1787

#include <vector>
#include <cstdlib>

std::vector<int> calculate_summation_of_absolute_differences(const std::vector<int>& nums) {
    int n = nums.size();
    std::vector<int> result(n, 0);

    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            if(i != j) {
                result[i] += std::abs(nums[i] - nums[j]);
            }
        }
    }

    return result;
}

-----
#include <vector>
#include <cstdlib>

std::vector<int> calculate_summation_of_absolute_differences(const std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1788

int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {
    int n = aliceValues.size();
    vector<pair<int, int>> sums;
    
    for (int i = 0; i < n; ++i) {
        sums.push_back({aliceValues[i] + bobValues[i], i});
    }
    
    sort(sums.rbegin(), sums.rend());
    
    int aliceScore = 0, bobScore = 0;
    for (int i = 0; i < n; ++i) {
        if (i % 2 == 0) aliceScore += aliceValues[sums[i].second];
        else bobScore += bobValues[sums[i].second];
    }
    
    return (aliceScore == bobScore) ? 0 : (aliceScore > bobScore) ? 1 : -1;
}

-----
int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) 
    // Your code here
}

************************************
Question ID: 1790

bool areAlmostEqual(string s1, string s2) {
    if(s1 == s2) return true;
    vector<int> diff;
    for(int i = 0; i < s1.length(); i++) {
        if(s1[i] != s2[i]) {
            diff.push_back(i);
        }
    }
    return diff.size() == 2 && s1[diff[0]] == s2[diff[1]] && s1[diff[1]] == s2[diff[0]];
}

-----
bool areAlmostEqual(string s1, string s2) 
    // Your code here
}

************************************
Question ID: 1791

int maximumWealth(vector<vector<int>>& accounts) {
    int max_wealth = 0;
    for (const auto& customer : accounts) {
        max_wealth = max(max_wealth, accumulate(customer.begin(), customer.end(), 0));
    }
    return max_wealth;
}


-----
int maximumWealth(vector<vector<int>>& accounts) 
    // Your code here
}


************************************
Question ID: 1792

#include <vector>
#include <stack>

std::vector<int> mostCompetitive(std::vector<int>& nums, int k) {
    std::stack<int> stk;
    int n = nums.size();

    for (int i = 0; i < n; i++) {
        while (!stk.empty() && nums[i] < stk.top() && stk.size() + n - i > k) {
            stk.pop();
        }
        if (stk.size() < k) {
            stk.push(nums[i]);
        }
    }

    std::vector<int> result(k);
    for (int i = k - 1; i >= 0; i--) {
        result[i] = stk.top();
        stk.pop();
    }

    return result;
}

-----
#include <vector>
#include <stack>

std::vector<int> mostCompetitive(std::vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 1793

int minMoves(vector<int>& nums, int limit) {
    int n = nums.size();
    vector<int> delta(2 * limit + 2, 0);

    for (int i = 0; i < n / 2; i++) {
        int lo = min(nums[i], nums[n - 1 - i]) + 1;
        int hi = max(nums[i], nums[n - 1 - i]) + limit;
        delta[lo]--;
        delta[nums[i] + nums[n - 1 - i]]--;
        delta[hi + 1]++;
    }
    int moves = n, current = n;
    for (int i = 2; i <= 2 * limit; i++) {
        current += delta[i];
        moves = min(moves, current);
    }
    return moves;
}


-----
int minMoves(vector<int>& nums, int limit) 
    // Your code here
}


************************************
Question ID: 1794

#include <algorithm>
#include <queue>
#include <vector>
using namespace std;

int minimumDeviation(vector<int>& nums) {
    priority_queue<int> pq;
    int min_val = INT_MAX;
    int n = nums.size();
    
    for (int num: nums) {
        if (num % 2 == 0) {
            pq.push(num);
        } else {
            pq.push(num * 2);
        }
        min_val = min(min_val, num);
    }
    
    int result = INT_MAX;
    while (true) {
        int top = pq.top();
        pq.pop();
        result = min(result, top - min_val);
        
        if (top % 2 == 1) break;
        pq.push(top / 2);
        min_val = min(min_val, top / 2);
    }
    return result;
}


-----
#include <algorithm>
#include <queue>
#include <vector>
using namespace std;

int minimumDeviation(vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 1796

int secondHighest(string s) {
    int largest = -1, second_largest = -1;
    for (char c : s) {
        if (isdigit(c)) {
            int d = c - '0';
            if (d > largest) {
                second_largest = largest;
                largest = d;
            } else if (d < largest && d > second_largest) {
                second_largest = d;
            }
        }
    }
    return second_largest;
}

-----
int secondHighest(string s) 
    // Your code here
}

************************************
Question ID: 1797

#include <string>

std::string interpret(std::string command) {
    std::string result;
    for (int i = 0; i < command.size(); ++i) {
        if (command[i] == 'G') result += 'G';
        else if (command[i] == '(' and command[i+1] == ')') {
            result += 'o';
            i++;
        } else {
            result += "al";
            i+=3;
        }
    }
    return result;
}

-----
#include <string>

std::string interpret(std::string command) 
    // Your code here
}

************************************
Question ID: 1798

#include <unordered_map>

int maxOperations(std::vector<int>& nums, int k) {
    std::unordered_map<int, int> count;
    int operations = 0;

    for (int num : nums) {
        if (count[k - num] > 0) {
            --count[k - num];
            ++operations;
        }
        else {
            ++count[num];
        }
    }

    return operations;
}


-----
#include <unordered_map>

int maxOperations(std::vector<int>& nums, int k) 
    // Your code here
}


************************************
Question ID: 1799

#include <bits/stdc++.h>
using namespace std;

int minimumIncompatibility(vector<int>& nums, int k) {
    int n = nums.size();
    if (n % k != 0) return -1;

    sort(nums.begin(), nums.end());
    multiset<int> st;
    for (int i = 0; i < k; ++i) {
        st.insert(nums[i * (n / k)] - nums[(i + 1) * (n / k) - 1]);
    }

    return accumulate(st.begin(), st.end(), 0);
}

-----
#include <bits/stdc++.h>
using namespace std;

int minimumIncompatibility(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 1800

#include <bits/stdc++.h>
using namespace std;
int concatenatedBinary(int n) {
    long long result = 0;
    for (int i = 1; i <= n; ++i) {
        int length = log2(i) + 1;
        result = ((result << length) % 1000000007 + i) % 1000000007;
    }
    return result;
}


-----
#include <bits/stdc++.h>
using namespace std;
int concatenatedBinary(int n) 
    // Your code here
}


************************************
Question ID: 1801

#include <queue>
#include <vector>
using namespace std;

int getNumberOfBacklogOrders(vector<vector<int>>& orders) {
    priority_queue<vector<int>> buy_orders;
    priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> sell_orders;
    int num_orders = 0, mod = 1e9 + 7;

    for (auto& order : orders) {
        int price = order[0];
        int amount = order[1];
        if (order[2] == 0) { // buy order
            while (amount > 0 && !sell_orders.empty() && sell_orders.top()[0] <= price) {
                int x = min(amount, sell_orders.top()[1]);
                amount -= x;
                sell_orders.top()[1] -= x;
                if (sell_orders.top()[1] == 0) {
                    sell_orders.pop();
                }
            }
            if (amount > 0) {
                buy_orders.push({price, amount});
            }
        } else { // sell order
            while (amount > 0 && !buy_orders.empty() && buy_orders.top()[0] >= price) {
                int x = min(amount, buy_orders.top()[1]);
                amount -= x;
                buy_orders.top()[1] -= x;
                if (buy_orders.top()[1] == 0) {
                    buy_orders.pop();
                }
            }
            if (amount > 0) {
                sell_orders.push({price, amount});
            }
        }
    }

    while (!buy_orders.empty()) {
        num_orders = (num_orders + buy_orders.top()[1]) % mod;
        buy_orders.pop();
    }

    while (!sell_orders.empty()) {
        num_orders = (num_orders + sell_orders.top()[1]) % mod;
        sell_orders.pop();
    }

    return num_orders;
}

-----
#include <queue>
#include <vector>
using namespace std;

int getNumberOfBacklogOrders(vector<vector<int>>& orders) 
    // Your code here
}

************************************
Question ID: 1802

#include <vector>
#include <queue>
using namespace std;

int countStudents(vector<int>& students, vector<int>& sandwiches) {
    queue<int> q;
    for (int student : students)
        q.push(student);

    int index = 0, attempts = 0;
    while (!q.empty()) {
        int student = q.front();
        if (student == sandwiches[index]) {
            q.pop();
            index++;
            attempts = 0;
        } else {
            q.pop();
            q.push(student);
            attempts++;
        }
        if (attempts == q.size())
            break;
    }

    return q.size();
}

-----
#include <vector>
#include <queue>
using namespace std;

int countStudents(vector<int>& students, vector<int>& sandwiches) 
    // Your code here
}

************************************
Question ID: 1803

#include <vector>

double averageWaitingTime(std::vector<std::vector<int>>& customers) {
    double wait_time = 0;
    int curr_time = 0;
    
    for (auto& customer : customers) {
        curr_time = std::max(curr_time, customer[0]) + customer[1];
        wait_time += curr_time - customer[0];
    }
    
    return wait_time / customers.size();
}


-----
#include <vector>

double averageWaitingTime(std::vector<std::vector<int>>& customers) 
    // Your code here
}


************************************
Question ID: 1805

int minMoves(vector<int>& nums, int k) {
    int n = nums.size();
    vector<int> ones;
    for(int i = 0; i < n; ++i){
        if(nums[i] == 1){
            ones.push_back(i - ones.size());
        }
    }
    
    int moves = 0;
    for(int i = 0; i < k; ++i){
        moves += (ones[i] - ones[k / 2]);
    }
    
    int min_moves = moves;
    for(int i = k; i < ones.size(); ++i){
        moves += ones[i] - ones[i - k] - k;
        min_moves = min(min_moves, moves);
    }
    
    return min_moves;
}


-----
int minMoves(vector<int>& nums, int k) 
    // Your code here
}


************************************
Question ID: 1806

int numberOfMatches(int n) {
    return n - 1;
}


-----
int numberOfMatches(int n) 
    // Your code here
}


************************************
Question ID: 1807

int minPartitions(string n) {
    int max_digit = 0;
    for (char c : n) {
        max_digit = max(max_digit, c - '0');
        if (max_digit == 9) break;
    }
    return max_digit;
}

-----
int minPartitions(string n) 
    // Your code here
}

************************************
Question ID: 1808

int stoneGame(vector<int>& stones) {
    int n = stones.size();
    vector<vector<int>> dp(n, vector<int>(n, 0));
    
    for (int i = n - 1; i >= 0; --i) {
        for (int j = i + 1; j < n; ++j) {
            dp[i][j] = max(stones[j] - dp[i][j - 1], stones[i] - dp[i + 1][j]);
        }
    }
    
    return dp[0][n - 1];
}

-----
int stoneGame(vector<int>& stones) 
    // Your code here
}

************************************
Question ID: 1812

#include <string>
#include <vector>

std::string reformatNumber(std::string number) {
    std::string cleaned_number;
    for (char c : number) {
        if (isdigit(c))
            cleaned_number.push_back(c);
    }

    std::vector<std::string> blocks;
    int n = cleaned_number.size();
    int i = 0;
    while (i < n) {
        if (n - i == 2 || n - i == 4) {
            blocks.push_back(cleaned_number.substr(i, 2));
            i += 2;
        } else {
            blocks.push_back(cleaned_number.substr(i, 3));
            i += 3;
        }
    }

    std::string formatted_number = blocks[0];
    for (int i = 1; i < blocks.size(); i++) {
        formatted_number += '-' + blocks[i];
    }
    return formatted_number;
}

-----
#include <string>
#include <vector>

std::string reformatNumber(std::string number) 
    // Your code here
}

************************************
Question ID: 1813

#include <unordered_set>
#include <vector>

int maximumUniqueSubarray(std::vector<int>& nums) {
    int max_sum = 0, current_sum = 0, left = 0;
    std::unordered_set<int> elements;
    
    for (int right = 0; right < nums.size(); ++right) {
        while (elements.count(nums[right])) {
            elements.erase(nums[left]);
            current_sum -= nums[left++];
        }
        
        elements.insert(nums[right]);
        current_sum += nums[right];
        max_sum = std::max(max_sum, current_sum);
    }
    
    return max_sum;
}


-----
#include <unordered_set>
#include <vector>

int maximumUniqueSubarray(std::vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 1814

int maxResult(vector<int>& nums, int k) {
    int n = nums.size();
    deque<int> dq;
    vector<int> dp(n);
    
    dp[0] = nums[0];
    dq.push_back(0);
    
    for (int i = 1; i < n; ++i) {
        while (!dq.empty() && dq.front() < i - k) {
            dq.pop_front();
        }
        
        dp[i] = nums[i] + dp[dq.front()];
        
        while (!dq.empty() && dp[i] >= dp[dq.back()]) {
            dq.pop_back();
        }
        
        dq.push_back(i);
    }
    
    return dp.back();
}

-----
int maxResult(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 1815

#include <vector>
#include <queue>
using namespace std;

vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {
    for (int i = 0; i < queries.size(); ++i) {
        queries[i].push_back(i);
    }
    sort(queries.begin(), queries.end(), [](const vector<int> &a, const vector<int> &b) {
        return a[2] < b[2];
    });
    sort(edgeList.begin(), edgeList.end(), [](const vector<int> &a, const vector<int> &b) {
        return a[2] < b[2];
    });

    vector<int> parent(n);
    for (int i = 0; i < n; ++i) {
        parent[i] = i;
    }

    function<int(int)> find = [&](int x) {
        return x == parent[x] ? x : parent[x] = find(parent[x]);
    };

    vector<bool> res(queries.size());
    int idx = 0;
    for (const auto &query : queries) {
        int p = query[0], q = query[1], limit = query[2], id = query[3];
        while (idx < edgeList.size() && edgeList[idx][2] < limit) {
            int u = edgeList[idx][0], v = edgeList[idx][1];
            int ru = find(u), rv = find(v);
            if (ru != rv) {
                parent[ru] = rv;
            }
            idx++;
        }
        res[id] = find(p) == find(q);
    }
    return res;
}

-----
#include <vector>
#include <queue>
using namespace std;

vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) 
    // Your code here
}

************************************
Question ID: 1816

#include <string>
#include <sstream>
using namespace std;

string truncateSentence(string s, int k) {
    istringstream is(s);
    string result, tmp;
    while (k--) {
        is >> tmp;
        result += tmp + " ";
    }
    result.pop_back();
    return result;
}

-----
#include <string>
#include <sstream>
using namespace std;

string truncateSentence(string s, int k) 
    // Your code here
}

************************************
Question ID: 1817

int totalMoney(int n) {
    int weeks = n / 7;
    int days_remaining = n % 7;
    return 28 * weeks + 7 * weeks * (weeks - 1) / 2 + (weeks + 1) * days_remaining + days_remaining * (days_remaining - 1) / 2;
}


-----
int totalMoney(int n) 
    // Your code here
}


************************************
Question ID: 1818

int maxPoints(string s, int x, int y) {
    int points = 0;
    for (int i = 1; i < s.length(); ++i) {
        if (s[i] == s[i - 1]) {
            points += max(x, y);
            s[i] = '#';
        }
    }
    return points;
}

-----
int maxPoints(string s, int x, int y) 
    // Your code here
}

************************************
Question ID: 1819

#include <vector>
using namespace std;

vector<int> largestLexSequence(int n) {
    vector<int> res(n);
    for (int i = 0; i < n; ++i) {
        res[i] = i % 2;
    }
    return res;
}

-----
#include <vector>
using namespace std;

vector<int> largestLexSequence(int n) 
    // Your code here
}

************************************
Question ID: 1820

#include <vector>
using namespace std;

int countTrees(vector<vector<int>>& pairs) {
    int nodes = pairs.size() + 1;
    vector<int> in_degrees(nodes, 0);
    for (vector<int>& pair : pairs) {
        in_degrees[pair[1]]++;
    }
    
    int res = 1;
    for (int i = 1; i < nodes; i++) {
        res *= in_degrees[i];
    }
    
    return res;
}

-----
#include <vector>
using namespace std;

int countTrees(vector<vector<int>>& pairs) 
    // Your code here
}

************************************
Question ID: 1822

int signFunc(int x) {
    if(x > 0) return 1;
    if(x < 0) return -1;
    return 0;
}

int arraySign(vector<int>& nums) {
    int product = 1;
    for(int i = 0; i < nums.size(); i++) {
        product *= signFunc(nums[i]);
    }
    return product;
}

-----
int signFunc(int x) 
    // Your code here
}

************************************
Question ID: 1823

#include <string>

bool halvesAreAlike(const std::string& s) {
    int half_length = s.length() / 2;
    int count_a = 0, count_b = 0;

    for (int i = 0; i < half_length; ++i) {
        if (strchr("aeiouAEIOU", s[i])) count_a++;
    }

    for (int i = half_length; i < s.length(); ++i) {
        if (strchr("aeiouAEIOU", s[i])) count_b++;
    }

    return count_a == count_b;
}

-----
#include <string>

bool halvesAreAlike(const std::string& s) 
    // Your code here
}

************************************
Question ID: 1824

#include <queue>

int eatenApples(vector<int>& apples, vector<int>& days) {
    int n = apples.size();
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    int ans = 0;

    for (int i = 0; i < n || !pq.empty(); ++i) {
        if (i < n && apples[i] > 0) {
            pq.push({i + days[i], apples[i]});
        }

        while (!pq.empty() && pq.top().first <= i) {
            pq.pop();
        }

        if (!pq.empty()) {
            ans++;
            auto curr_apple = pq.top();
            pq.pop();
            if (curr_apple.second > 1) {
                curr_apple.second--;
                pq.push(curr_apple);
            }
        }
    }

    return ans;
}


-----
#include <queue>

int eatenApples(vector<int>& apples, vector<int>& days) 
    // Your code here
}


************************************
Question ID: 1825

#include <algorithm>
#include <vector>
#include <numeric>

int minimumWorkingTime(std::vector<int>& jobs, int k) {
    int max_job = *std::max_element(jobs.begin(), jobs.end());
    int sum_jobs = std::accumulate(jobs.begin(), jobs.end(), 0);

    int left = max_job, right = sum_jobs;
    while (left < right) {
        int mid = left + (right - left) / 2;
        int count = 1, current_sum = 0;

        for (int job : jobs) {
            if (current_sum + job > mid) {
                count++;
                current_sum = 0;
            }
            current_sum += job;
        }

        if (count <= k) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}


-----
#include <algorithm>
#include <vector>
#include <numeric>

int minimumWorkingTime(std::vector<int>& jobs, int k) 
    // Your code here
}


************************************
Question ID: 1826

#include <vector>
#include <algorithm>
using namespace std;

vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {
    sort(nums.begin(), nums.end());
    for (int i = 0; i < queries.size(); ++i) {
        queries[i].push_back(i);
    }
    sort(queries.begin(), queries.end(), [](vector<int> &a, vector<int> &b) {
        return a[1] < b[1];
    });

    vector<int> ans(queries.size());
    int idx = 0, trie[200010][2] = {}, sum[200010] = {1}, cnt = 0;
    for (const auto &q : queries) {
        int x = q[0], m = q[1], k = q[2], p = 0;
        while (idx < nums.size() && nums[idx] <= m) {
            int cur = 0, t = nums[idx++];
            for (int i = 31; i >= 0; --i) {
                int bit = ((t >> i) & 1);
                if (!trie[cur][bit]) {
                    trie[cur][bit] = ++cnt;
                }
                cur = trie[cur][bit];
            }
            sum[cur]++;
        }
        if (!cnt) { 
            ans[k] = -1; 
            continue; 
        }
        int cur = 0, ans2 = 0;
        for (int i = 31; i >= 0; --i) {
            int bit = ((x >> i) & 1);
            if (trie[cur][bit ^ 1]) {
                cur = trie[cur][bit ^ 1];
                ans2 |= (1 << i);
            } else {
                cur = trie[cur][bit];
            }
        }
        ans[k] = ans2;
    }
    return ans;
}


-----
#include <vector>
#include <algorithm>
using namespace std;

vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) 
    // Your code here
}


************************************
Question ID: 1827

int min_operations(vector<int>& nums) {
    int operations = 0;
    for (int i = 1; i < nums.size(); i++) {
        if (nums[i] <= nums[i - 1]) {
            operations += (nums[i - 1] - nums[i]) + 1;
            nums[i] = nums[i - 1] + 1;
        }
    }
    return operations;
}

-----
int min_operations(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1828

#include <vector>
using namespace std;

vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {
    vector<int> answer;
    for (auto& query : queries) {
        int inside = 0;
        for (auto& point : points) {
            int dx = point[0] - query[0];
            int dy = point[1] - query[1];
            if (dx * dx + dy * dy <= query[2] * query[2]) {
                inside++;
            }
        }
        answer.push_back(inside);
    }
    return answer;
}


-----
#include <vector>
using namespace std;

vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) 
    // Your code here
}


************************************
Question ID: 1829

#include <vector>
#include <algorithm>
using namespace std;

bool compare(vector<int>& a, vector<int>& b) {
    return a[1] > b[1];
}

int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {
    sort(boxTypes.begin(), boxTypes.end(), compare);
    
    int totalUnits = 0;
    for (auto& box : boxTypes) {
        int boxCount = min(truckSize, box[0]);
        totalUnits += boxCount * box[1];
        truckSize -= boxCount;
        if (truckSize == 0) {
            break;
        }
    }
    
    return totalUnits;
}

-----
#include <vector>
#include <algorithm>
using namespace std;

bool compare(vector<int>& a, vector<int>& b) 
    // Your code here
}

************************************
Question ID: 1830

#include <unordered_map>

int countPairs(vector<int>& deliciousness) {
    const int MOD = 1e9 + 7;
    unordered_map<int, int> hashMap;
    int maxVal = *max_element(deliciousness.begin(), deliciousness.end());
    int maxSum = maxVal * 2;
    
    int count = 0;
    for (int val : deliciousness) {
        for (int sum = 1; sum <= maxSum; sum <<= 1) {
            count = (count + hashMap[sum - val]) % MOD;
        }
        hashMap[val]++;
    }
    
    return count;
}

-----
#include <unordered_map>

int countPairs(vector<int>& deliciousness) 
    // Your code here
}

************************************
Question ID: 1832

#include <vector>
#include <unordered_map>

int minOperations(std::vector<int>& target, std::vector<int>& arr) {
    std::unordered_map<int, int> index_map;
    for (int i = 0; i < target.size(); ++i) {
        index_map[target[i]] = i;
    }

    std::vector<int> lis;
    for (int num : arr) {
        if (index_map.count(num)) {
            int pos = std::lower_bound(lis.begin(), lis.end(), index_map[num]) - lis.begin();
            if (pos == lis.size()) {
                lis.push_back(index_map[num]);
            } else {
                lis[pos] = index_map[num];
            }
        }
    }

    return target.size() - lis.size();
}

-----
#include <vector>
#include <unordered_map>

int minOperations(std::vector<int>& target, std::vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1833

int largestAltitude(vector<int>& gain) {
    int max_altitude = 0, current_altitude = 0;
    for (int i = 0; i < gain.size(); ++i) {
        current_altitude += gain[i];
        max_altitude = max(max_altitude, current_altitude);
    }
    return max_altitude;
}

-----
int largestAltitude(vector<int>& gain) 
    // Your code here
}

************************************
Question ID: 1834

#include <vector>
#include <unordered_set>
#include <unordered_map>

int minimumTeachings(int n, std::vector<std::vector<int>>& languages, std::vector<std::vector<int>>& friendships) {
    std::unordered_map<int, std::unordered_set<int>> language_users;
    std::unordered_set<int> unconnected_users;

    for (const auto& friendship : friendships) {
        int u = friendship[0], v = friendship[1];
        bool canCommunicate = false;

        for (int lang : languages[u - 1]) {
            if (languages[v-1].find(lang) != languages[v-1].end()) {
                canCommunicate = true;
                break;
            }
        }

        if (!canCommunicate) {
            unconnected_users.insert(u);
            unconnected_users.insert(v);
        }
    }

    int res = unconnected_users.size();
    for (int i = 1; i <= n; ++i) {
        int cnt = 0;
        for (int user : unconnected_users) {
            if (languages[user - 1].find(i) == languages[user - 1].end()) {
                cnt++;
            }
        }
        res = std::min(res, cnt);
    }

    return res;
}

-----
#include <vector>
#include <unordered_set>
#include <unordered_map>

int minimumTeachings(int n, std::vector<std::vector<int>>& languages, std::vector<std::vector<int>>& friendships) 
    // Your code here
}

************************************
Question ID: 1835

#include <vector>

std::vector<int> decode(std::vector<int>& encoded) {
    int n = encoded.size() + 1;
    int total_xor = 0;
    for (int i = 1; i <= n; ++i) {
        total_xor ^= i;
    }
    int encoded_xor = 0;
    for (int i = 1; i < n - 1; i += 2) {
        encoded_xor ^= encoded[i];
    }
    std::vector<int> perm(n);
    perm[0] = total_xor ^ encoded_xor;
    for (int i = 1; i < n; ++i) {
        perm[i] = perm[i - 1] ^ encoded[i - 1];
    }
    return perm;
}

-----
#include <vector>

std::vector<int> decode(std::vector<int>& encoded) 
    // Your code here
}

************************************
Question ID: 1836

#include <vector>
#include <map>
#include <cmath>

using namespace std;

const int MOD = 1e9 + 7;

vector<int> productWays(vector<vector<int>>& queries) {
    vector<int> res;
    for (auto& q : queries) {
        int n = q[0], k = q[1];

        vector<int> pf;
        map<int, int> pm;
        for (int i = 2; i * i <= k; ++i) {
            int cnt = 0;
            while (k % i == 0) {
                cnt++;
                k /= i;
            }
            if (cnt) {
                pf.push_back(cnt);
                pm[cnt]++;
            }
        }

        if (k > 1) {
            pm[k]++;
            pf.push_back(1);
        }

        long long ans = 1;
        for (int p : pf) {
            ans = (ans * (p * (n - 1) + 1)) % MOD;
        }

        res.push_back(ans);
    }
    return res;
}

-----
#include <vector>
#include <map>
#include <cmath>

using namespace std;

const int MOD = 1e9 + 7;

vector<int> productWays(vector<vector<int>>& queries) 
    // Your code here
}

************************************
Question ID: 1837

int sumBase(int n, int k) {
    int sum = 0;
    while (n > 0) {
        sum += n % k;
        n /= k;
    }
    return sum;
}


-----
int sumBase(int n, int k) 
    // Your code here
}


************************************
Question ID: 1838

int maxFrequency(vector<int>& nums, int k) {
    sort(nums.begin(), nums.end());
    int n = nums.size(), i = 0;
    long long sum = 0;
    int max_freq = 0;

    for (int j = 0; j < n; j++) {
        sum += nums[j];
        while (sum + k < static_cast<long long>(nums[j]) * (j - i + 1)) {
            sum -= nums[i++];
        }
        max_freq = max(max_freq, j - i + 1);
    }

    return max_freq;
}

-----
int maxFrequency(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 1839

#include <vector>

std::vector<int> decode(std::vector<int>& encoded, int first) {
    std::vector<int> arr(encoded.size() + 1);
    arr[0] = first;
    for (int i = 0; i < encoded.size(); i++) {
        arr[i + 1] = arr[i] ^ encoded[i];
    }
    return arr;
}


-----
#include <vector>

std::vector<int> decode(std::vector<int>& encoded, int first) 
    // Your code here
}


************************************
Question ID: 1840

#include <vector>
#include <unordered_map>

using namespace std;

void dfs(int node, vector<int>& visited, unordered_map<int, vector<int>>& graph, vector<int>& group) {
    if (visited[node]) return;
    visited[node] = 1;
    group.push_back(node);
    for (int neighbor : graph[node]) dfs(neighbor, visited, graph, group);
}

int minimumHammingDistance(vector<int>& source, vector<int>& target, vector<vector<int>>& allowedSwaps) {
    int n = source.size();
    unordered_map<int, vector<int>> graph;
    for (auto& swap : allowedSwaps) {
        graph[swap[0]].push_back(swap[1]);
        graph[swap[1]].push_back(swap[0]);
    }

    int res = 0;
    vector<int> visited(n, 0);
    for (int i = 0; i < n; ++i) {
        if (!visited[i]) {
            vector<int> group;
            dfs(i, visited, graph, group);
            unordered_map<int, int> count;

            for (int node : group) count[source[node]]++;
            for (int node : group) if (count[target[node]]-- > 0) res++;
        }
    }
    
    return n - res;
}


-----
#include <vector>
#include <unordered_map>

using namespace std;

void dfs(int node, vector<int>& visited, unordered_map<int, vector<int>>& graph, vector<int>& group) 
    // Your code here
}


************************************
Question ID: 1842

#include <algorithm>
#include <string>
using namespace std;

string nextPalindrome(string num) {
    int n = num.size();
    string firstHalf = num.substr(0, (n + 1) / 2);
    next_permutation(firstHalf.begin(), firstHalf.end());

    if (firstHalf > num.substr(0, (n + 1) / 2)) {
        string secondHalf = firstHalf;
        reverse(secondHalf.begin(), secondHalf.end());
        if (n % 2 == 1) secondHalf = secondHalf.substr(1);
        return firstHalf + secondHalf;
    }

    return "";
}

-----
#include <algorithm>
#include <string>
using namespace std;

string nextPalindrome(string num) 
    // Your code here
}

************************************
Question ID: 1844

int countBalls(int lowLimit, int highLimit) {
    std::vector<int> boxCounts(46, 0);
    for(int i = lowLimit; i <= highLimit; i++) {
        int boxNumber = 0;
        int num = i;
        while(num) {
            boxNumber += num % 10;
            num /= 10;
        }
        boxCounts[boxNumber]++;
    }
    return *std::max_element(boxCounts.begin(), boxCounts.end());
}

-----
int countBalls(int lowLimit, int highLimit) 
    // Your code here
}

************************************
Question ID: 1845

#include <algorithm>
#include <vector>
using namespace std;

int largestSubmatrix(vector<vector<int>>& matrix) {
    int m = matrix.size(), n = matrix[0].size();
    vector<int> height(n, 0);
    int max_area = 0;

    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (matrix[i][j] == 1) height[j]++;
            else height[j] = 0;
        }
        vector<int> sorted_height(height);
        sort(sorted_height.begin(), sorted_height.end());
        for (int j = 0; j < n; ++j) {
            max_area = max(max_area, sorted_height[j] * (n - j));
        }
    }
    return max_area;
}


-----
#include <algorithm>
#include <vector>
using namespace std;

int largestSubmatrix(vector<vector<int>>& matrix) 
    // Your code here
}


************************************
Question ID: 1846

int maximumElementAfterDecrementingAndRearranging(vector<int>& arr) {
    sort(arr.begin(), arr.end());
    arr[0] = 1;
    for (int i = 1; i < arr.size(); i++) {
        arr[i] = min(arr[i], arr[i - 1] + 1);
    }
    return arr[arr.size() - 1];
}

-----
int maximumElementAfterDecrementingAndRearranging(vector<int>& arr) 
    // Your code here
}

************************************
Question ID: 1847


```cpp
#include <vector>
#include <set>
#include <limits>
using namespace std;

vector<int> closestRoom(vector<vector<int>>& rooms, vector<vector<int>>& queries) {
    sort(rooms.begin(), rooms.end(), [](const vector<int>& a, const vector<int>& b) {
        return a[1] > b[1];
    });
    
    vector<int> result(queries.size());
    for (int i = 0; i < queries.size(); ++i) {
        queries[i].push_back(i);
    }
    
    sort(queries.begin(), queries.end(), [](const vector<int>& a, const vector<int>& b) {
        return a[1] > b[1];
    });
    
    set<int> ids;
    int j = 0;
    for (const auto& q : queries) {
        while (j < rooms.size() && rooms[j][1] >= q[1]) {
            ids.insert(rooms[j++][0]);
        }
        if (ids.empty()) {
            result[q[2]] = -1;
        } else {
            int closestDiff = numeric_limits<int>::max();
            int closestId = -1;
            for (int id : {q[0], *ids.upper_bound(q[0]), *prev(ids.upper_bound(q[0]))}) {
                if (ids.count(id)) {
                    int diff = abs(id - q[0]);
                    if (diff < closestDiff) {
                        closestDiff = diff;
                        closestId = id;
                    }
                }
            }
            result[q[2]] = closestId;
        }
    }
    
    return result;
}
```


-----

```cpp
#include <vector>
#include <set>
#include <limits>
using namespace std;

vector<int> closestRoom(vector<vector<int>>& rooms, vector<vector<int>>& queries) 
    // Your code here
}
```


************************************
Question ID: 1848

int sumOfUniqueElements(const std::vector<int>& nums) {
    std::unordered_map<int, int> elemCount;
    for (const int num : nums) {
        elemCount[num]++;
    }
    int sum = 0;
    for (const auto &[elem, count] : elemCount) {
        if (count == 1) {
            sum += elem;
        }
    }
    return sum;
}


-----
int sumOfUniqueElements(const std::vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 1849

int maxAbsoluteSum(vector<int>& nums) {
    int max_sum = 0, min_sum = 0, max_so_far = 0, min_so_far = 0;
    for (int num : nums) {
        max_so_far = max(num, max_so_far + num);
        max_sum = max(max_sum, max_so_far);

        min_so_far = min(num,min_so_far + num);
        min_sum = min(min_sum, min_so_far);
    }
    return max(max_sum, abs(min_sum));
}

-----
int maxAbsoluteSum(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1850

#include <string>
#include <algorithm>

int min_length_after_operations(const std::string &s) {
    int a_count = std::count(s.begin(), s.end(), 'a');
    int b_count = std::count(s.begin(), s.end(), 'b');
    int c_count = std::count(s.begin(), s.end(), 'c');

    if (a_count % 2 == b_count % 2 && b_count % 2 == c_count % 2) {
        return s.length() % 2;
    }
    return (s.length() + 1) % 2;
}

-----
#include <string>
#include <algorithm>

int min_length_after_operations(const std::string &s) 
    // Your code here
}

************************************
Question ID: 1851

#include <vector>
#include <algorithm>
using namespace std;

bool compare(vector<int>& a, vector<int>& b) {
    return a[1] < b[1];
}

int maxValue(vector<vector<int>>& events, int k) {
    sort(events.begin(), events.end(), compare);
    int n = events.size();
    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));

    for (int i = 1; i <= n; i++) {
        int start = -1;
        for (int j = i - 1; j >= 1; j--) {
            if(events[j - 1][1] < events[i - 1][0]) {
                start = j;
                break;
            }
        }

        for (int j = 1; j <= k; j++) {
            if (start == -1) {
                dp[i][j] = max(dp[i - 1][j], events[i - 1][2]);
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[start][j - 1] + events[i - 1][2]);
            }
        }
    }

    return dp[n][k];
}


-----
#include <vector>
#include <algorithm>
using namespace std;

bool compare(vector<int>& a, vector<int>& b) 
    // Your code here
}


************************************
Question ID: 1852

#include <unordered_map>
#include <vector>
using namespace std;

vector<int> distinctNumbersInSubarrays(vector<int>& nums, int k) {
    unordered_map<int, int> counts;
    vector<int> ans;
    for (int i = 0; i < nums.size(); i++) {
        counts[nums[i]]++;
        if (i >= k) {
            counts[nums[i - k]]--;
            if (counts[nums[i - k]] == 0) {
                counts.erase(nums[i - k]);
            }
        }
        if (i >= k - 1) {
            ans.push_back(counts.size());
        }
    }
    return ans;
}

-----
#include <unordered_map>
#include <vector>
using namespace std;

vector<int> distinctNumbersInSubarrays(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 1854

int maxAliveYear(vector<vector<int>>& logs) {
    vector<int> years(101, 0);
    for (vector<int> log : logs) {
        years[log[0] - 1950]++;
        years[log[1] - 1950]--;
    }
    int max_population = years[0];
    int max_year = 1950;
    for (int i = 1; i < 101; i++) {
        years[i] += years[i - 1];
        if (years[i] > max_population) {
            max_population = years[i];
            max_year = i + 1950;
        }
    }
    return max_year;
}

-----
int maxAliveYear(vector<vector<int>>& logs) 
    // Your code here
}

************************************
Question ID: 1855

int maxDistance(vector<int>& nums1, vector<int>& nums2) {
    int i = 0, j = 0, maxDist = 0;
    while (i < nums1.size() && j < nums2.size()) {
        if (nums1[i] > nums2[j]) {
            ++i;
        } else {
            maxDist = max(maxDist, j - i);
            ++j;
        }
    }
    return maxDist;
}

-----
int maxDistance(vector<int>& nums1, vector<int>& nums2) 
    // Your code here
}

************************************
Question ID: 1856

#include <vector>
#include <stack>
using namespace std;
constexpr int MOD = 1e9 + 7;

int maxSumMinProduct(vector<int>& nums) {
    long long max_product = 0;
    stack<int> stk;
    vector<long long> prefix_sum(nums.size() + 1);

    for (int i = 0; i < nums.size(); i++) {
        prefix_sum[i + 1] = prefix_sum[i] + nums[i];
    }

    for(int i = 0; i < nums.size(); i++) {
        while (!stk.empty() && nums[stk.top()] > nums[i]) {
            int min_val = nums[stk.top()];
            stk.pop();
            max_product = max(max_product, min_val * (prefix_sum[i] - prefix_sum[stk.empty() ? 0 : stk.top() + 1]));
        }
        stk.push(i);
    }
    
    while (!stk.empty()) {
        int min_val = nums[stk.top()];
        stk.pop();
        max_product = max(max_product, min_val * (prefix_sum[nums.size()] - prefix_sum[stk.empty() ? 0 : stk.top() + 1]));
    }

    return max_product % MOD;
}


-----
#include <vector>
#include <stack>
using namespace std;
constexpr int MOD = 1e9 + 7;

int maxSumMinProduct(vector<int>& nums) 
    // Your code here
}


************************************
Question ID: 1857

#include <vector>
#include <string>
#include <unordered_map>

using namespace std;

int largestPathValue(string colors, vector<vector<int>>& edges) {
    int n = colors.size();
    vector<vector<int>> adj(n);
    vector<int> inDegrees(n, 0);

    for (auto& e : edges) {
        adj[e[0]].push_back(e[1]);
        inDegrees[e[1]]++;
    }

    vector<vector<int>> colorCounts(n, vector<int>(26, 0));
    vector<int> queue;
    for (int i = 0; i < n; i++) {
        if (inDegrees[i] == 0) {
            queue.push_back(i);
        }
    }

    int visitedNodes = 0;
    int maxColorValue = 0;

    while (!queue.empty()) {
        int node = queue.back();
        queue.pop_back();
        int color = colors[node] - 'a';
        visitedNodes++;

        for (int neighbor : adj[node]) {
            for (int c = 0; c < 26; c++) {
                int count = colorCounts[node][c] + (c == color);
                colorCounts[neighbor][c] = max(colorCounts[neighbor][c], count);
                maxColorValue = max(maxColorValue, count);
            }
            if (--inDegrees[neighbor] == 0) {
                queue.push_back(neighbor);
            }
        }
    }

    return visitedNodes == n ? maxColorValue : -1;
}


-----
#include <vector>
#include <string>
#include <unordered_map>

using namespace std;

int largestPathValue(string colors, vector<vector<int>>& edges) 
    // Your code here
}


************************************
Question ID: 1858

#include <string>
using namespace std;

string maximumTime(string time) {
    if (time[0] == '?') {
        time[0] = (time[1] == '?' || time[1] - '0' < 4) ? '2' : '1';
    }
    if (time[1] == '?') {
        time[1] = (time[0] == '2') ? '3' : '9';
    }
    if (time[3] == '?') {
        time[3] = '5';
    }
    if (time[4] == '?') {
        time[4] = '9';
    }
    return time;
}

-----
#include <string>
using namespace std;

string maximumTime(string time) 
    // Your code here
}

************************************
Question ID: 1859

int minOperationsToSatisfyConditions(std::string a, std::string b) {
    int same = 0, less = 0, greater = 0;
    
    for (size_t i = 0; i < a.length(); ++i) {
        if (a[i] == b[i]) same++;
        else if (a[i] < b[i]) less++;
        else greater++;
    }

    return std::min({same + std::max(less, greater), less, greater});
}

-----
int minOperationsToSatisfyConditions(std::string a, std::string b) 
    // Your code here
}

************************************
Question ID: 1860

#include <vector>
#include <queue>

int kthLargestValue(std::vector<std::vector<int>>& matrix, int k) {
    int m = matrix.size(), n = matrix[0].size();
    std::vector<std::vector<int>> prefixXOR(m + 1, std::vector<int>(n + 1, 0));
    std::priority_queue<int, std::vector<int>, std::greater<int>> pq;

    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            prefixXOR[i][j] = matrix[i - 1][j - 1] ^ prefixXOR[i - 1][j] ^ prefixXOR[i][j - 1] ^ prefixXOR[i - 1][j - 1];
            pq.push(prefixXOR[i][j]);
            if (pq.size() > k) {
                pq.pop();
            }
        }
    }
    return pq.top();
}


-----
#include <vector>
#include <queue>

int kthLargestValue(std::vector<std::vector<int>>& matrix, int k) 
    // Your code here
}


************************************
Question ID: 1861

int min_boxes_touching_floor(int n) {
    return (n + 1) / 2;
}

-----
int min_boxes_touching_floor(int n) 
    // Your code here
}

************************************
Question ID: 1862

int sumOfFloooredPairs(vector<int>& nums) {
    const int MOD = 1e9 + 7;
    int n = nums.size();
    int max_element = *max_element(nums.begin(), nums.end());
    vector<long long> cnt(max_element + 1, 0);
    for (int num : nums)
        cnt[num]++;
    for (int i = 1; i <= max_element; i++)
        cnt[i] += cnt[i - 1];
    
    long long res = 0;
    for (int num : nums) {
        for (int j = 1, k = 1; k <= max_element; j++, k += num) {
            res += j * (cnt[min(k + num - 1, max_element)] - cnt[k - 1]);
            res %= MOD;
        }
    }
    
    return res;
}

-----
int sumOfFloooredPairs(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1863

int subsetXORSum(vector<int>& nums) {
    int ans = 0, n = nums.size(), max_val = 1 << n;
    for (int i = 1; i < max_val; i++) {
        int xor_total = 0;
        for (int j = 0; j < n; ++j) {
            if (i & (1 << j)) {
                xor_total ^= nums[j];
            }
        }
        ans += xor_total;
    }
    return ans;
}

-----
int subsetXORSum(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1864

int minSwaps(string s) {
    int zeroCount = 0, oneCount = 0;
    for (char c : s) {
        (c == '0') ? zeroCount++ : oneCount++;
    }

    if (abs(zeroCount - oneCount) > 1) {
        return -1;
    }

    int swaps1 = 0, swaps2 = 0;
    for (int i = 0; i < s.length(); i++) {
        if (i % 2 == 0 && s[i] != '0') {
            swaps1++;
        }
        if (i % 2 == 1 && s[i] != '1') {
            swaps1++;
        }
    }
    swaps1 = swaps1 / 2;

    for (int i = 0; i < s.length(); i++) {
        if (i % 2 == 0 && s[i] != '1') {
            swaps2++;
        }
        if (i % 2 == 1 && s[i] != '0') {
            swaps2++;
        }
    }
    swaps2 = swaps2 / 2;

    if (zeroCount == oneCount) {
        return min(swaps1, swaps2);
    }
    return (zeroCount > oneCount) ? swaps2 : swaps1;
}

-----
int minSwaps(string s) 
    // Your code here
}

************************************
Question ID: 1865

#include <unordered_map>
#include <vector>

class FindSumPairs {
public:
    std::vector<int> nums1;
    std::vector<int> nums2;
    std::unordered_map<int, int> nums2Map;

    FindSumPairs(std::vector<int>& nums1, std::vector<int>& nums2) : nums1(nums1), nums2(nums2) {
        for (int num : nums2) {
            nums2Map[num]++;
        }
    }

    void add(int index, int val) {
        nums2Map[nums2[index]]--;
        nums2[index] += val;
        nums2Map[nums2[index]]++;
    }

    int count(int tot) {
        int count = 0;
        for (int num : nums1) {
            count += nums2Map[tot - num];
        }
        return count;
    }
};


-----
#include <unordered_map>
#include <vector>

class FindSumPairs 
    // Your code here
};


************************************
Question ID: 1866

#include <vector>
#include <unordered_map>

std::vector<int> restoreArray(std::vector<std::vector<int>>& adjacentPairs) {
    std::unordered_map<int, std::vector<int>> graph;
    for (const auto& pair : adjacentPairs) {
        graph[pair[0]].push_back(pair[1]);
        graph[pair[1]].push_back(pair[0]);
    }
    std::vector<int> nums;
    for (const auto& entry : graph) {
        if (entry.second.size() == 1) {
            nums.push_back(entry.first);
            break;
        }
    }
    nums.push_back(graph[nums[0]][0]);
    for (int i = 2; i < graph.size(); ++i) {
        int n = graph[nums.back()].size();
        nums.push_back(nums.back() == graph[nums[i-2]][0] ? graph[nums[i-2]][1] : graph[nums[i-2]][0]);
    }
    return nums;
}

-----
#include <vector>
#include <unordered_map>

std::vector<int> restoreArray(std::vector<std::vector<int>>& adjacentPairs) 
    // Your code here
}

************************************
Question ID: 1868

#include <vector>
using namespace std;

vector<vector<int>> findRLEProduct(vector<vector<int>>& encoded1, vector<vector<int>>& encoded2) {
    vector<vector<int>> result;
    int i = 0, j = 0, count1 = 0, count2 = 0;

    while (i < encoded1.size() && j < encoded2.size()) {
        int product = encoded1[i][0] * encoded2[j][0];
        int count = min(encoded1[i][1] - count1, encoded2[j][1] - count2);
        count1 += count;
        count2 += count;

        if (!result.empty() && result.back()[0] == product) {
            result.back()[1] += count;
        } else {
            result.push_back({product, count});
        }

        if (count1 == encoded1[i][1]) {
            i++;
            count1 = 0;
        }

        if (count2 == encoded2[j][1]) {
            j++;
            count2 = 0;
        }
    }

    return result;
}

-----
#include <vector>
using namespace std;

vector<vector<int>> findRLEProduct(vector<vector<int>>& encoded1, vector<vector<int>>& encoded2) 
    // Your code here
}

************************************
Question ID: 1869

bool checkZeroOnes(string s) {
    int max_ones = 0, max_zeros = 0, current_ones = 0, current_zeros = 0;
    for (char c : s) {
        if (c == '1') {
            current_ones++;
            current_zeros = 0;
        } else {
            current_zeros++;
            current_ones = 0;
        }
        max_ones = max(max_ones, current_ones);
        max_zeros = max(max_zeros, current_zeros);
    }
    return max_ones > max_zeros;
}

-----
bool checkZeroOnes(string s) 
    // Your code here
}

************************************
Question ID: 1870

int minSpeedOnTime(vector<int>& dist, double hour) {
    double max_time = hour - dist.size() + 1;
    double lower = 1.0, upper = 1e7;
    while (upper - lower >= 1e-9) {
        double mid = (lower + upper) / 2;
        double time_taken = 0.0;
        for (int i = 0; i < dist.size(); ++i) {
            time_taken += ceil(dist[i] / mid) - (i == dist.size() - 1 ? 0 : 1);
        }
        if (time_taken <= max_time) {
            upper = mid;
        } else {
            lower = mid;
        }
    }
    return (lower <= 1e7) ? int(ceil(lower)) : -1;
}

-----
int minSpeedOnTime(vector<int>& dist, double hour) 
    // Your code here
}

************************************
Question ID: 1871

bool isPalindrome(const std::string &s, int l, int r) {
    while (l < r) {
        if (s[l++] != s[r--]) return false;
    }
    return true;
}

bool checkPartitioning(std::string s) {
    int n = s.length();
    for (int i = 0; i < n - 2; ++i) {
        if (isPalindrome(s, 0, i)) {
            for (int j = i + 1; j < n - 1; ++j) {
                if (isPalindrome(s, i + 1, j) && isPalindrome(s, j + 1, n - 1)) {
                    return true;
                }
            }
        }
    }
    return false;
}


-----
bool isPalindrome(const std::string &s, int l, int r) 
    // Your code here
}


************************************
Question ID: 1872

#include <vector>

std::vector<bool> canEat(std::vector<int>& candiesCount, std::vector<std::vector<int>>& queries) {
    std::vector<long long> prefixSum(candiesCount.size() + 1);
    for (int i = 0; i < candiesCount.size(); ++i) {
        prefixSum[i + 1] = prefixSum[i] + candiesCount[i];
    }

    std::vector<bool> result(queries.size());
    for (int i = 0; i < queries.size(); ++i) {
        int favoriteType = queries[i][0], favoriteDay = queries[i][1], dailyCap = queries[i][2];
        long long x1 = favoriteDay + 1;
        long long y1 = (favoriteDay + 1LL) * dailyCap;

        long long x2 = prefixSum[favoriteType] + 1;
        long long y2 = prefixSum[favoriteType + 1];

        result[i] = !(x1 > y2 || y1 < x2);
    }

    return result;
}

-----
#include <vector>

std::vector<bool> canEat(std::vector<int>& candiesCount, std::vector<std::vector<int>>& queries) 
    // Your code here
}

************************************
Question ID: 1874

#include <vector>

bool canChoose(const std::vector<std::vector<int>>& groups, const std::vector<int>& nums) {
    int g_i = 0, n_i = 0;
    while (g_i < groups.size() && n_i + groups[g_i].size() <= nums.size()) {
        bool match = true;
        for (int i = 0; i < groups[g_i].size(); ++i) {
            if (groups[g_i][i] != nums[n_i + i]) {
                match = false;
                break;
            }
        }
        if (match) {
            n_i += groups[g_i].size();
            g_i++;
        } else {
            n_i++;
        }
    }
    return g_i == groups.size();
}

-----
#include <vector>

bool canChoose(const std::vector<std::vector<int>>& groups, const std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1876

#include <vector>
#include <queue>
using namespace std;

vector<vector<int>> highestIsland(vector<vector<int>>& isWater) {
    int m = isWater.size();
    int n = isWater[0].size();
    vector<vector<int>> height(m, vector<int>(n, -1));
    queue<pair<int, int>> q;

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (isWater[i][j] == 1) {
                height[i][j] = 0;
                q.push({i, j});
            }
        }
    }

    vector<int> dx = {-1, 0, 1, 0};
    vector<int> dy = {0, 1, 0, -1};

    while (!q.empty()) {
        int x = q.front().first;
        int y = q.front().second;
        q.pop();

        for (int i = 0; i < 4; i++) {
            int newX = x + dx[i];
            int newY = y + dy[i];

            if (newX >= 0 && newX < m && newY >= 0 && newY < n && height[newX][newY] == -1) {
                height[newX][newY] = height[x][y] + 1;
                q.push({newX, newY});
            }
        }
    }

    return height;
}

-----
#include <vector>
#include <queue>
using namespace std;

vector<vector<int>> highestIsland(vector<vector<int>>& isWater) 
    // Your code here
}

************************************
Question ID: 1877

int minPairSum(vector<int>& nums) {
    sort(nums.begin(), nums.end());
    int max_sum = 0;
    for (int i = 0; i < nums.size() / 2; ++i)
        max_sum = max(max_sum, nums[i] + nums[nums.size() - 1 - i]);
    return max_sum;
}

-----
int minPairSum(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1878

bool check(vector<int>& nums) {
    int count = 0;
    for (int i = 1; i < nums.size(); ++i) {
        if (nums[i] < nums[i - 1]) {
            ++count;
        }
        if (count > 1) {
            return false;
        }
    }
    return (count == 1) || (nums.front() >= nums.back());
}

-----
bool check(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1879

int maxScore(int a, int b, int c) {
    return (a + b + c - std::max({a, b, c})) / 2;
}


-----
int maxScore(int a, int b, int c) 
    // Your code here
}


************************************
Question ID: 1880

#include <string>

std::string largestMerge(std::string word1, std::string word2) {
    std::string merge = "";
    while (!word1.empty() || !word2.empty()) {
        if (word1 > word2) {
            merge += word1[0];
            word1 = word1.substr(1);
        } else {
            merge += word2[0];
            word2 = word2.substr(1);
        }
    }
    return merge;
}

-----
#include <string>

std::string largestMerge(std::string word1, std::string word2) 
    // Your code here
}

************************************
Question ID: 1881

#include <algorithm>
#include <set>

int minAbsDifference(std::vector<int>& nums, int goal) {
    int n = nums.size();
    std::vector<int> left(nums.begin(), nums.begin() + n / 2);
    std::vector<int> right(nums.begin() + n / 2, nums.end());
    std::set<int> sums;

    for (int mask = 0; mask < (1 << left.size()); ++mask) {
        int sum = 0;
        for (int i = 0; i < left.size(); ++i) {
            if (mask & (1 << i)) {
                sum += left[i];
            }
        }
        sums.insert(sum);
    }

    int ans = std::abs(goal);

    for (int mask = 0; mask < (1 << right.size()); ++mask) {
        int sum = 0;
        for (int i = 0; i < right.size(); ++i) {
            if (mask & (1 << i)) {
                sum += right[i];
            }
        }
        auto it = sums.lower_bound(goal - sum);
        if (it != sums.end()) {
            ans = std::min(ans, std::abs((*it) + sum - goal));
        }
        if (it != sums.begin()) {
            ans = std::min(ans, std::abs((*std::prev(it)) + sum - goal));
        }
    }

    return ans;
}

-----
#include <algorithm>
#include <set>

int minAbsDifference(std::vector<int>& nums, int goal) 
    // Your code here
}

************************************
Question ID: 1882

#include <vector>
#include <queue>
#include <set>

std::vector<int> assignTasks(std::vector<int>& servers, std::vector<int>& tasks) {
    std::vector<int> res(tasks.size());
    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> free_servers;
    std::priority_queue<std::pair<int, std::pair<int, int>>, std::vector<std::pair<int, std::pair<int, int>>>, std::greater<std::pair<int, std::pair<int, int>>>> busy_servers;

    for (int i = 0; i < servers.size(); ++i) {
        free_servers.push({servers[i], i});
    }

    for (int t = 0, i = 0; i < tasks.size(); ++t) {
        while (!busy_servers.empty() && busy_servers.top().first == t) {
            auto [server, job] = busy_servers.top().second;
            free_servers.push({server, job});
            busy_servers.pop();
        }
        if (t < tasks.size() && !free_servers.empty()) {
            res[i] = free_servers.top().second;
            busy_servers.push({t + tasks[i], {servers[res[i]], res[i]}});
            free_servers.pop();
            ++i;
        }
    }

    return res;
}


-----
#include <vector>
#include <queue>
#include <set>

std::vector<int> assignTasks(std::vector<int>& servers, std::vector<int>& tasks) 
    // Your code here
}


************************************
Question ID: 1883

#include <vector>
#include <limits>
using namespace std;

int minSkips(vector<int>& dist, int speed, int hoursBefore) {
    int n = dist.size();
    vector<vector<double>> dp(n + 1, vector<double>(n + 1, 1e9));
    dp[0][0] = 0;

    for (int i = 0; i < n; ++i) {
        for (int j = -1; j < i; ++j) {
            double t = dist[i] / double(speed) + (j != -1);
            dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j] + t);
            double skipped_t = ceil(dp[i][j] + dist[i] / double(speed)) - dp[i][j];
            dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + skipped_t);
        }
    }

    for (int i = 0; i <= n; ++i) {
        if (dp[n][i] <= hoursBefore) return i;
    }
    return -1;
}

-----
#include <vector>
#include <limits>
using namespace std;

int minSkips(vector<int>& dist, int speed, int hoursBefore) 
    // Your code here
}

************************************
Question ID: 1884

int min_operations_to_alternate(const std::string& s) {
    int count_a = 0, count_b = 0;
    for (std::size_t i = 0; i < s.size(); ++i) {
        if (i % 2 == 0) {
            if (s[i] == '0') count_a++;
            else count_b++;
        } else {
            if (s[i] == '0') count_b++;
            else count_a++;
        }
    }
    return std::min(count_a, count_b);
}

-----
int min_operations_to_alternate(const std::string& s) 
    // Your code here
}

************************************
Question ID: 1885

int countHomogenous(std::string s) {
    int res = 0, count = 1, mod = 1e9 + 7;
    for (int i = 1; i < s.size(); ++i) {
        count = (s[i] == s[i - 1]) ? count + 1 : 1;
        res = (res + count) % mod;
    }
    return res;
}

-----
int countHomogenous(std::string s) 
    // Your code here
}

************************************
Question ID: 1886

#include <queue>
#include <vector>

int minimumSize(std::vector<int>& nums, int maxOperations) {
    std::priority_queue<int> pq(nums.begin(), nums.end());
    while (maxOperations > 0) {
        int maxBalls = pq.top();
        pq.pop();
        pq.push(maxBalls / 2);
        pq.push(maxBalls - (maxBalls / 2));
        maxOperations--;
    }
    return pq.top();
}

-----
#include <queue>
#include <vector>

int minimumSize(std::vector<int>& nums, int maxOperations) 
    // Your code here
}

************************************
Question ID: 1887

#include <vector>
#include <unordered_map>
#include <algorithm>

int minTrioDegree(int n, std::vector<std::vector<int>>& edges) {
    std::unordered_map<int, std::unordered_map<int, bool>> graph;
    std::vector<int> degree(n + 1, 0);

    for (auto& edge : edges) {
        graph[edge[0]][edge[1]] = graph[edge[1]][edge[0]] = true;
        degree[edge[0]]++;
        degree[edge[1]]++;
    }

    int minDegree = INT_MAX;
    for (auto& edge : edges) {
        int u = edge[0], v = edge[1];
        for (int w = 1; w <= n; ++w) {
            if (graph[u][w] && graph[v][w]) {
                minDegree = std::min(minDegree, degree[u] + degree[v] + degree[w] - 6);
            }
        }
    }

    return minDegree == INT_MAX ? -1 : minDegree;
}


-----
#include <vector>
#include <unordered_map>
#include <algorithm>

int minTrioDegree(int n, std::vector<std::vector<int>>& edges) 
    // Your code here
}


************************************
Question ID: 1888

#include <vector>
#include <limits>

int nearestValidPoint(int x, int y, std::vector<std::vector<int>>& points) {
    int minDistance = std::numeric_limits<int>::max();
    int minIndex = -1;

    for (int i = 0; i < points.size(); ++i) {
        if (x == points[i][0] || y == points[i][1]) {
            int distance = std::abs(x - points[i][0]) + std::abs(y - points[i][1]);
            if (distance < minDistance) {
                minDistance = distance;
                minIndex = i;
            }
        }
    }

    return minIndex;
}

-----
#include <vector>
#include <limits>

int nearestValidPoint(int x, int y, std::vector<std::vector<int>>& points) 
    // Your code here
}

************************************
Question ID: 1889

bool checkPowersOfThree(int n) {
    while (n > 0) {
        if (n % 3 == 2) return false;
        n /= 3;
    }
    return true;
}

-----
bool checkPowersOfThree(int n) 
    // Your code here
}

************************************
Question ID: 1893

bool isCovered(vector<vector<int>>& ranges, int left, int right) {
    for (int i = left; i <= right; i++) {
        bool found = false;
        for (const auto& range : ranges) {
            if (i >= range[0] && i <= range[1]) {
                found = true;
                break;
            }
        }
        if (!found) return false;
    }
    return true;
}

-----
bool isCovered(vector<vector<int>>& ranges, int left, int right) 
    // Your code here
}

************************************
Question ID: 1894

#include <string>

std::string mergeAlternately(std::string word1, std::string word2) {
    std::string merged = "";
    int i = 0, j = 0;
    while (i < word1.size() || j < word2.size()) {
        if (i < word1.size()) merged += word1[i++];
        if (j < word2.size()) merged += word2[j++];
    }
    return merged;
}

-----
#include <string>

std::string mergeAlternately(std::string word1, std::string word2) 
    // Your code here
}

************************************
Question ID: 1895

#include <vector>
#include <string>

std::vector<int> minOperations(std::string boxes) {
    std::vector<int> result(boxes.size(), 0);
    int count = 0, total = 0;
    
    for (int i = 0; i < boxes.size(); i++) {
        total += count;
        result[i] = total;
        if (boxes[i] == '1') count++;
    }

    count = 0;
    total = 0;
    for (int i = boxes.size() - 1; i >= 0; i--) {
        total += count;
        result[i] += total;
        if (boxes[i] == '1') count++;
    }

    return result;
}

-----
#include <vector>
#include <string>

std::vector<int> minOperations(std::string boxes) 
    // Your code here
}

************************************
Question ID: 1896

#include <vector>
#include <algorithm>
using namespace std;

int maximumScore(vector<int>& nums, vector<int>& multipliers) {
    int n = nums.size(), m = multipliers.size();
    vector<vector<int>> dp(m + 1, vector<int>(m + 1, 0));
    int maxScore = INT_MIN;

    for (int i = 0; i <= m; ++i) {
        for (int j = 0; i + j <= m; ++j) {
            if (i == 0 && j == 0) continue;
            int score = 0;
            if (i == 0) {
                score = dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1];
            } else if (j == 0) {
                score = dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1];
            } else {
              score = max(dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1],
                          dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1]);
            }
            dp[i][j] = score;
            if (i + j == m) {
                maxScore = max(maxScore, score);
            }
        }
    }

    return maxScore;
}

-----
#include <vector>
#include <algorithm>
using namespace std;

int maximumScore(vector<int>& nums, vector<int>& multipliers) 
    // Your code here
}

************************************
Question ID: 1897

#include <string>
using namespace std;

int longestPalindromeSubseq(string word1, string word2) {
    int n = word1.length();
    int m = word2.length();

    int dp[1001][1001] = {0};

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (word1[i] == word2[j]) {
                dp[i + 1][j + 1] = dp[i][j] + 1;
            } else {
                dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);
            }
        }
    }

    return dp[n][m];
}

-----
#include <string>
using namespace std;

int longestPalindromeSubseq(string word1, string word2) 
    // Your code here
}

************************************
Question ID: 1898

int maximumRemovals(string s, string p, vector<int>& removable) {
    int low = 0, high = removable.size();
    while (low < high) {
        int mid = (low + high + 1) / 2;
        string temp_s = s;
        for (int i = 0; i < mid; i++) {
            temp_s[removable[i]] = '-';
        }
        int i = 0, j = 0;
        while (i < temp_s.size() && j < p.size()) {
            if (temp_s[i] == p[j]) {
                j++;
            }
            i++;
        }
        if (j == p.size()) {
            low = mid;
        } else {
            high = mid - 1;
        }
    }
    return low;
}


-----
int maximumRemovals(string s, string p, vector<int>& removable) 
    // Your code here
}


************************************
Question ID: 1899

#include <vector>
#include <string>
#include <unordered_map>

using namespace std;

int countMatches(vector<vector<string>>& items, string ruleKey, string ruleValue){
    unordered_map<string, int> rule = {{"type", 0}, {"color", 1}, {"name", 2}};
    int count = 0;

    for (const auto& item : items) {
        if (item[rule[ruleKey]] == ruleValue) {
            count++;
        }
    }

    return count;
}

-----
#include <vector>
#include <string>
#include <unordered_map>

using namespace std;

int countMatches(vector<vector<string>>& items, string ruleKey, string ruleValue)
    // Your code here
}

************************************
Question ID: 1900

#include <vector>

int closestCost(std::vector<int>& baseCosts, std::vector<int>& toppingCosts, int target) {
    int closest = baseCosts[0];
    for (int base : baseCosts) {
        int cost = base;
        for (int i = 0; i < 1 << (toppingCosts.size() * 2); ++i) {
            int bitMask = i;
            for (int j = 0; j < toppingCosts.size(); ++j, bitMask >>= 2) {
                cost += (bitMask & 3) * toppingCosts[j];
            }

            if (abs(target - cost) < abs(target - closest)) {
                closest = cost;
            } else if (abs(target - cost) == abs(target - closest) && cost < closest) {
                closest = cost;
            }

            cost = base;
        }
    }
    return closest;
}


-----
#include <vector>

int closestCost(std::vector<int>& baseCosts, std::vector<int>& toppingCosts, int target) 
    // Your code here
}


************************************
Question ID: 1901

int min_operations(vector<int>& nums1, vector<int>& nums2) {
    int sum1 = accumulate(nums1.begin(), nums1.end(), 0);
    int sum2 = accumulate(nums2.begin(), nums2.end(), 0);
    if (sum1 == sum2) return 0;
    if (sum1 < sum2) swap(nums1, nums2);
    sort(nums1.begin(), nums1.end(), greater<int>());
    sort(nums2.begin(), nums2.end());
    int diff = abs(sum1 - sum2), operations = 0;
    int i = 0, j = 0;
    while (diff > 0 && (i < nums1.size() || j < nums2.size())) {
        int option1 = i < nums1.size() ? nums1[i] - 1 : 0;
        int option2 = j < nums2.size() ? 6 - nums2[j] : 0;
        if (option1 > option2) {
            diff -= option1;
            i++;
        } else {
            diff -= option2;
            j++;
        }
        operations++;
    }
    return diff == 0 ? operations : -1;
}


-----
int min_operations(vector<int>& nums1, vector<int>& nums2) 
    // Your code here
}


************************************
Question ID: 1902

#include <vector>
using namespace std;

vector<double> getCollisionTimes(vector<vector<int>>& cars) {
    vector<double> collisions(cars.size(), -1);
    for (int i = cars.size() - 1; i >= 0; --i) {
        double time_to_collision = 1e9;
        for (int j = i + 1; j < cars.size(); ++j) {
            if (cars[j][1] > cars[i][1]) continue;
            double current_collision = (double)(cars[j][0] - cars[i][0]) / (cars[i][1] - cars[j][1]);
            if(current_collision < time_to_collision) {
                time_to_collision = min(time_to_collision, min(collisions[j], current_collision));
            }
        }
        collisions[i] = time_to_collision == 1e9 ? -1.0 : time_to_collision;
    }
    return collisions;
}

-----
#include <vector>
using namespace std;

vector<double> getCollisionTimes(vector<vector<int>>& cars) 
    // Your code here
}

************************************
Question ID: 1903

std::string largestOddNumber(std::string num) {
    for (int i = num.length() - 1; i >= 0; i--) {
        if ((num[i] - '0') % 2 != 0) {
            return num.substr(0, i + 1);
        }
    }
    return "";
}

-----
std::string largestOddNumber(std::string num) 
    // Your code here
}

************************************
Question ID: 1904

int secondLargestDigit(string s) {
    int largest = -1, secondLargest = -1;
    for (char c : s) {
        if (isdigit(c)) {
            int digit = c - '0';
            if (digit > largest) {
                secondLargest = largest;
                largest = digit;
            } else if (digit != largest && digit > secondLargest) {
                secondLargest = digit;
            }
        }
    }
    return secondLargest;
}

-----
int secondLargestDigit(string s) 
    // Your code here
}

************************************
Question ID: 1906

#include <algorithm>

int maxScore(std::vector<int>& nums) {
    int n = nums.size(), ans = 0;
    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(n * 2 + 1, -1));

    std::function<int(int, int)> gcd = [&](int x, int y) {
        if (y == 0) return x;
        return gcd(y, x % y);
    };

    std::function<int(int, int)> dfs = [&](int i, int j) {
        if (i > n) return 0;
        if (dp[i][j] != -1) return dp[i][j];
        for (int k = j + 1; k < n * 2; ++k) {
            ans = std::max(ans, dfs(i + 1, k) + i * gcd(nums[j], nums[k]));
        }
        return dp[i][j] = ans;
    };

    return dfs(1, 0);
}

-----
#include <algorithm>

int maxScore(std::vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1908

bool aliceWins(vector<int>& piles) {
    int xor_sum = 0;
    for (int pile : piles) {
        xor_sum ^= pile;
    }
    return xor_sum != 0;
}


-----
bool aliceWins(vector<int>& piles) 
    // Your code here
}


************************************
Question ID: 1909

bool canBeIncreasing(vector<int>& nums) {
    int count = 0;
    for (int i = 1; i < nums.size(); ++i) {
        if (nums[i - 1] >= nums[i]) {
            count++;
            if (count > 1) return false;
            if (i > 1 && nums[i - 2] >= nums[i] && i < nums.size() - 1 && nums[i - 1] >= nums[i + 1]) return false;
        }
    }
    return true;
}

-----
bool canBeIncreasing(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1910

bool checkOnesSegment(std::string s) {
    int count = 0;
    for (int i = 0; i < s.length(); ++i) {
        if (s[i] == '1') {
            if (i > 0 && s[i - 1] == '0') {
                count++;
            }
        }
    }
    return count <= 1;
}

-----
bool checkOnesSegment(std::string s) 
    // Your code here
}

************************************
Question ID: 1911

int minElements(std::vector<int>& nums, int limit, int goal) {
    long long sum = 0;
    for (int num : nums) sum += num;
    long long diff = abs(goal - sum);
    return (diff + limit - 1) / limit;
}


-----
int minElements(std::vector<int>& nums, int limit, int goal) 
    // Your code here
}


************************************
Question ID: 1912

#include <vector>
#include <queue>
#include <utility>

using namespace std;

const int mod = 1e9 + 7;

int countRestrictedPaths(int n, vector<vector<int>>& edges) {
    vector<vector<pair<int, int>>> graph(n + 1);
    vector<long long> dist(n + 1, 1e18);

    for (auto& edge : edges) {
        int u = edge[0], v = edge[1], weight = edge[2];
        graph[u].push_back({v, weight});
        graph[v].push_back({u, weight});
    }

    priority_queue<pair<long long, int>> pq;
    pq.push({0, n});
    dist[n] = 0;

    while (!pq.empty()) {
        int u = pq.top().second;
        long long d = -pq.top().first;
        pq.pop();

        if (d != dist[u]) continue;

        for (auto& to : graph[u]) {
            int v = to.first, w = to.second;
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({-dist[v], v});
            }
        }
    }

    vector<int> dp(n + 1, -1);
    function<int(int)> dfs = [&](int u) {
        if (u == n) return 1;
        if (dp[u] != -1) return dp[u];
        int ans = 0;
        for (auto& to : graph[u]) {
            int v = to.first;
            if (dist[v] < dist[u]) {
                ans = (ans + dfs(v)) % mod;
            }
        }
        return dp[u] = ans;
    };

    return dfs(1);
}

-----
#include <vector>
#include <queue>
#include <utility>

using namespace std;

const int mod = 1e9 + 7;

int countRestrictedPaths(int n, vector<vector<int>>& edges) 
    // Your code here
}

************************************
Question ID: 1913

#include <vector>
#include <unordered_map>

int minChanges(std::vector<int>& nums, int k) {
    int n = nums.size();
    std::vector<int> xor_prefix(n+1);
    for (int i = 1; i <= n; ++i) {
        xor_prefix[i] = xor_prefix[i-1] ^ nums[i-1];
    }
    
    std::vector<std::unordered_map<int, int>> dp(k);
    std::vector<int> min_dp(k, n);
    
    for (int i = 1; i <= n; ++i) {
        int x = xor_prefix[i] ^ xor_prefix[i - k];
        
        if (i >= k) {
            dp[0][x]++;
        }
        
        for (int j = 1; i - j * k >= 0; ++j) {
            dp[j][x]++;
            min_dp[j] = std::min(min_dp[j], dp[j-1][x] - dp[j][x]);
        }
    }
    
    int answer = n;
    for (int j = 0; j < k; ++j) {
        answer = std::min(answer, min_dp[j] + j);
    }
    return answer;
}

-----
#include <vector>
#include <unordered_map>

int minChanges(std::vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 1914

#include <vector>

std::vector<std::vector<int>> rotateGrid(std::vector<std::vector<int>>& grid, int k) {
    if (grid.empty()) return grid;
    
    int m = grid.size(); // number of rows
    int n = grid[0].size(); // number of columns
    int numLayers = std::min(m, n) / 2;

    for (int layer = 0; layer < numLayers; ++layer) {
        int numToRotate = (m - 2 * layer) * 2 + (n - 2 * layer - 2) * 2; // number of elements in the outer ring
        int effective_k = k % numToRotate; // effective number of rotations
        
        while (effective_k--) {
            int temp = grid[layer][layer];
            for (int i = layer + 1; i < m - layer; ++i) std::swap(temp, grid[i][layer]);
            for (int j = layer + 1; j < n - layer; ++j) std::swap(temp, grid[m - layer - 1][j]);
            for (int i = m - layer - 2; i >= layer; --i) std::swap(temp, grid[i][n - layer - 1]);
            for (int j = n - layer - 2; j > layer; --j) std::swap(temp, grid[layer][j]);
        }
    }

    return grid;
}

-----
#include <vector>

std::vector<std::vector<int>> rotateGrid(std::vector<std::vector<int>>& grid, int k) 
    // Your code here
}

************************************
Question ID: 1915

bool areAlmostEqual(std::string s1, std::string s2) {
    int diff_count = 0;
    int first_diff = -1;
    int second_diff = -1;
    for (int i = 0; i < s1.length(); ++i) {
        if (s1[i] != s2[i]) {
            diff_count++;
            if (diff_count == 1)
                first_diff = i;
            else if (diff_count == 2)
                second_diff = i;
            else
                return false;
        }
    }
    return diff_count == 0 || (diff_count == 2 && s1[first_diff] == s2[second_diff] && s1[second_diff] == s2[first_diff]);
}

-----
bool areAlmostEqual(std::string s1, std::string s2) 
    // Your code here
}

************************************
Question ID: 1916

int findCenter(vector<vector<int>>& edges) {
    if (edges[0][0] == edges[1][0] || edges[0][0] == edges[1][1]) {
        return edges[0][0];
    }
    return edges[0][1];
}

-----
int findCenter(vector<vector<int>>& edges) 
    // Your code here
}

************************************
Question ID: 1918

int maxScore(vector<int>& nums, int k) {
    int n = nums.size();
    int result = 0;
    for (int i = k; i >= 0; i--) {
        for (int j = k; j < n; j++) {
            int min_val = nums[i];
            for (int x = i; x <= j; x++)
                min_val = min(min_val, nums[x]);
            result = max(result, min_val * (j - i + 1));
        }
    }
    return result;
}

-----
int maxScore(vector<int>& nums, int k) 
    // Your code here
}

************************************
Question ID: 1920

bool squareIsWhite(std_sequence(string coordinates) {
return (coordinates[0] - 'a' + coordinates[1] - '1') % 2 == 0;
}

-----
bool squareIsWhite(std_sequence(string coordinates) 
    // Your code here
}

************************************
Question ID: 1921

int eliminateMaximum(vector<int>& dist, vector<int>& speed) {
    int n = dist.size();
    vector<int> time_to_reach_city(n);
    for (int i = 0; i < n; i++) {
        time_to_reach_city[i] = (dist[i] + speed[i] - 1) / speed[i];
    }
    sort(time_to_reach_city.begin(), time_to_reach_city.end());
    int eliminated = 0;
    for (int i = 0; i < n && time_to_reach_city[i] > i; i++) {
        eliminated++;
    }
    return eliminated;
}

-----
int eliminateMaximum(vector<int>& dist, vector<int>& speed) 
    // Your code here
}

************************************
Question ID: 1922

long long goodDigitStrings(int n) {
    const int mod = 1000000007;
    long long even_count = 1, prime_count = 1;
    for (int i = 0; i < n; ++i) {
        if (i % 2 == 0) even_count = (even_count * 5) % mod;
        else prime_count = (prime_count * 4) % mod;
    }
    return (even_count * prime_count) % mod;
}

-----
long long goodDigitStrings(int n) 
    // Your code here
}

************************************
Question ID: 1923

#include <string>
#include <vector>
#include <sstream>

bool areSentencesSimilar(std::string sentence1, std::string sentence2) {
    std::vector<std::string> words1, words2;
    std::stringstream ss1(sentence1), ss2(sentence2);
    std::string word;
    
    while (ss1 >> word) words1.push_back(word);
    while (ss2 >> word) words2.push_back(word);
    
    while (
        !words1.empty() && !words2.empty() &&
        words1.front() == words2.front()
    ) {
        words1.erase(words1.begin());
        words2.erase(words2.begin());
    }
    
    while (
        !words1.empty() && !words2.empty() &&
        words1.back() == words2.back()
    ) {
        words1.pop_back();
        words2.pop_back();
    }
    
    return words1.empty() || words2.empty();
}

-----
#include <string>
#include <vector>
#include <sstream>

bool areSentencesSimilar(std::string sentence1, std::string sentence2) 
    // Your code here
}

************************************
Question ID: 1924

#include <vector>
#include <algorithm>

int maxHappyGroups(int batchSize, std::vector<int> &groups) {
    std::vector<int> remainders(batchSize, 0);
    for (int g : groups) {
        remainders[g % batchSize]++;
    }
    
    int result = remainders[0];
    int i = 1, j = batchSize - 1;
    
    while (i < j) {
        result += std::min(remainders[i], remainders[j]);
        i++;
        j--;
    }
    if (i == j) {
        result += remainders[i] / 2;
    }
    
    return result;
}

-----
#include <vector>
#include <algorithm>

int maxHappyGroups(int batchSize, std::vector<int> &groups) 
    // Your code here
}

************************************
Question ID: 1925

int reverse(int x) {
    int rev = 0;
    while (x != 0) {
        rev = rev * 10 + x % 10;
        x = x / 10;
    }
    return rev;
}

int countNicePairs(vector<int>& nums) {
    const int MOD = 1e9 + 7;
    unordered_map<int, int> count;
    int result = 0;

    for (int num : nums) {
        int diff = num - reverse(num);
        count[diff]++;
    }

    for (auto &[_, val] : count) {
        result = (result + ((val * (val - 1LL)) / 2) % MOD) % MOD;
    }

    return result;
}

-----
int reverse(int x) 
    // Your code here
}

************************************
Question ID: 1926

#include <vector>
#include <queue>

using namespace std;

int nearest_exit(vector<vector<char>> &maze, vector<int> entrance) {
    int m = maze.size();
    int n = maze[0].size();
    vector<vector<int>> moves = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    queue<pair<int, int>> q;
    q.push({entrance[0], entrance[1]});

    int steps = -1;
    while (!q.empty()) {
        steps++;
        int size = q.size();
        for (int i = 0; i < size; ++i) {
            auto [r, c] = q.front();
            q.pop();
            if (maze[r][c] == '+') continue;
            if (r == 0 || r == m-1 || c == 0 || c == n-1) {
                if (r != entrance[0] || c != entrance[1]) return steps;
            }
            maze[r][c] = '+';
            for (const auto &move : moves) {
                int nr = r + move[0];
                int nc = c + move[1];
                if (nr >= 0 && nr < m && nc >= 0 && nc < n) {
                    q.push({nr, nc});
                }
            }
        }
    }
    return -1;
}

-----
#include <vector>
#include <queue>

using namespace std;

int nearest_exit(vector<vector<char>> &maze, vector<int> entrance) 
    // Your code here
}

************************************
Question ID: 1927

int maxAscendingSum(vector<int>& nums) {
    int maxSum = 0, currentSum = nums[0];

    for (int i = 1; i < nums.size(); ++i) {
        if (nums[i] > nums[i - 1]) {
            currentSum += nums[i];
        } else {
            maxSum = max(maxSum, currentSum);
            currentSum = nums[i];
        }
    }

    return max(maxSum, currentSum);
}

-----
int maxAscendingSum(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1928

#include <queue>
#include <vector>

int getNumberOfBacklogOrders(std::vector<std::vector<int>>& orders) {
    auto cmpSell = [](std::vector<int>& a, std::vector<int>& b) {
        return a[0] > b[0];
    };
    auto cmpBuy = [](std::vector<int>& a, std.stringvector<int>&b) {
        return a[0] < b[0];
    };

    std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, decltype(cmpSell)> sell(cmpSell);
    std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, decltype(cmpBuy)> buy(cmpBuy);

    for (auto& order : orders) {
        if (order[2] == 0) {
            while (!sell.empty() && order[1] > 0 && sell.top()[0] <= order[0]) {
                std::vector<int>& currOrder = sell.top();
                int executedAmount = std::min(order[1], currOrder[1]);
                order[1] -= executedAmount;
                currOrder[1] -= executedAmount;
                if (currOrder[1] == 0) {
                    sell.pop();
                }
            }
            if (order[1] > 0) {
                buy.push(order);
            }
        } else {
            while (!buy.empty() && order[1] > 0 && buy.top()[0] >= order[0]) {
                std::vector<int>& currOrder = buy.top();
                int executedAmount = std::min(order[1], currOrder[1]);
                order[1] -= executedAmount;
                currOrder[1] -= executedAmount;
                if (currOrder[1] == 0) {
                    buy.pop();
                }
            }
            if (order[1] > 0) {
                sell.push(order);
            }
        }
    }

    int64_t res = 0;
    while (!buy.empty()) {
        res += buy.top()[1];
        buy.pop();
    }
    while (!sell.empty()) {
        res += sell.top()[1];
        sell.pop();
    }

    res %= 1000000007;
    return static_cast<int>(res);
}


-----
#include <queue>
#include <vector>

int getNumberOfBacklogOrders(std::vector<std::vector<int>>& orders) 
    // Your code here
}


************************************
Question ID: 1929

int maxValue(int n, int index, int maxSum) {
    maxSum -= n;
    int left = 0, right = maxSum, ans = 0;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        long long sum = min(mid, index) * (min(mid, index) + 1LL) / 2 + min(mid, n - index - 1) * (min(mid, n - index) + 1LL) / 2;
        if (mid > index) {
            sum += (mid - index - 1LL) * (mid - index) / 2;
        }
        if (mid > n - index) {
            sum += (mid - n + index) * (mid - n + index + 1) / 2;
        }
        if (sum <= maxSum) {
            ans = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return ans + 1;
}

-----
int maxValue(int n, int index, int maxSum) 
    // Your code here
}

************************************
Question ID: 1930

#include <vector>
#include <algorithm>

int maxConsecutiveValues(std::vector<int>& coins) {
    std::sort(coins.begin(), coins.end());
    int maxValue = 0;
    for (int coin : coins) {
        if (coin <= maxValue + 1) {
            maxValue += coin;
        } else {
            break;
        }
    }
    return maxValue + 1;
}

-----
#include <vector>
#include <algorithm>

int maxConsecutiveValues(std::vector<int>& coins) 
    // Your code here
}

************************************
Question ID: 1931

int numOfWays(int m, int n) {
    long mod = 1e9 + 7;
    long a = 6, b = 6, c = 3, d = 3;
    while (--n) {
        long temp_a = a, temp_c = c;
        a = (a * 3 + b * 2) % mod;
        b = (temp_a * 2 + b * 2) % mod;
        c = (c * 3 + d * 2) % mod;
        d = (temp_c * 2 + d * 2) % mod;
    }
    return m == 1 ? b : (a + c) % mod;
}

-----
int numOfWays(int m, int n) 
    // Your code here
}

************************************
Question ID: 1933

#include <string>
#include <unordered_set>

int numDifferentIntegers(std::string word) {
    for (char &c : word) {
        if (c < '0' || c > '9') {
            c = ' ';
        }
    }
    std::istringstream iss(word);
    std::string num;
    std::unordered_set<std::string> uniqueNums;
    while (iss >> num) {
        num.erase(0, num.find_first_not_of('0'));
        uniqueNums.insert(num);
    }
    return uniqueNums.size();
}

-----
#include <string>
#include <unordered_set>

int numDifferentIntegers(std::string word) 
    // Your code here
}

************************************
Question ID: 1935

int min_operations(int n) {
    int count = 1;
    int temp = 1;

    while (temp % n != 0) {
        temp = (temp * 2) % n;
        count++;
    }

    return count;
}

-----
int min_operations(int n) 
    // Your code here
}

************************************
Question ID: 1936

#include <cmath>

const int MOD = 1e9 + 7;

int numberOfNiceDivisors(int primeFactors) {
    long long result = 1;
    for (int p = 2; p <= primeFactors; ++p) {
        if (primeFactors % p == 0) {
            int count = 0;
            while (primeFactors % p == 0) {
                primeFactors /= p;
                ++count;
            }
            result = (result * (count * 2 + 1)) % MOD;
        }
    }
    return result;
}

-----
#include <cmath>

const int MOD = 1e9 + 7;

int numberOfNiceDivisors(int primeFactors) 
    // Your code here
}

************************************
Question ID: 1937

int maxPoints(vector<vector<int>>& points) {
    int m = points.size(), n = points[0].size();
    vector<long> dp(n, 0);
    for (auto& row : points) {
        vector<long> next_dp(n, 0);
        for (int c1 = 0; c1 < n; ++c1) {
            long score = dp[c1] + row[c1] - c1;
            for (int c2 = 0; c2 < n; ++c2) {
                next_dp[c2] = max(next_dp[c2], score - row[c1] + c2);
            }
        }
        dp.swap(next_dp);
    }
    return *max_element(dp.begin(), dp.end());
}

-----
int maxPoints(vector<vector<int>>& points) 
    // Your code here
}

************************************
Question ID: 1938

int minOperations(vector<int>& nums) {
    int operations = 0;
    for (int i = 1; i < nums.size(); ++i) {
        if (nums[i] <= nums[i - 1]) {
            operations += nums[i - 1] - nums[i] + 1;
            nums[i] = nums[i - 1] + 1;
        }
    }
    return operations;
}

-----
int minOperations(vector<int>& nums) 
    // Your code here
}

************************************
Question ID: 1942

#include <vector>
#include <set>
#include <map>

int smallestChair(std::vector<std::vector<int>>& times, int targetFriend) {
    std::multimap<int, int> events;
    for (int i = 0; i < times.size(); ++i) {
        events.insert({times[i][0], i});
        events.insert({times[i][1], ~i});
    }

    std::set<int> availableChairs;
    std::vector<int> assignedChair(times.size());

    for (const auto &[time, idx] : events) {
        if (idx >= 0) {
            int chair = *availableChairs.begin();
            availableChairs.erase(availableChairs.begin());
            assignedChair[idx] = chair;
            if (idx == targetFriend) return chair;
        } else {
            availableChairs.insert(assignedChair[~idx]);
        }
    }

    return -1;
}

-----
#include <vector>
#include <set>
#include <map>

int smallestChair(std::vector<std::vector<int>>& times, int targetFriend) 
    // Your code here
}

************************************
