[
    {
        "title": "Two Sum",
        "description": "Given an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
        "example": "Example 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]",
        "level": "Easy",
        "tags": [
            "Array",
            "Two Pointers"
        ],
        "test_cases": {
            "inputs": [
                "[2,7,11,15], 9",
                "[3,2,4], 6",
                "[3,3], 6",
                "[-1,-2,-3,-4,-5], -8",
                "[0,0,0,0,0], 0",
                "[1,2,3,4,5], 10",
                "[10,20,30,40,50], 60",
                "[-10,-20,-30,-40,-50], -60",
                "[100,200,300,400,500], 1000",
                "[-100,-200,-300,-400,-500], -1000"
            ],
            "outputs": [
                "[0,1]",
                "[1,2]",
                "[0,1]",
                "[2,4]",
                "[0,1]",
                "[1,4]",
                "[1,3]",
                "[0,2]",
                "[0,4]",
                "[0,2]"
            ]
        }
    },
    null,
    {
        "title": "Longest Substring Without Repeating Characters",
        "description": "Given a string `s`, find the length of the longest substring without repeating characters.",
        "example": "Example 1:\n\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.",
        "level": "Medium",
        "tags": [
            "string",
            "sliding window",
            "hash table"
        ],
        "test_cases": {
            "inputs": [
                "\"abcabcbb\"",
                "\"bbbbb\"",
                "\"pwwkew\"",
                "\"\"",
                "\"a\"",
                "\"abcdefg\"",
                "\"aab\"",
                "\"abbac\"",
                "\"abcdeff\"",
                "\"abcabcabc\""
            ],
            "outputs": [
                "3",
                "1",
                "3",
                "0",
                "1",
                "7",
                "2",
                "3",
                "5",
                "3"
            ]
        }
    },
    null,
    {
        "title": "Longest Palindromic Substring",
        "description": "Given a string `s`, find and return the longest palindromic substring in `s`.",
        "example": "Example 1:\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\nExample 2:\n\nInput: s = \"cbbd\"\nOutput: \"bb\"",
        "level": "Medium",
        "tags": [
            "string",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                "\"babad\"",
                "\"cbbd\"",
                "\"a\"",
                "\"ac\"",
                "\"bb\"",
                "\"racecar\"",
                "\"abcdeedcba\"",
                "\"abcdefedcba\"",
                "\"abcdeedcbafg\"",
                "\"abcdefghijkllkjihgfedcba\""
            ],
            "outputs": [
                "\"bab\"",
                "\"bb\"",
                "\"a\"",
                "\"a\"",
                "\"bb\"",
                "\"racecar\"",
                "\"abcdeedcba\"",
                "\"abcdefedcba\"",
                "\"abcdeedcba\"",
                "\"abcdefghijkllkjihgfedcba\""
            ]
        }
    },
    {
        "title": "Zigzag Conversion",
        "description": "The string `PAYPALISHIRING` is written in a zigzag pattern on a given number of rows. Write a function `convert` that takes a string and the number of rows as input and returns the string in the zigzag pattern.",
        "example": "Example 1:\n\nInput: s = `PAYPALISHIRING`, numRows = 3\nOutput: `PAHNAPLSIIGYIR`\n\nExample 2:\n\nInput: s = `PAYPALISHIRING`, numRows = 4\nOutput: `PINALSIGYAHRPI`\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n\nExample 3:\n\nInput: s = `A`, numRows = 1\nOutput: `A`",
        "level": "Medium",
        "tags": [
            "string",
            "pattern"
        ],
        "test_cases": {
            "inputs": [
                "`PAYPALISHIRING`, 3",
                "`PAYPALISHIRING`, 4",
                "`A`, 1",
                "`HELLO WORLD`, 2",
                "`ABCD`, 2",
                "`ABCD`, 3",
                "`ABCD`, 4",
                "`ABCD`, 5",
                "`ABCD`, 6",
                "`ABCD`, 7"
            ],
            "outputs": [
                "`PAHNAPLSIIGYIR`",
                "`PINALSIGYAHRPI`",
                "`A`",
                "`HLOWRDLOLE`",
                "`ACBD`",
                "`ABDC`",
                "`ABCD`",
                "`ABCD`",
                "`ABCD`",
                "`ABCD`"
            ]
        }
    },
    {
        "title": "Reverse Integer",
        "description": "Given a signed 32-bit integer `x`, return `x` with its digits reversed. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-231, 231 - 1]`, then return `0`.\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).",
        "example": "Example 1:\n\nInput: x = 123\nOutput: 321\n\nExample 2:\n\nInput: x = -123\nOutput: -321\n\nExample 3:\n\nInput: x = 120\nOutput: 21",
        "level": "Easy",
        "tags": [
            "Math"
        ],
        "test_cases": {
            "inputs": [
                "123",
                "-123",
                "120",
                "0",
                "1",
                "-1",
                "100",
                "-100",
                "2147483647",
                "-2147483648"
            ],
            "outputs": [
                "321",
                "-321",
                "21",
                "0",
                "1",
                "-1",
                "1",
                "-1",
                "0",
                "0"
            ]
        }
    },
    null,
    {
        "title": "Palindrome Integer",
        "description": "Given an integer `x`, determine if it is a palindrome. Return `true` if `x` is a palindrome, and `false` otherwise.",
        "example": "Example 1:\n\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.",
        "level": "Easy",
        "tags": [
            "math"
        ],
        "test_cases": {
            "inputs": [
                "121",
                "-121",
                "10",
                "0",
                "12321",
                "1234321",
                "1234567890987654321",
                "9876543210123456789",
                "1234567890",
                "9876543210"
            ],
            "outputs": [
                "true",
                "false",
                "false",
                "true",
                "true",
                "true",
                "true",
                "true",
                "false",
                "false"
            ]
        }
    },
    {
        "title": "Regular Expression Matching",
        "description": "Given an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:\n\n*   `'.'` Matches any single character.\n*   `'*'` Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).",
        "example": "Example 1:\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\nExample 2:\n\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n\nExample 3:\n\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".",
        "level": "Medium",
        "tags": [
            "string",
            "regex"
        ],
        "test_cases": {
            "inputs": [
                "\"aa\", \"a\"",
                "\"aa\", \"a*\"",
                "\"ab\", \".*\"",
                "\"aab\", \"c*a*b\"",
                "\"mississippi\", \"mis*is*p*\"",
                "\"ab\", \".*c\"",
                "\"aaa\", \"a*a\"",
                "\"aaa\", \"ab*a*c*a\"",
                "\"a\", \"ab*a\"",
                "\"a\", \".*..a*\""
            ],
            "outputs": [
                "false",
                "true",
                "true",
                "true",
                "false",
                "false",
                "true",
                "true",
                "false",
                "false"
            ]
        }
    },
    {
        "title": "Container With Most Water",
        "description": "Given an integer array `height` of length `n`, where each element represents the height of a vertical line. Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water the container can store.",
        "example": "Example:\n\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.",
        "level": "Medium",
        "tags": [
            "Array",
            "Two Pointers"
        ],
        "test_cases": {
            "inputs": [
                "[1,8,6,2,5,4,8,3,7]",
                "[1,1]",
                "[4,3,2,1,4]",
                "[1,2,1]",
                "[1,2,4,3]",
                "[1,2,3,4,5]",
                "[5,4,3,2,1]",
                "[1,1,1,1,1]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[10,9,8,7,6,5,4,3,2,1]"
            ],
            "outputs": [
                "49",
                "1",
                "16",
                "2",
                "4",
                "6",
                "4",
                "4",
                "25",
                "25"
            ]
        }
    },
    null,
    null,
    {
        "title": "Longest Common Prefix",
        "description": "Write a function that takes an array of strings and returns the longest common prefix string among them. If there is no common prefix, return an empty string.",
        "example": "Example:\n\nInput: [\"flower\", \"flow\", \"flight\"]\nOutput: \"fl\"\n\nExplanation: The longest common prefix among the input strings is \"fl\".\n\nInput: [\"dog\", \"racecar\", \"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.",
        "level": "Easy",
        "tags": [
            "array",
            "string"
        ],
        "test_cases": {
            "inputs": [
                "[\"flower\", \"flow\", \"flight\"]",
                "[\"dog\", \"racecar\", \"car\"]",
                "[\"apple\", \"application\", \"app\"]",
                "[\"coding\", \"code\", \"coder\"]",
                "[\"hello\", \"hell\", \"help\"]",
                "[\"program\", \"programming\", \"programmer\"]",
                "[\"java\", \"javascript\", \"javadoc\"]",
                "[\"python\", \"pyramid\", \"py\"]",
                "[\"algorithm\", \"algorithms\", \"algo\"]",
                "[\"computer\", \"compute\", \"com\"]"
            ],
            "outputs": [
                "\"fl\"",
                "\"\"",
                "\"app\"",
                "\"cod\"",
                "\"hel\"",
                "\"program\"",
                "\"jav\"",
                "\"py\"",
                "\"algo\"",
                "\"com\""
            ]
        }
    },
    {
        "title": "Triplets with Zero Sum",
        "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.",
        "example": "Example 1:\n\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0. nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0. The distinct triplets are [-1,0,1] and [-1,-1,2]. Notice that the order of the output and the order of the triplets does not matter.\n\nExample 2:\n\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\n\nExample 3:\n\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.",
        "level": "Medium",
        "tags": [
            "Array",
            "Two Pointers"
        ],
        "test_cases": {
            "inputs": [
                "[-1,0,1,2,-1,-4]",
                "[0,1,1]",
                "[0,0,0]",
                "[-2,0,1,1,2]",
                "[1,2,-2,-1]",
                "[-1,0,1,2,-1,-4,3,4,5,6,7,8,9,10]",
                "[-1,-1,-1,0,0,0,1,1,1]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]",
                "[0,0,0,0,0,0,0,0,0,0]"
            ],
            "outputs": [
                "[[-1,-1,2],[-1,0,1]]",
                "[]",
                "[[0,0,0]]",
                "[[-2,0,2],[-1,-1,2],[-1,0,1]]",
                "[[-2,-1,3],[-2,0,2],[-1,-1,2],[-1,0,1]]",
                "[[-4,1,3],[-4,2,2],[-4,3,1],[-4,4,0],[-1,-1,2],[-1,0,1]]",
                "[[-1,-1,2],[-1,0,1],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]]",
                "[]",
                "[]",
                "[[0,0,0]]"
            ]
        }
    },
    {
        "title": "Closest Three Sum",
        "description": "Given an integer array `nums` of length `n` and an integer `target`, find three integers in `nums` such that the sum is closest to `target`. Return the sum of the three integers.",
        "example": "Given an array nums = [-1,2,1,-4] and target = 1, the closest three sum is 2. (-1 + 2 + 1 = 2).",
        "level": "Medium",
        "tags": [
            "array",
            "two pointers"
        ],
        "test_cases": {
            "inputs": [
                "[-1,2,1,-4], 1",
                "[0,0,0], 1",
                "[1,2,3,4,5], 10",
                "[-10,-5,0,5,10], 0",
                "[1,1,1,1,1], 3",
                "[1,2,3,4,5], 100",
                "[-1,-2,-3,-4,-5], -10",
                "[10,20,30,40,50], 100",
                "[0,0,0,0,0], 5",
                "[-1,-1,-1,-1,-1], -5"
            ],
            "outputs": [
                "2",
                "0",
                "9",
                "0",
                "3",
                "15",
                "-9",
                "60",
                "0",
                "-3"
            ]
        }
    },
    {
        "title": "Letter Combinations of a Phone Number",
        "description": "Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.\n\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.",
        "example": "Example 1:\n\nInput: digits = \"23\"\nOutput: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]\n\nExample 2:\n\nInput: digits = \"\"\nOutput: []\n\nExample 3:\n\nInput: digits = \"2\"\nOutput: [\"a\", \"b\", \"c\"]",
        "level": "Easy",
        "tags": [
            "String",
            "Recursion"
        ],
        "test_cases": {
            "inputs": [
                "23",
                "2",
                "79",
                "456",
                "8",
                "9",
                "234",
                "5678",
                "29",
                "4"
            ],
            "outputs": [
                [
                    "ad",
                    "ae",
                    "af",
                    "bd",
                    "be",
                    "bf",
                    "cd",
                    "ce",
                    "cf"
                ],
                [
                    "a",
                    "b",
                    "c"
                ],
                [
                    "pw",
                    "px",
                    "py",
                    "pz",
                    "qw",
                    "qx",
                    "qy",
                    "qz",
                    "rw",
                    "rx",
                    "ry",
                    "rz",
                    "sw",
                    "sx",
                    "sy",
                    "sz"
                ],
                [
                    "gjm",
                    "gjn",
                    "gjo",
                    "gkm",
                    "gkn",
                    "gko",
                    "glm",
                    "gln",
                    "glo",
                    "hjm",
                    "hjn",
                    "hjo",
                    "hkm",
                    "hkn",
                    "hko",
                    "hlm",
                    "hln",
                    "hlo",
                    "ijm",
                    "ijn",
                    "ijo",
                    "ikm",
                    "ikn",
                    "iko",
                    "ilm",
                    "iln",
                    "ilo"
                ],
                [
                    "t",
                    "u",
                    "v"
                ],
                [
                    "w",
                    "x",
                    "y",
                    "z"
                ],
                [
                    "adg",
                    "adh",
                    "adi",
                    "aeg",
                    "aeh",
                    "aei",
                    "afg",
                    "afh",
                    "afi",
                    "bdg",
                    "bdh",
                    "bdi",
                    "beg",
                    "beh",
                    "bei",
                    "bfg",
                    "bfh",
                    "bfi",
                    "cdg",
                    "cdh",
                    "cdi",
                    "ceg",
                    "ceh",
                    "cei",
                    "cfg",
                    "cfh",
                    "cfi"
                ],
                [
                    "jmpt",
                    "jmpu",
                    "jmpv",
                    "jmqt",
                    "jmqu",
                    "jmqv",
                    "jmrt",
                    "jmru",
                    "jmrv",
                    "jmst",
                    "jmsu",
                    "jmsv",
                    "jnot",
                    "jnou",
                    "jnov",
                    "jnot",
                    "jnou",
                    "jnov",
                    "jnot",
                    "jnou",
                    "jnov",
                    "jnot",
                    "jnou",
                    "jnov",
                    "jnot",
                    "jnou",
                    "jnov",
                    "jnot",
                    "jnou",
                    "jnov"
                ],
                [
                    "aw",
                    "ax",
                    "ay",
                    "az",
                    "bw",
                    "bx",
                    "by",
                    "bz",
                    "cw",
                    "cx",
                    "cy",
                    "cz",
                    "dw",
                    "dx",
                    "dy",
                    "dz",
                    "ew",
                    "ex",
                    "ey",
                    "ez",
                    "fw",
                    "fx",
                    "fy",
                    "fz"
                ],
                [
                    "gj",
                    "gk",
                    "gl",
                    "hj",
                    "hk",
                    "hl",
                    "ij",
                    "ik",
                    "il"
                ],
                [
                    "gjm",
                    "gjn",
                    "gjo",
                    "gkm",
                    "gkn",
                    "gko",
                    "glm",
                    "gln",
                    "glo",
                    "hjm",
                    "hjn",
                    "hjo",
                    "hkm",
                    "hkn",
                    "hko",
                    "hlm",
                    "hln",
                    "hlo",
                    "ijm",
                    "ijn",
                    "ijo",
                    "ikm",
                    "ikn",
                    "iko",
                    "ilm",
                    "iln",
                    "ilo"
                ]
            ]
        }
    },
    null,
    {
        "title": "Remove Nth Node From End of Linked List",
        "description": "Given the head of a linked list, remove the nth node from the end of the list and return its head.",
        "example": "Example 1:\n\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n\nExample 2:\n\nInput: head = [1], n = 1\nOutput: []\n\nExample 3:\n\nInput: head = [1,2], n = 1\nOutput: [1]",
        "level": "Medium",
        "tags": [
            "linked list"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3,4,5]",
                "[1]",
                "[1,2]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[5,4,3,2,1]",
                "[1,2,3,4,5]",
                "[1,2,3,4,5]",
                "[1,2,3,4,5]",
                "[1,2,3,4,5]",
                "[1,2,3,4,5]"
            ],
            "outputs": [
                "[1,2,3,5]",
                "[]",
                "[1]",
                "[1,2,3,4,5,6,7,8,10]",
                "[5,4,3,2]",
                "[2,3,4,5]",
                "[1,2,3,4]",
                "[1,2,3,5]",
                "[1,2,4,5]",
                "[1,3,4,5]"
            ]
        }
    },
    null,
    {
        "title": "Merge Sorted Linked Lists",
        "description": "You are given the heads of two sorted linked lists `list1` and `list2`. Merge the two lists into one sorted list by splicing together the nodes of the first two lists. Return the head of the merged linked list.",
        "example": "Example 1:\n\nInput: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\n\nExample 2:\n\nInput: list1 = [], list2 = []\nOutput: []\n\nExample 3:\n\nInput: list1 = [], list2 = [0]\nOutput: [0]",
        "level": "Easy",
        "tags": [
            "linked list",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,4]",
                "[1,3,4]",
                "[]",
                "[]",
                "[]",
                "[0]",
                "[1,2,3,4,5]",
                "[6,7,8,9,10]",
                "[1,3,5,7,9]",
                "[2,4,6,8,10]",
                "[-10,-5,0,5,10]",
                "[-20,-10,0,10,20]",
                "[-100,-50,0,50,100]",
                "[-100,-90,-80,-70,-60]",
                "[100,90,80,70,60]",
                "[1,1,1,1,1]",
                "[2,2,2,2,2]",
                "[1,2,3,4,5]",
                "[5,4,3,2,1]"
            ],
            "outputs": [
                "[1,1,2,3,4,4]",
                "[]",
                "[0]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[-10,-5,0,5,10]",
                "[-20,-10,0,10,20]",
                "[-100,-50,0,50,100]",
                "[-100,-90,-80,-70,-60]",
                "[100,90,80,70,60]",
                "[1,1,1,1,1,2,2,2,2,2]",
                "[1,2,3,4,5]",
                "[5,4,3,2,1]",
                "[1,1,1,1,1,2,2,2,2,2]",
                "[1,2,3,4,5]",
                "[5,4,3,2,1]"
            ]
        }
    },
    null,
    {
        "title": "Merge Sorted Linked Lists",
        "description": "You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
        "example": "Example 1:\n\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n1->4->5,\n1->3->4,\n2->6\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6\n\nExample 2:\n\nInput: lists = []\nOutput: []\n\nExample 3:\n\nInput: lists = [[]]\nOutput: []",
        "level": "Medium",
        "tags": [
            "linked list",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "[[1,4,5],[1,3,4],[2,6]]",
                "[[1,2,3],[4,5,6],[7,8,9]]",
                "[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]",
                "[[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15]]",
                "[[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18]]",
                "[[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21]]",
                "[[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,24]]",
                "[[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,24],[25,26,27]]",
                "[[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,24],[25,26,27],[28,29,30]]",
                "[[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,24],[25,26,27],[28,29,30],[31,32,33]]"
            ],
            "outputs": [
                "[1,1,2,3,4,4,5,6]",
                "[1,2,3,4,5,6,7,8,9]",
                "[1,2,3,4,5,6,7,8,9,10,11,12]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33]"
            ]
        }
    },
    {
        "title": "Swap Adjacent Nodes in Linked List",
        "description": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed).",
        "example": "Example 1:\n\nInput: head = [1,2,3,4]\nOutput: [2,1,4,3]\n\nExample 2:\n\nInput: head = []\nOutput: []\n\nExample 3:\n\nInput: head = [1]\nOutput: [1]",
        "level": "Medium",
        "tags": [
            "linked list",
            "swapping"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3,4]",
                "[]",
                "[1]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[2,4,6,8,10]",
                "[1,3,5,7,9]",
                "[1,2,3,4,5,6,7,8,9]",
                "[9,8,7,6,5,4,3,2,1]",
                "[1,1,1,1,1,1,1,1,1,1]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]"
            ],
            "outputs": [
                "[2,1,4,3]",
                "[]",
                "[1]",
                "[2,1,4,3,6,5,8,7,10,9]",
                "[4,2,8,6,10]",
                "[3,1,7,5,9]",
                "[2,1,4,3,6,5,8,7,9]",
                "[8,9,6,7,4,5,2,3,1]",
                "[2,1,1,1,1,1,1,1,1,1]",
                "[2,1,4,3,6,5,8,7,10,9,12,11,14,13,16,15,18,17,20,19]"
            ]
        }
    },
    null,
    {
        "title": "Remove Duplicates from Sorted Array",
        "description": "Given an integer array `nums` sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in `nums`.",
        "example": "Example 1:\n\nInput: nums = [1,1,2]\nOutput: 2\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores).\n\nExample 2:\n\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores).",
        "level": "Easy",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "[1,1,2]",
                "[0,0,1,1,1,2,2,3,3,4]",
                "[-1,-1,0,0,0,1,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9]",
                "[10,10,10,10,10]",
                "[-5,-5,-4,-4,-3,-3,-2,-2,-1,-1,0,0,1,1,2,2,3,3,4,4]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,1,1,1,1,1,1,1,1,1]",
                "[]",
                "[100]",
                "[1,2,3,4,5,6,7,8,9,10,10,10,10,10,10,10,10,10,10,10]"
            ],
            "outputs": [
                "2",
                "5",
                "10",
                "1",
                "5",
                "10",
                "1",
                "0",
                "1",
                "10"
            ]
        }
    },
    null,
    {
        "title": "First Occurrence of Needle in Haystack",
        "description": "Given two strings `needle` and `haystack`, return the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`.",
        "example": "Example 1:\n\nInput: haystack = \"sadbutsad \", needle = \"sad \"\nOutput: 0\nExplanation: \"sad \" occurs at index 0 and 6. The first occurrence is at index 0, so we return 0.\n\nExample 2:\n\nInput: haystack = \"leetcode \", needle = \"leeto \"\nOutput: -1\nExplanation: \"leeto \" did not occur in \"leetcode \", so we return -1.",
        "level": "Easy",
        "tags": [
            "string",
            "search"
        ],
        "test_cases": {
            "inputs": [
                "\"sadbutsad \", \"sad \"",
                "\"leetcode \", \"leeto \"",
                "\"hello world\", \"world\"",
                "\"programming\", \"gram\"",
                "\"apple\", \"banana\"",
                "\"abcde\", \"cde\"",
                "\"abcde\", \"xyz\"",
                "\"abcde\", \"\"",
                "\"\", \"abcde\"",
                "\"\", \"\""
            ],
            "outputs": [
                "0",
                "-1",
                "6",
                "3",
                "-1",
                "2",
                "-1",
                "0",
                "-1",
                "0"
            ]
        }
    },
    {
        "title": "Integer Division without Using Multiplication, Division, and Mod Operator",
        "description": "Given two integers `dividend` and `divisor`, divide two integers without using multiplication, division, and mod operator. The integer division should truncate toward zero. Return the quotient after dividing `dividend` by `divisor`. If the quotient is greater than 231 - 1, return 231 - 1. If the quotient is less than -231, return -231.",
        "example": "Example:\n\nInput: dividend = 10, divisor = 3\nOutput: 3\nExplanation: 10/3 = 3.33333.. which is truncated to 3.",
        "level": "Medium",
        "tags": [
            "math",
            "bit manipulation"
        ],
        "test_cases": {
            "inputs": [
                "10, 3",
                "7, -3",
                "0, 1",
                "1, 1",
                "-1, 1",
                "1, -1",
                "-1, -1",
                "2147483647, 1",
                "-2147483648, 1",
                "2147483647, -1"
            ],
            "outputs": [
                "3",
                "-2",
                "0",
                "1",
                "-1",
                "-1",
                "1",
                "2147483647",
                "-2147483648",
                "-2147483647"
            ]
        }
    },
    {
        "title": "Concatenated Substring",
        "description": "Given a string `s` and an array of strings `words`, find all the starting indices of the concatenated substrings in `s`. A concatenated substring is a substring that contains all the strings of any permutation of `words` concatenated. Return the indices in any order.",
        "example": "Example 1:\n\nInput: s = \"barfoothefoobarman\", words = [\"foo\", \"bar\"]\nOutput: [0, 9]\nExplanation: The substring starting at index 0 is \"barfoo\", which is the concatenation of [\"bar\", \"foo\"]. The substring starting at index 9 is \"foobar\", which is the concatenation of [\"foo\", \"bar\"].\n\nExample 2:\n\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\", \"good\", \"best\", \"word\"]\nOutput: []\nExplanation: There is no substring in `s` that is equal to the concatenation of any permutation of `words`.\n\nExample 3:\n\nInput: s = \"barfoofoobarthefoobarman\", words = [\"bar\", \"foo\", \"the\"]\nOutput: [6, 9, 12]\nExplanation: The substring starting at index 6 is \"foobarthe\", which is the concatenation of [\"foo\", \"bar\", \"the\"]. The substring starting at index 9 is \"barthefoo\", which is the concatenation of [\"bar\", \"the\", \"foo\"]. The substring starting at index 12 is \"thefoobar\", which is the concatenation of [\"the\", \"foo\", \"bar\"].",
        "level": "Medium",
        "tags": [
            "string",
            "array",
            "permutation"
        ],
        "test_cases": {
            "inputs": [
                "\"barfoothefoobarman\", [\"foo\", \"bar\"]",
                "\"wordgoodgoodgoodbestword\", [\"word\", \"good\", \"best\", \"word\"]",
                "\"barfoofoobarthefoobarman\", [\"bar\", \"foo\", \"the\"]",
                "\"abcdefg\", [\"abc\", \"def\", \"g\"]",
                "\"hellohellohello\", [\"hello\", \"hello\"]",
                "\"abcdabcdabcdabcd\", [\"abcd\", \"abcd\", \"abcd\"]",
                "\"foobarfoobar\", [\"foo\", \"bar\"]",
                "\"abcabcabc\", [\"abc\", \"abc\"]",
                "\"xyzxyzxyz\", [\"xyz\", \"xyz\"]",
                "\"aaaabbbbcccc\", [\"aaa\", \"bbb\", \"ccc\"]"
            ],
            "outputs": [
                "[0, 9]",
                "[]",
                "[6, 9, 12]",
                "[0, 3]",
                "[0, 5]",
                "[0, 4, 8]",
                "[0, 3]",
                "[0, 3, 6]",
                "[0, 3, 6]",
                "[]"
            ]
        }
    },
    {
        "title": "Next Permutation",
        "description": "Given an array of integers, find the next lexicographically greater permutation of the array. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). The replacement must be in place and use only constant extra memory.",
        "example": "Example:\n\nInput: [1,2,3]\nOutput: [1,3,2]\n\nExplanation: The next permutation of [1,2,3] is [1,3,2].\n\nInput: [3,2,1]\nOutput: [1,2,3]\n\nExplanation: The next permutation of [3,2,1] is [1,2,3].\n\nInput: [1,1,5]\nOutput: [1,5,1]\n\nExplanation: The next permutation of [1,1,5] is [1,5,1].",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3]",
                "[3,2,1]",
                "[1,1,5]",
                "[1,2,3,4]",
                "[4,3,2,1]",
                "[1,1,1,1]",
                "[1,2,1,3]",
                "[5,4,3,2,1]",
                "[1,2,3,4,5]",
                "[5,4,3,2,1,0]"
            ],
            "outputs": [
                "[1,3,2]",
                "[1,2,3]",
                "[1,5,1]",
                "[1,2,4,3]",
                "[1,2,3,4]",
                "[1,1,1,1]",
                "[1,3,1,2]",
                "[1,2,3,4,5]",
                "[1,2,3,5,4]",
                "[0,1,2,3,4,5]"
            ]
        }
    },
    null,
    {
        "title": "Search in Rotated Sorted Array",
        "description": "You are given an integer array `nums` sorted in ascending order (with **distinct** values). Prior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`. Given the array `nums` **after** the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or -1 if it is not in `nums`. You must write an algorithm with O(log n) runtime complexity.",
        "example": "Example:\n\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\n\nExplanation: The target element 0 is present at index 4 in the rotated sorted array.\n\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\n\nExplanation: The target element 3 is not present in the rotated sorted array.\n\nInput: nums = [1], target = 0\nOutput: -1\n\nExplanation: The target element 0 is not present in the rotated sorted array.",
        "level": "Medium",
        "tags": [
            "array",
            "binary search"
        ],
        "test_cases": {
            "inputs": [
                "[4,5,6,7,0,1,2], 0",
                "[4,5,6,7,0,1,2], 3",
                "[1], 0",
                "[1,3,5], 5",
                "[1,3,5], 2",
                "[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500], 250"
            ],
            "outputs": [
                "4",
                "-1",
                "-1",
                "2",
                "-1",
                "249"
            ]
        }
    },
    {
        "title": "Find Target Range",
        "description": "Given an array of integers `nums` sorted in non-decreasing order, find the starting and ending position of a given `target` value. If `target` is not found in the array, return `[-1, -1]`. You must write an algorithm with `O(log n)` runtime complexity.",
        "example": "Example:\n\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\n\nExplanation: The target value 8 is found at index 3 and 4 in the array.\n\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\n\nExplanation: The target value 6 is not found in the array.\n\nInput: nums = [], target = 0\nOutput: [-1,-1]\n\nExplanation: The array is empty, so the target value 0 is not found.",
        "level": "Medium",
        "tags": [
            "array",
            "binary search"
        ],
        "test_cases": {
            "inputs": [
                "[5,7,7,8,8,10], 8",
                "[5,7,7,8,8,10], 6",
                "[], 0",
                "[1,2,3,4,5], 3",
                "[1,2,3,4,5], 6",
                "[1,1,1,1,1], 1",
                "[1,1,1,1,1], 2",
                "[-5,-3,0,2,4,6,8], 0",
                "[-5,-3,0,2,4,6,8], -5",
                "[-5,-3,0,2,4,6,8], 8"
            ],
            "outputs": [
                "[3,4]",
                "[-1,-1]",
                "[-1,-1]",
                "[2,2]",
                "[-1,-1]",
                "[0,4]",
                "[-1,-1]",
                "[2,2]",
                "[0,0]",
                "[6,6]"
            ]
        }
    },
    {
        "title": "Search Insert Position",
        "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou must write an algorithm with O(log n) runtime complexity.",
        "example": "Example 1:\n\nInput: nums = [1,3,5,6], target = 5\nOutput: 2\n\nExample 2:\n\nInput: nums = [1,3,5,6], target = 2\nOutput: 1\n\nExample 3:\n\nInput: nums = [1,3,5,6], target = 7\nOutput: 4",
        "level": "Easy",
        "tags": [
            "array",
            "binary search"
        ],
        "test_cases": {
            "inputs": [
                "[1,3,5,6], 5",
                "[1,3,5,6], 2",
                "[1,3,5,6], 7",
                "[1,3,5,6], 0",
                "[1,3,5,6], 6",
                "[1,3,5,6], 4",
                "[1,3,5,6], 1",
                "[1,3,5,6], 3",
                "[1,3,5,6], 8",
                "[1,3,5,6], -1"
            ],
            "outputs": [
                "2",
                "1",
                "4",
                "0",
                "3",
                "2",
                "0",
                "1",
                "4",
                "0"
            ]
        }
    },
    {
        "title": "Valid Sudoku",
        "description": "Given a 9 x 9 Sudoku board, determine if it is valid. Only the filled cells need to be validated according to the following rules:\n\n1. Each row must contain the digits 1-9 without repetition.\n2. Each column must contain the digits 1-9 without repetition.\n3. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\n\nNote: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules.",
        "example": "Example 1:\n\nInput: board = [\n  [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n  [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n  [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n  [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n  [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n  [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n  [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n  [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n  [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n]\nOutput: true\n\nExample 2:\n\nInput: board = [\n  [\"8\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n  [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n  [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n  [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n  [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n  [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n  [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n  [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n  [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n]\nOutput: false\nExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.",
        "level": "Medium",
        "tags": [
            "array",
            "matrix"
        ],
        "test_cases": {
            "inputs": [
                "[[\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"], [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"], [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"], [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"], [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"], [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"], [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"], [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"], [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]]",
                "[[\"8\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"], [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"], [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"], [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"], [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"], [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"], [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"], [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"], [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]]"
            ],
            "outputs": [
                "true",
                "false"
            ]
        }
    },
    null,
    {
        "title": "Count and Say Sequence",
        "description": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula. Given a positive integer n, return the nth term of the count-and-say sequence.",
        "example": "Example 1:\n\nInput: n = 1\nOutput: \"1\"\nExplanation: This is the base case.\n\nExample 2:\n\nInput: n = 4\nOutput: \"1211\"\nExplanation: countAndSay(1) = \"1\", countAndSay(2) = say \"1\" = one 1 = \"11\", countAndSay(3) = say \"11\" = two 1's = \"21\", countAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"",
        "level": "Easy",
        "tags": [
            "string",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                "1",
                "2",
                "3",
                "4",
                "5",
                "10",
                "15",
                "20",
                "25",
                "30"
            ],
            "outputs": [
                "1",
                "11",
                "21",
                "1211",
                "111221",
                "13211311123113112211",
                "311311222113111231131112132112311321322112111312211312111322212311322113212221",
                "111312211312111322212311322113212221",
                "311311222113111231131112132112311321322112111312211312111322212311322113212221",
                "311311222113111231131112132112311321322112111312211312111322212311322113212221"
            ]
        }
    },
    {
        "title": "Unique Combinations",
        "description": "Given an array of distinct integers `candidates` and a target integer `target`, return a list of all unique combinations of `candidates` where the chosen numbers sum to `target`. The same number may be chosen from `candidates` an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.",
        "example": "Example 1:\n\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation: 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times. 7 is a candidate, and 7 = 7. These are the only two combinations.",
        "level": "Medium",
        "tags": [
            "array",
            "backtracking"
        ],
        "test_cases": {
            "inputs": [
                "[2,3,6,7]",
                "[2,3,5]",
                "[2]",
                "[1,2,3,4,5]",
                "[10,20,30,40]",
                "[5,10,15,20,25]",
                "[2,4,6,8,10]",
                "[1,3,5,7,9]",
                "[2,3,5,7,11]",
                "[1,2,4,8,16]"
            ],
            "outputs": [
                "[[2,2,3],[7]]",
                "[[2,2,2,2],[2,3,3],[3,5]]",
                "[]",
                "[[1,1,1,1,1],[1,1,1,2],[1,1,3],[1,2,2],[1,4],[2,3],[5]]",
                "[[10,10,10,10],[10,10,20],[20,20],[40]]",
                "[[5,5,5,5,5],[5,5,5,10],[5,5,15],[5,20],[10,10,10],[10,15],[25]]",
                "[[2,2,2,2,2],[2,2,2,4],[2,2,6],[2,8],[4,4,4],[4,12],[6,6],[10]]",
                "[[1,1,1,1,1],[1,1,1,3],[1,1,5],[1,7],[3,3,3],[3,9],[5,5],[9]]",
                "[[2,2,2,2,2],[2,2,2,3,3],[2,2,2,7],[2,2,3,5],[2,2,11],[2,3,3,3],[2,3,7],[2,5,5],[2,13],[3,3,5,5],[3,7,7],[4,4,4,4],[4,4,8],[4,12],[5,5,5,5],[5,5,10,10],[5,15],[7,7,7],[8,8],[10,10],[16]]"
            ]
        }
    },
    {
        "title": "Unique Combinations",
        "description": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. The solution set must not contain duplicate combinations.",
        "example": "Example 1:\n\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[[1,1,6],[1,2,5],[1,7],[2,6]]\n\nExample 2:\n\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[[1,2,2],[5]]",
        "level": "Medium",
        "tags": [
            "array",
            "backtracking"
        ],
        "test_cases": {
            "inputs": [
                "[10,1,2,7,6,1,5], 8",
                "[2,5,2,1,2], 5",
                "[1,2,3,4,5], 9",
                "[1,1,1,1,1], 3",
                "[3,4,5,6,7], 10",
                "[10,20,30,40,50], 100",
                "[1,2,3,4,5], 15",
                "[2,4,6,8,10], 20",
                "[5,10,15,20,25], 30",
                "[1,3,5,7,9], 12"
            ],
            "outputs": [
                "[[1,1,6],[1,2,5],[1,7],[2,6]]",
                "[[1,2,2],[5]]",
                "[[1,2,3,3],[1,2,4],[1,3,5],[2,3,4],[5,4],[5,3,1],[5,2,2],[5,1,3],[4,3,2],[4,5],[3,2,4],[3,5,1],[3,1,5],[2,4,3],[2,5,2],[2,1,6],[1,4,4],[1,5,3],[1,3,5],[1,1,7]]",
                "[[1,1,1],[1,1,1],[1,1,1],[1,1,1],[1,1,1]]",
                "[[3,7],[4,6],[5,5]]",
                "[[10,20,30,40],[10,20,50],[10,40,50],[20,30,50]]",
                "[[1,2,3,4,5]]",
                "[[2,4,6,8],[10,10]]",
                "[[5,10,15],[20,10]]",
                "[[1,3,5,3],[1,3,7],[1,5,6],[3,9],[9,3]]"
            ]
        }
    },
    {
        "title": "Smallest Missing Positive Integer",
        "description": "Given an unsorted integer array `nums`, find the smallest missing positive integer. Implement an algorithm that runs in `O(n)` time and uses constant extra space.",
        "example": "Example 1:\n\nInput: nums = [1,2,0]\nOutput: 3\nExplanation: The numbers in the range [1,2] are all in the array.\n\nExample 2:\n\nInput: nums = [3,4,-1,1]\nOutput: 2\nExplanation: 1 is in the array but 2 is missing.\n\nExample 3:\n\nInput: nums = [7,8,9,11,12]\nOutput: 1\nExplanation: The smallest positive integer 1 is missing.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,0]",
                "[3,4,-1,1]",
                "[7,8,9,11,12]",
                "[-1,-2,-3]",
                "[0,1,2,3,4]",
                "[1,2,3,4,5]",
                "[2,3,4,5,6]",
                "[1,3,5,7,9]",
                "[2,4,6,8,10]",
                "[0,0,0,0,0]"
            ],
            "outputs": [
                "3",
                "2",
                "1",
                "1",
                "5",
                "6",
                "1",
                "2",
                "1",
                "1"
            ]
        }
    },
    {
        "title": "Trapping Rain Water",
        "description": "Given an elevation map represented by an array of non-negative integers, where the width of each bar is 1, compute how much water it can trap after raining.",
        "example": "Example 1:\n\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n\nExample 2:\n\nInput: height = [4,2,0,3,2,5]\nOutput: 9",
        "level": "Medium",
        "tags": [
            "array",
            "two pointers",
            "stack"
        ],
        "test_cases": {
            "inputs": [
                "[0,1,0,2,1,0,1,3,2,1,2,1]",
                "[4,2,0,3,2,5]",
                "[0,0,0,0,0,0]",
                "[1,2,3,4,5]",
                "[5,4,3,2,1]",
                "[5,0,5,0,5]",
                "[1,0,1,0,1]",
                "[1,2,3,4,5,4,3,2,1]",
                "[5,4,3,2,1,2,3,4,5]",
                "[1,0,1,0,1,0,1,0,1]"
            ],
            "outputs": [
                "6",
                "9",
                "0",
                "0",
                "0",
                "10",
                "2",
                "0",
                "0",
                "4"
            ]
        }
    },
    {
        "title": "String Multiplication",
        "description": "Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string. You must not use any built-in BigInteger library or convert the inputs to integer directly.",
        "example": "Example:\n\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\n\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"",
        "level": "Medium",
        "tags": [
            "string",
            "math"
        ],
        "test_cases": {
            "inputs": [
                "\"2\"",
                "\"3\"",
                "\"123\"",
                "\"456\"",
                "\"0\"",
                "\"1\"",
                "\"999\"",
                "\"1000\"",
                "\"999999\"",
                "\"1000000\""
            ],
            "outputs": [
                "\"6\"",
                "\"56088\"",
                "\"0\"",
                "\"123\"",
                "\"0\"",
                "\"999\"",
                "\"999000\"",
                "\"999999000\"",
                "\"999999000000\"",
                "\"1000000000000\""
            ]
        }
    },
    null,
    {
        "title": "Minimum Number of Jumps",
        "description": "You are given a 0-indexed array of integers `nums` of length `n`. You are initially positioned at `nums[0]`. Each element `nums[i]` represents the maximum length of a forward jump from index `i`. In other words, if you are at `nums[i]`, you can jump to any `nums[i + j]` where: 0 <= j <= nums[i] and i + j < n. Return the minimum number of jumps to reach `nums[n - 1]`. The test cases are generated such that you can reach `nums[n - 1]`.",
        "example": "Example:\n\nInput: nums = [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                "[2,3,1,1,4]",
                "[2,3,0,1,4]",
                "[1,2,3,4,5]",
                "[5,4,3,2,1]",
                "[1,1,1,1,1]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[10,9,8,7,6,5,4,3,2,1]",
                "[1,1,1,1,1,1,1,1,1,1]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]",
                "[20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]"
            ],
            "outputs": [
                "2",
                "2",
                "4",
                "4",
                "4",
                "5",
                "10",
                "9",
                "10",
                "20"
            ]
        }
    },
    null,
    {
        "title": "Unique Permutations with Duplicates",
        "description": "Given a collection of numbers that might contain duplicates, return all possible unique permutations in any order.",
        "example": "Example 1:\n\nInput: nums = [1,1,2]\nOutput: [[1,1,2],[1,2,1],[2,1,1]]\n\nExample 2:\n\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "level": "Medium",
        "tags": [
            "array",
            "backtracking"
        ],
        "test_cases": {
            "inputs": [
                "[1,1,2]",
                "[1,2,3]",
                "[1,1,1,2]",
                "[3,3,0,3]",
                "[4,4,4,4]",
                "[1,2,2,3,3,3]",
                "[5,5,5,5,5,5,5,5]",
                "[0,0,0,0,0,0,0,0,0]",
                "[1,2,3,4,5,6,7,8]",
                "[10,10,10,10,10,10,10,10,10,10]"
            ],
            "outputs": [
                "[[1,1,2],[1,2,1],[2,1,1]]",
                "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
                "[[1,1,1,2],[1,1,2,1],[1,2,1,1],[2,1,1,1]]",
                "[[0,3,3,3],[3,0,3,3],[3,3,0,3],[3,3,3,0]]",
                "[[4,4,4,4]]",
                "[[1,2,2,3,3,3],[1,2,3,2,3,3],[1,2,3,3,2,3],[1,2,3,3,3,2],[1,3,2,2,3,3],[1,3,2,3,2,3],[1,3,2,3,3,2],[1,3,3,2,2,3],[1,3,3,2,3,2],[1,3,3,3,2,2],[2,1,2,3,3,3],[2,1,3,2,3,3],[2,1,3,3,2,3],[2,1,3,3,3,2],[2,3,1,2,3,3],[2,3,1,3,2,3],[2,3,1,3,3,2],[2,3,3,1,2,3],[2,3,3,1,3,2],[2,3,3,2,1,3],[3,1,2,2,3,3],[3,1,2,3,2,3],[3,1,2,3,3,2],[3,1,3,2,2,3],[3,1,3,2,3,2],[3,1,3,3,2,2],[3,2,1,2,3,3],[3,2,1,3,2,3],[3,2,1,3,3,2],[3,2,3,1,2,3],[3,2,3,1,3,2],[3,2,3,2,1,3],[3,3,1,2,2,3],[3,3,1,2,3,2],[3,3,1,3,2,2],[3,3,2,1,2,3],[3,3,2,1,3,2],[3,3,2,2,1,3]]",
                "[[5,5,5,5,5,5,5,5]]",
                "[[0,0,0,0,0,0,0,0,0]]",
                "[[1,2,3,4,5,6,7,8]]",
                "[[10,10,10,10,10,10,10,10,10,10]]"
            ]
        }
    },
    {
        "title": "Rotate Image",
        "description": "You are given an `n x n` 2D `matrix` representing an image. Rotate the image by 90 degrees (clockwise) in-place, modifying the input 2D matrix directly.",
        "example": "Example:\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\n\nExplanation: The original matrix is:\n1 2 3\n4 5 6\n7 8 9\n\nAfter rotating 90 degrees clockwise, the matrix becomes:\n7 4 1\n8 5 2\n9 6 3",
        "level": "Medium",
        "tags": [
            "array",
            "matrix",
            "in-place"
        ],
        "test_cases": {
            "inputs": [
                "[[1,2,3],[4,5,6],[7,8,9]]",
                "[[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]",
                "[[1]]",
                "[[1,2],[3,4]]",
                "[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]",
                "[[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]]",
                "[[1,2,3,4,5,6],[7,8,9,10,11,12],[13,14,15,16,17,18],[19,20,21,22,23,24],[25,26,27,28,29,30],[31,32,33,34,35,36]]",
                "[[1,2,3,4,5,6,7],[8,9,10,11,12,13,14],[15,16,17,18,19,20,21],[22,23,24,25,26,27,28],[29,30,31,32,33,34,35],[36,37,38,39,40,41,42],[43,44,45,46,47,48,49]]",
                "[[1,2,3,4,5,6,7,8],[9,10,11,12,13,14,15,16],[17,18,19,20,21,22,23,24],[25,26,27,28,29,30,31,32],[33,34,35,36,37,38,39,40],[41,42,43,44,45,46,47,48],[49,50,51,52,53,54,55,56],[57,58,59,60,61,62,63,64]]",
                "[[1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18],[19,20,21,22,23,24,25,26,27],[28,29,30,31,32,33,34,35,36],[37,38,39,40,41,42,43,44,45],[46,47,48,49,50,51,52,53,54],[55,56,57,58,59,60,61,62,63],[64,65,66,67,68,69,70,71,72],[73,74,75,76,77,78,79,80,81]]"
            ],
            "outputs": [
                "[[7,4,1],[8,5,2],[9,6,3]]",
                "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
                "[[1]]",
                "[[3,1],[4,2]]",
                "[[13,9,5,1],[14,10,6,2],[15,11,7,3],[16,12,8,4]]",
                "[[21,16,11,6,1],[22,17,12,7,2],[23,18,13,8,3],[24,19,14,9,4],[25,20,15,10,5]]",
                "[[31,25,19,13,7,1],[32,26,20,14,8,2],[33,27,21,15,9,3],[34,28,22,16,10,4],[35,29,23,17,11,5],[36,30,24,18,12,6]]",
                "[[43,36,29,22,15,8,1],[44,37,30,23,16,9,2],[45,38,31,24,17,10,3],[46,39,32,25,18,11,4],[47,40,33,26,19,12,5],[48,41,34,27,20,13,6],[49,42,35,28,21,14,7]]",
                "[[57,49,41,33,25,17,9,1],[58,50,42,34,26,18,10,2],[59,51,43,35,27,19,11,3],[60,52,44,36,28,20,12,4],[61,53,45,37,29,21,13,5],[62,54,46,38,30,22,14,6],[63,55,47,39,31,23,15,7],[64,56,48,40,32,24,16,8]]",
                "[[73,64,55,46,37,28,19,10,1],[74,65,56,47,38,29,20,11,2],[75,66,57,48,39,30,21,12,3],[76,67,58,49,40,31,22,13,4],[77,68,59,50,41,32,23,14,5],[78,69,60,51,42,33,24,15,6],[79,70,61,52,43,34,25,16,7],[80,71,62,53,44,35,26,17,8],[81,72,63,54,45,36,27,18,9]]"
            ]
        }
    },
    null,
    {
        "title": "Power Function",
        "description": "Implement a function `power(x, n)` that calculates `x` raised to the power `n` (i.e., `x^n`).",
        "example": "Example:\n\nInput: x = 2.00000, n = 10\nOutput: 1024.00000\n\nInput: x = 2.10000, n = 3\nOutput: 9.26100\n\nInput: x = 2.00000, n = -2\nOutput: 0.25000\nExplanation: 2^-2 = 1/2^2 = 1/4 = 0.25",
        "level": "Medium",
        "tags": [
            "math",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                {
                    "x": 2.0,
                    "n": 0
                },
                {
                    "x": 3.5,
                    "n": 4
                },
                {
                    "x": 1.5,
                    "n": -3
                },
                {
                    "x": 0.5,
                    "n": 10
                },
                {
                    "x": -2.0,
                    "n": 5
                },
                {
                    "x": 4.2,
                    "n": -2
                },
                {
                    "x": 10.0,
                    "n": 1
                },
                {
                    "x": 0.0,
                    "n": 5
                },
                {
                    "x": 1.0,
                    "n": 100
                },
                {
                    "x": -3.0,
                    "n": 3
                }
            ],
            "outputs": [
                1.0,
                150.0625,
                0.2962962962962963,
                0.0009765625,
                -32.0,
                0.05555555555555555,
                10.0,
                0.0,
                1.0,
                -27.0
            ]
        }
    },
    null,
    {
        "title": "N-Queens Puzzle Solutions",
        "description": "Given an integer n, the task is to find the number of distinct solutions to the n-queens puzzle. The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.",
        "example": "Example:\n\nInput: n = 4\nOutput: 2\nExplanation: There are two distinct solutions to the 4-queens puzzle as shown.\n\nInput: n = 1\nOutput: 1",
        "level": "Medium",
        "tags": [
            "backtracking",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                "4",
                "1",
                "2",
                "3",
                "5",
                "6",
                "7",
                "8",
                "9"
            ],
            "outputs": [
                "2",
                "1",
                "0",
                "10",
                "4",
                "40",
                "92",
                "352",
                "724"
            ]
        }
    },
    {
        "title": "Maximum Subarray Sum",
        "description": "Given an integer array `nums`, find the subarray with the largest sum, and return its sum.",
        "example": "Example 1:\n\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                "[-2,1,-3,4,-1,2,1,-5,4]",
                "[1]",
                "[5,4,-1,7,8]",
                "[-1,-2,-3,-4,-5]",
                "[1,2,3,4,5]",
                "[-2,-3,4,-1,-2,1,5,-3]",
                "[0,0,0,0,0,0,0,0,0,0]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[-1,0,1,0,-1,0,1,0,-1,0]",
                "[10,-5,20,-30,40,-10]"
            ],
            "outputs": [
                "6",
                "1",
                "23",
                "-1",
                "15",
                "7",
                "0",
                "55",
                "1",
                "40"
            ]
        }
    },
    null,
    null,
    {
        "title": "Merge Overlapping Intervals",
        "description": "Given an array of intervals where each interval is represented as [start, end], merge all overlapping intervals and return an array of non-overlapping intervals that cover all the intervals in the input.",
        "example": "Example 1:\n\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\nExample 2:\n\nInput: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "[[1,3],[2,6],[8,10],[15,18]]",
                "[[1,4],[4,5]]",
                "[[1,2],[3,4],[5,6],[7,8]]",
                "[[1,5],[2,3],[4,6],[7,8]]",
                "[[1,10],[2,3],[4,5],[6,7]]",
                "[[1,3],[4,6],[7,9],[10,12]]",
                "[[1,2],[2,3],[3,4],[4,5]]",
                "[[1,2],[3,4],[5,6],[7,8],[9,10]]",
                "[[1,5],[2,6],[3,7],[4,8]]",
                "[[1,3],[2,4],[5,7],[6,8]]"
            ],
            "outputs": [
                "[[1,6],[8,10],[15,18]]",
                "[[1,5]]",
                "[[1,2],[3,4],[5,6],[7,8]]",
                "[[1,6],[7,8]]",
                "[[1,10]]",
                "[[1,3],[4,6],[7,9],[10,12]]",
                "[[1,5]]",
                "[[1,2],[3,4],[5,6],[7,8],[9,10]]",
                "[[1,8]]",
                "[[1,4],[5,8]]"
            ]
        }
    },
    null,
    {
        "title": "Length of Last Word",
        "description": "Given a string `s` consisting of words and spaces, return the length of the last word in the string. A word is a maximal substring consisting of non-space characters only.",
        "example": "Example 1:\n\nInput: s = \"Hello World \"\nOutput: 5\nExplanation: The last word is \"World \" with length 5.",
        "level": "Easy",
        "tags": [
            "string"
        ],
        "test_cases": {
            "inputs": [
                "\"Hello World \"",
                "\"   fly me   to   the moon   \"",
                "\"luffy is still joyboy \"",
                "\"This is a test\"",
                "\"Coding is fun\"",
                "\"  Hello  \"",
                "\"  Hello World\"",
                "\"Hello World\"",
                "\"Hello World  \"",
                "\"  Hello World  \""
            ],
            "outputs": [
                "5",
                "4",
                "6",
                "4",
                "3",
                "5",
                "5",
                "5",
                "5",
                "5"
            ]
        }
    },
    {
        "title": "Spiral Matrix",
        "description": "Given a positive integer `n`, generate an `n x n` matrix filled with elements from `1` to `n^2` in spiral order.",
        "example": "Example 1:\n\nInput: n = 3\nOutput: [[1,2,3],[8,9,4],[7,6,5]]\n\nExample 2:\n\nInput: n = 1\nOutput: [[1]]",
        "level": "Medium",
        "tags": [
            "array",
            "matrix"
        ],
        "test_cases": {
            "inputs": [
                "3",
                "4",
                "5",
                "6",
                "7",
                "8",
                "9",
                "10",
                "15",
                "20"
            ],
            "outputs": [
                "[[1,2,3],[8,9,4],[7,6,5]]",
                "[[1,2,3,4],[12,13,14,5],[11,16,15,6],[10,9,8,7]]",
                "[[1,2,3,4,5],[16,17,18,19,6],[15,24,25,20,7],[14,23,22,21,8],[13,12,11,10,9]]",
                "[[1,2,3,4,5,6],[20,21,22,23,24,7],[19,32,33,34,25,8],[18,31,36,35,26,9],[17,30,29,28,27,10],[16,15,14,13,12,11]]",
                "[[1,2,3,4,5,6,7],[24,25,26,27,28,29,8],[23,40,41,42,43,30,9],[22,39,48,49,44,31,10],[21,38,47,46,45,32,11],[20,37,36,35,34,33,12],[19,18,17,16,15,14,13]]",
                "[[1,2,3,4,5,6,7,8],[28,29,30,31,32,33,34,9],[27,48,49,50,51,52,35,10],[26,47,60,61,62,53,36,11],[25,46,59,64,63,54,37,12],[24,45,58,57,56,55,38,13],[23,44,43,42,41,40,39,14],[22,21,20,19,18,17,16,15]]",
                "[[1,2,3,4,5,6,7,8,9],[32,33,34,35,36,37,38,39,10],[31,56,57,58,59,60,61,40,11],[30,55,72,73,74,75,62,41,12],[29,54,71,80,81,76,63,42,13],[28,53,70,79,78,77,64,43,14],[27,52,69,68,67,66,65,44,15],[26,51,50,49,48,47,46,45,16],[25,24,23,22,21,20,19,18,17]]",
                "[[1,2,3,4,5,6,7,8,9,10],[36,37,38,39,40,41,42,43,44,11],[35,64,65,66,67,68,69,70,45,12],[34,63,84,85,86,87,88,71,46,13],[33,62,83,96,97,98,89,72,47,14],[32,61,82,95,100,99,90,73,48,15],[31,60,81,94,93,92,91,74,49,16],[30,59,80,79,78,77,76,75,50,17],[29,58,57,56,55,54,53,52,51,18],[28,27,26,25,24,23,22,21,20,19]]",
                "[[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],[44,45,46,47,48,49,50,51,52,53,54,55,56,16,17],[43,80,81,82,83,84,85,86,87,88,89,90,57,18,19],[42,79,112,113,114,115,116,117,118,119,120,91,58,20,21],[41,78,111,128,129,130,131,132,133,134,121,92,59,22,23],[40,77,110,127,136,137,138,139,140,135,122,93,60,24,25],[39,76,109,126,141,144,145,146,143,124,123,94,61,26,27],[38,75,108,125,142,147,148,149,142,125,124,95,62,28,29],[37,74,107,106,105,104,103,102,101,100,99,98,97,96,63,30],[36,73,72,71,70,69,68,67,66,65,64,63,62,61,60,31],[35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20],[19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4],[3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0]]",
                "[[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],[48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,21],[47,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,67,22],[46,95,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,113,68,23],[45,94,143,192,193,194,195,196,197,198,199,200,201,202,203,204,159,114,69,24],[44,93,142,191,224,225,226,227,228,229,230,231,232,233,234,205,160,115,70,25],[43,92,141,190,223,240,241,242,243,244,245,246,247,248,235,206,161,116,71,26],[42,91,140,189,222,239,248,249,250,251,252,253,254,249,236,207,162,117,72,27],[41,90,139,188,221,238,247,256,257,258,259,260,255,250,237,208,163,118,73,28],[40,89,138,187,220,237,246,255,264,265,266,261,256,251,238,209,164,119,74,29],[39,88,137,186,219,236,245,254,263,272,267,262,257,252,239,210,165,120,75,30],[38,87,136,185,218,235,244,253,262,271,270,269,258,253,240,211,166,121,76,31],[37,86,135,184,217,234,243,252,261,270,269,268,259,254,241,212,167,122,77,32],[36,85,134,183,216,233,242,251,260,269,268,267,260,255,242,213,168,123,78,33],[35,84,133,182,215,232,241,250,259,268,267,266,261,256,243,214,169,124,79,34],[34,83,132,181,214,231,240,249,258,267,266,265,262,257,244,215,170,125,80,35],[33,82,131,180,213,230,239,248,257,266,265,264,263,258,245,216,171,126,81,36],[32,81,130,179,212,229,238,247,256,265,264,263,262,259,246,217,172,127,82,37],[31,80,129,178,211,228,237,246,255,264,263,262,261,260,247,218,173,128,83,38],[30,79,128,177,210,227,236,245,254,263,262,261,260,259,248,219,174,129,84,39],[29,78,127,176,209,226,235,244,253,262,261,260,259,258,249,220,175,130,85,40],[28,77,126,175,208,225,234,243,252,261,260,259,258,257,250,221,176,131,86,41],[27,76,125,174,207,224,233,242,251,260,259,258,257,256,251,222,177,132,87,42],[26,75,124,173,206,223,232,241,250,259,258,257,256,255,252,223,178,133,88,43],[25,74,123,172,205,222,231,240,249,258,257,256,255,254,253,224,179,134,89,44],[24,73,122,171,204,221,230,239,248,257,256,255,254,253,252,225,180,135,90,45],[23,72,121,170,203,220,229,238,247,256,255,254,253,252,251,226,181,136,91,46],[22,71,120,169,202,219,228,237,246,255,254,253,252,251,250,227,182,137,92,47],[21,70,119,168,201,218,227,236,245,254,253,252,251,250,249,228,183,138,93,48],[20,69,118,167,200,217,226,235,244,253,252,251,250,249,248,229,184,139,94,49],[19,68,117,166,199,216,225,234,243,252,251,250,249,248,247,230,185,140,95,50],[18,67,116,165,198,215,224,233,242,251,250,249,248,247,246,231,186,141,96,51],[17,66,115,164,197,214,223,232,241,250,249,248,247,246,245,232,187,142,97,52],[16,65,114,163,196,213,222,231,240,249,248,247,246,245,244,233,188,143,98,53],[15,64,113,162,195,212,221,230,239,248,247,246,245,244,243,234,189,144,99,54],[14,63,112,161,194,211,220,229,238,247,246,245,244,243,242,235,190,145,100,55],[13,62,111,160,193,210,219,228,237,246,245,244,243,242,241,236,191,146,101,56],[12,61,110,159,192,209,218,227,236,245,244,243,242,241,240,237,192,147,102,57],[11,60,109,158,191,208,217,226,235,244,243,242,241,240,239,238,193,148,103,58],[10,59,108,157,190,207,216,225,234,243,242,241,240,239,238,237,194,149,104,59],[9,58,107,156,189,206,215,224,233,242,241,240,239,238,237,236,195,150,105,60],[8,57,106,155,188,205,214,223,232,241,240,239,238,237,236,235,196,151,106,61],[7,56,105,154,187,204,213,222,231,240,239,238,237,236,235,234,197,152,107,62],[6,55,104,153,186,203,212,221,230,239,238,237,236,235,234,233,198,153,108,63],[5,54,103,152,185,202,211,220,229,238,237,236,235,234,233,232,199,154,109,64],[4,53,102,151,184,201,210,219,228,237,236,235,234,233,232,231,200,155,110,65],[3,52,101,150,183,200,209,218,227,236,235,234,233,232,231,230,201,156,111,66],[2,51,100,149,182,199,208,217,226,235,234,233,232,231,230,229,202,157,112,67],[1,50,99,148,181,198,207,216,225,234,233,232,231,230,229,228,203,158,113,68],[0,49,98,147,180,197,206,215,224,233,232,231,230,229,228,227,204,159,114,69],[0,48,97,146,179,196,205,214,223,232,231,230,229,228,227,226,205,160,115,70],[0,47,96,145,178,195,204,213,222,231,230,229,228,227,226,225,206,161,116,71],[0,46,95,144,177,194,203,212,221,230,229,228,227,226,225,224,207,162,117,72],[0,45,94,143,176,193,202,211,220,229,228,227,226,225,224,223,208,163,118,73],[0,44,93,142,175,192,201,210,219,228,227,226,225,224,223,222,209,164,119,74],[0,43,92,141,174,191,200,209,218,227,226,225,224,223,222,221,210,165,120,75],[0,42,91,140,173,190,199,208,217,226,225,224,223,222,221,220,211,166,121,76],[0,41,90,139,172,189,198,207,216,225,224,223,222,221,220,219,212,167,122,77],[0,40,89,138,171,188,197,206,215,224,223,222,221,220,219,218,213,168,123,78],[0,39,88,137,170,187,196,205,214,223,222,221,220,219,218,217,214,169,124,79],[0,38,87,136,169,186,195,204,213,222,221,220,219,218,217,216,215,170,125,80],[0,37,86,135,168,185,194,203,212,221,220,219,218,217,216,215,214,171,126,81],[0,36,85,134,167,184,193,202,211,220,219,218,217,216,215,214,213,172,127,82],[0,35,84,133,166,183,192,201,210,219,218,217,216,215,214,213,212,173,128,83],[0,34,83,132,165,182,191,200,209,218,217,216,215,214,213,212,211,174,129,84],[0,33,82,131,164,181,190,199,208,217,216,215,214,213,212,211,210,175,130,85],[0,32,81,130,163,180,189,198,207,216,215,214,213,212,211,210,209,176,131,86],[0,31,80,129,162,179,188,197,206,215,214,213,212,211,210,209,208,177,132,87],[0,30,79,128,161,178,187,196,205,214,213,212,211,210,209,208,207,178,133,88],[0,29,78,127,160,177,186,195,204,213,212,211,210,209,208,207,206,179,134,89],[0,28,77,126,159,176,185,194,203,212,211,210,209,208,207,206,205,180,135,90],[0,27,76,125,158,175,184,193,202,211,210,209,208,207,206,205,204,181,136,91],[0,26,75,124,157,174,183,192,201,210,209,208,207,206,205,204,203,182,137,92],[0,25,74,123,156,173,182,191,200,209,208,207,206,205,204,203,202,183,138,93],[0,24,73,122,155,172,181,190,199,208,207,206,205,204,203,202,201,184,139,94],[0,23,72,121,154,171,180,189,198,207,206,205,204,203,202,201,200,185,140,95],[0,22,71,120,153,170,179,188,197,206,205,204,203,202,201,200,199,186,141,96],[0,21,70,119,152,169,178,187,196,205,204,203,202,201,200,199,198,187,142,97],[0,20,69,118,151,168,177,186,195,204,203,202,201,200,199,198,197,188,143,98],[0,19,68,117,150,167,176,185,194,203,202,201,200,199,198,197,196,189,144,99],[0,18,67,116,149,166,175,184,193,202,201,200,199,198,197,196,195,190,145,100],[0,17,66,115,148,165,174,183,192,201,200,199,198,197,196,195,194,191,146,101],[0,16,65,114,147,164,173,182,191,200,199,198,197,196,195,194,193,192,147,102],[0,15,64,113,112,111,110,109,108,107,106,105,104,103,102,101,100,99,98,97],[0,14,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46],[0,13,12,11,10,9,8,7,6,5,4,3,2,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]"
            ]
        }
    },
    {
        "title": "Permutation Sequence",
        "description": "Given a set of numbers from 1 to n, the set contains a total of n! unique permutations. By listing and labeling all of the permutations in order, return the kth permutation sequence.",
        "example": "Given n = 3 and k = 3, the set of permutations is [\"123\", \"132\", \"213\", \"231\", \"312\", \"321\"]. The 3rd permutation is \"213\".",
        "level": "Medium",
        "tags": [
            "Math",
            "Backtracking"
        ],
        "test_cases": {
            "inputs": [
                {
                    "n": 3,
                    "k": 3
                },
                {
                    "n": 4,
                    "k": 9
                },
                {
                    "n": 3,
                    "k": 1
                },
                {
                    "n": 5,
                    "k": 24
                },
                {
                    "n": 2,
                    "k": 2
                },
                {
                    "n": 6,
                    "k": 720
                },
                {
                    "n": 7,
                    "k": 5040
                },
                {
                    "n": 8,
                    "k": 40320
                },
                {
                    "n": 9,
                    "k": 362880
                },
                {
                    "n": 9,
                    "k": 1
                }
            ],
            "outputs": [
                "213",
                "2314",
                "123",
                "54321",
                "21",
                "654321",
                "7654321",
                "87654321",
                "987654321",
                "123456789"
            ]
        }
    },
    {
        "title": "Rotate Linked List",
        "description": "Given the head of a linked list, rotate the list to the right by k places.",
        "example": "Example 1:\n\nInput: head = [1,2,3,4,5], k = 2\nOutput: [4,5,1,2,3]\n\nExample 2:\n\nInput: head = [0,1,2], k = 4\nOutput: [2,0,1]",
        "level": "Medium",
        "tags": [
            "linked list"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3,4,5]",
                "[0,1,2]",
                "[1]",
                "[]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[10,20,30,40,50]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]"
            ],
            "outputs": [
                "[4,5,1,2,3]",
                "[2,0,1]",
                "[1]",
                "[]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[40,50,10,20,30]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[9,10,1,2,3,4,5,6,7,8]",
                "[8,9,10,1,2,3,4,5,6,7]",
                "[7,8,9,10,1,2,3,4,5,6]"
            ]
        }
    },
    {
        "title": "Unique Paths",
        "description": "A robot is located at the top-left corner of an m x n grid. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid. Given the dimensions of the grid, return the number of possible unique paths that the robot can take to reach the bottom-right corner.",
        "example": "Example 1:\n\nInput: m = 3, n = 7\nOutput: 28\n\nExample 2:\n\nInput: m = 3, n = 2\nOutput: 3\nExplanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down",
        "level": "Medium",
        "tags": [
            "dynamic programming",
            "grid"
        ],
        "test_cases": {
            "inputs": [
                "3, 7",
                "3, 2",
                "1, 1",
                "2, 2",
                "5, 5",
                "10, 10",
                "1, 10",
                "10, 1",
                "100, 100",
                "50, 50"
            ],
            "outputs": [
                "28",
                "3",
                "1",
                "2",
                "70",
                "48620",
                "1",
                "1",
                "227508830794229349661819540395688853956041682601541047340",
                "204225"
            ]
        }
    },
    {
        "title": "Unique Paths II",
        "description": "You are given an `m x n` integer array `grid`. There is a robot initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nAn obstacle and space are marked as `1` or `0` respectively in `grid`. A path that the robot takes cannot include **any** square that is an obstacle.\n\nReturn the number of possible unique paths that the robot can take to reach the bottom-right corner.\n\n**Example 1:**\n\n**Input:** obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n**Output:** 2\n**Explanation:** There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right\n\n**Example 2:**\n\n**Input:** obstacleGrid = [[0,1],[0,0]]\n**Output:** 1\n\n**Constraints:**\n\n- `m == obstacleGrid.length`\n- `n == obstacleGrid[i].length`\n- `1 <= m, n <= 100`\n- `obstacleGrid[i][j]` is `0` or `1`.",
        "example": "Example:\n\nInput: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: 2\nExplanation: There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right",
        "level": "Medium",
        "tags": [
            "dynamic programming",
            "grid"
        ],
        "test_cases": {
            "inputs": [
                "[[0,0,0],[0,1,0],[0,0,0]]",
                "[[0,1],[0,0]]",
                "[[0,0,0],[0,0,0],[0,0,0]]",
                "[[0,0,0],[0,1,0],[0,0,1]]",
                "[[0,0,0,0],[0,1,0,0],[0,0,0,0],[0,0,0,0]]",
                "[[0,0,0,0],[0,1,0,0],[0,0,0,0],[0,0,0,1]]",
                "[[0,0,0,0,0],[0,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]",
                "[[0,0,0,0,0],[0,1,0,0,0],[0,0,0,0,0],[0,0,0,0,1]]",
                "[[0,0,0,0,0],[0,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]",
                "[[0,0,0,0,0],[0,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,1]]"
            ],
            "outputs": [
                "2",
                "1",
                "6",
                "0",
                "6",
                "0",
                "20",
                "0",
                "70",
                "0"
            ]
        }
    },
    null,
    {
        "title": "Valid Number",
        "description": "Given a string `s`, determine if it is a valid number. A valid number can be split into components in a specific order: a decimal number or an integer, followed by an optional 'e' or 'E' and an integer. A decimal number can have an optional sign character, followed by one of the following formats: one or more digits followed by a dot, one or more digits followed by a dot and one or more digits, or a dot followed by one or more digits. An integer can have an optional sign character followed by one or more digits.",
        "example": "Example 1:\n\nInput: s = \"0 \"\nOutput: true\n\nExample 2:\n\nInput: s = \"e \"\nOutput: false\n\nExample 3:\n\nInput: s = \". \"\nOutput: false",
        "level": "Medium",
        "tags": [
            "string",
            "parsing"
        ],
        "test_cases": {
            "inputs": [
                "\"2 \"",
                "\"0089 \"",
                "\"-0.1 \"",
                "\"+3.14 \"",
                "\"4. \"",
                "\"-.9 \"",
                "\"2e10 \"",
                "\"-90E3 \"",
                "\"3e+7 \"",
                "\"+6e-1 \"",
                "\"53.5e93 \"",
                "\"-123.456e789 \"",
                "\"abc \"",
                "\"1a \"",
                "\"1e \"",
                "\"e3 \"",
                "\"99e2.5 \"",
                "\"--6 \"",
                "\"-+3 \"",
                "\"95a54e53 \""
            ],
            "outputs": [
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "false",
                "false",
                "false",
                "false",
                "false",
                "false",
                "false",
                "false"
            ]
        }
    },
    {
        "title": "Increment Large Integer",
        "description": "You are given a large integer represented as an integer array `digits`, where each `digits[i]` is the `ith` digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`'s.\n\nIncrement the large integer by one and return the resulting array of digits.",
        "example": "Example 1:\n\nInput: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123. Incrementing by one gives 123 + 1 = 124. Thus, the result should be [1,2,4].\n\nExample 2:\n\nInput: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321. Incrementing by one gives 4321 + 1 = 4322. Thus, the result should be [4,3,2,2].\n\nExample 3:\n\nInput: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9. Incrementing by one gives 9 + 1 = 10. Thus, the result should be [1,0].",
        "level": "Easy",
        "tags": [
            "array",
            "math"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3]",
                "[4,3,2,1]",
                "[9]",
                "[0]",
                "[1,9]",
                "[9,9]",
                "[1,0,0]",
                "[9,9,9]",
                "[1,2,3,4,5,6,7,8,9]",
                "[9,8,7,6,5,4,3,2,1]"
            ],
            "outputs": [
                "[1,2,4]",
                "[4,3,2,2]",
                "[1,0]",
                "[1]",
                "[2,0]",
                "[1,0,0]",
                "[1,0,1]",
                "[1,0,0,0]",
                "[1,2,3,4,5,6,7,8,0]",
                "[9,8,7,6,5,4,3,2,2]"
            ]
        }
    },
    {
        "title": "Binary String Sum",
        "description": "Given two binary strings `a` and `b`, return their sum as a binary string.",
        "example": "Example 1:\n\nInput: a = \"11\", b = \"1\"\nOutput: \"100\"\n\nExample 2:\n\nInput: a = \"1010\", b = \"1011\"\nOutput: \"10101\"",
        "level": "Easy",
        "tags": [
            "string",
            "math"
        ],
        "test_cases": {
            "inputs": [
                "\"11\", \"1\"",
                "\"1010\", \"1011\"",
                "\"0\", \"0\"",
                "\"1\", \"0\"",
                "\"0\", \"1\"",
                "\"1111\", \"1111\"",
                "\"1001\", \"1010\"",
                "\"110\", \"10\"",
                "\"101010\", \"101010\"",
                "\"111111\", \"1\""
            ],
            "outputs": [
                "\"100\"",
                "\"10101\"",
                "\"0\"",
                "\"1\"",
                "\"1\"",
                "\"11110\"",
                "\"10011\"",
                "\"1000\"",
                "\"1010100\"",
                "\"1000000\""
            ]
        }
    },
    null,
    {
        "title": "Square Root Rounded Down",
        "description": "Given a non-negative integer `x`, return the square root of `x` rounded down to the nearest integer. The returned integer should be non-negative as well. You must not use any built-in exponent function or operator.",
        "example": "Example 1:\n\nInput: x = 4\nOutput: 2\nExplanation: The square root of 4 is 2, so we return 2.\n\nExample 2:\n\nInput: x = 8\nOutput: 2\nExplanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.",
        "level": "Easy",
        "tags": [
            "math",
            "binary search"
        ],
        "test_cases": {
            "inputs": [
                "0",
                "1",
                "2",
                "3",
                "4",
                "9",
                "16",
                "25",
                "100",
                "231"
            ],
            "outputs": [
                "0",
                "1",
                "1",
                "1",
                "2",
                "3",
                "4",
                "5",
                "10",
                "15"
            ]
        }
    },
    {
        "title": "Distinct Ways to Climb Stairs",
        "description": "You are climbing a staircase. It takes `n` steps to reach the top. Each time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?",
        "example": "Example 1:\n\nInput: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\nExample 2:\n\nInput: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step",
        "level": "Easy",
        "tags": [
            "Dynamic Programming"
        ],
        "test_cases": {
            "inputs": [
                "1",
                "2",
                "3",
                "4",
                "5",
                "10",
                "15",
                "20",
                "30",
                "45"
            ],
            "outputs": [
                "1",
                "2",
                "3",
                "5",
                "8",
                "89",
                "987",
                "10946",
                "1346269",
                "1836311903"
            ]
        }
    },
    {
        "title": "Simplified Canonical Path",
        "description": "Given an absolute path to a file or directory in a Unix-style file system, convert it to the simplified canonical path. The canonical path should start with a single slash, any two directories should be separated by a single slash, and the path should not end with a trailing slash. The path should only contain the directories on the path from the root directory to the target file or directory, and should not contain any periods or double periods.",
        "example": "Example:\n\nInput: \"/home/\"\nOutput: \"/home\"\nExplanation: The canonical path does not have a trailing slash after the last directory name.\n\nInput: \"/../\"\nOutput: \"/\"\nExplanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\n\nInput: \"/home//foo/\"\nOutput: \"/home/foo\"\nExplanation: In the canonical path, multiple consecutive slashes are replaced by a single one.",
        "level": "Medium",
        "tags": [
            "string",
            "file system"
        ],
        "test_cases": {
            "inputs": [
                "\"/home/\"",
                "\"/../\"",
                "\"/home//foo/\"",
                "\"/usr/local/../bin/\"",
                "\"/var/www/html/../../images/\"",
                "\"/home/user/../user2/\"",
                "\"/home/user/./../user2/\"",
                "\"/home/user/../../user2/\"",
                "\"/home/user/../../../user2/\"",
                "\"/home/user/../../../../user2/\""
            ],
            "outputs": [
                "\"/home\"",
                "\"/\"",
                "\"/home/foo\"",
                "\"/usr/bin\"",
                "\"/images\"",
                "\"/home/user2\"",
                "\"/home/user2\"",
                "\"/user2\"",
                "\"/\"",
                "\"/\""
            ]
        }
    },
    null,
    null,
    null,
    null,
    {
        "title": "Minimum Window Substring",
        "description": "Given two strings `s` and `t` of lengths `m` and `n` respectively, return the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window. If there is no such substring, return the empty string `\"\"`.",
        "example": "Example 1:\n\nInput: s = \"ADOBECODEBANC \", t = \"ABC \"\nOutput: \"BANC \"\nExplanation: The minimum window substring \"BANC \" includes 'A', 'B', and 'C' from string t.\n\nExample 2:\n\nInput: s = \"a \", t = \"a \"\nOutput: \"a \"\nExplanation: The entire string s is the minimum window.\n\nExample 3:\n\nInput: s = \"a \", t = \"aa \"\nOutput: \" \"\nExplanation: Both 'a's from t must be included in the window. Since the largest window of s only has one 'a', return empty string.",
        "level": "Medium",
        "tags": [
            "string",
            "sliding window"
        ],
        "test_cases": {
            "inputs": [
                "\"ADOBECODEBANC \", \"ABC \"",
                "\"a \", \"a \"",
                "\"a \", \"aa \"",
                "\"abcdefg \", \"xyz \"",
                "\"hello world \", \"o l \"",
                "\"programming \", \"gmm \"",
                "\"banana \", \"an \"",
                "\"racecar \", \"race \"",
                "\"apple \", \"le \"",
                "\"abcd \", \"abcd \""
            ],
            "outputs": [
                "\"BANC \"",
                "\"a \"",
                "\" \"",
                "\"\"",
                "\"o l \"",
                "\"gmm \"",
                "\"an \"",
                "\"race \"",
                "\"le \"",
                "\"abcd\""
            ]
        }
    },
    {
        "title": "Combinations of K Numbers",
        "description": "Given two integers `n` and `k`, return all possible combinations of `k` numbers chosen from the range `[1, n]`. You may return the answer in any order.",
        "example": "Example 1:\n\nInput: n = 4, k = 2\nOutput: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nExplanation: There are 4 choose 2 = 6 total combinations. Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n\nExample 2:\n\nInput: n = 1, k = 1\nOutput: [[1]]\nExplanation: There is 1 choose 1 = 1 total combination.",
        "level": "Medium",
        "tags": [
            "array",
            "combinations"
        ],
        "test_cases": {
            "inputs": [
                "4, 2",
                "1, 1",
                "5, 3",
                "10, 5",
                "20, 10",
                "6, 4",
                "3, 2",
                "8, 3",
                "15, 6",
                "2, 1"
            ],
            "outputs": [
                "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]",
                "[[1]]",
                "[[1,2,3],[1,2,4],[1,2,5],[1,3,4],[1,3,5],[1,4,5],[2,3,4],[2,3,5],[2,4,5],[3,4,5]]",
                "[[1,2,3,4,5],[1,2,3,4,6],[1,2,3,4,7],[1,2,3,4,8],[1,2,3,4,9],[1,2,3,5,6],[1,2,3,5,7],[1,2,3,5,8],[1,2,3,5,9],[1,2,3,6,7]]",
                "[[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,11],[1,2,3,4,5,6,7,8,9,12],[1,2,3,4,5,6,7,8,9,13],[1,2,3,4,5,6,7,8,9,14],[1,2,3,4,5,6,7,8,9,15],[1,2,3,4,5,6,7,8,9,16],[1,2,3,4,5,6,7,8,9,17],[1,2,3,4,5,6,7,8,9,18],[1,2,3,4,5,6,7,8,9,19]]",
                "[[1,2,3,4],[1,2,3,5],[1,2,3,6],[1,2,4,5],[1,2,4,6],[1,2,5,6],[1,3,4,5],[1,3,4,6],[1,3,5,6],[2,3,4,5],[2,3,4,6],[2,3,5,6]]",
                "[[1,2],[1,3],[2,3]]",
                "[[1,2,3],[1,2,4],[1,2,5],[1,3,4],[1,3,5],[1,4,5],[2,3,4],[2,3,5],[2,4,5]]",
                "[[1,2,3,4,5,6],[1,2,3,4,5,7],[1,2,3,4,5,8],[1,2,3,4,5,9],[1,2,3,4,5,10],[1,2,3,4,6,7],[1,2,3,4,6,8],[1,2,3,4,6,9],[1,2,3,4,6,10],[1,2,3,4,7,8]]",
                "[[1]]"
            ]
        }
    },
    {
        "title": "Subsets",
        "description": "Given an integer array `nums` of **unique** elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.",
        "example": "Example 1:\n\nInput: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\nExample 2:\n\nInput: nums = [0]\nOutput: [[],[0]]",
        "level": "Medium",
        "tags": [
            "array",
            "backtracking"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3]",
                "[0]",
                "[4,5,6]",
                "[-1,0,1]",
                "[10,20,30,40]",
                "[2,4,6,8,10]",
                "[7,8,9,10,11]",
                "[1,3,5,7,9,11]",
                "[2,3,5,7,11,13,17]",
                "[1,2,4,8,16,32,64,128,256,512]"
            ],
            "outputs": [
                "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
                "[[],[0]]",
                "[[],[4],[5],[4,5],[6],[4,6],[5,6],[4,5,6]]",
                "[[],[-1],[0],[-1,0],[1],[-1,1],[0,1],[-1,0,1]]",
                "[[],[10],[20],[10,20],[30],[10,30],[20,30],[10,20,30],[40],[10,40],[20,40],[10,20,40],[30,40],[10,30,40],[20,30,40],[10,20,30,40]]",
                "[[],[2],[4],[2,4],[6],[2,6],[4,6],[2,4,6],[8],[2,8],[4,8],[2,4,8],[6,8],[2,6,8],[4,6,8],[2,4,6,8],[10],[2,10],[4,10],[2,4,10],[6,10],[2,6,10],[4,6,10],[2,4,6,10],[8,10],[2,8,10],[4,8,10],[2,4,8,10],[6,8,10],[2,6,8,10],[4,6,8,10],[2,4,6,8,10]]",
                "[[],[7],[8],[7,8],[9],[7,9],[8,9],[7,8,9],[10],[7,10],[8,10],[7,8,10],[9,10],[7,9,10],[8,9,10],[7,8,9,10],[11],[7,11],[8,11],[7,8,11],[9,11],[7,9,11],[8,9,11],[7,8,9,11],[10,11],[7,10,11],[8,10,11],[7,8,10,11],[9,10,11],[7,9,10,11],[8,9,10,11],[7,8,9,10,11]]",
                "[[],[1],[3],[1,3],[5],[1,5],[3,5],[1,3,5],[7],[1,7],[3,7],[1,3,7],[5,7],[1,5,7],[3,5,7],[1,3,5,7],[9],[1,9],[3,9],[1,3,9],[5,9],[1,5,9],[3,5,9],[1,3,5,9],[7,9],[1,7,9],[3,7,9],[1,3,7,9],[5,7,9],[1,5,7,9],[3,5,7,9],[1,3,5,7,9],[11],[1,11],[3,11],[1,3,11],[5,11],[1,5,11],[3,5,11],[1,3,5,11],[7,11],[1,7,11],[3,7,11],[1,3,7,11],[5,7,11],[1,5,7,11],[3,5,7,11],[1,3,5,7,11]]",
                "[[],[2],[3],[2,3],[5],[2,5],[3,5],[2,3,5],[7],[2,7],[3,7],[2,3,7],[5,7],[2,5,7],[3,5,7],[2,3,5,7],[11],[2,11],[3,11],[2,3,11],[5,11],[2,5,11],[3,5,11],[2,3,5,11],[13],[2,13],[3,13],[2,3,13],[5,13],[2,5,13],[3,5,13],[2,3,5,13],[17],[2,17],[3,17],[2,3,17],[5,17],[2,5,17],[3,5,17],[2,3,5,17],[11,13],[2,11,13],[3,11,13],[2,3,11,13],[5,11,13],[2,5,11,13],[3,5,11,13],[2,3,5,11,13],[11,17],[2,11,17],[3,11,17],[2,3,11,17],[5,11,17],[2,5,11,17],[3,5,11,17],[2,3,5,11,17],[13,17],[2,13,17],[3,13,17],[2,3,13,17],[5,13,17],[2,5,13,17],[3,5,13,17],[2,3,5,13,17]]",
                "[[],[1],[2],[1,2],[4],[1,4],[2,4],[1,2,4],[8],[1,8],[2,8],[1,2,8],[4,8],[1,4,8],[2,4,8],[1,2,4,8],[16],[1,16],[2,16],[1,2,16],[4,16],[1,4,16],[2,4,16],[1,2,4,16],[32],[1,32],[2,32],[1,2,32],[4,32],[1,4,32],[2,4,32],[1,2,4,32],[64],[1,64],[2,64],[1,2,64],[4,64],[1,4,64],[2,4,64],[1,2,4,64],[128],[1,128],[2,128],[1,2,128],[4,128],[1,4,128],[2,4,128],[1,2,4,128],[256],[1,256],[2,256],[1,2,256],[4,256],[1,4,256],[2,4,256],[1,2,4,256],[512],[1,512],[2,512],[1,2,512],[4,512],[1,4,512],[2,4,512],[1,2,4,512]]"
            ]
        }
    },
    {
        "title": "Word Search",
        "description": "Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
        "example": "Example 1:\n\nInput: board = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], word = 'ABCCED'\nOutput: true\n\nExample 2:\n\nInput: board = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], word = 'SEE'\nOutput: true\n\nExample 3:\n\nInput: board = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], word = 'ABCB'\nOutput: false",
        "level": "Medium",
        "tags": [
            "array",
            "backtracking"
        ],
        "test_cases": {
            "inputs": [
                "[['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']]",
                "[['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']]",
                "[['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']]",
                "[['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']]",
                "[['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']]",
                "[['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']]",
                "[['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']]",
                "[['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']]",
                "[['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']]",
                "[['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']]"
            ],
            "outputs": [
                "true",
                "true",
                "false",
                "true",
                "false",
                "true",
                "false",
                "false",
                "true",
                "true"
            ]
        }
    },
    null,
    null,
    {
        "title": "Remove Duplicates from Sorted Linked List",
        "description": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.",
        "example": "Example 1:\n\nInput: head = [1,2,3,3,4,4,5]\nOutput: [1,2,5]\n\nExample 2:\n\nInput: head = [1,1,1,2,3]\nOutput: [2,3]",
        "level": "Medium",
        "tags": [
            "linked list",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3,3,4,4,5]",
                "[1,1,1,2,3]",
                "[1,1,1,1,1,1]",
                "[1,2,2,3,3,3,4,4,4,4]",
                "[]",
                "[1]",
                "[1,2]",
                "[1,1,2,2,3,3,4,4,5,5]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[10,9,8,7,6,5,4,3,2,1]"
            ],
            "outputs": [
                "[1,2,5]",
                "[2,3]",
                "[]",
                "[1]",
                "[]",
                "[1]",
                "[1,2]",
                "[3,4,5]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]"
            ]
        }
    },
    {
        "title": "Remove Duplicates from Sorted Linked List",
        "description": "Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.",
        "example": "Example 1:\n\nInput: head = [1,1,2]\nOutput: [1,2]\n\nExample 2:\n\nInput: head = [1,1,2,3,3]\nOutput: [1,2,3]",
        "level": "Easy",
        "tags": [
            "linked list",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "[1,1,2]",
                "[1,1,2,3,3]",
                "[1,1,1,1,1]",
                "[1,2,3,4,5]",
                "[]",
                "[1]",
                "[1,2,2,3,3,3,4,4,4,4,5,5,5,5,5]",
                "[-1,-1,0,0,0,1,1,1,1,1]",
                "[10,20,30,40,50,60,70,80,90,100]",
                "[1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,8,8,8,9,9,9,10,10,10]"
            ],
            "outputs": [
                "[1,2]",
                "[1,2,3]",
                "[1]",
                "[1,2,3,4,5]",
                "[]",
                "[1]",
                "[1,2,3,4,5]",
                "[-1,0,1]",
                "[10,20,30,40,50,60,70,80,90,100]",
                "[1,2,3,4,5,6,7,8,9,10]"
            ]
        }
    },
    {
        "title": "Largest Rectangle in Histogram",
        "description": "Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, write a function that returns the area of the largest rectangle in the histogram.",
        "example": "Example 1:\n\nInput: heights = [2,1,5,6,2,3]\nOutput: 10\nExplanation: The above is a histogram where the width of each bar is 1. The largest rectangle is shown in the red area, which has an area of 10 units.\n\nExample 2:\n\nInput: heights = [2,4]\nOutput: 4",
        "level": "Medium",
        "tags": [
            "array",
            "stack"
        ],
        "test_cases": {
            "inputs": [
                "[2,1,5,6,2,3]",
                "[2,4]",
                "[1,2,3,4,5]",
                "[5,4,3,2,1]",
                "[1,1,1,1,1]",
                "[1,2,3,4,5,4,3,2,1]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[10,9,8,7,6,5,4,3,2,1]",
                "[1,1,1,1,1,1,1,1,1,1]",
                "[1,2,3,4,5,6,7,8,9,10,9,8,7,6,5,4,3,2,1]"
            ],
            "outputs": [
                "10",
                "4",
                "9",
                "5",
                "5",
                "15",
                "30",
                "30",
                "10",
                "30"
            ]
        }
    },
    {
        "title": "Largest Rectangle of 1's",
        "description": "Given a binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.",
        "example": "Example 1:\n\nInput: matrix = [[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]\nOutput: 6\nExplanation: The maximal rectangle is shown in the above picture.\n\nExample 2:\n\nInput: matrix = [[0]]\nOutput: 0\n\nExample 3:\n\nInput: matrix = [[1]]\nOutput: 1",
        "level": "Medium",
        "tags": [
            "matrix",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                "[[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]",
                "[[0]]",
                "[[1]]",
                "[[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]",
                "[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]",
                "[[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]]",
                "[[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 0]]",
                "[[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]",
                "[[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]",
                "[[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]"
            ],
            "outputs": [
                "6",
                "0",
                "1",
                "20",
                "0",
                "9",
                "16",
                "16",
                "16",
                "16"
            ]
        }
    },
    {
        "title": "Partition Linked List",
        "description": "Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions.",
        "example": "Example 1:\n\nInput: head = [1,4,3,2,5,2], x = 3\nOutput: [1,2,2,4,3,5]\n\nExample 2:\n\nInput: head = [2,1], x = 2\nOutput: [1,2]",
        "level": "Medium",
        "tags": [
            "linked list",
            "partitioning"
        ],
        "test_cases": {
            "inputs": [
                "[1,4,3,2,5,2]",
                "[2,1]",
                "[3,1,2]",
                "[5,4,3,2,1]",
                "[1,2,3,4,5]",
                "[5,5,5,5,5]",
                "[1,1,1,1,1]",
                "[2,2,2,2,2]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[10,9,8,7,6,5,4,3,2,1]"
            ],
            "outputs": [
                "[1,2,2,4,3,5]",
                "[1,2]",
                "[1,2,3]",
                "[4,3,2,1,5]",
                "[1,2,3,4,5]",
                "[5,5,5,5,5]",
                "[1,1,1,1,1]",
                "[2,2,2,2,2]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]"
            ]
        }
    },
    {
        "title": "Scrambled String",
        "description": "Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1. A string can be scrambled by splitting it into two non-empty substrings at a random index and randomly deciding to swap the substrings or keep them in the same order. Apply this algorithm recursively on each substring until the length of the substring is 1. Return true if s2 is a scrambled string of s1, otherwise return false.",
        "example": "Example:\n\nInput: s1 = \"great\", s2 = \"rgeat\"\nOutput: true\nExplanation: One possible scenario applied on s1 is:\n\"great\" --> \"gr/eat\" // divide at random index.\n\"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n\"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is \"rgeat\" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.",
        "level": "Medium",
        "tags": [
            "string",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                "\"great\", \"rgeat\"",
                "\"abcde\", \"caebd\"",
                "\"a\", \"a\"",
                "\"abcd\", \"bdac\"",
                "\"hello\", \"loleh\"",
                "\"programming\", \"gmmnirporga\"",
                "\"leetcode\", \"leotcede\"",
                "\"apple\", \"papel\"",
                "\"algorithm\", \"logarithm\"",
                "\"python\", \"typhon\""
            ],
            "outputs": [
                "true",
                "false",
                "true",
                "true",
                "true",
                "false",
                "true",
                "true",
                "false",
                "true"
            ]
        }
    },
    {
        "title": "Merge Sorted Arrays",
        "description": "You are given two integer arrays `nums1` and `nums2`, sorted in non-decreasing order, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively. Merge `nums1` and `nums2` into a single array sorted in non-decreasing order. The final sorted array should be stored inside the array `nums1`. To accommodate this, `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to 0 and should be ignored. `nums2` has a length of `n`.",
        "example": "Example:\n\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\nOutput: [1,2,2,3,5,6]\nExplanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.",
        "level": "Easy",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3,0,0,0], 3, [2,5,6], 3",
                "[1], 1, [], 0",
                "[0], 0, [1], 1",
                "[1,3,5,0,0,0], 3, [2,4,6], 3",
                "[1,2,3,4,5,6], 6, [], 0",
                "[], 0, [1,2,3], 3",
                "[1,2,3,4,5,6], 3, [7,8,9], 3",
                "[1,2,3,4,5,6], 0, [7,8,9], 3",
                "[1,2,3,4,5,6], 6, [7,8,9], 0",
                "[1,2,3,4,5,6], 0, [], 0"
            ],
            "outputs": [
                "[1,2,2,3,5,6]",
                "[1]",
                "[1]",
                "[1,2,3,4,5,6]",
                "[1,2,3,4,5,6]",
                "[1,2,3]",
                "[1,2,3,4,5,6,7,8,9]",
                "[1,2,3,4,5,6,7,8,9]",
                "[1,2,3,4,5,6]",
                "[1,2,3,4,5,6]"
            ]
        }
    },
    {
        "title": "N-Bit Gray Code Sequence",
        "description": "Given an integer n, return any valid n-bit gray code sequence. An n-bit gray code sequence is a sequence of 2n integers where every integer is in the inclusive range [0, 2n - 1]. The first integer is 0. An integer appears no more than once in the sequence. The binary representation of every pair of adjacent integers differs by exactly one bit, and the binary representation of the first and last integers differs by exactly one bit.",
        "example": "Example 1:\n\nInput: n = 2\nOutput: [0,1,3,2]\nExplanation:\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n\nExample 2:\n\nInput: n = 1\nOutput: [0,1]",
        "level": "Medium",
        "tags": [
            "bit manipulation"
        ],
        "test_cases": {
            "inputs": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                16
            ],
            "outputs": [
                [
                    0,
                    1,
                    3,
                    2
                ],
                [
                    0,
                    1,
                    3,
                    2,
                    6,
                    7,
                    5,
                    4
                ],
                [
                    0,
                    1,
                    3,
                    2,
                    6,
                    7,
                    5,
                    4,
                    12,
                    13,
                    15,
                    14,
                    10,
                    11,
                    9,
                    8
                ],
                [
                    0,
                    1,
                    3,
                    2,
                    6,
                    7,
                    5,
                    4,
                    12,
                    13,
                    15,
                    14,
                    10,
                    11,
                    9,
                    8,
                    24,
                    25,
                    27,
                    26,
                    30,
                    31,
                    29,
                    28,
                    20,
                    21,
                    23,
                    22,
                    18,
                    19,
                    17,
                    16
                ],
                [
                    0,
                    1,
                    3,
                    2,
                    6,
                    7,
                    5,
                    4,
                    12,
                    13,
                    15,
                    14,
                    10,
                    11,
                    9,
                    8,
                    24,
                    25,
                    27,
                    26,
                    30,
                    31,
                    29,
                    28,
                    20,
                    21,
                    23,
                    22,
                    18,
                    19,
                    17,
                    16,
                    48,
                    49,
                    51,
                    50,
                    54,
                    55,
                    53,
                    52,
                    60,
                    61,
                    63,
                    62,
                    58,
                    59,
                    57,
                    56,
                    40,
                    41,
                    43,
                    42,
                    46,
                    47,
                    45,
                    44,
                    36,
                    37,
                    39,
                    38,
                    34,
                    35,
                    33,
                    32
                ],
                [
                    0,
                    1,
                    3,
                    2,
                    6,
                    7,
                    5,
                    4,
                    12,
                    13,
                    15,
                    14,
                    10,
                    11,
                    9,
                    8,
                    24,
                    25,
                    27,
                    26,
                    30,
                    31,
                    29,
                    28,
                    20,
                    21,
                    23,
                    22,
                    18,
                    19,
                    17,
                    16,
                    48,
                    49,
                    51,
                    50,
                    54,
                    55,
                    53,
                    52,
                    60,
                    61,
                    63,
                    62,
                    58,
                    59,
                    57,
                    56,
                    40,
                    41,
                    43,
                    42,
                    46,
                    47,
                    45,
                    44,
                    36,
                    37,
                    39,
                    38,
                    34,
                    35,
                    33,
                    32,
                    96,
                    97,
                    99,
                    98,
                    102,
                    103,
                    101,
                    100,
                    108,
                    109,
                    111,
                    110,
                    106,
                    107,
                    105,
                    104,
                    120,
                    121,
                    123,
                    122,
                    126,
                    127,
                    125,
                    124,
                    116,
                    117,
                    119,
                    118,
                    114,
                    115,
                    113,
                    112
                ],
                [
                    0,
                    1,
                    3,
                    2,
                    6,
                    7,
                    5,
                    4,
                    12,
                    13,
                    15,
                    14,
                    10,
                    11,
                    9,
                    8,
                    24,
                    25,
                    27,
                    26,
                    30,
                    31,
                    29,
                    28,
                    20,
                    21,
                    23,
                    22,
                    18,
                    19,
                    17,
                    16,
                    48,
                    49,
                    51,
                    50,
                    54,
                    55,
                    53,
                    52,
                    60,
                    61,
                    63,
                    62,
                    58,
                    59,
                    57,
                    56,
                    40,
                    41,
                    43,
                    42,
                    46,
                    47,
                    45,
                    44,
                    36,
                    37,
                    39,
                    38,
                    34,
                    35,
                    33,
                    32,
                    96,
                    97,
                    99,
                    98,
                    102,
                    103,
                    101,
                    100,
                    108,
                    109,
                    111,
                    110,
                    106,
                    107,
                    105,
                    104,
                    120,
                    121,
                    123,
                    122,
                    126,
                    127,
                    125,
                    124,
                    116,
                    117,
                    119,
                    118,
                    114,
                    115,
                    113,
                    112,
                    80,
                    81,
                    83,
                    82,
                    86,
                    87,
                    85,
                    84,
                    92,
                    93,
                    95,
                    94,
                    90,
                    91,
                    89,
                    88
                ],
                [
                    0,
                    1,
                    3,
                    2,
                    6,
                    7,
                    5,
                    4,
                    12,
                    13,
                    15,
                    14,
                    10,
                    11,
                    9,
                    8,
                    24,
                    25,
                    27,
                    26,
                    30,
                    31,
                    29,
                    28,
                    20,
                    21,
                    23,
                    22,
                    18,
                    19,
                    17,
                    16,
                    48,
                    49,
                    51,
                    50,
                    54,
                    55,
                    53,
                    52,
                    60,
                    61,
                    63,
                    62,
                    58,
                    59,
                    57,
                    56,
                    40,
                    41,
                    43,
                    42,
                    46,
                    47,
                    45,
                    44,
                    36,
                    37,
                    39,
                    38,
                    34,
                    35,
                    33,
                    32,
                    96,
                    97,
                    99,
                    98,
                    102,
                    103,
                    101,
                    100,
                    108,
                    109,
                    111,
                    110,
                    106,
                    107,
                    105,
                    104,
                    120,
                    121,
                    123,
                    122,
                    126,
                    127,
                    125,
                    124,
                    116,
                    117,
                    119,
                    118,
                    114,
                    115,
                    113,
                    112,
                    80,
                    81,
                    83,
                    82,
                    86,
                    87,
                    85,
                    84,
                    92,
                    93,
                    95,
                    94,
                    90,
                    91,
                    89,
                    88,
                    240,
                    241,
                    243,
                    242,
                    246,
                    247,
                    245,
                    244,
                    252,
                    253,
                    255,
                    254,
                    250,
                    251,
                    249,
                    248,
                    232,
                    233,
                    235,
                    234,
                    238,
                    239,
                    237,
                    236,
                    228,
                    229,
                    231,
                    230,
                    226,
                    227,
                    225,
                    224,
                    160,
                    161,
                    163,
                    162,
                    166,
                    167,
                    165,
                    164,
                    172,
                    173,
                    175,
                    174,
                    170,
                    171,
                    169,
                    168
                ],
                [
                    0,
                    1,
                    3,
                    2,
                    6,
                    7,
                    5,
                    4,
                    12,
                    13,
                    15,
                    14,
                    10,
                    11,
                    9,
                    8,
                    24,
                    25,
                    27,
                    26,
                    30,
                    31,
                    29,
                    28,
                    20,
                    21,
                    23,
                    22,
                    18,
                    19,
                    17,
                    16,
                    48,
                    49,
                    51,
                    50,
                    54,
                    55,
                    53,
                    52,
                    60,
                    61,
                    63,
                    62,
                    58,
                    59,
                    57,
                    56,
                    40,
                    41,
                    43,
                    42,
                    46,
                    47,
                    45,
                    44,
                    36,
                    37,
                    39,
                    38,
                    34,
                    35,
                    33,
                    32,
                    96,
                    97,
                    99,
                    98,
                    102,
                    103,
                    101,
                    100,
                    108,
                    109,
                    111,
                    110,
                    106,
                    107,
                    105,
                    104,
                    120,
                    121,
                    123,
                    122,
                    126,
                    127,
                    125,
                    124,
                    116,
                    117,
                    119,
                    118,
                    114,
                    115,
                    113,
                    112,
                    80,
                    81,
                    83,
                    82,
                    86,
                    87,
                    85,
                    84,
                    92,
                    93,
                    95,
                    94,
                    90,
                    91,
                    89,
                    88,
                    240,
                    241,
                    243,
                    242,
                    246,
                    247,
                    245,
                    244,
                    252,
                    253,
                    255,
                    254,
                    250,
                    251,
                    249,
                    248,
                    232,
                    233,
                    235,
                    234,
                    238,
                    239,
                    237,
                    236,
                    228,
                    229,
                    231,
                    230,
                    226,
                    227,
                    225,
                    224,
                    160,
                    161,
                    163,
                    162,
                    166,
                    167,
                    165,
                    164,
                    172,
                    173,
                    175,
                    174,
                    170,
                    171,
                    169,
                    168,
                    480,
                    481,
                    483,
                    482,
                    486,
                    487,
                    485,
                    484,
                    492,
                    493,
                    495,
                    494,
                    490,
                    491,
                    489,
                    488,
                    472,
                    473,
                    475,
                    474,
                    478,
                    479,
                    477,
                    476,
                    468,
                    469,
                    471,
                    470,
                    466,
                    467,
                    465,
                    464,
                    416,
                    417,
                    419,
                    418,
                    422,
                    423,
                    421,
                    420,
                    428,
                    429,
                    431,
                    430,
                    426,
                    427,
                    425,
                    424,
                    408,
                    409,
                    411,
                    410,
                    414,
                    415,
                    413,
                    412,
                    404,
                    405,
                    407,
                    406,
                    402,
                    403,
                    401,
                    400
                ],
                [
                    0,
                    1,
                    3,
                    2,
                    6,
                    7,
                    5,
                    4,
                    12,
                    13,
                    15,
                    14,
                    10,
                    11,
                    9,
                    8,
                    24,
                    25,
                    27,
                    26,
                    30,
                    31,
                    29,
                    28,
                    20,
                    21,
                    23,
                    22,
                    18,
                    19,
                    17,
                    16,
                    48,
                    49,
                    51,
                    50,
                    54,
                    55,
                    53,
                    52,
                    60,
                    61,
                    63,
                    62,
                    58,
                    59,
                    57,
                    56,
                    40,
                    41,
                    43,
                    42,
                    46,
                    47,
                    45,
                    44,
                    36,
                    37,
                    39,
                    38,
                    34,
                    35,
                    33,
                    32,
                    96,
                    97,
                    99,
                    98,
                    102,
                    103,
                    101,
                    100,
                    108,
                    109,
                    111,
                    110,
                    106,
                    107,
                    105,
                    104,
                    120,
                    121,
                    123,
                    122,
                    126,
                    127,
                    125,
                    124,
                    116,
                    117,
                    119,
                    118,
                    114,
                    115,
                    113,
                    112,
                    80,
                    81,
                    83,
                    82,
                    86,
                    87,
                    85,
                    84,
                    92,
                    93,
                    95,
                    94,
                    90,
                    91,
                    89,
                    88,
                    240,
                    241,
                    243,
                    242,
                    246,
                    247,
                    245,
                    244,
                    252,
                    253,
                    255,
                    254,
                    250,
                    251,
                    249,
                    248,
                    232,
                    233,
                    235,
                    234,
                    238,
                    239,
                    237,
                    236,
                    228,
                    229,
                    231,
                    230,
                    226,
                    227,
                    225,
                    224,
                    160,
                    161,
                    163,
                    162,
                    166,
                    167,
                    165,
                    164,
                    172,
                    173,
                    175,
                    174,
                    170,
                    171,
                    169,
                    168,
                    480,
                    481,
                    483,
                    482,
                    486,
                    487,
                    485,
                    484,
                    492,
                    493,
                    495,
                    494,
                    490,
                    491,
                    489,
                    488,
                    472,
                    473,
                    475,
                    474,
                    478,
                    479,
                    477,
                    476,
                    468,
                    469,
                    471,
                    470,
                    466,
                    467,
                    465,
                    464,
                    416,
                    417,
                    419,
                    418,
                    422,
                    423,
                    421,
                    420,
                    428,
                    429,
                    431,
                    430,
                    426,
                    427,
                    425,
                    424,
                    408,
                    409,
                    411,
                    410,
                    414,
                    415,
                    413,
                    412,
                    404,
                    405,
                    407,
                    406,
                    402,
                    403,
                    401,
                    400,
                    960,
                    961,
                    963,
                    962,
                    966,
                    967,
                    965,
                    964,
                    972,
                    973,
                    975,
                    974,
                    970,
                    971,
                    969,
                    968,
                    952,
                    953,
                    955,
                    954,
                    958,
                    959,
                    957,
                    956,
                    948,
                    949,
                    951,
                    950,
                    946,
                    947,
                    945,
                    944,
                    896,
                    897,
                    899,
                    898,
                    902,
                    903,
                    901,
                    900,
                    908,
                    909,
                    911,
                    910,
                    906,
                    907,
                    905,
                    904,
                    888,
                    889,
                    891,
                    890,
                    894,
                    895,
                    893,
                    892,
                    884,
                    885,
                    887,
                    886,
                    882,
                    883,
                    881,
                    880
                ]
            ]
        }
    },
    {
        "title": "Subset Power Set",
        "description": "Given an integer array `nums` that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.",
        "example": "Example 1:\n\nInput: nums = [1,2,2]\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\n\nExample 2:\n\nInput: nums = [0]\nOutput: [[],[0]]",
        "level": "Medium",
        "tags": [
            "array",
            "backtracking"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,2]",
                "[0]",
                "[1,1,2,2]",
                "[3,3,3,3]",
                "[-1,0,1]",
                "[4,4,4,4,4]",
                "[5,6,7,8,9]",
                "[10,10,10,10,10]",
                "[2,4,6,8,10]",
                "[-5,-4,-3,-2,-1]"
            ],
            "outputs": [
                "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
                "[[],[0]]",
                "[[],[1],[1,1],[1,1,2],[1,1,2,2],[1,2],[1,2,2],[2],[2,2]]",
                "[[],[3],[3,3],[3,3,3],[3,3,3,3]]",
                "[[],[-1],[0],[1],[-1,0],[-1,1],[0,1],[-1,0,1]]",
                "[[],[4],[4,4],[4,4,4],[4,4,4,4],[4,4,4,4,4]]",
                "[[],[5],[6],[7],[8],[9],[5,6],[5,7],[5,8],[5,9],[6,7],[6,8],[6,9],[7,8],[7,9],[8,9],[5,6,7],[5,6,8],[5,6,9],[5,7,8],[5,7,9],[5,8,9],[6,7,8],[6,7,9],[6,8,9],[7,8,9],[5,6,7,8],[5,6,7,9],[5,6,8,9],[5,7,8,9],[6,7,8,9],[5,6,7,8,9]]",
                "[[],[10],[10,10],[10,10,10],[10,10,10,10],[10,10,10,10,10]]",
                "[[],[2],[4],[6],[8],[10],[2,4],[2,6],[2,8],[2,10],[4,6],[4,8],[4,10],[6,8],[6,10],[8,10],[2,4,6],[2,4,8],[2,4,10],[2,6,8],[2,6,10],[2,8,10],[4,6,8],[4,6,10],[4,8,10],[6,8,10],[2,4,6,8],[2,4,6,10],[2,4,8,10],[2,6,8,10],[4,6,8,10],[2,4,6,8,10]]",
                "[[],[-5],[-4],[-3],[-2],[-1],[-5,-4],[-5,-3],[-5,-2],[-5,-1],[-4,-3],[-4,-2],[-4,-1],[-3,-2],[-3,-1],[-2,-1],[-5,-4,-3],[-5,-4,-2],[-5,-4,-1],[-5,-3,-2],[-5,-3,-1],[-5,-2,-1],[-4,-3,-2],[-4,-3,-1],[-4,-2,-1],[-3,-2,-1],[-5,-4,-3,-2],[-5,-4,-3,-1],[-5,-4,-2,-1],[-5,-3,-2,-1],[-4,-3,-2,-1],[-5,-4,-3,-2,-1]]"
            ]
        }
    },
    null,
    {
        "title": "Reverse Linked List from Position",
        "description": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.",
        "example": "Example 1:\n\nInput: head = [1,2,3,4,5], left = 2, right = 4\nOutput: [1,4,3,2,5]\n\nExample 2:\n\nInput: head = [5], left = 1, right = 1\nOutput: [5]",
        "level": "Medium",
        "tags": [
            "linked list"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3,4,5]",
                "[5]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]"
            ],
            "outputs": [
                "[1,4,3,2,5]",
                "[5]",
                "[1,2,3,4,5,10,9,8,7,6]",
                "[1]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[10,9,8,7,6,5,4,3,2,1]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]"
            ]
        }
    },
    {
        "title": "Valid IP Addresses",
        "description": "Given a string `s` containing only digits, return all possible valid IP addresses that can be formed by inserting dots into `s`. A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.",
        "example": "Example 1:\n\nInput: s = \"25525511135\"\nOutput: [\"255.255.11.135\", \"255.255.111.35\"]\n\nExample 2:\n\nInput: s = \"0000\"\nOutput: [\"0.0.0.0\"]\n\nExample 3:\n\nInput: s = \"101023\"\nOutput: [\"1.0.10.23\", \"1.0.102.3\", \"10.1.0.23\", \"10.10.2.3\", \"101.0.2.3\"]",
        "level": "Medium",
        "tags": [
            "string",
            "backtracking"
        ],
        "test_cases": {
            "inputs": [
                "25525511135",
                "0000",
                "101023",
                "19216811",
                "123456789",
                "11111111111111111111",
                "98765432109876543210",
                "12345678901234567890",
                "111111111111111111111",
                "123456789012345678901"
            ],
            "outputs": [
                [
                    "255.255.11.135",
                    "255.255.111.35"
                ],
                [
                    "0.0.0.0"
                ],
                [
                    "1.0.10.23",
                    "1.0.102.3",
                    "10.1.0.23",
                    "10.10.2.3",
                    "101.0.2.3"
                ],
                [
                    "192.168.1.1"
                ],
                [],
                [],
                [],
                [],
                [],
                []
            ]
        }
    },
    {
        "title": "Binary Tree Inorder Traversal",
        "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values.",
        "example": "Example 1:\n\nInput: root = [1,null,2,3]\nOutput: [1,3,2]\n\nExample 2:\n\nInput: root = []\nOutput: []\n\nExample 3:\n\nInput: root = [1]\nOutput: [1]",
        "level": "Medium",
        "tags": [
            "binary tree",
            "inorder traversal"
        ],
        "test_cases": {
            "inputs": [
                "[1,null,2,3]",
                "[]",
                "[1]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[5,3,6,2,4,null,8,1,null,null,null,7,9]",
                "[1,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9,null,10]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]"
            ],
            "outputs": [
                "[1,3,2]",
                "[]",
                "[1]",
                "[4,2,5,1,6,3,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9]",
                "[7,5,8,3,9,1,10,2,4,6]",
                "[10,5,15,2,7,12,17,1,3,6,8,11,13,16,18,4,9,14,19,20]",
                "[25,12,31,6,18,28,36,3,9,15,21,27,33,39,1,4,7,10,13,16,19,22,25,28,31,34,37,40,2,5,8,11,14,17,20,23,26,29,32,35,38,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]"
            ]
        }
    },
    null,
    null,
    null,
    {
        "title": "Valid Binary Search Tree",
        "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees.",
        "example": "Example 1:\n\nInput: root = [2,1,3]\nOutput: true\n\nExample 2:\n\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.",
        "level": "Medium",
        "tags": [
            "binary tree",
            "binary search tree",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                "[2,1,3]",
                "[5,1,4,null,null,3,6]",
                "[1,null,2]",
                "[10,5,15,null,null,6,20]",
                "[3,1,5,0,2,4,6]",
                "[1,1]",
                "[2,2,2]",
                "[1,2,3,4,5,6,7]",
                "[7,6,5,4,3,2,1]",
                "[5,4,6,null,null,3,7]"
            ],
            "outputs": [
                "true",
                "false",
                "true",
                "false",
                "true",
                "false",
                "false",
                "true",
                "false",
                "false"
            ]
        }
    },
    null,
    {
        "title": "Binary Tree Comparison",
        "description": "Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
        "example": "Example 1:\n\nInput: p = [1,2,3], q = [1,2,3]\nOutput: true\n\nExample 2:\n\nInput: p = [1,2], q = [1,null,2]\nOutput: false\n\nExample 3:\n\nInput: p = [1,2,1], q = [1,1,2]\nOutput: false",
        "level": "Easy",
        "tags": [
            "binary tree",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3]",
                "[1,2,3]",
                "[1,2]",
                "[1,null,2]",
                "[1,2,1]",
                "[1,1,2]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]"
            ],
            "outputs": [
                "true",
                "false",
                "false",
                "true",
                "false",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true"
            ]
        }
    },
    {
        "title": "Symmetric Binary Tree",
        "description": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).",
        "example": "Example 1:\n\nInput: root = [1,2,2,3,4,4,3]\nOutput: true\n\nExample 2:\n\nInput: root = [1,2,2,null,3,null,3]\nOutput: false",
        "level": "Medium",
        "tags": [
            "binary tree",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,2,3,4,4,3]",
                "[1,2,2,null,3,null,3]",
                "[1,2,2,3,4,4,3,5,6,6,5]",
                "[1,2,2,3,4,4,3,null,null,5,6,6,5]",
                "[1,2,2,3,4,4,3,null,null,5,6,6,5,7,8,8,7]",
                "[1,2,2,3,4,4,3,null,null,5,6,6,5,7,8,8,7,null,null,9,10,10,9]",
                "[1,2,2,3,4,4,3,null,null,5,6,6,5,7,8,8,7,null,null,9,10,10,9,11,12,12,11]",
                "[1,2,2,3,4,4,3,null,null,5,6,6,5,7,8,8,7,null,null,9,10,10,9,11,12,12,11,null,null,13,14,14,13]",
                "[1,2,2,3,4,4,3,null,null,5,6,6,5,7,8,8,7,null,null,9,10,10,9,11,12,12,11,null,null,13,14,14,13,null,null,15,16,16,15]",
                "[1,2,2,3,4,4,3,null,null,5,6,6,5,7,8,8,7,null,null,9,10,10,9,11,12,12,11,null,null,13,14,14,13,null,null,15,16,16,15,17,18,18,17]"
            ],
            "outputs": [
                "true",
                "false",
                "true",
                "false",
                "true",
                "false",
                "true",
                "false",
                "true",
                "false"
            ]
        }
    },
    {
        "title": "Binary Tree Level Order Traversal",
        "description": "Given the root of a binary tree, return the level order traversal of its nodes' values. The level order traversal is the traversal of the tree in a breadth-first manner, from left to right, level by level.",
        "example": "Example 1:\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[9,20],[15,7]]\n\nExample 2:\n\nInput: root = [1]\nOutput: [[1]]\n\nExample 3:\n\nInput: root = []\nOutput: []",
        "level": "Medium",
        "tags": [
            "binary tree",
            "breadth-first search"
        ],
        "test_cases": {
            "inputs": [
                "[3,9,20,null,null,15,7]",
                "[1]",
                "[]",
                "[5,3,6,2,4,null,7]",
                "[1,2,3,4,5]",
                "[1,null,2,null,3,null,4,null,5]",
                "[1,2,3,4,null,null,5]",
                "[1,2,3,null,null,4,5]",
                "[1,2,3,4,5,null,null,null,null,6,7,null,null,8,9]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]"
            ],
            "outputs": [
                "[[3],[9,20],[15,7]]",
                "[[1]]",
                "[]",
                "[[5],[3,6],[2,4,7]]",
                "[[1],[2,3],[4,5]]",
                "[[1],[2],[3],[4],[5]]",
                "[[1],[2,3],[4,5]]",
                "[[1],[2,3],[4,5]]",
                "[[1],[2,3],[4],[5,6,7],[8,9]]",
                "[[1],[2,3],[4,5],[6,7,8,9],[10,11,12,13,14,15]]"
            ]
        }
    },
    {
        "title": "Zigzag Level Order Traversal",
        "description": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. The zigzag level order traversal is a traversal where we visit the nodes in a zigzag pattern, starting from the leftmost node in the first level, then moving to the rightmost node in the second level, and so on. Within each level, we visit the nodes from left to right and then from right to left for the next level, alternating between the two directions.",
        "example": "Example 1:\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[20,9],[15,7]]\n\nExample 2:\n\nInput: root = [1]\nOutput: [[1]]\n\nExample 3:\n\nInput: root = []\nOutput: []",
        "level": "Medium",
        "tags": [
            "binary tree",
            "traversal"
        ],
        "test_cases": {
            "inputs": [
                "[3,9,20,null,null,15,7]",
                "[1]",
                "[]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]",
                "[5,4,8,11,null,13,4,7,2,null,null,5,1]",
                "[1,2,3,4,5,null,null,6,7,null,null,null,null,8]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]",
                "[100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]"
            ],
            "outputs": [
                "[[3],[20,9],[15,7]]",
                "[[1]]",
                "[]",
                "[[1],[3,2],[4,5,6,7],[10,9,8]]",
                "[[1],[3,2],[4,5,6,7],[15,14,13,12,11,10,9,8],[9,10,11,12,13,14,15],[20,19,18,17,16]]",
                "[[5],[8,4],[11,13,4],[7,2,5,1]]",
                "[[1],[3,2],[4,5,6,7],[8]]",
                "[[1],[3,2],[4,5,6,7],[15,14,13,12,11,10,9,8],[16,17,18,19,20],[35,34,33,32,31,30,29,28,27,26,25,24,23,22,21]]",
                "[[1],[3,2],[4,5,6,7],[15,14,13,12,11,10,9,8],[16,17,18,19,20],[35,34,33,32,31,30,29,28,27,26,25,24,23,22,21],[36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]]",
                "[[100],[99,98],[97,96,95,94],[93,92,91,90,89,88,87,86],[85,84,83,82,81,80,79,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]]"
            ]
        }
    },
    null,
    null,
    null,
    null,
    null,
    {
        "title": "Convert Sorted Linked List to Height-Balanced BST",
        "description": "Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height-balanced binary search tree.",
        "example": "Example:\n\nInput: head = [-10,-3,0,5,9]\nOutput: [0,-3,9,-10,null,5]\nExplanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.",
        "level": "Medium",
        "tags": [
            "linked list",
            "binary search tree",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                "[-10,-3,0,5,9]",
                "[]",
                "[1]",
                "[1,2,3,4,5]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[-5,-4,-3,-2,-1,0,1,2,3,4,5]",
                "[1,3,5,7,9,11,13,15,17,19]"
            ],
            "outputs": [
                "[0,-3,9,-10,null,5]",
                "[]",
                "[1]",
                "[3,2,5,1,null,4]",
                "[5,2,8,1,3,6,9,null,null,null,4,null,7,10]",
                "[0,-2,2,-4,-1,1,3,-5,null,null,null,null,null,null,4]",
                "[11,5,15,3,7,13,17,1,null,null,null,9,null,null,null,null,null,null,null,null,null,null,null,null,19]"
            ]
        }
    },
    {
        "title": "Height Balanced Binary Tree",
        "description": "Given a binary tree, determine if it is height-balanced. A binary tree is considered height-balanced if the left and right subtrees of every node differ in height by no more than 1.",
        "example": "Example 1:\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: true\n\nExplanation: The binary tree is height-balanced because the difference in height between the left and right subtrees of every node is at most 1.\n\nExample 2:\n\nInput: root = [1,2,2,3,3,null,null,4,4]\nOutput: false\n\nExplanation: The binary tree is not height-balanced because the difference in height between the left and right subtrees of node 1 is 2, which is greater than 1.\n\nExample 3:\n\nInput: root = []\nOutput: true\n\nExplanation: An empty tree is considered height-balanced.\n",
        "level": "Easy",
        "tags": [
            "Binary Tree",
            "Recursion"
        ],
        "test_cases": {
            "inputs": [
                "[3,9,20,null,null,15,7]",
                "[1,2,2,3,3,null,null,4,4]",
                "[]",
                "[1,2,2,3,null,null,3,4,null,null,4]",
                "[1,2,2,3,null,null,3,4,null,null,4,null,null,5]",
                "[1,2,2,3,null,null,3,4,null,null,4,null,null,5,null,null,5]",
                "[1,2,2,3,null,null,3,4,null,null,4,null,null,5,null,null,5,null,null,6]",
                "[1,2,2,3,null,null,3,4,null,null,4,null,null,5,null,null,5,null,null,6,null,null,6]",
                "[1,2,2,3,null,null,3,4,null,null,4,null,null,5,null,null,5,null,null,6,null,null,6,null,null,7]",
                "[1,2,2,3,null,null,3,4,null,null,4,null,null,5,null,null,5,null,null,6,null,null,6,null,null,7,null,null,7]"
            ],
            "outputs": [
                "true",
                "false",
                "true",
                "true",
                "false",
                "false",
                "false",
                "false",
                "false",
                "false"
            ]
        }
    },
    {
        "title": "Minimum Depth of Binary Tree",
        "description": "Given a binary tree, find the minimum depth, which is the number of nodes along the shortest path from the root node down to the nearest leaf node. A leaf is a node with no children.",
        "example": "Example 1:\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: 2\n\nExplanation: The minimum depth is 2 because the shortest path from the root node (3) to the nearest leaf node (15) is [3, 20, 15].\n\nExample 2:\n\nInput: root = [2,null,3,null,4,null,5,null,6]\nOutput: 5\n\nExplanation: The minimum depth is 5 because the shortest path from the root node (2) to the nearest leaf node (6) is [2, 3, 4, 5, 6].",
        "level": "Easy",
        "tags": [
            "binary tree",
            "depth",
            "leaf node"
        ],
        "test_cases": {
            "inputs": [
                "[3,9,20,null,null,15,7]",
                "[2,null,3,null,4,null,5,null,6]",
                "[]",
                "[1]",
                "[1,2]",
                "[1,null,2]",
                "[1,2,3]",
                "[1,2,3,4,5]",
                "[1,2,3,4,null,null,5]",
                "[1,2,3,null,null,4,null,null,5]"
            ],
            "outputs": [
                "2",
                "5",
                "0",
                "1",
                "2",
                "2",
                "2",
                "2",
                "3",
                "3"
            ]
        }
    },
    {
        "title": "Root to Leaf Path Sum",
        "description": "Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a **root-to-leaf** path such that adding up all the values along the path equals `targetSum`. A **leaf** is a node with no children.",
        "example": "Example 1:\n\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\nOutput: true\nExplanation: The root-to-leaf path with the target sum is shown.\n\nExample 2:\n\nInput: root = [1,2,3], targetSum = 5\nOutput: false\nExplanation: There two root-to-leaf paths in the tree: (1 --> 2): The sum is 3. (1 --> 3): The sum is 4. There is no root-to-leaf path with sum = 5.\n\nExample 3:\n\nInput: root = [], targetSum = 0\nOutput: false\nExplanation: Since the tree is empty, there are no root-to-leaf paths.",
        "level": "Medium",
        "tags": [
            "binary tree",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                "[5,4,8,11,null,13,4,7,2,null,null,null,1]",
                "[1,2,3]",
                "[]",
                "[1]",
                "[1,2]",
                "[1,2,3,4,5]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]"
            ],
            "outputs": [
                "true",
                "false",
                "false",
                "true",
                "false",
                "true",
                "true",
                "true",
                "true",
                "true"
            ]
        }
    },
    {
        "title": "Root-to-Leaf Paths with Target Sum",
        "description": "Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references. A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.",
        "example": "Example 1:\n\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\nOutput: [[5,4,11,2],[5,8,4,5]]\nExplanation: There are two paths whose sum equals targetSum: 5 + 4 + 11 + 2 = 22 and 5 + 8 + 4 + 5 = 22.\n\nExample 2:\n\nInput: root = [1,2,3], targetSum = 5\nOutput: []\n\nExample 3:\n\nInput: root = [1,2], targetSum = 0\nOutput: []",
        "level": "Medium",
        "tags": [
            "Binary Tree",
            "Recursion"
        ],
        "test_cases": {
            "inputs": [
                "[5,4,8,11,null,13,4,7,2,null,null,5,1]",
                "[1,2,3]",
                "[1,2]",
                "[1]",
                "[]",
                "[5,4,8,11,null,13,4,7,2,null,null,5,1]",
                "[1,2,3]",
                "[1,2]",
                "[1]",
                "[]"
            ],
            "outputs": [
                "22",
                "5",
                "0",
                "1",
                "0",
                "[[5,4,11,2],[5,8,4,5]]",
                "[]",
                "[]",
                "[]",
                "[]"
            ]
        }
    },
    null,
    {
        "title": "Distinct Subsequences",
        "description": "Given two strings `s` and `t`, return the number of distinct subsequences of `s` which equals `t`.",
        "example": "Example 1:\n\nInput: s = \"rabbbit\", t = \"rabbit\"\nOutput: 3\nExplanation: There are 3 ways you can generate \"rabbit\" from s.\n1. \"rabb\" + \"it\"\n2. \"ra\" + \"bbit\"\n3. \"rab\" + \"bit\"\n\nExample 2:\n\nInput: s = \"babgbag\", t = \"bag\"\nOutput: 5\nExplanation: There are 5 ways you can generate \"bag\" from s.\n1. \"ba\" + \"g\" + \"bag\"\n2. \"ba\" + \"gb\" + \"ag\"\n3. \"b\" + \"abg\" + \"ag\"\n4. \"bab\" + \"g\" + \"ag\"\n5. \"babg\" + \"bag\"",
        "level": "Medium",
        "tags": [
            "dynamic programming",
            "string"
        ],
        "test_cases": {
            "inputs": [
                "\"rabbbit\", \"rabbit\"",
                "\"babgbag\", \"bag\"",
                "\"abcde\", \"ace\"",
                "\"abcde\", \"abcde\"",
                "\"abcde\", \"\"",
                "\"\", \"abcde\"",
                "\"abcde\", \"abcdef\"",
                "\"abcdef\", \"abcde\"",
                "\"abcde\", \"abcdeabcde\"",
                "\"abcdeabcde\", \"abcde\""
            ],
            "outputs": [
                "3",
                "5",
                "1",
                "1",
                "1",
                "0",
                "0",
                "0",
                "16",
                "10"
            ]
        }
    },
    {
        "title": "Populate Next Right Pointers in Perfect Binary Tree",
        "description": "You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:\n\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\n\nInitially, all next pointers are set to NULL.",
        "example": "Example:\n\nInput: root = [1,2,3,4,5,6,7]\nOutput: [1,#,2,3,#,4,5,6,7,#]\nExplanation: Given the above perfect binary tree, your function should populate each next pointer to point to its next right node, just like in the example output. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.",
        "level": "Medium",
        "tags": [
            "binary tree",
            "pointers"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3,4,5,6,7]",
                "[]",
                "[1]",
                "[1,2]",
                "[1,2,3]",
                "[1,2,3,4]",
                "[1,2,3,4,5]",
                "[1,2,3,4,5,6]",
                "[1,2,3,4,5,6,7]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]"
            ],
            "outputs": [
                "[1,#,2,3,#,4,5,6,7,#]",
                "[]",
                "[1,#]",
                "[1,#,2,#]",
                "[1,#,2,3,#]",
                "[1,#,2,3,4,#]",
                "[1,#,2,3,4,5,#]",
                "[1,#,2,3,4,5,6,#]",
                "[1,#,2,3,4,5,6,7,#]",
                "[1,#,2,3,4,5,6,7,8,9,10,11,12,13,14,15,#]"
            ]
        }
    },
    {
        "title": "Populate Next Right Pointers in Binary Tree",
        "description": "Given a binary tree, populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`. Initially, all next pointers are set to `NULL`.",
        "example": "Example 1:\n\nInput: root = [1,2,3,4,5,null,7]\nOutput: [1,#,2,3,#,4,5,7,#]\nExplanation: Given the above binary tree, your function should populate each next pointer to point to its next right node, just like in the figure. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.",
        "level": "Medium",
        "tags": [
            "binary tree",
            "pointers"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3,4,5,null,7]",
                "[]",
                "[1]",
                "[1,2,3]",
                "[1,2,3,4,5,6,7]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]"
            ],
            "outputs": [
                "[1,#,2,3,#,4,5,7,#]",
                "[]",
                "[1,#]",
                "[1,#,2,3,#]",
                "[1,#,2,3,#,4,5,6,7,#]",
                "[1,#,2,3,#,4,5,6,7,#,8,9,10,11,12,13,14,15,#]",
                "[1,#,2,3,#,4,5,6,7,#,8,9,10,11,12,13,14,15,#,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,#]"
            ]
        }
    },
    {
        "title": "Pascal's Triangle",
        "description": "Given an integer `numRows`, return the first numRows of Pascal's triangle. In Pascal's triangle, each number is the sum of the two numbers directly above it.",
        "example": "Example:\n\nInput: numRows = 5\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n\nInput: numRows = 1\nOutput: [[1]]",
        "level": "Easy",
        "tags": [
            "array",
            "math"
        ],
        "test_cases": {
            "inputs": [
                "5",
                "1",
                "2",
                "3",
                "10",
                "15",
                "20",
                "25",
                "30",
                "50"
            ],
            "outputs": [
                "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]",
                "[[1]]",
                "[[1],[1,1]]",
                "[[1],[1,1],[1,2,1]]",
                "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1]]",
                "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1]]",
                "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1]]",
                "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1]]",
                "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1]]",
                "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1]]",
                "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1]]",
                "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1]]"
            ]
        }
    },
    null,
    null,
    {
        "title": "Maximize Stock Profit",
        "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day. You want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
        "example": "Example 1:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\nExample 2:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.",
        "level": "Easy",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                "[7,1,5,3,6,4]",
                "[7,6,4,3,1]",
                "[1,2,3,4,5]",
                "[7,6,4,3,1,8,9,10]",
                "[1,1,1,1,1,1,1,1]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[10,9,8,7,6,5,4,3,2,1]",
                "[5,4,3,2,1,10,9,8,7,6]",
                "[1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10]",
                "[10,9,8,7,6,5,4,3,2,1,10,9,8,7,6,5,4,3,2,1]"
            ],
            "outputs": [
                "5",
                "0",
                "4",
                "9",
                "0",
                "9",
                "0",
                "9",
                "9",
                "9"
            ]
        }
    },
    null,
    {
        "title": "Maximum Profit from Stock Transactions",
        "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day. Find the maximum profit you can achieve by completing at most two transactions. Note that you may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
        "example": "Example 1:\n\nInput: prices = [3,3,5,0,0,3,1,4]\nOutput: 6\nExplanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\n\nExample 2:\n\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n\nExample 3:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                "[3,3,5,0,0,3,1,4]",
                "[1,2,3,4,5]",
                "[7,6,4,3,1]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[10,9,8,7,6,5,4,3,2,1]",
                "[1,1,1,1,1,1,1,1,1,1]",
                "[1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10]",
                "[10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1]",
                "[1,2,3,4,5,6,7,8,9,10,9,8,7,6,5,4,3,2,1]",
                "[10,9,8,7,6,5,4,3,2,1,2,3,4,5,6,7,8,9,10]"
            ],
            "outputs": [
                "6",
                "4",
                "0",
                "9",
                "0",
                "0",
                "19",
                "19",
                "9",
                "9"
            ]
        }
    },
    null,
    {
        "title": "Palindrome Check",
        "description": "Given a string `s`, determine if it is a palindrome after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters. Return `true` if it is a palindrome, and `false` otherwise.",
        "example": "Example 1:\n\nInput: s = \"A man, a plan, a canal: Panama\"\nOutput: true\nExplanation: \"amanaplanacanalpanama\" is a palindrome.\n\nExample 2:\n\nInput: s = \"race a car\"\nOutput: false\nExplanation: \"raceacar\" is not a palindrome.\n\nExample 3:\n\nInput: s = \"\"\nOutput: true\nExplanation: s is an empty string after removing non-alphanumeric characters. Since an empty string reads the same forward and backward, it is a palindrome.",
        "level": "Easy",
        "tags": [
            "string",
            "palindrome"
        ],
        "test_cases": {
            "inputs": [
                "\"A man, a plan, a canal: Panama\"",
                "\"race a car\"",
                "\"\"",
                "\"No lemon, no melon\"",
                "\"Was it a car or a cat I saw?\"",
                "\"12321\"",
                "\"Hello, World!\"",
                "\"Madam, in Eden, I'm Adam\"",
                "\"Able was I ere I saw Elba\"",
                "\"Palindrome\"",
                "\"1234567890987654321\""
            ],
            "outputs": [
                "true",
                "false",
                "true",
                "true",
                "true",
                "true",
                "false",
                "true",
                "true",
                "false",
                "true"
            ]
        }
    },
    null,
    {
        "title": "Shortest Transformation Sequence",
        "description": "Given a transformation sequence from a start word to an end word using a dictionary of words, find the shortest transformation sequence. A transformation sequence is a sequence of words where each adjacent pair of words differs by a single letter. All words in the sequence must be present in the dictionary. Return the number of words in the shortest transformation sequence, or 0 if no such sequence exists.",
        "example": "Example:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nOutput: 5\nExplanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", which is 5 words long.",
        "level": "Medium",
        "tags": [
            "graph",
            "breadth-first search",
            "word ladder"
        ],
        "test_cases": {
            "inputs": [
                {
                    "beginWord": "hit",
                    "endWord": "cog",
                    "wordList": [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog"
                    ]
                },
                {
                    "beginWord": "hit",
                    "endWord": "cog",
                    "wordList": [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log"
                    ]
                },
                {
                    "beginWord": "a",
                    "endWord": "c",
                    "wordList": [
                        "a",
                        "b",
                        "c"
                    ]
                },
                {
                    "beginWord": "red",
                    "endWord": "tax",
                    "wordList": [
                        "ted",
                        "tex",
                        "red",
                        "tax",
                        "tad",
                        "den",
                        "rex",
                        "pee"
                    ]
                },
                {
                    "beginWord": "hot",
                    "endWord": "dog",
                    "wordList": [
                        "hot",
                        "dog"
                    ]
                },
                {
                    "beginWord": "a",
                    "endWord": "z",
                    "wordList": [
                        "a",
                        "b",
                        "c",
                        "d",
                        "e",
                        "f",
                        "g",
                        "h",
                        "i",
                        "j",
                        "k",
                        "l",
                        "m",
                        "n",
                        "o",
                        "p",
                        "q",
                        "r",
                        "s",
                        "t",
                        "u",
                        "v",
                        "w",
                        "x",
                        "y",
                        "z"
                    ]
                },
                {
                    "beginWord": "hit",
                    "endWord": "cog",
                    "wordList": [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat"
                    ]
                },
                {
                    "beginWord": "hit",
                    "endWord": "cog",
                    "wordList": [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot"
                    ]
                },
                {
                    "beginWord": "hit",
                    "endWord": "cog",
                    "wordList": [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog"
                    ]
                },
                {
                    "beginWord": "hit",
                    "endWord": "cog",
                    "wordList": [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog",
                        "hag"
                    ]
                }
            ],
            "outputs": [
                5,
                0,
                2,
                4,
                0,
                26,
                5,
                4,
                3,
                4
            ]
        }
    },
    null,
    null,
    null,
    {
        "title": "Palindrome Partitioning",
        "description": "Given a string `s`, partition `s` such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of `s`.",
        "example": "Example 1:\n\nInput: s = \"aab\"\nOutput: [['a','a','b'],['aa','b']]\n\nExample 2:\n\nInput: s = \"a\"\nOutput: [['a']]\n",
        "level": "Medium",
        "tags": [
            "string",
            "backtracking"
        ],
        "test_cases": {
            "inputs": [
                "\"aab\"",
                "\"a\"",
                "\"racecar\"",
                "\"level\"",
                "\"madam\"",
                "\"abcba\"",
                "\"abba\"",
                "\"aabbaa\"",
                "\"abacabadabacaba\"",
                "\"aaaaaaa\""
            ],
            "outputs": [
                "[['a','a','b'],['aa','b']]",
                "[['a']]",
                "[['r','a','c','e','c','a','r']]",
                "[['l','e','v','e','l']]",
                "[['m','a','d','a','m']]",
                "[['a','b','c','b','a']]",
                "[['a','b','b','a']]",
                "[['a','a','b','b','a','a']]",
                "[['a','b','a','c','a','b','a','d','a','b','a','c','a','b','a']]]",
                "[['a','a','a','a','a','a','a']]"
            ]
        }
    },
    null,
    null,
    {
        "title": "Gas Station Circuit",
        "description": "You are given `n` gas stations along a circular route. Each gas station has a certain amount of gas and it costs a certain amount of gas to travel from one station to the next. You have a car with an unlimited gas tank. The task is to find the starting gas station's index from where you can travel around the circuit once in the clockwise direction. If there is no such station, return -1.",
        "example": "Example 1:\n\nInput: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\nOutput: 3\nExplanation: Start at station 3 (index 3) and fill up with 4 units of gas. Your tank = 0 + 4 = 4. Travel to station 4. Your tank = 4 - 1 + 5 = 8. Travel to station 0. Your tank = 8 - 2 + 1 = 7. Travel to station 1. Your tank = 7 - 3 + 2 = 6. Travel to station 2. Your tank = 6 - 4 + 3 = 5. Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3. Therefore, return 3 as the starting index.\n\nExample 2:\n\nInput: gas = [2,3,4], cost = [3,4,3]\nOutput: -1\nExplanation: You can't start at station 0 or 1, as there is not enough gas to travel to the next station. Let's start at station 2 and fill up with 4 units of gas. Your tank = 0 + 4 = 4. Travel to station 0. Your tank = 4 - 3 + 2 = 3. Travel to station 1. Your tank = 3 - 3 + 3 = 3. You cannot travel back to station 2, as it requires 4 units of gas but you only have 3. Therefore, you can't travel around the circuit once no matter where you start.",
        "level": "Medium",
        "tags": [
            "array",
            "greedy"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3,4,5]",
                "[3,4,5,1,2]",
                "[2,3,4]",
                "[3,4,3]",
                "[5,8,2,6,9]",
                "[4,5,6,7,8]",
                "[1,1,1,1,1]",
                "[2,2,2,2,2]",
                "[0,0,0,0,0]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[10,9,8,7,6,5,4,3,2,1]"
            ],
            "outputs": [
                "3",
                "-1",
                "0",
                "-1",
                "4",
                "0",
                "0",
                "-1",
                "0",
                "0",
                "-1"
            ]
        }
    },
    {
        "title": "Minimum Number of Candies",
        "description": "You are given an array of ratings representing the rating of each child standing in a line. You need to distribute candies to these children subject to the following requirements: each child must have at least one candy and children with a higher rating should receive more candies than their neighbors. Return the minimum number of candies you need to distribute to the children.",
        "example": "Example 1:\n\nInput: ratings = [1,0,2]\nOutput: 5\nExplanation: You can allocate to the first, second, and third child with 2, 1, 2 candies respectively.\n\nExample 2:\n\nInput: ratings = [1,2,2]\nOutput: 4\nExplanation: You can allocate to the first, second, and third child with 1, 2, 1 candies respectively. The third child gets 1 candy because it satisfies the above two conditions.",
        "level": "Medium",
        "tags": [
            "array",
            "greedy"
        ],
        "test_cases": {
            "inputs": [
                "[1,0,2]",
                "[1,2,2]",
                "[1,3,4,5,2]",
                "[5,4,3,2,1]",
                "[1,1,1,1,1]",
                "[1,2,3,4,5]",
                "[5,4,3,2,1,5,4,3,2,1]",
                "[1,2,3,4,5,4,3,2,1]",
                "[1,2,3,4,5,1,2,3,4,5]",
                "[1,2,3,4,5,5,4,3,2,1]"
            ],
            "outputs": [
                "5",
                "4",
                "11",
                "15",
                "5",
                "15",
                "30",
                "20",
                "25",
                "30"
            ]
        }
    },
    {
        "title": "Find the Single Number",
        "description": "Given a non-empty array of integers, every element appears twice except for one. Find that single one. Implement a solution with a linear runtime complexity and use only constant extra space.",
        "example": "Example 1:\n\nInput: nums = [2,2,1]\nOutput: 1\n\nExample 2:\n\nInput: nums = [4,1,2,1,2]\nOutput: 4\n\nExample 3:\n\nInput: nums = [1]\nOutput: 1",
        "level": "Easy",
        "tags": [
            "array",
            "bit manipulation"
        ],
        "test_cases": {
            "inputs": [
                "[2,2,1]",
                "[4,1,2,1,2]",
                "[1]",
                "[-1,-1,-2]",
                "[0,0,1,1,2,2,3,3,4,5,5,6,6]",
                "[9,9,8,8,7,7,6,6,5,5,4,4,3,3,2,2,1]",
                "[100,200,300,400,500,600,700,800,900,1000,900,800,700,600,500,400,300,200]",
                "[-100,-200,-300,-400,-500,-600,-700,-800,-900,-1000,-900,-800,-700,-600,-500,-400,-300,-200]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]"
            ],
            "outputs": [
                "1",
                "4",
                "1",
                "-2",
                "4",
                "1",
                "1000",
                "-1000",
                "100"
            ]
        }
    },
    {
        "title": "Find Single Element in Array",
        "description": "Given an integer array `nums` where every element appears three times except for one, which appears exactly once. Find the single element and return it. Implement a solution with a linear runtime complexity and use only constant extra space.",
        "example": "Example 1:\n\nInput: nums = [2,2,3,2]\nOutput: 3\n\nExample 2:\n\nInput: nums = [0,1,0,1,0,1,99]\nOutput: 99",
        "level": "Medium",
        "tags": [
            "array",
            "bit manipulation"
        ],
        "test_cases": {
            "inputs": [
                "[2,2,3,2]",
                "[0,1,0,1,0,1,99]",
                "[-1,-1,-1,2,2,2,-3]",
                "[5,5,5,7,7,7,9]",
                "[4,4,4,8,8,8,12]",
                "[1,1,1,3,3,3,5]",
                "[9,9,9,11,11,11,13]",
                "[6,6,6,10,10,10,14]",
                "[2,2,2,4,4,4,6]",
                "[0,0,0,2,2,2,4]"
            ],
            "outputs": [
                "3",
                "99",
                "-3",
                "9",
                "12",
                "5",
                "13",
                "14",
                "6",
                "4"
            ]
        }
    },
    null,
    {
        "title": "Word Segmentation",
        "description": "Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation.",
        "example": "Example 1:\n\nInput: s = \"leetcode \", wordDict = [ \"leet \", \"code \"]\nOutput: true\nExplanation: Return true because \"leetcode \" can be segmented as \"leet code \".\n\nExample 2:\n\nInput: s = \"applepenapple \", wordDict = [ \"apple \", \"pen \"]\nOutput: true\nExplanation: Return true because \"applepenapple \" can be segmented as \"apple pen apple \".\nNote that you are allowed to reuse a dictionary word.\n\nExample 3:\n\nInput: s = \"catsandog \", wordDict = [ \"cats \", \"dog \", \"sand \", \"and \", \"cat \"]\nOutput: false",
        "level": "Medium",
        "tags": [
            "string",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                "\"leetcode \", [ \"leet \", \"code \"]",
                "\"applepenapple \", [ \"apple \", \"pen \"]",
                "\"catsandog \", [ \"cats \", \"dog \", \"sand \", \"and \", \"cat \"]",
                "\"programming \", [ \"program \", \"programming \"]",
                "\"algorithm \", [ \"algo \", \"rithm \"]",
                "\"dynamicprogramming \", [ \"dynamic \", \"programming \"]",
                "\"leetcode \", [ \"leet \", \"code \", \"leetcode \"]",
                "\"applepenapple \", [ \"apple \", \"pen \", \"applepen \"]",
                "\"catsandog \", [ \"cats \", \"dog \", \"sand \", \"and \", \"cat \", \"catsandog \"]",
                "\"programming \", [ \"program \", \"programming \", \"programming \"]",
                "\"algorithm \", [ \"algo \", \"rithm \", \"algorithm \"]"
            ],
            "outputs": [
                "true",
                "true",
                "false",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true"
            ]
        }
    },
    {
        "title": "Sentence Construction",
        "description": "Given a string `s` and a dictionary of strings `wordDict`, add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order. Note that the same word in the dictionary may be reused multiple times in the segmentation.",
        "example": "Example 1:\n\nInput: s = \"catsanddog \", wordDict = [ \"cat \", \"cats \", \"and \", \"sand \", \"dog \"]\nOutput: [ \"cats and dog \", \"cat sand dog \"]\n\nExample 2:\n\nInput: s = \"pineapplepenapple \", wordDict = [ \"apple \", \"pen \", \"applepen \", \"pine \", \"pineapple \"]\nOutput: [ \"pine apple pen apple \", \"pineapple pen apple \", \"pine applepen apple \"]\nExplanation: Note that you are allowed to reuse a dictionary word.\n\nExample 3:\n\nInput: s = \"catsandog \", wordDict = [ \"cats \", \"dog \", \"sand \", \"and \", \"cat \"]\nOutput: []",
        "level": "Medium",
        "tags": [
            "string",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                "\"catsanddog \", [ \"cat \", \"cats \", \"and \", \"sand \", \"dog \"]",
                "\"pineapplepenapple \", [ \"apple \", \"pen \", \"applepen \", \"pine \", \"pineapple \"]",
                "\"catsandog \", [ \"cats \", \"dog \", \"sand \", \"and \", \"cat \"]",
                "\"iloveleetcode \", [ \"i \", \"love \", \"leetcode \"]",
                "\"programmingisfun \", [ \"programming \", \"is \", \"fun \"]",
                "\"hellothere \", [ \"hello \", \"there \"]",
                "\"thisisatest \", [ \"this \", \"is \", \"a \", \"test \"]",
                "\"onetwothree \", [ \"one \", \"two \", \"three \"]",
                "\"abcde \", [ \"a \", \"b \", \"c \", \"d \", \"e \"]",
                "\"xyz \", [ \"x \", \"y \", \"z \"]"
            ],
            "outputs": [
                "[ \"cats and dog \", \"cat sand dog \"]",
                "[ \"pine apple pen apple \", \"pineapple pen apple \", \"pine applepen apple \"]",
                "[]",
                "[ \"i love leetcode \"]",
                "[ \"programming is fun \"]",
                "[ \"hello there \"]",
                "[ \"this is a test \"]",
                "[ \"one two three \"]",
                "[ \"a b c d e \"]",
                "[ \"x y z \"]"
            ]
        }
    },
    {
        "title": "Linked List Cycle",
        "description": "Given the head of a linked list, determine if the linked list has a cycle in it. A cycle exists if there is a node in the list that can be reached again by continuously following the next pointer. The tail's next pointer is connected to a node at a specific index denoted by `pos`. Return true if there is a cycle in the linked list, otherwise return false.",
        "example": "Example 1:\n\nInput: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n\nExample 2:\n\nInput: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.\n\nExample 3:\n\nInput: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list.",
        "level": "Easy",
        "tags": [
            "Linked List",
            "Cycle Detection"
        ],
        "test_cases": {
            "inputs": [
                "[3,2,0,-4]",
                "[1,2]",
                "[1]",
                "[]",
                "[1,2,3,4,5]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]"
            ],
            "outputs": [
                "true",
                "true",
                "false",
                "false",
                "false",
                "false",
                "false",
                "false",
                "false",
                "false"
            ]
        }
    },
    {
        "title": "Linked List Cycle",
        "description": "Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail`s next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.\n\nDo not modify the linked list.",
        "example": "Example 1:\n\nInput: head = [3,2,0,-4], pos = 1\nOutput: tail connects to node index 1\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\n\nExample 2:\n\nInput: head = [1,2], pos = 0\nOutput: tail connects to node index 0\nExplanation: There is a cycle in the linked list, where tail connects to the first node.\n\nExample 3:\n\nInput: head = [1], pos = -1\nOutput: no cycle\nExplanation: There is no cycle in the linked list.",
        "level": "Medium",
        "tags": [
            "Linked List",
            "Cycle Detection"
        ],
        "test_cases": {
            "inputs": [
                "[3,2,0,-4]",
                "[1,2]",
                "[1]",
                "[1,2,3,4,5]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60]"
            ],
            "outputs": [
                "tail connects to node index 1",
                "tail connects to node index 0",
                "no cycle",
                "no cycle",
                "no cycle",
                "no cycle",
                "no cycle",
                "no cycle",
                "no cycle",
                "no cycle"
            ]
        }
    },
    {
        "title": "Reorder Linked List",
        "description": "Given the head of a singly linked-list, reorder the list to be on the following form: L0 -> Ln -> L1 -> Ln-1 -> L2 -> Ln-2 -> ... You may not modify the values in the list's nodes. Only nodes themselves may be changed.",
        "example": "Example 1:\n\nInput: head = [1,2,3,4]\nOutput: [1,4,2,3]\n\nExample 2:\n\nInput: head = [1,2,3,4,5]\nOutput: [1,5,2,4,3]",
        "level": "Medium",
        "tags": [
            "linked list"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3,4]",
                "[1,2,3,4,5]",
                "[1]",
                "[1,2]",
                "[1,2,3]",
                "[1,2,3,4,5,6]",
                "[1,2,3,4,5,6,7]",
                "[1,2,3,4,5,6,7,8]",
                "[1,2,3,4,5,6,7,8,9]",
                "[1,2,3,4,5,6,7,8,9,10]"
            ],
            "outputs": [
                "[1,4,2,3]",
                "[1,5,2,4,3]",
                "[1]",
                "[1,2]",
                "[1,3,2]",
                "[1,6,2,5,3,4]",
                "[1,7,2,6,3,5,4]",
                "[1,8,2,7,3,6,4,5]",
                "[1,9,2,8,3,7,4,6,5]",
                "[1,10,2,9,3,8,4,7,5,6]"
            ]
        }
    },
    null,
    {
        "title": "Binary Tree Postorder Traversal",
        "description": "Given the root of a binary tree, return the postorder traversal of its nodes' values.",
        "example": "Example 1:\n\nInput: root = [1,null,2,3]\nOutput: [3,2,1]\n\nExample 2:\n\nInput: root = []\nOutput: []\n\nExample 3:\n\nInput: root = [1]\nOutput: [1]",
        "level": "Medium",
        "tags": [
            "binary tree",
            "traversal",
            "postorder"
        ],
        "test_cases": {
            "inputs": [
                "[1,null,2,3]",
                "[]",
                "[1]",
                "[1,2,3,4,5]",
                "[5,4,3,2,1]",
                "[1,2,null,3,null,4,null,5]",
                "[5,null,4,null,3,null,2,1]",
                "[1,2,3,4,null,null,5,null,null,6,null,null]",
                "[6,null,null,5,null,null,4,null,null,3,null,null,2,1]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]"
            ],
            "outputs": [
                "[3,2,1]",
                "[]",
                "[1]",
                "[4,5,2,3,1]",
                "[1,2,3,4,5]",
                "[3,4,2,5,1]",
                "[5,4,3,2,1]",
                "[4,5,2,6,3,7,1]",
                "[6,5,4,3,2,1]",
                "[100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]"
            ]
        }
    },
    {
        "title": "LRU Cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class with the following methods:\n\n- `LRUCache(int capacity)`: Initialize the LRU cache with a positive size `capacity`.\n- `int get(int key)`: Return the value of the `key` if it exists in the cache, otherwise return -1.\n- `void put(int key, int value)`: Update the value of the `key` if it exists in the cache. Otherwise, add the `key-value` pair to the cache. If the number of keys exceeds the `capacity`, evict the least recently used key.\n\nThe `get` and `put` methods must each run in O(1) average time complexity.",
        "example": "Example:\n\nInput:\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n\nOutput:\nnull, null, null, 1, null, -1, null, -1, 3, 4",
        "level": "Medium",
        "tags": [
            "Data Structure",
            "Cache"
        ],
        "test_cases": {
            "inputs": [
                "[2]",
                "[1, 1]",
                "[2, 2]",
                "[1]",
                "[3, 3]",
                "[2]",
                "[4, 4]",
                "[1]",
                "[3]",
                "[4]"
            ],
            "outputs": [
                "null",
                "null",
                "null",
                "1",
                "null",
                "-1",
                "null",
                "-1",
                "3",
                "4"
            ]
        }
    },
    {
        "title": "Insertion Sort Linked List",
        "description": "Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head.",
        "example": "Example 1:\n\nInput: head = [4,2,1,3]\nOutput: [1,2,3,4]\n\nExample 2:\n\nInput: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]",
        "level": "Medium",
        "tags": [
            "linked list",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "[4,2,1,3]",
                "[-1,5,3,4,0]",
                "[1]",
                "[3,2,1]",
                "[5,4,3,2,1]",
                "[1,2,3,4,5]",
                "[-1,-2,-3,-4,-5]",
                "[0,0,0,0,0]",
                "[1,1,1,1,1]",
                "[5,4,3,2,1,0,-1,-2,-3,-4,-5]"
            ],
            "outputs": [
                "[1,2,3,4]",
                "[-1,0,3,4,5]",
                "[1]",
                "[1,2,3]",
                "[1,2,3,4,5]",
                "[1,1,1,1,1]",
                "[-5,-4,-3,-2,-1]",
                "[0,0,0,0,0]",
                "[1,1,1,1,1]",
                "[-5,-4,-3,-2,-1,0,1,2,3,4,5]"
            ]
        }
    },
    {
        "title": "Sort Linked List",
        "description": "Given the head of a linked list, return the list after sorting it in ascending order.",
        "example": "Example 1:\n\nInput: head = [4,2,1,3]\nOutput: [1,2,3,4]\n\nExample 2:\n\nInput: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]\n\nExample 3:\n\nInput: head = []\nOutput: []",
        "level": "Medium",
        "tags": [
            "linked list",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "[4,2,1,3]",
                "[-1,5,3,4,0]",
                "[]",
                "[1]",
                "[5,4,3,2,1]",
                "[1,2,3,4,5]",
                "[9,8,7,6,5,4,3,2,1]",
                "[-5,-10,0,5,10]",
                "[1,1,1,1,1]",
                "[2,1,4,3,6,5,8,7,10,9]"
            ],
            "outputs": [
                "[1,2,3,4]",
                "[-1,0,3,4,5]",
                "[]",
                "[1]",
                "[1,2,3,4,5]",
                "[1,2,3,4,5]",
                "[1,2,3,4,5,6,7,8,9]",
                "[-10,-5,0,5,10]",
                "[1,1,1,1,1]",
                "[1,2,3,4,5,6,7,8,9,10]"
            ]
        }
    },
    {
        "title": "Maximum Points on a Straight Line",
        "description": "Given an array of points on the X-Y plane, find the maximum number of points that lie on the same straight line.",
        "example": "Example 1:\n\nInput: points = [[1,1],[2,2],[3,3]]\nOutput: 3\n\nExample 2:\n\nInput: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4",
        "level": "Medium",
        "tags": [
            "array",
            "math"
        ],
        "test_cases": {
            "inputs": [
                "[[1,1],[2,2],[3,3]]",
                "[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]",
                "[[1,1],[2,2],[3,3],[4,4],[5,5]]",
                "[[1,1],[2,2],[3,3],[4,4],[5,5],[6,6],[7,7]]",
                "[[1,1],[2,2],[3,3],[4,4],[5,5],[6,6],[7,7],[8,8]]",
                "[[1,1],[2,2],[3,3],[4,4],[5,5],[6,6],[7,7],[8,8],[9,9]]",
                "[[1,1],[2,2],[3,3],[4,4],[5,5],[6,6],[7,7],[8,8],[9,9],[10,10]]",
                "[[1,1],[2,2],[3,3],[4,4],[5,5],[6,6],[7,7],[8,8],[9,9],[10,10],[11,11]]",
                "[[1,1],[2,2],[3,3],[4,4],[5,5],[6,6],[7,7],[8,8],[9,9],[10,10],[11,11],[12,12]]",
                "[[1,1],[2,2],[3,3],[4,4],[5,5],[6,6],[7,7],[8,8],[9,9],[10,10],[11,11],[12,12],[13,13]]"
            ],
            "outputs": [
                "3",
                "4",
                "5",
                "7",
                "8",
                "9",
                "10",
                "11",
                "12",
                "13"
            ]
        }
    },
    null,
    null,
    {
        "title": "Largest Product Subarray",
        "description": "Given an integer array `nums`, find a subarray that has the largest product, and return the product.",
        "example": "Example 1:\n\nInput: nums = [2,3,-2,4]\nOutput: 6\nExplanation: [2,3] has the largest product 6.",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                "[2,3,-2,4]",
                "[-2,0,-1]",
                "[1,2,3,4,5]",
                "[-1,-2,-3,-4,-5]",
                "[0,0,0,0,0]",
                "[1,2,3,0,4,5]",
                "[1,2,3,0,4,5,0]",
                "[1,2,3,0,4,5,0,6]",
                "[1,2,3,0,4,5,0,6,0]",
                "[1,2,3,0,4,5,0,6,0,7]"
            ],
            "outputs": [
                "6",
                "0",
                "120",
                "120",
                "0",
                "20",
                "20",
                "120",
                "120",
                "120"
            ]
        }
    },
    {
        "title": "Minimum Element in Rotated Sorted Array",
        "description": "Given a sorted rotated array of unique elements, find the minimum element in the array. The array is rotated between 1 and n times. Implement an algorithm that runs in O(log n) time.",
        "example": "Example:\n\nInput: [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.",
        "level": "Medium",
        "tags": [
            "array",
            "binary search"
        ],
        "test_cases": {
            "inputs": [
                "[3,4,5,1,2]",
                "[4,5,6,7,0,1,2]",
                "[11,13,15,17]",
                "[1,2,3,4,5]",
                "[5,4,3,2,1]",
                "[2,3,4,5,1]",
                "[1]",
                "[1,2]",
                "[2,1]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[10,9,8,7,6,5,4,3,2,1]"
            ],
            "outputs": [
                "1",
                "0",
                "11",
                "1",
                "1",
                "1",
                "1",
                "1",
                "1",
                "1",
                "1"
            ]
        }
    },
    null,
    null,
    null,
    {
        "title": "Read N Characters from File",
        "description": "You are given a file and a method `read4` that reads four consecutive characters from the file and writes them into the buffer array `buf4`. Implement a method `read` that reads `n` characters from the file and stores them in the buffer array `buf`. You cannot directly manipulate the file, and the `read` function will only be called once for each test case. Return the number of actual characters read.",
        "example": "Example:\n\nInput: file = \"abcde\", n = 4\nOutput: 4\nExplanation: After calling your read method, buf should contain \"abcd\". We read a total of 4 characters from the file, so return 4.",
        "level": "Medium",
        "tags": [
            "file",
            "buffer",
            "read4"
        ],
        "test_cases": {
            "inputs": [
                "\"abcde\", 4",
                "\"abcde\", 5",
                "\"abcdABCD1234\", 12",
                "\"Hello World!\", 10",
                "\"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\", 30",
                "\"1234567890\", 5",
                "\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\", 50",
                "\"This is a test file.\", 20",
                "\"Testing 1, 2, 3...\", 15",
                "\"The quick brown fox jumps over the lazy dog.\", 40"
            ],
            "outputs": [
                "4",
                "5",
                "12",
                "10",
                "30",
                "5",
                "50",
                "20",
                "15",
                "40"
            ]
        }
    },
    {
        "title": "Read N Characters Given Read4",
        "description": "You are given a file and a method `read4` that reads four consecutive characters from the file and writes them into a buffer array. Implement a method `read` to read `n` characters from the file using the `read4` method. The `read` method may be called multiple times. You cannot manipulate the file directly, and the destination buffer array `buf` is guaranteed to have enough space for storing `n` characters.",
        "example": "Given the file `abcde `, the `read4` method will read four characters at a time. For example, after calling `read4(buf4)`, the buffer array `buf4` will contain `abcd`, and the file pointer will point to the character `e`. Implement the `read` method to read `n` characters from the file and store them in the buffer array `buf`. The return value should be the number of actual characters read.\n\nFile file = new File(`abcde `);\nchar[] buf = new char[4];\nread4(buf); // returns 4, buf = `abcd`\nread4(buf); // returns 1, buf = `e`\nread4(buf); // returns 0, buf = ``\n\nread(buf, 1); // After calling your read method, buf should contain `a`. Return 1.\nread(buf, 2); // After calling your read method, buf should contain `bc`. Return 2.\nread(buf, 1); // After calling your read method, buf should contain `d`. Return 1.\nread(buf, 4); // After calling your read method, buf should contain `e`. Return 1.\nread(buf, 1); // After calling your read method, buf should contain ``. Return 0.",
        "level": "Medium",
        "tags": [
            "string",
            "file",
            "buffer"
        ],
        "test_cases": {
            "inputs": [
                "\"abcde \"",
                "[1, 2, 1]",
                "\"abcde \"",
                "[4, 1]",
                "\"abcdefghij \"",
                "[1, 2, 3, 4]",
                "\"abcdefghij \"",
                "[10, 1, 1, 1, 1, 1, 1, 1, 1, 1]",
                "\"abcdefghijklmnopqrstuvwxyz \"",
                "[26, 26, 26, 26, 26, 26, 26, 26, 26, 26]",
                "\"abcdefghijklmnopqrstuvwxyz \"",
                "[27, 27, 27, 27, 27, 27, 27, 27, 27, 27]",
                "\"abcdefghijklmnopqrstuvwxyz \"",
                "[30, 30, 30, 30, 30, 30, 30, 30, 30, 30]",
                "\"abcdefghijklmnopqrstuvwxyz \"",
                "[40, 40, 40, 40, 40, 40, 40, 40, 40, 40]"
            ],
            "outputs": [
                "[1, 2, 0]",
                "[3, 0]",
                "[1, 2, 3, 4]",
                "[10, 1, 1, 1, 1, 1, 1, 1, 1, 1]",
                "[26, 26, 26, 26, 26, 26, 26, 26, 26, 26]",
                "[27, 27, 27, 27, 27, 27, 27, 27, 27, 27]",
                "[30, 30, 30, 30, 30, 30, 30, 30, 30, 30]",
                "[26, 26, 26, 26, 26, 26, 26, 26, 26, 26]",
                "[26, 26, 26, 26, 26, 26, 26, 26, 26, 26]",
                "[26, 26, 26, 26, 26, 26, 26, 26, 26, 26]"
            ]
        }
    },
    {
        "title": "Longest Substring with At Most Two Distinct Characters",
        "description": "Given a string `s`, find the length of the longest substring that contains at most two distinct characters. Return the length of the substring.",
        "example": "Example 1:\n\nInput: s = \"eceba\"\nOutput: 3\nExplanation: The longest substring with at most two distinct characters is \"ece\" with a length of 3.\n\nExample 2:\n\nInput: s = \"ccaabbb\"\nOutput: 5\nExplanation: The longest substring with at most two distinct characters is \"aabbb\" with a length of 5.",
        "level": "Medium",
        "tags": [
            "string",
            "sliding window",
            "two pointers"
        ],
        "test_cases": {
            "inputs": [
                "\"eceba\"",
                "\"ccaabbb\"",
                "\"abcabcabc\"",
                "\"aabbbccc\"",
                "\"aaaaaa\"",
                "\"abababab\"",
                "\"\"",
                "\"a\"",
                "\"aa\"",
                "\"aaa\""
            ],
            "outputs": [
                "3",
                "5",
                "9",
                "6",
                "6",
                "8",
                "0",
                "1",
                "2",
                "3"
            ]
        }
    },
    {
        "title": "Intersection of Two Linked Lists",
        "description": "Given the heads of two singly linked-lists `headA` and `headB`, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return `null`.\n\nThe linked lists must retain their original structure after the function returns.\n\nCustom Judge:\n\nThe inputs to the judge are given as follows (your program is not given these inputs):\n\n- `intersectVal` - The value of the node where the intersection occurs. This is `0` if there is no intersected node.\n- `listA` - The first linked list.\n- `listB` - The second linked list.\n- `skipA` - The number of nodes to skip ahead in `listA` (starting from the head) to get to the intersected node.\n- `skipB` - The number of nodes to skip ahead in `listB` (starting from the head) to get to the intersected node.\n\nThe judge will then create the linked structure based on these inputs and pass the two heads, `headA` and `headB` to your program. If you correctly return the intersected node, then your solution will be accepted.",
        "example": "Example 1:\n\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\nOutput: Intersected at '8'\nExplanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n\nExample 2:\n\nInput: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\nOutput: Intersected at '2'\nExplanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\n\nExample 3:\n\nInput: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\nOutput: No intersection\nExplanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.",
        "level": "Medium",
        "tags": [
            "Linked List"
        ],
        "test_cases": {
            "inputs": [
                {
                    "intersectVal": 8,
                    "listA": [
                        4,
                        1,
                        8,
                        4,
                        5
                    ],
                    "listB": [
                        5,
                        6,
                        1,
                        8,
                        4,
                        5
                    ],
                    "skipA": 2,
                    "skipB": 3
                },
                {
                    "intersectVal": 2,
                    "listA": [
                        1,
                        9,
                        1,
                        2,
                        4
                    ],
                    "listB": [
                        3,
                        2,
                        4
                    ],
                    "skipA": 3,
                    "skipB": 1
                },
                {
                    "intersectVal": 0,
                    "listA": [
                        2,
                        6,
                        4
                    ],
                    "listB": [
                        1,
                        5
                    ],
                    "skipA": 3,
                    "skipB": 2
                },
                {
                    "intersectVal": 0,
                    "listA": [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    "listB": [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    "skipA": 0,
                    "skipB": 0
                },
                {
                    "intersectVal": 5,
                    "listA": [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    "listB": [
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    "skipA": 4,
                    "skipB": 0
                },
                {
                    "intersectVal": 0,
                    "listA": [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    "listB": [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    "skipA": 4,
                    "skipB": 4
                },
                {
                    "intersectVal": 3,
                    "listA": [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    "listB": [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    "skipA": 2,
                    "skipB": 1
                },
                {
                    "intersectVal": 0,
                    "listA": [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    "listB": [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    "skipA": 5,
                    "skipB": 5
                },
                {
                    "intersectVal": 0,
                    "listA": [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    "listB": [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    "skipA": 0,
                    "skipB": 5
                },
                {
                    "intersectVal": 0,
                    "listA": [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    "listB": [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    "skipA": 5,
                    "skipB": 0
                }
            ],
            "outputs": [
                "Intersected at '8'",
                "Intersected at '2'",
                "No intersection",
                "No intersection",
                "Intersected at '5'",
                "No intersection",
                "Intersected at '3'",
                "No intersection",
                "No intersection",
                "No intersection"
            ]
        }
    },
    {
        "title": "One Edit Distance",
        "description": "Given two strings `s` and `t`, return `true` if they are both one edit distance apart, otherwise return `false`. A string `s` is said to be one distance apart from a string `t` if you can:\n\n- Insert **exactly one** character into `s` to get `t`.\n- Delete **exactly one** character from `s` to get `t`.\n- Replace **exactly one** character of `s` with **a different character** to get `t`.",
        "example": "Example 1:\n\nInput: s = \"ab\", t = \"acb\"\nOutput: true\nExplanation: We can insert 'c' into s to get t.\n\nExample 2:\n\nInput: s = \"\", t = \"\"\nOutput: false\nExplanation: We cannot get t from s by only one step.",
        "level": "Easy",
        "tags": [
            "string",
            "editing"
        ],
        "test_cases": {
            "inputs": [
                "\"ab\", \"acb\"",
                "\"\", \"\"",
                "\"abc\", \"ab\"",
                "\"abc\", \"abcd\"",
                "\"abc\", \"ac\"",
                "\"abc\", \"bc\"",
                "\"abc\", \"abdc\"",
                "\"abc\", \"abec\"",
                "\"abc\", \"abf\"",
                "\"abc\", \"abg\"",
                "\"abc\", \"abhc\""
            ],
            "outputs": [
                "true",
                "false",
                "true",
                "true",
                "true",
                "true",
                "false",
                "false",
                "false",
                "false",
                "false"
            ]
        }
    },
    {
        "title": "Peak Element",
        "description": "Given a 0-indexed integer array `nums`, find a peak element and return its index. A peak element is an element that is strictly greater than its neighbors. If the array contains multiple peaks, return the index to any of the peaks. You may imagine that `nums[-1] = nums[n] = -\u221e`. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Write an algorithm that runs in O(log n) time.",
        "example": "Example 1:\n\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.\n\nExample 2:\n\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.",
        "level": "Medium",
        "tags": [
            "array",
            "binary search"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3,1]",
                "[1,2,1,3,5,6,4]",
                "[1,2,3,4,5]",
                "[5,4,3,2,1]",
                "[1]",
                "[1,2]",
                "[2,1]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[10,9,8,7,6,5,4,3,2,1]"
            ],
            "outputs": [
                "2",
                "1",
                "4",
                "0",
                "0",
                "1",
                "0",
                "9",
                "0"
            ]
        }
    },
    null,
    {
        "title": "Maximum Successive Difference",
        "description": "Given an integer array `nums`, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\n\nYou must write an algorithm that runs in linear time and uses linear extra space.",
        "example": "Example 1:\n\nInput: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.\n\nExample 2:\n\nInput: nums = [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0.",
        "level": "Easy",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "[3,6,9,1]",
                "[10]",
                "[5,5,5,5]",
                "[1,2,3,4,5]",
                "[5,4,3,2,1]",
                "[1,3,5,7,9]",
                "[9,7,5,3,1]",
                "[1,1,1,1,1]",
                "[1,10,100,1000]",
                "[1000,100,10,1]"
            ],
            "outputs": [
                "3",
                "0",
                "0",
                "1",
                "0",
                "2",
                "2",
                "0",
                "900",
                "900"
            ]
        }
    },
    {
        "title": "Compare Version Numbers",
        "description": "Given two version numbers, `version1` and `version2`, compare them. Version numbers consist of one or more revisions joined by a dot '.'. Each revision consists of digits and may contain leading zeros. Every revision contains at least one character. Revisions are 0-indexed from left to right, with the leftmost revision being revision 0, the next revision being revision 1, and so on. To compare version numbers, compare their revisions in left-to-right order. Revisions are compared using their integer value ignoring any leading zeros. This means that revisions `1` and `001` are considered equal. If a version number does not specify a revision at an index, then treat the revision as `0`. Return the following: If `version1 < version2`, return `-1`. If `version1 > version2`, return `1`. Otherwise, return `0`.",
        "example": "Example:\n\nInput: version1 = \"1.01\", version2 = \"1.001\"\nOutput: 0\nExplanation: Ignoring leading zeroes, both \"01\" and \"001\" represent the same integer \"1\".",
        "level": "Easy",
        "tags": [
            "string",
            "parsing"
        ],
        "test_cases": {
            "inputs": [
                "\"1.01\"",
                "\"1.001\"",
                "\"1.0\"",
                "\"1.0.0\"",
                "\"0.1\"",
                "\"1.1\"",
                "\"1.0.1\"",
                "\"1.0.2\"",
                "\"1.0.10\"",
                "\"1.0.20\"",
                "\"1.0.100\"",
                "\"1.0.200\"",
                "\"1.0.1000\"",
                "\"1.0.2000\"",
                "\"1.0.10000\"",
                "\"1.0.20000\"",
                "\"1.0.100000\"",
                "\"1.0.200000\"",
                "\"1.0.1000000\"",
                "\"1.0.2000000\""
            ],
            "outputs": [
                "0",
                "0",
                "0",
                "0",
                "-1",
                "-1",
                "1",
                "1",
                "-1",
                "-1",
                "-1",
                "-1",
                "-1",
                "-1",
                "-1",
                "-1",
                "-1",
                "-1",
                "-1",
                "-1"
            ]
        }
    },
    {
        "title": "Fraction to Recurring Decimal",
        "description": "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. If multiple answers are possible, return any of them.",
        "example": "Given numerator = 4 and denominator = 333, the fraction is 4/333. The decimal representation of this fraction is 0.(012), where the digits 012 repeat infinitely. Therefore, the expected output is '0.(012)'.",
        "level": "Medium",
        "tags": [
            "math",
            "string"
        ],
        "test_cases": {
            "inputs": [
                {
                    "numerator": 1,
                    "denominator": 2
                },
                {
                    "numerator": 2,
                    "denominator": 1
                },
                {
                    "numerator": 4,
                    "denominator": 333
                },
                {
                    "numerator": 1,
                    "denominator": 3
                },
                {
                    "numerator": 22,
                    "denominator": 7
                },
                {
                    "numerator": 0,
                    "denominator": 1
                },
                {
                    "numerator": -1,
                    "denominator": 2
                },
                {
                    "numerator": 1,
                    "denominator": -2
                },
                {
                    "numerator": -4,
                    "denominator": -333
                },
                {
                    "numerator": 123456789,
                    "denominator": 987654321
                }
            ],
            "outputs": [
                "0.5",
                "2",
                "0.(012)",
                "0.(3)",
                "3.(142857)",
                "0",
                "-0.5",
                "-0.5",
                "0.(0123456789)",
                "0.(1250468601)"
            ]
        }
    },
    {
        "title": "Two Sum II - Input array is sorted",
        "description": "Given a 1-indexed array of integers `numbers` that is already sorted in non-decreasing order, find two numbers such that they add up to a specific `target` number. Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 <= numbers.length`.\n\nReturn the indices of the two numbers, `index1` and `index2`, added by one as an integer array `[index1, index2]` of length 2.\n\nYour solution must use only constant extra space.",
        "example": "Example:\n\nInput: numbers = [2,7,11,15], target = 9\nOutput: [1,2]\nExplanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].",
        "level": "Easy",
        "tags": [
            "array",
            "two pointers"
        ],
        "test_cases": {
            "inputs": [
                "[2,7,11,15]",
                "[2,3,4]",
                "[-1,0]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[-5,-4,-3,-2,-1,0,1,2,3,4,5]",
                "[-10,-5,0,5,10,15,20,25,30,35,40]",
                "[1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,93,95,97,99]",
                "[-1000,-900,-800,-700,-600,-500,-400,-300,-200,-100,0,100,200,300,400,500,600,700,800,900,1000]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]",
                "[-1000,-999,-998,-997,-996,-995,-994,-993,-992,-991,-990,-989,-988,-987,-986,-985,-984,-983,-982,-981,-980,-979,-978,-977,-976,-975,-974,-973,-972,-971,-970,-969,-968,-967,-966,-965,-964,-963,-962,-961,-960,-959,-958,-957,-956,-955,-954,-953,-952,-951,-950,-949,-948,-947,-946,-945,-944,-943,-942,-941,-940,-939,-938,-937,-936,-935,-934,-933,-932,-931,-930,-929,-928,-927,-926,-925,-924,-923,-922,-921,-920,-919,-918,-917,-916,-915,-914,-913,-912,-911,-910]",
                "[-1000,-999,-998,-997,-996,-995,-994,-993,-992,-991,-990,-989,-988,-987,-986,-985,-984,-983,-982,-981,-980,-979,-978,-977,-976,-975,-974,-973,-972,-971,-970,-969,-968,-967,-966,-965,-964,-963,-962,-961,-960,-959,-958,-957,-956,-955,-954,-953,-952,-951,-950,-949,-948,-947,-946,-945,-944,-943,-942,-941,-940,-939,-938,-937,-936,-935,-934,-933,-932,-931,-930,-929,-928,-927,-926,-925,-924,-923,-922,-921,-920,-919,-918,-917,-916,-915,-914,-913,-912,-911,-910]",
                "[-1000,-999,-998,-997,-996,-995,-994,-993,-992,-991,-990,-989,-988,-987,-986,-985,-984,-983,-982,-981,-980,-979,-978,-977,-976,-975,-974,-973,-972,-971,-970,-969,-968,-967,-966,-965,-964,-963,-962,-961,-960,-959,-958,-957,-956,-955,-954,-953,-952,-951,-950,-949,-948,-947,-946,-945,-944,-943,-942,-941,-940,-939,-938,-937,-936,-935,-934,-933,-932,-931,-930,-929,-928,-927,-926,-925,-924,-923,-922,-921,-920,-919,-918,-917,-916,-915,-914,-913,-912,-911,-910]"
            ],
            "outputs": [
                "[1,2]",
                "[1,3]",
                "[1,2]",
                "[1,2]",
                "[5,6]",
                "[1,6]",
                "[1,2]",
                "[1,11]",
                "[1,11]",
                "[1,11]"
            ]
        }
    },
    {
        "title": "Excel Column Title",
        "description": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.",
        "example": "For example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28\n\nExample 1:\n\nInput: columnNumber = 1\nOutput: \"A\"\n\nExample 2:\n\nInput: columnNumber = 28\nOutput: \"AB\"\n\nExample 3:\n\nInput: columnNumber = 701\nOutput: \"ZY\"",
        "level": "Easy",
        "tags": [
            "math"
        ],
        "test_cases": {
            "inputs": [
                1,
                28,
                701,
                52,
                100,
                26,
                27,
                1000,
                1234,
                456789
            ],
            "outputs": [
                "A",
                "AB",
                "ZY",
                "AZ",
                "CV",
                "Z",
                "AA",
                "ALL",
                "AUL",
                "MPK"
            ]
        }
    },
    null,
    null,
    null,
    {
        "title": "Trailing Zeroes in Factorial",
        "description": "Given an integer `n`, return the number of trailing zeroes in `n!`. The factorial of a number `n` is the product of all positive integers less than or equal to `n`. For example, `5! = 5 * 4 * 3 * 2 * 1 = 120`. A trailing zero is a zero at the end of a number. For example, `120` has one trailing zero. Write a function `trailingZeroes` to solve this problem.",
        "example": "Example 1:\n\nInput: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.\n\nExample 2:\n\nInput: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.\n\nExample 3:\n\nInput: n = 0\nOutput: 0",
        "level": "Easy",
        "tags": [
            "math",
            "factorial"
        ],
        "test_cases": {
            "inputs": [
                "3",
                "5",
                "0",
                "1",
                "10",
                "15",
                "20",
                "25",
                "30",
                "50"
            ],
            "outputs": [
                "0",
                "1",
                "0",
                "0",
                "2",
                "3",
                "4",
                "6",
                "7",
                "12"
            ]
        }
    },
    null,
    {
        "title": "Knight's Minimum Initial Health",
        "description": "The demons have captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers). To reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Return the knight's minimum initial health so that he can rescue the princess.",
        "example": "Example:\n\nInput: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]\nOutput: 7\nExplanation: The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.",
        "level": "Medium",
        "tags": [
            "dynamic programming",
            "grid"
        ],
        "test_cases": {
            "inputs": [
                "[[-2,-3,3],[-5,-10,1],[10,30,-5]]",
                "[[0]]",
                "[[1,2,3],[-4,-5,-6],[7,8,9]]",
                "[[-1,2,3],[4,-5,6],[7,8,-9]]",
                "[[0,0,0],[0,0,0],[0,0,0]]",
                "[[1,1,1],[1,1,1],[1,1,1]]",
                "[[-1,-1,-1],[-1,-1,-1],[-1,-1,-1]]",
                "[[1,1,1],[-1,-1,-1],[-1,-1,-1]]",
                "[[-1,-1,-1],[1,1,1],[-1,-1,-1]]",
                "[[-1,-1,-1],[-1,-1,-1],[1,1,1]]"
            ],
            "outputs": [
                "7",
                "1",
                "1",
                "2",
                "1",
                "1",
                "4",
                "2",
                "2",
                "2"
            ]
        }
    },
    {
        "title": "Largest Number Formation",
        "description": "Given a list of non-negative integers `nums`, arrange them in a way that forms the largest number and return it as a string.",
        "example": "Example 1:\n\nInput: nums = [10,2]\nOutput: \"210\"\n\nExample 2:\n\nInput: nums = [3,30,34,5,9]\nOutput: \"9534330\"",
        "level": "Medium",
        "tags": [
            "sorting",
            "string"
        ],
        "test_cases": {
            "inputs": [
                "[10,2]",
                "[3,30,34,5,9]",
                "[1,2,3,4,5]",
                "[9,8,7,6,5]",
                "[0,0,0,0,0]",
                "[100,20,3,400,5]",
                "[999,888,777,666,555]",
                "[123,321,456,654,789]",
                "[11,111,1111,11111,111111]",
                "[9,99,999,9999,99999]"
            ],
            "outputs": [
                "\"210\"",
                "\"9534330\"",
                "\"54321\"",
                "\"98765\"",
                "\"0\"",
                "\"54321003\"",
                "\"999888777666555\"",
                "\"789654321\"",
                "\"11111111111111111111\"",
                "\"99999999999999999999\""
            ]
        }
    },
    {
        "title": "Reverse Words in Character Array",
        "description": "Given a character array `s`, reverse the order of the words. A word is defined as a sequence of non-space characters. The words in `s` will be separated by a single space. Your code must solve the problem in-place, i.e. without allocating extra space.",
        "example": "Example 1:\n\nInput: s = [\"t\",\"h\",\"e\",\" \",\"s\",\"k\",\"y\",\" \",\"i\",\"s\",\" \",\"b\",\"l\",\"u\",\"e\"]\nOutput: [\"b\",\"l\",\"u\",\"e\",\" \",\"i\",\"s\",\" \",\"s\",\"k\",\"y\",\" \",\"t\",\"h\",\"e\"]\n\nExample 2:\n\nInput: s = [\"a\"]\nOutput: [\"a\"]",
        "level": "Easy",
        "tags": [
            "array",
            "string"
        ],
        "test_cases": {
            "inputs": [
                "[\"t\",\"h\",\"e\",\" \",\"s\",\"k\",\"y\",\" \",\"i\",\"s\",\" \",\"b\",\"l\",\"u\",\"e\"]",
                "[\"a\"]",
                "[\"h\",\"e\",\"l\",\"l\",\"o\",\" \",\"w\",\"o\",\"r\",\"l\",\"d\"]",
                "[\"c\",\"o\",\"d\",\"i\",\"n\",\"g\",\" \",\"i\",\"s\",\" \",\"f\",\"u\",\"n\"]",
                "[\"r\",\"e\",\"v\",\"e\",\"r\",\"s\",\"e\",\" \",\"m\",\"e\"]",
                "[\"p\",\"r\",\"o\",\"g\",\"r\",\"a\",\"m\",\"m\",\"i\",\"n\",\"g\",\" \",\"i\",\"s\",\" \",\"a\",\"w\",\"e\",\"s\",\"o\",\"m\",\"e\"]",
                "[\"l\",\"e\",\"a\",\"r\",\"n\",\"i\",\"n\",\"g\",\" \",\"i\",\"s\",\" \",\"f\",\"u\",\"n\"]",
                "[\"c\",\"o\",\"d\",\"e\",\" \",\"c\",\"h\",\"a\",\"l\",\"l\",\"e\",\"n\",\"g\",\"e\"]",
                "[\"h\",\"a\",\"p\",\"p\",\"y\",\" \",\"c\",\"o\",\"d\",\"i\",\"n\",\"g\"]",
                "[\"p\",\"r\",\"o\",\"b\",\"l\",\"e\",\"m\",\" \",\"s\",\"o\",\"l\",\"v\",\"i\",\"n\",\"g\"]"
            ],
            "outputs": [
                "[\"b\",\"l\",\"u\",\"e\",\" \",\"i\",\"s\",\" \",\"s\",\"k\",\"y\",\" \",\"t\",\"h\",\"e\"]",
                "[\"a\"]",
                "[\"w\",\"o\",\"r\",\"l\",\"d\",\" \",\"h\",\"e\",\"l\",\"l\",\"o\"]",
                "[\"f\",\"u\",\"n\",\" \",\"i\",\"s\",\" \",\"c\",\"o\",\"d\",\"i\",\"n\",\"g\"]",
                "[\"m\",\"e\",\" \",\"r\",\"e\",\"v\",\"e\",\"r\",\"s\",\"e\"]",
                "[\"a\",\"w\",\"e\",\"s\",\"o\",\"m\",\"e\",\" \",\"i\",\"s\",\" \",\"p\",\"r\",\"o\",\"g\",\"r\",\"a\",\"m\",\"m\",\"i\",\"n\",\"g\"]",
                "[\"f\",\"u\",\"n\",\" \",\"i\",\"s\",\" \",\"l\",\"e\",\"a\",\"r\",\"n\",\"i\",\"n\",\"g\"]",
                "[\"c\",\"h\",\"a\",\"l\",\"l\",\"e\",\"n\",\"g\",\"e\",\" \",\"c\",\"o\",\"d\",\"e\"]",
                "[\"c\",\"o\",\"d\",\"i\",\"n\",\"g\",\" \",\"h\",\"a\",\"p\",\"p\",\"y\"]",
                "[\"s\",\"o\",\"l\",\"v\",\"i\",\"n\",\"g\",\" \",\"p\",\"r\",\"o\",\"b\",\"l\",\"e\",\"m\"]"
            ]
        }
    },
    null,
    {
        "title": "Maximum Profit with at most k Transactions",
        "description": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `k`. Find the maximum profit you can achieve by buying and selling stocks. You may complete at most `k` transactions, where each transaction consists of buying one stock and selling one stock. However, you may not engage in multiple transactions simultaneously, meaning you must sell the stock before you buy again.",
        "example": "Example:\n\nInput: k = 2, prices = [2,4,1]\nOutput: 2\nExplanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                {
                    "k": 2,
                    "prices": [
                        2,
                        4,
                        1
                    ]
                },
                {
                    "k": 2,
                    "prices": [
                        3,
                        2,
                        6,
                        5,
                        0,
                        3
                    ]
                },
                {
                    "k": 1,
                    "prices": [
                        7,
                        1,
                        5,
                        3,
                        6,
                        4
                    ]
                },
                {
                    "k": 3,
                    "prices": [
                        1,
                        2,
                        3,
                        4,
                        5
                    ]
                },
                {
                    "k": 0,
                    "prices": [
                        7,
                        6,
                        4,
                        3,
                        1
                    ]
                },
                {
                    "k": 2,
                    "prices": [
                        1,
                        2,
                        4,
                        2,
                        5,
                        7,
                        2,
                        4,
                        9,
                        0
                    ]
                },
                {
                    "k": 4,
                    "prices": [
                        3,
                        3,
                        5,
                        0,
                        0,
                        3,
                        1,
                        4
                    ]
                },
                {
                    "k": 1,
                    "prices": [
                        1
                    ]
                },
                {
                    "k": 2,
                    "prices": [
                        1,
                        2
                    ]
                },
                {
                    "k": 2,
                    "prices": [
                        2,
                        1
                    ]
                }
            ],
            "outputs": [
                2,
                7,
                5,
                4,
                0,
                13,
                6,
                0,
                1,
                0
            ]
        }
    },
    null,
    null,
    {
        "title": "Count the Number of '1' Bits",
        "description": "Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).",
        "example": "Example:\n\nInput: n = \"00000000000000000000000000001011\"\nOutput: 3\nExplanation: The input binary string \"00000000000000000000000000001011\" has a total of three '1' bits.",
        "level": "Easy",
        "tags": [
            "bit manipulation"
        ],
        "test_cases": {
            "inputs": [
                "\"00000000000000000000000000001011\"",
                "\"00000000000000000000000010000000\"",
                "\"11111111111111111111111111111101\"",
                "\"00000000000000000000000000000000\"",
                "\"11111111111111111111111111111111\"",
                "\"01010101010101010101010101010101\"",
                "\"10101010101010101010101010101010\"",
                "\"00000000000000000000000000000001\"",
                "\"00000000000000000000000000000010\"",
                "\"00000000000000000000000000000011\""
            ],
            "outputs": [
                "3",
                "1",
                "31",
                "0",
                "32",
                "16",
                "16",
                "1",
                "1",
                "2"
            ]
        }
    },
    {
        "title": "Transpose Text File",
        "description": "Given a text file `file.txt`, transpose its content. Each row in the file has the same number of columns, and each field is separated by a space character (' '). Transpose the rows and columns of the file.",
        "example": "Example:\n\nInput:\nfile.txt\n\nContent of file.txt:\nname age\nalice 21\nryan 30\n\nOutput:\nname alice ryan\nage 21 30\n\nExplanation: The content of the file is transposed, with each row becoming a column and each column becoming a row.",
        "level": "Easy",
        "tags": [
            "file",
            "transpose"
        ],
        "test_cases": {
            "inputs": [
                "file.txt",
                "file.txt",
                "file.txt",
                "file.txt",
                "file.txt",
                "file.txt",
                "file.txt",
                "file.txt",
                "file.txt",
                "file.txt"
            ],
            "outputs": [
                "name alice ryan\nage 21 30",
                "1 2 3\n4 5 6\n7 8 9",
                "a b c d\ne f g h\ni j k l",
                "hello world\nhow are you",
                "apple banana cherry\norange mango pineapple",
                "1 a\n2 b\n3 c\n4 d",
                "x y z\na b c\nd e f",
                "alpha beta gamma\ndelta epsilon zeta",
                "programming is fun\nlet's code",
                "this is a test\nfor transposing text"
            ]
        }
    },
    null,
    {
        "title": "Right Side View of Binary Tree",
        "description": "Given the root of a binary tree, imagine yourself standing on the right side of it. Return the values of the nodes you can see ordered from top to bottom.",
        "example": "Example 1:\n\nInput: root = [1,2,3,null,5,null,4]\nOutput: [1,3,4]\n\nExample 2:\n\nInput: root = [1,null,3]\nOutput: [1,3]\n\nExample 3:\n\nInput: root = []\nOutput: []",
        "level": "Medium",
        "tags": [
            "binary tree",
            "traversal"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3,null,5,null,4]",
                "[1,null,3]",
                "[]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]"
            ],
            "outputs": [
                "[1,3,4]",
                "[1,3]",
                "[]",
                "[1,3,7,15]",
                "[1,3,7,15,20]",
                "[1,3,7,15,20,25]",
                "[1,3,7,15,20,25,30]",
                "[1,3,7,15,20,25,30,40]",
                "[1,3,7,15,20,25,30,40,50]",
                "[1,3,7,15,20,25,30,40,50,60]",
                "[1,3,7,15,20,25,30,40,50,60,70]",
                "[1,3,7,15,20,25,30,40,50,60,70,80]",
                "[1,3,7,15,20,25,30,40,50,60,70,80,90]",
                "[1,3,7,15,20,25,30,40,50,60,70,80,90,100]"
            ]
        }
    },
    {
        "title": "Number of Islands",
        "description": "Given an m x n 2D binary grid, count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water.",
        "example": "Example 1:\n\nInput: grid = [\n  [\"1\", \"1\", \"1\", \"1\", \"0\"],\n  [\"1\", \"1\", \"0\", \"1\", \"0\"],\n  [\"1\", \"1\", \"0\", \"0\", \"0\"],\n  [\"0\", \"0\", \"0\", \"0\", \"0\"]\n]\nOutput: 1\n\nExample 2:\n\nInput: grid = [\n  [\"1\", \"1\", \"0\", \"0\", \"0\"],\n  [\"1\", \"1\", \"0\", \"0\", \"0\"],\n  [\"0\", \"0\", \"1\", \"0\", \"0\"],\n  [\"0\", \"0\", \"0\", \"1\", \"1\"]\n]\nOutput: 3",
        "level": "Medium",
        "tags": [
            "array",
            "graph",
            "DFS"
        ],
        "test_cases": {
            "inputs": [
                {
                    "grid": [
                        [
                            "1",
                            "1",
                            "1",
                            "1",
                            "0"
                        ],
                        [
                            "1",
                            "1",
                            "0",
                            "1",
                            "0"
                        ],
                        [
                            "1",
                            "1",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "0",
                            "0",
                            "0",
                            "0",
                            "0"
                        ]
                    ]
                },
                {
                    "grid": [
                        [
                            "1",
                            "1",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "1",
                            "1",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "0",
                            "0",
                            "1",
                            "0",
                            "0"
                        ],
                        [
                            "0",
                            "0",
                            "0",
                            "1",
                            "1"
                        ]
                    ]
                },
                {
                    "grid": [
                        [
                            "1",
                            "0",
                            "1",
                            "0",
                            "1"
                        ],
                        [
                            "0",
                            "1",
                            "0",
                            "1",
                            "0"
                        ],
                        [
                            "1",
                            "0",
                            "1",
                            "0",
                            "1"
                        ],
                        [
                            "0",
                            "1",
                            "0",
                            "1",
                            "0"
                        ]
                    ]
                },
                {
                    "grid": [
                        [
                            "1",
                            "1",
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "1",
                            "1",
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "1",
                            "1",
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "1",
                            "1",
                            "1",
                            "1",
                            "1"
                        ]
                    ]
                },
                {
                    "grid": [
                        [
                            "0",
                            "0",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "0",
                            "0",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "0",
                            "0",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "0",
                            "0",
                            "0",
                            "0",
                            "0"
                        ]
                    ]
                },
                {
                    "grid": [
                        [
                            "1",
                            "0",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "0",
                            "1",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "0",
                            "0",
                            "1",
                            "0",
                            "0"
                        ],
                        [
                            "0",
                            "0",
                            "0",
                            "1",
                            "0"
                        ]
                    ]
                },
                {
                    "grid": [
                        [
                            "1",
                            "1",
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "1",
                            "0",
                            "0",
                            "0",
                            "1"
                        ],
                        [
                            "1",
                            "0",
                            "1",
                            "0",
                            "1"
                        ],
                        [
                            "1",
                            "1",
                            "1",
                            "1",
                            "1"
                        ]
                    ]
                },
                {
                    "grid": [
                        [
                            "1",
                            "1",
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "1",
                            "0",
                            "0",
                            "0",
                            "1"
                        ],
                        [
                            "1",
                            "0",
                            "0",
                            "0",
                            "1"
                        ],
                        [
                            "1",
                            "1",
                            "1",
                            "1",
                            "1"
                        ]
                    ]
                },
                {
                    "grid": [
                        [
                            "1",
                            "1",
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "1",
                            "1",
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "1",
                            "1",
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "1",
                            "1",
                            "1",
                            "1",
                            "1"
                        ]
                    ]
                },
                {
                    "grid": [
                        [
                            "1",
                            "1",
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "1",
                            "1",
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "1",
                            "1",
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "1",
                            "1",
                            "1",
                            "1",
                            "0"
                        ]
                    ]
                }
            ],
            "outputs": [
                1,
                3,
                8,
                1,
                0,
                4,
                1,
                1,
                1,
                2
            ]
        }
    },
    {
        "title": "Bitwise AND of Numbers Range",
        "description": "Given two integers `left` and `right` that represent the range `[left, right]`, return the bitwise AND of all numbers in this range, inclusive.",
        "example": "Example 1:\n\nInput: left = 5, right = 7\nOutput: 4\n\nExample 2:\n\nInput: left = 0, right = 0\nOutput: 0\n\nExample 3:\n\nInput: left = 1, right = 2147483647\nOutput: 0",
        "level": "Medium",
        "tags": [
            "bit manipulation"
        ],
        "test_cases": {
            "inputs": [
                "5, 7",
                "0, 0",
                "1, 2147483647",
                "10, 15",
                "100, 100",
                "0, 1",
                "3, 3",
                "8, 10",
                "16, 20",
                "1000, 2000"
            ],
            "outputs": [
                "4",
                "0",
                "0",
                "8",
                "100",
                "0",
                "3",
                "8",
                "16",
                "0"
            ]
        }
    },
    {
        "title": "Happy Number",
        "description": "Write a function to determine if a number is a happy number.\n\nA happy number is a number defined by the following process:\n\n- Starting with any positive integer, replace the number by the sum of the squares of its digits.\n- Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\n- Those numbers for which this process ends in 1 are happy.\n\nImplement a function `isHappyNumber(n: int) -> bool` that returns `True` if `n` is a happy number, and `False` otherwise.",
        "example": "Example 1:\n\nInput: n = 19\nOutput: True\nExplanation:\n1^2 + 9^2 = 82\n8^2 + 2^2 = 68\n6^2 + 8^2 = 100\n1^2 + 0^2 + 0^2 = 1\n\nExample 2:\n\nInput: n = 2\nOutput: False",
        "level": "Easy",
        "tags": [
            "math",
            "recursion"
        ],
        "test_cases": {
            "inputs": "19\n2\n7\n10\n13\n20\n23\n28\n31\n32",
            "outputs": "True\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\nTrue\nFalse\nFalse"
        }
    },
    {
        "title": "Remove Nodes with Given Value",
        "description": "Given the head of a linked list and an integer val, remove all the nodes of the linked list that have Node.val == val, and return the new head.",
        "example": "Example 1:\n\nInput: head = [1,2,6,3,4,5,6], val = 6\nOutput: [1,2,3,4,5]\n\nExample 2:\n\nInput: head = [], val = 1\nOutput: []\n\nExample 3:\n\nInput: head = [7,7,7,7], val = 7\nOutput: []",
        "level": "Easy",
        "tags": [
            "linked list"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,6,3,4,5,6]",
                "[]",
                "[7,7,7,7]",
                "[1,1,1,1,1]",
                "[2,2,2,2,2]",
                "[3,3,3,3,3]",
                "[4,4,4,4,4]",
                "[5,5,5,5,5]",
                "[6,6,6,6,6]",
                "[1,2,3,4,5]"
            ],
            "outputs": [
                "[1,2,3,4,5]",
                "[]",
                "[]",
                "[]",
                "[]",
                "[]",
                "[]",
                "[]",
                "[]",
                "[1,2,3,4,5]"
            ]
        }
    },
    {
        "title": "Count Prime Numbers",
        "description": "Given an integer `n`, return the number of prime numbers that are strictly less than `n`.",
        "example": "Example 1:\n\nInput: n = 10\nOutput: 4\nExplanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.",
        "level": "Easy",
        "tags": [
            "Math",
            "Prime Numbers"
        ],
        "test_cases": {
            "inputs": [
                "10",
                "0",
                "1",
                "20",
                "100",
                "1000",
                "10000",
                "100000",
                "1000000",
                "5000000"
            ],
            "outputs": [
                "4",
                "0",
                "0",
                "8",
                "25",
                "168",
                "1229",
                "9592",
                "78498",
                "348513"
            ]
        }
    },
    {
        "title": "Isomorphic Strings",
        "description": "Given two strings `s` and `t`, determine if they are isomorphic. Two strings `s` and `t` are isomorphic if the characters in `s` can be replaced to get `t`. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.",
        "example": "Example 1:\n\nInput: s = \"egg\", t = \"add\"\nOutput: true\n\nExample 2:\n\nInput: s = \"foo\", t = \"bar\"\nOutput: false\n\nExample 3:\n\nInput: s = \"paper\", t = \"title\"\nOutput: true",
        "level": "Easy",
        "tags": [
            "string",
            "mapping"
        ],
        "test_cases": {
            "inputs": [
                "\"egg\", \"add\"",
                "\"foo\", \"bar\"",
                "\"paper\", \"title\"",
                "\"ab\", \"aa\"",
                "\"abcd\", \"aabb\"",
                "\"abc\", \"def\"",
                "\"abc\", \"cba\"",
                "\"abc\", \"ab\"",
                "\"abc\", \"abcd\"",
                "\"abc\", \"abcc\""
            ],
            "outputs": [
                "true",
                "false",
                "true",
                "false",
                "false",
                "true",
                "true",
                "false",
                "false",
                "false"
            ]
        }
    },
    null,
    null,
    null,
    null,
    {
        "title": "Course Ordering",
        "description": "You are given a total of `numCourses` courses labeled from `0` to `numCourses - 1`. The prerequisites for each course are given in the form of an array `prerequisites`, where `prerequisites[i] = [ai, bi]` indicates that course `bi` must be taken before course `ai`. Return the ordering of courses you should take to finish all courses. If it is impossible to finish all courses, return an empty array.",
        "example": "Example 1:\n\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: [0,1]\nExplanation: To take course 1, you must have finished course 0. So the correct course order is [0,1].\n\nExample 2:\n\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,2,1,3]\nExplanation: To take course 3, you must have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n\nExample 3:\n\nInput: numCourses = 1, prerequisites = []\nOutput: [0]\n\n",
        "level": "Medium",
        "tags": [
            "Graph",
            "Topological Sort"
        ],
        "test_cases": {
            "inputs": [
                {
                    "numCourses": 2,
                    "prerequisites": [
                        [
                            1,
                            0
                        ]
                    ]
                },
                {
                    "numCourses": 4,
                    "prerequisites": [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            3,
                            1
                        ],
                        [
                            3,
                            2
                        ]
                    ]
                },
                {
                    "numCourses": 1,
                    "prerequisites": []
                },
                {
                    "numCourses": 3,
                    "prerequisites": [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ]
                    ]
                },
                {
                    "numCourses": 5,
                    "prerequisites": [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ]
                    ]
                },
                {
                    "numCourses": 3,
                    "prerequisites": [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            0,
                            2
                        ]
                    ]
                },
                {
                    "numCourses": 2,
                    "prerequisites": [
                        [
                            1,
                            0
                        ],
                        [
                            0,
                            1
                        ]
                    ]
                },
                {
                    "numCourses": 4,
                    "prerequisites": [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            0,
                            3
                        ]
                    ]
                },
                {
                    "numCourses": 3,
                    "prerequisites": [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            1,
                            2
                        ]
                    ]
                },
                {
                    "numCourses": 5,
                    "prerequisites": [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            0,
                            4
                        ]
                    ]
                }
            ],
            "outputs": [
                [
                    0,
                    1
                ],
                [
                    0,
                    2,
                    1,
                    3
                ],
                [
                    0
                ],
                [
                    0,
                    1,
                    2
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4
                ],
                [],
                [],
                [],
                [],
                []
            ]
        }
    },
    {
        "title": "Word Dictionary",
        "description": "Design a data structure that supports adding new words and finding if a string matches any previously added string. Implement the `WordDictionary` class with the following methods:\n\n- `WordDictionary()`: Initializes the object.\n- `void addWord(word)`: Adds `word` to the data structure, it can be matched later.\n- `bool search(word)`: Returns `true` if there is any string in the data structure that matches `word` or `false` otherwise. `word` may contain dots `'.'` where dots can be matched with any letter.",
        "example": "Example:\n\nInput:\nwordDictionary = new WordDictionary()\nwordDictionary.addWord(\"bad\")\nwordDictionary.addWord(\"dad\")\nwordDictionary.addWord(\"mad\")\nwordDictionary.search(\"pad\")\nwordDictionary.search(\"bad\")\nwordDictionary.search(\".ad\")\nwordDictionary.search(\"b..\")\n\nOutput:\nnull\nnull\nnull\nfalse\ntrue\ntrue\ntrue\n\nExplanation:\nWordDictionary wordDictionary = new WordDictionary()\nwordDictionary.addWord(\"bad\")\nwordDictionary.addWord(\"dad\")\nwordDictionary.addWord(\"mad\")\nwordDictionary.search(\"pad\") // return False\nwordDictionary.search(\"bad\") // return True\nwordDictionary.search(\".ad\") // return True\nwordDictionary.search(\"b..\") // return True",
        "level": "Medium",
        "tags": [
            "Data Structure",
            "String",
            "Trie"
        ],
        "test_cases": {
            "inputs": [
                "[\"WordDictionary\", \"addWord\", \"addWord\", \"addWord\", \"search\", \"search\", \"search\", \"search\"]",
                "[[], [\"bad\"], [\"dad\"], [\"mad\"], [\"pad\"], [\"bad\"], [\".ad\"], [\"b..\"]]"
            ],
            "outputs": [
                "null",
                "null",
                "null",
                "null",
                "false",
                "true",
                "true",
                "true"
            ]
        }
    },
    {
        "title": "Word Search on Board",
        "description": "Given an m x n board of characters and a list of strings words, return all words on the board. Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.",
        "example": "Example 1:\n\nInput: board = [['o', 'a', 'a', 'n'], ['e', 't', 'a', 'e'], ['i', 'h', 'k', 'r'], ['i', 'f', 'l', 'v']], words = ['oath', 'pea', 'eat', 'rain']\nOutput: ['eat', 'oath']\n\nExample 2:\n\nInput: board = [['a', 'b'], ['c', 'd']], words = ['abcb']\nOutput: []",
        "level": "Medium",
        "tags": [
            "array",
            "backtracking"
        ],
        "test_cases": {
            "inputs": [
                {
                    "board": [
                        [
                            "o",
                            "a",
                            "a",
                            "n"
                        ],
                        [
                            "e",
                            "t",
                            "a",
                            "e"
                        ],
                        [
                            "i",
                            "h",
                            "k",
                            "r"
                        ],
                        [
                            "i",
                            "f",
                            "l",
                            "v"
                        ]
                    ],
                    "words": [
                        "oath",
                        "pea",
                        "eat",
                        "rain"
                    ]
                },
                {
                    "board": [
                        [
                            "a",
                            "b"
                        ],
                        [
                            "c",
                            "d"
                        ]
                    ],
                    "words": [
                        "abcb"
                    ]
                },
                {
                    "board": [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    "words": [
                        "abc",
                        "def",
                        "ghi"
                    ]
                },
                {
                    "board": [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    "words": [
                        "ace",
                        "bdf",
                        "ghi"
                    ]
                },
                {
                    "board": [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    "words": [
                        "abc",
                        "def",
                        "ghi",
                        "adg",
                        "beh",
                        "cfi"
                    ]
                },
                {
                    "board": [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    "words": [
                        "aaa",
                        "bbb",
                        "ccc"
                    ]
                },
                {
                    "board": [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    "words": [
                        "aaa",
                        "bbb",
                        "ccc",
                        "abc",
                        "def",
                        "ghi"
                    ]
                },
                {
                    "board": [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    "words": [
                        "aaa",
                        "bbb",
                        "ccc",
                        "abc",
                        "def",
                        "ghi",
                        "adg",
                        "beh",
                        "cfi"
                    ]
                },
                {
                    "board": [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    "words": [
                        "aaa",
                        "bbb",
                        "ccc",
                        "abc",
                        "def",
                        "ghi",
                        "adg",
                        "beh",
                        "cfi",
                        "aaa",
                        "bbb",
                        "ccc",
                        "abc",
                        "def",
                        "ghi",
                        "adg",
                        "beh",
                        "cfi"
                    ]
                },
                {
                    "board": [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    "words": [
                        "aaa",
                        "bbb",
                        "ccc",
                        "abc",
                        "def",
                        "ghi",
                        "adg",
                        "beh",
                        "cfi",
                        "aaa",
                        "bbb",
                        "ccc",
                        "abc",
                        "def",
                        "ghi",
                        "adg",
                        "beh",
                        "cfi",
                        "aaa",
                        "bbb",
                        "ccc",
                        "abc",
                        "def",
                        "ghi",
                        "adg",
                        "beh",
                        "cfi",
                        "aaa",
                        "bbb",
                        "ccc",
                        "abc",
                        "def",
                        "ghi",
                        "adg",
                        "beh",
                        "cfi"
                    ]
                }
            ],
            "outputs": [
                [
                    "eat",
                    "oath"
                ],
                [],
                [
                    "abc",
                    "def",
                    "ghi"
                ],
                [
                    "ace",
                    "bdf",
                    "ghi"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "adg",
                    "beh",
                    "cfi"
                ],
                [],
                [
                    "abc",
                    "def",
                    "ghi",
                    "adg",
                    "beh",
                    "cfi"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "adg",
                    "beh",
                    "cfi"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "adg",
                    "beh",
                    "cfi"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "adg",
                    "beh",
                    "cfi"
                ]
            ]
        }
    },
    null,
    {
        "title": "Shortest Palindrome",
        "description": "Given a string `s`, you can convert it to a palindrome by adding characters in front of it. Write a function that returns the shortest palindrome you can find by performing this transformation.",
        "example": "Example 1:\n\nInput: s = \"aacecaaa\"\nOutput: \"aaacecaaa\"\n\nExample 2:\n\nInput: s = \"abcd\"\nOutput: \"dcbabcd\"",
        "level": "Medium",
        "tags": [
            "string",
            "palindrome"
        ],
        "test_cases": {
            "inputs": [
                "\"aacecaaa\"",
                "\"abcd\"",
                "\"race\"",
                "\"level\"",
                "\"noon\"",
                "\"abcde\"",
                "\"madam\"",
                "\"radar\"",
                "\"stats\"",
                "\"deed\""
            ],
            "outputs": [
                "\"aaacecaaa\"",
                "\"dcbabcd\"",
                "\"ecarace\"",
                "\"level\"",
                "\"noon\"",
                "\"edcbabcde\"",
                "\"madam\"",
                "\"radar\"",
                "\"stats\"",
                "\"deed\""
            ]
        }
    },
    {
        "title": "Kth Largest Element in an Array",
        "description": "Given an integer array `nums` and an integer `k`, return the `kth` largest element in the array. Note that it is the `kth` largest element in the sorted order, not the `kth` distinct element. You must solve it in `O(n)` time complexity.",
        "example": "Example 1:\n\nInput: nums = [3,2,1,5,6,4], k = 2\nOutput: 5\n\nExample 2:\n\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4",
        "level": "Medium",
        "tags": [
            "Array",
            "Sorting"
        ],
        "test_cases": {
            "inputs": [
                "[3,2,1,5,6,4]",
                "[3,2,3,1,2,4,5,5,6]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[10,9,8,7,6,5,4,3,2,1]",
                "[-1,-2,-3,-4,-5]",
                "[5,5,5,5,5]",
                "[1]",
                "[-1]",
                "[0,0,0,0,0,0,0,0,0,0]",
                "[9,8,7,6,5,4,3,2,1,0]"
            ],
            "outputs": [
                "5",
                "4",
                "9",
                "1",
                "-3",
                "5",
                "1",
                "-1",
                "0",
                "0"
            ]
        }
    },
    {
        "title": "Valid Combinations of Numbers",
        "description": "Given a positive integer `k` and a target sum `n`, find all valid combinations of `k` numbers that sum up to `n`. The valid combinations must satisfy the following conditions: \n\n- Only numbers `1` through `9` can be used.\n- Each number can be used at most once.\n\nReturn a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.",
        "example": "Example 1:\n\nInput: k = 3, n = 7\nOutput: [[1,2,4]]\nExplanation: 1 + 2 + 4 = 7. There are no other valid combinations.\n\nExample 2:\n\nInput: k = 3, n = 9\nOutput: [[1,2,6],[1,3,5],[2,3,4]]\nExplanation: 1 + 2 + 6 = 9, 1 + 3 + 5 = 9, 2 + 3 + 4 = 9. There are no other valid combinations.\n\nExample 3:\n\nInput: k = 4, n = 1\nOutput: []\nExplanation: There are no valid combinations. Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combinations.",
        "level": "Medium",
        "tags": [
            "array",
            "backtracking"
        ],
        "test_cases": {
            "inputs": [
                "3, 7",
                "3, 9",
                "4, 1",
                "2, 5",
                "5, 15",
                "6, 30",
                "7, 45",
                "8, 60",
                "9, 45",
                "9, 55"
            ],
            "outputs": [
                "[[1,2,4]]",
                "[[1,2,6],[1,3,5],[2,3,4]]",
                "[]",
                "[[1,4]]",
                "[[1,2,3,4,5]]",
                "[[1,2,3,4,5,15]]",
                "[[1,2,3,4,5,6,24]]",
                "[[1,2,3,4,5,6,7,32]]",
                "[[1,2,3,4,5,6,7,8,9]]",
                "[[1,2,3,4,5,6,7,8,19],[1,2,3,4,5,6,7,9,18],[1,2,3,4,5,6,8,9,19],[1,2,3,4,5,7,8,9,20],[1,2,3,4,6,7,8,9,21],[1,2,3,5,6,7,8,9,22],[1,2,4,5,6,7,8,9,23],[1,3,4,5,6,7,8,9,24],[2,3,4,5,6,7,8,9,25],[3,4,5,6,7,8,9,10,19],[3,4,5,6,7,8,9,11,18],[3,4,5,6,7,8,10,11,19],[3,4,5,6,7,9,10,11,20],[3,4,5,6,8,9,10,11,21],[3,4,5,7,8,9,10,11,22],[3,4,6,7,8,9,10,11,23],[3,5,6,7,8,9,10,11,24],[4,5,6,7,8,9,10,11,25]]"
            ]
        }
    },
    {
        "title": "Duplicate Integer Check",
        "description": "Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.",
        "example": "Example 1:\n\nInput: nums = [1,2,3,1]\nOutput: true\n\nExample 2:\n\nInput: nums = [1,2,3,4]\nOutput: false\n\nExample 3:\n\nInput: nums = [1,1,1,3,3,4,3,2,4,2]\nOutput: true",
        "level": "Easy",
        "tags": [
            "array"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3,1]",
                "[1,2,3,4]",
                "[1,1,1,3,3,4,3,2,4,2]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,1,1,1,1,1,1,1,1,1]",
                "[1,2,3,4,5,6,7,8,9,10,1]",
                "[1,2,3,4,5,6,7,8,9,10,10]",
                "[1,2,3,4,5,6,7,8,9,10,10,10]",
                "[1,2,3,4,5,6,7,8,9,10,10,10,10]",
                "[1,2,3,4,5,6,7,8,9,10,10,10,10,10]"
            ],
            "outputs": [
                "true",
                "false",
                "true",
                "false",
                "false",
                "true",
                "true",
                "true",
                "true",
                "true"
            ]
        }
    },
    {
        "title": "Skyline Contour",
        "description": "A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.",
        "example": "Example 1:\n\nInput: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]\nOutput: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\nExplanation: Figure A shows the buildings of the input. Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.\n\nExample 2:\n\nInput: buildings = [[0,2,3],[2,5,3]]\nOutput: [[0,3],[5,0]]",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "[[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]",
                "[[0,2,3],[2,5,3]]",
                "[[1,5,7],[3,8,9],[6,10,5],[9,12,8]]",
                "[[0,3,5],[2,6,8],[4,9,6],[7,12,10]]",
                "[[1,4,6],[3,7,9],[5,9,7],[8,12,11]]",
                "[[0,2,4],[1,3,6],[2,4,8],[3,5,10]]",
                "[[1,3,5],[2,4,7],[3,5,9],[4,6,12]]",
                "[[0,1,2],[1,2,3],[2,3,4],[3,4,5]]",
                "[[0,1,1],[1,2,2],[2,3,3],[3,4,4]]",
                "[[0,1,4],[1,2,3],[2,3,2],[3,4,1]]"
            ],
            "outputs": [
                "[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]",
                "[[0,3],[5,0]]",
                "[[1,7],[3,9],[6,5],[10,0],[12,8]]",
                "[[0,5],[2,8],[4,6],[9,0],[12,10]]",
                "[[1,9],[3,11],[7,7],[12,0]]",
                "[[0,4],[2,6],[4,8],[5,6],[9,0]]",
                "[[1,7],[2,9],[3,12],[5,9],[6,7],[7,0]]",
                "[[0,2],[1,3],[2,4],[3,5],[4,0]]",
                "[[0,1],[1,2],[2,3],[3,4],[4,0]]",
                "[[0,4],[4,0]]"
            ]
        }
    },
    {
        "title": "Duplicate Element within K Distance",
        "description": "Given an integer array `nums` and an integer `k`, return `true` if there are two distinct indices `i` and `j` in the array such that `nums[i]` is equal to `nums[j]` and the absolute difference between `i` and `j` is less than or equal to `k`.",
        "example": "Example 1:\n\nInput: nums = [1,2,3,1], k = 3\nOutput: true\n\nExplanation: In this example, there are two distinct indices i=0 and j=3 such that nums[i] = nums[j] = 1 and the absolute difference between i and j is 3, which is less than or equal to k.\n\nExample 2:\n\nInput: nums = [1,0,1,1], k = 1\nOutput: true\n\nExplanation: In this example, there are two distinct indices i=1 and j=2 such that nums[i] = nums[j] = 1 and the absolute difference between i and j is 1, which is less than or equal to k.\n\nExample 3:\n\nInput: nums = [1,2,3,1,2,3], k = 2\nOutput: false\n\nExplanation: In this example, there are no distinct indices i and j such that nums[i] = nums[j] and the absolute difference between i and j is less than or equal to k.",
        "level": "Easy",
        "tags": [
            "array",
            "searching"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3,1]",
                "[1,0,1,1]",
                "[1,2,3,1,2,3]",
                "[1,1,1,1,1,1]",
                "[1,2,3,4,5,6]",
                "[1,2,3,4,5,6,1]",
                "[1,2,3,4,5,6,1,2]",
                "[1,2,3,4,5,6,1,2,3]",
                "[1,2,3,4,5,6,1,2,3,4]",
                "[1,2,3,4,5,6,1,2,3,4,5]"
            ],
            "outputs": [
                "true",
                "true",
                "false",
                "true",
                "false",
                "true",
                "true",
                "true",
                "true",
                "true"
            ]
        }
    },
    {
        "title": "Index and Value Difference",
        "description": "Given an integer array `nums` and two integers `indexDiff` and `valueDiff`, find a pair of indices `(i, j)` that satisfy the following conditions: \n\n- `i != j`\n- `abs(i - j) <= indexDiff`\n- `abs(nums[i] - nums[j]) <= valueDiff`\n\nReturn `true` if such a pair exists, or `false` otherwise.",
        "example": "Example 1:\n\nInput: nums = [1,2,3,1], indexDiff = 3, valueDiff = 0\nOutput: true\nExplanation: We can choose (i, j) = (0, 3). We satisfy the three conditions:\n- i != j --> 0 != 3\n- abs(i - j) <= indexDiff --> abs(0 - 3) <= 3\n- abs(nums[i] - nums[j]) <= valueDiff --> abs(1 - 1) <= 0\n\nExample 2:\n\nInput: nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3\nOutput: false\nExplanation: After trying all the possible pairs (i, j), we cannot satisfy the three conditions, so we return false.",
        "level": "Medium",
        "tags": [
            "array",
            "math"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3,1]",
                "[1,5,9,1,5,9]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,1,1,1,1,1,1,1,1,1]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[1,2,3,4,5,6,7,8,9,10]"
            ],
            "outputs": [
                "true",
                "false",
                "true",
                "false",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true"
            ]
        }
    },
    {
        "title": "Largest Square of Ones",
        "description": "Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.",
        "example": "Example 1:\n\nInput: matrix = [[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]\nOutput: 4\n\nExample 2:\n\nInput: matrix = [[0, 1], [1, 0]]\nOutput: 1\n\nExample 3:\n\nInput: matrix = [[0]]\nOutput: 0",
        "level": "Medium",
        "tags": [
            "matrix",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                "[[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]",
                "[[0, 1], [1, 0]]",
                "[[0]]",
                "[[1, 1, 1], [1, 1, 1], [1, 1, 1]]",
                "[[1, 1, 1], [1, 0, 1], [1, 1, 1]]",
                "[[1, 1, 1], [1, 1, 1], [1, 1, 0]]",
                "[[1, 0, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]",
                "[[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]",
                "[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]",
                "[[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 0]]"
            ],
            "outputs": [
                4,
                1,
                0,
                9,
                1,
                0,
                9,
                16,
                0,
                9
            ]
        }
    },
    {
        "title": "Count Nodes in Complete Binary Tree",
        "description": "Given the root of a complete binary tree, return the number of nodes in the tree. A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. The last level can have between 1 and 2h nodes inclusive, where h is the height of the tree. Design an algorithm that runs in less than O(n) time complexity.",
        "example": "Example 1:\n\nInput: root = [1,2,3,4,5,6]\nOutput: 6\n\nExample 2:\n\nInput: root = []\nOutput: 0\n\nExample 3:\n\nInput: root = [1]\nOutput: 1",
        "level": "Medium",
        "tags": [
            "binary tree",
            "complete binary tree",
            "tree traversal"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3,4,5,6]",
                "[]",
                "[1]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200]"
            ],
            "outputs": [
                "6",
                "0",
                "1",
                "20",
                "100",
                "200"
            ]
        }
    },
    {
        "title": "Total Area of Rectilinear Rectangles",
        "description": "Given the coordinates of two rectilinear rectangles in a 2D plane, calculate the total area covered by the two rectangles.",
        "example": "Example:\n\nInput: ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2\nOutput: 45\n\nExplanation: The total area covered by the two rectangles is 45 square units.",
        "level": "Easy",
        "tags": [
            "geometry",
            "math"
        ],
        "test_cases": {
            "inputs": [
                {
                    "ax1": -3,
                    "ay1": 0,
                    "ax2": 3,
                    "ay2": 4,
                    "bx1": 0,
                    "by1": -1,
                    "bx2": 9,
                    "by2": 2
                },
                {
                    "ax1": -2,
                    "ay1": -2,
                    "ax2": 2,
                    "ay2": 2,
                    "bx1": -2,
                    "by1": -2,
                    "bx2": 2,
                    "by2": 2
                },
                {
                    "ax1": -5,
                    "ay1": -5,
                    "ax2": 5,
                    "ay2": 5,
                    "bx1": -10,
                    "by1": -10,
                    "bx2": 10,
                    "by2": 10
                },
                {
                    "ax1": -1,
                    "ay1": -1,
                    "ax2": 1,
                    "ay2": 1,
                    "bx1": -3,
                    "by1": -3,
                    "bx2": 3,
                    "by2": 3
                },
                {
                    "ax1": -4,
                    "ay1": -4,
                    "ax2": 4,
                    "ay2": 4,
                    "bx1": -2,
                    "by1": -2,
                    "bx2": 2,
                    "by2": 2
                },
                {
                    "ax1": -10,
                    "ay1": -10,
                    "ax2": 10,
                    "ay2": 10,
                    "bx1": -5,
                    "by1": -5,
                    "bx2": 5,
                    "by2": 5
                },
                {
                    "ax1": -1,
                    "ay1": -1,
                    "ax2": 1,
                    "ay2": 1,
                    "bx1": -1,
                    "by1": -1,
                    "bx2": 1,
                    "by2": 1
                },
                {
                    "ax1": -5,
                    "ay1": -5,
                    "ax2": 5,
                    "ay2": 5,
                    "bx1": -5,
                    "by1": -5,
                    "bx2": 5,
                    "by2": 5
                },
                {
                    "ax1": -3,
                    "ay1": -3,
                    "ax2": 3,
                    "ay2": 3,
                    "bx1": -2,
                    "by1": -2,
                    "bx2": 2,
                    "by2": 2
                },
                {
                    "ax1": -4,
                    "ay1": -4,
                    "ax2": 4,
                    "ay2": 4,
                    "bx1": -6,
                    "by1": -6,
                    "bx2": 6,
                    "by2": 6
                }
            ],
            "outputs": [
                45,
                16,
                400,
                36,
                64,
                400,
                4,
                100,
                36,
                144
            ]
        }
    },
    {
        "title": "Basic Calculator",
        "description": "Given a string `s` representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation. You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.",
        "example": "Example 1:\n\nInput: s = \"1 + 1\"\nOutput: 2\n\nExample 2:\n\nInput: s = \"2-1 + 2\"\nOutput: 3\n\nExample 3:\n\nInput: s = \"(1+(4+5+2)-3)+(6+8)\"\nOutput: 23",
        "level": "Medium",
        "tags": [
            "string",
            "stack",
            "math"
        ],
        "test_cases": {
            "inputs": [
                "\"1 + 1\"",
                "\"2-1 + 2\"",
                "\"(1+(4+5+2)-3)+(6+8)\"",
                "\"10 - 5 + 3\"",
                "\"(2+3) - (4-1)\"",
                "\"5 - (3 + 2)\"",
                "\"(1 + 2) - (3 + 4)\"",
                "\"10 - (5 - 3)\"",
                "\"(2 + 3) - 4\"",
                "\"5 - (3 - 2)\""
            ],
            "outputs": [
                "2",
                "3",
                "23",
                "8",
                "2",
                "0",
                "-4",
                "8",
                "1",
                "4"
            ]
        }
    },
    {
        "title": "Implement Stack using Two Queues",
        "description": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (`push`, `top`, `pop`, and `empty`). You must use only standard operations of a queue, which means that only `push to back`, `peek/pop from front`, `size` and `is empty` operations are valid.",
        "example": "Example:\n\nInput:\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False\n\nOutput:\nnull, null, null, 2, 2, false\n\nExplanation:\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False",
        "level": "Medium",
        "tags": [
            "stack",
            "queue"
        ],
        "test_cases": {
            "inputs": [
                "[\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"]",
                "[[], [1], [2], [], [], []]"
            ],
            "outputs": [
                "null",
                "null",
                "null",
                "2",
                "2",
                "false"
            ]
        }
    },
    {
        "title": "Invert Binary Tree",
        "description": "Given the root of a binary tree, invert the tree by swapping the left and right child of each node, and return its root.",
        "example": "Example 1:\n\nInput: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]\n\nExample 2:\n\nInput: root = [2,1,3]\nOutput: [2,3,1]\n\nExample 3:\n\nInput: root = []\nOutput: []",
        "level": "Easy",
        "tags": [
            "Binary Tree",
            "Recursion"
        ],
        "test_cases": {
            "inputs": [
                "[4,2,7,1,3,6,9]",
                "[2,1,3]",
                "[]",
                "[1]",
                "[5,3,8,2,4,7,9]",
                "[10,5,15,2,7,12,20]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[10,9,8,7,6,5,4,3,2,1]",
                "[1,3,null,5,7,null,9]",
                "[1,null,2,null,3,null,4,null,5]"
            ],
            "outputs": [
                "[4,7,2,9,6,3,1]",
                "[2,3,1]",
                "[]",
                "[1]",
                "[5,8,3,9,7,4,2]",
                "[10,15,5,20,12,7,2]",
                "[1,3,2,5,4,7,6,10,9,8]",
                "[10,1,9,2,8,3,7,4,6,5]",
                "[1,null,3,null,7,5,null,9]",
                "[1,null,2,null,4,null,3,null,5]"
            ]
        }
    },
    {
        "title": "Evaluate Expression",
        "description": "Given a string `s` which represents an expression, evaluate this expression and return its value. The integer division should truncate toward zero. You may assume that the given expression is always valid. All intermediate results will be in the range of `[-231, 231 - 1]`. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.",
        "example": "Example 1:\n\nInput: s = \"3+2*2\"\nOutput: 7\n\nExample 2:\n\nInput: s = \" 3/2 \"\nOutput: 1\n\nExample 3:\n\nInput: s = \" 3+5 / 2 \"\nOutput: 5",
        "level": "Medium",
        "tags": [
            "string",
            "math"
        ],
        "test_cases": {
            "inputs": [
                "\"3+2*2\"",
                "\" 3/2 \"",
                "\" 3+5 / 2 \"",
                "\"10-5*2\"",
                "\" 100 / 10 + 5 * 2 - 3\"",
                "\" 2 * (3 + 4)\"",
                "\" 10 / 3\"",
                "\" 10 / 3 + 1\"",
                "\" 10 / (3 + 1)\"",
                "\" 10 / (3 + 1) + 2 * 3\""
            ],
            "outputs": [
                "7",
                "1",
                "5",
                "0",
                "17",
                "14",
                "3",
                "4",
                "2",
                "8"
            ]
        }
    },
    {
        "title": "Smallest Sorted Ranges",
        "description": "Given a sorted unique integer array `nums`, return the smallest sorted list of ranges that cover all the numbers in the array exactly. Each range `[a,b]` in the list should be output as `\"a->b\"` if `a != b` or `\"a\"` if `a == b`.",
        "example": "Example 1:\n\nInput: nums = [0,1,2,4,5,7]\nOutput: [\"0->2\", \"4->5\", \"7\"]\nExplanation: The ranges are:\n[0,2] --> \"0->2\"\n[4,5] --> \"4->5\"\n[7,7] --> \"7\"\n\nExample 2:\n\nInput: nums = [0,2,3,4,6,8,9]\nOutput: [\"0\", \"2->4\", \"6\", \"8->9\"]\nExplanation: The ranges are:\n[0,0] --> \"0\"\n[2,4] --> \"2->4\"\n[6,6] --> \"6\"\n[8,9] --> \"8->9\"",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "[0,1,2,4,5,7]",
                "[0,2,3,4,6,8,9]",
                "[]",
                "[0]",
                "[0,1,2,3,4,5,6,7,8,9]",
                "[-5,-4,-3,-2,-1,0,1,2,3,4,5]",
                "[1,3,5,7,9,11,13,15,17,19]",
                "[-10,-8,-6,-4,-2,0,2,4,6,8,10]",
                "[100,200,300,400,500]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]"
            ],
            "outputs": [
                "[\"0->2\", \"4->5\", \"7\"]",
                "[\"0\", \"2->4\", \"6\", \"8->9\"]",
                "[]",
                "[\"0\"]",
                "[\"0->9\"]",
                "[\"-5->5\"]",
                "[\"1->19\"]",
                "[\"-10->10\"]",
                "[\"100->500\"]",
                "[\"1->20\"]"
            ]
        }
    },
    null,
    null,
    {
        "title": "Power of Two",
        "description": "Given an integer `n`, determine if it is a power of two. Return `true` if `n` is a power of two, otherwise return `false`.",
        "example": "Example 1:\n\nInput: n = 1\nOutput: true\nExplanation: 2^0 = 1\n\nExample 2:\n\nInput: n = 16\nOutput: true\nExplanation: 2^4 = 16\n\nExample 3:\n\nInput: n = 3\nOutput: false",
        "level": "Easy",
        "tags": [
            "math",
            "bit manipulation"
        ],
        "test_cases": {
            "inputs": [
                "1",
                "16",
                "3",
                "0",
                "32",
                "1024",
                "17",
                "15",
                "64",
                "100"
            ],
            "outputs": [
                "true",
                "true",
                "false",
                "false",
                "true",
                "true",
                "false",
                "false",
                "true",
                "false"
            ]
        }
    },
    null,
    null,
    null,
    null,
    null,
    {
        "title": "Delete Node in Singly-Linked List",
        "description": "Given a singly-linked list `head` and a node `node` to be deleted, delete the given node from the linked list. You are not given access to the first node of `head`. All values in the linked list are unique, and it is guaranteed that the given node `node` is not the last node in the list. Delete the given node by removing its value from the linked list, decreasing the number of nodes by one. The order of values before and after the node should remain the same.",
        "example": "Example 1:\n\nInput: head = [4,5,1,9], node = 5\nOutput: [4,1,9]\nExplanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.\n\nExample 2:\n\nInput: head = [4,5,1,9], node = 1\nOutput: [4,5,9]\nExplanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.",
        "level": "Easy",
        "tags": [
            "linked list"
        ],
        "test_cases": {
            "inputs": [
                {
                    "head": [
                        4,
                        5,
                        1,
                        9
                    ],
                    "node": 5
                },
                {
                    "head": [
                        4,
                        5,
                        1,
                        9
                    ],
                    "node": 1
                },
                {
                    "head": [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    "node": 3
                },
                {
                    "head": [
                        7,
                        8,
                        9,
                        10
                    ],
                    "node": 7
                },
                {
                    "head": [
                        2,
                        4,
                        6,
                        8,
                        10
                    ],
                    "node": 10
                },
                {
                    "head": [
                        1,
                        3,
                        5,
                        7,
                        9
                    ],
                    "node": 5
                },
                {
                    "head": [
                        2,
                        4,
                        6,
                        8,
                        10
                    ],
                    "node": 4
                },
                {
                    "head": [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    "node": 2
                },
                {
                    "head": [
                        7,
                        8,
                        9,
                        10
                    ],
                    "node": 9
                },
                {
                    "head": [
                        1,
                        3,
                        5,
                        7,
                        9
                    ],
                    "node": 7
                }
            ],
            "outputs": [
                [
                    4,
                    1,
                    9
                ],
                [
                    4,
                    5,
                    9
                ],
                [
                    1,
                    2,
                    4,
                    5
                ],
                [
                    8,
                    9,
                    10
                ],
                [
                    2,
                    4,
                    6,
                    8
                ],
                [
                    1,
                    3,
                    7,
                    9
                ],
                [
                    2,
                    6,
                    8,
                    10
                ],
                [
                    1,
                    3,
                    4,
                    5
                ],
                [
                    7,
                    8,
                    10
                ],
                [
                    1,
                    3,
                    5,
                    9
                ]
            ]
        }
    },
    null,
    {
        "title": "Max Sliding Window",
        "description": "Given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position, return the max sliding window.",
        "example": "Example 1:\n\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [3,3,5,5,6,7]\nExplanation:\nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7      5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n\nExample 2:\n\nInput: nums = [1], k = 1\nOutput: [1]",
        "level": "Medium",
        "tags": [
            "array",
            "sliding window"
        ],
        "test_cases": {
            "inputs": [
                "[1,3,-1,-3,5,3,6,7]",
                "[1]",
                "[4,2,6,8,1,3,5,7,9]",
                "[-1,-2,-3,-4,-5]",
                "[10,9,8,7,6,5,4,3,2,1]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[5,5,5,5,5,5,5,5,5,5]",
                "[1,2,3,4,5,6,7,8,9,10,9,8,7,6,5,4,3,2,1]",
                "[1,2,3,4,5,6,7,8,9,10,9,8,7,6,5,4,3,2,1,0]",
                "[1,2,3,4,5,6,7,8,9,10,9,8,7,6,5,4,3,2,1,0,-1]"
            ],
            "outputs": [
                "[3,3,5,5,6,7]",
                "[1]",
                "[6,8,8,8,8,7,9]",
                "[-1]",
                "[10,9,8,7,6,5,4,3,2]",
                "[10,10,10,10,10,10,10,10,10]",
                "[10,10,10,10,10,10,10,10,10,10,9,9,9,9,9,9,9,9,9]",
                "[10,10,10,10,10,10,10,10,10,10,9,9,9,9,9,9,9,9,9,9,8]",
                "[10,10,10,10,10,10,10,10,10,10,9,9,9,9,9,9,9,9,9,9,8,7]"
            ]
        }
    },
    {
        "title": "Search in Sorted Matrix",
        "description": "You are given an `m x n` matrix where each row and each column is sorted in ascending order. Write a function that efficiently searches for a target value in the matrix. If the target is found, return `true`; otherwise, return `false`.",
        "example": "For example, given the following matrix:\n\n```\nmatrix = [\n  [1, 4, 7, 11, 15],\n  [2, 5, 8, 12, 19],\n  [3, 6, 9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n```\n\nIf we are searching for the target value `5`, the function should return `true` because `5` is present in the matrix. However, if we are searching for the target value `20`, the function should return `false` because `20` is not present in the matrix.",
        "level": "Medium",
        "tags": [
            "matrix",
            "search",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                {
                    "matrix": [
                        [
                            1,
                            4,
                            7,
                            11,
                            15
                        ],
                        [
                            2,
                            5,
                            8,
                            12,
                            19
                        ],
                        [
                            3,
                            6,
                            9,
                            16,
                            22
                        ],
                        [
                            10,
                            13,
                            14,
                            17,
                            24
                        ],
                        [
                            18,
                            21,
                            23,
                            26,
                            30
                        ]
                    ],
                    "target": 5
                },
                {
                    "matrix": [
                        [
                            1,
                            4,
                            7,
                            11,
                            15
                        ],
                        [
                            2,
                            5,
                            8,
                            12,
                            19
                        ],
                        [
                            3,
                            6,
                            9,
                            16,
                            22
                        ],
                        [
                            10,
                            13,
                            14,
                            17,
                            24
                        ],
                        [
                            18,
                            21,
                            23,
                            26,
                            30
                        ]
                    ],
                    "target": 20
                },
                {
                    "matrix": [
                        [
                            -5,
                            -4,
                            -3
                        ],
                        [
                            -3,
                            -2,
                            -1
                        ],
                        [
                            0,
                            1,
                            2
                        ]
                    ],
                    "target": -3
                },
                {
                    "matrix": [
                        [
                            -5,
                            -4,
                            -3
                        ],
                        [
                            -3,
                            -2,
                            -1
                        ],
                        [
                            0,
                            1,
                            2
                        ]
                    ],
                    "target": 0
                },
                {
                    "matrix": [
                        [
                            -5,
                            -4,
                            -3
                        ],
                        [
                            -3,
                            -2,
                            -1
                        ],
                        [
                            0,
                            1,
                            2
                        ]
                    ],
                    "target": 3
                },
                {
                    "matrix": [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ]
                    ],
                    "target": 3
                },
                {
                    "matrix": [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ]
                    ],
                    "target": 6
                },
                {
                    "matrix": [
                        [
                            1
                        ],
                        [
                            2
                        ],
                        [
                            3
                        ],
                        [
                            4
                        ],
                        [
                            5
                        ]
                    ],
                    "target": 3
                },
                {
                    "matrix": [
                        [
                            1
                        ],
                        [
                            2
                        ],
                        [
                            3
                        ],
                        [
                            4
                        ],
                        [
                            5
                        ]
                    ],
                    "target": 6
                },
                {
                    "matrix": [
                        [
                            1
                        ]
                    ],
                    "target": 1
                }
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                false,
                true,
                false,
                true,
                false,
                true
            ]
        }
    },
    {
        "title": "Expression Evaluation",
        "description": "Given a string `expression` of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.",
        "example": "Example 1:\n\nInput: expression = \"2-1-1\"\nOutput: [0,2]\nExplanation:\n((2-1)-1) = 0\n(2-(1-1)) = 2\n\nExample 2:\n\nInput: expression = \"2*3-4*5\"\nOutput: [-34,-14,-10,-10,10]\nExplanation:\n(2*(3-(4*5))) = -34\n((2*3)-(4*5)) = -14\n((2*(3-4))*5) = -10\n(2*((3-4)*5)) = -10\n(((2*3)-4)*5) = 10",
        "level": "Medium",
        "tags": [
            "string",
            "recursion",
            "math"
        ],
        "test_cases": {
            "inputs": [
                "\"2-1-1\"",
                "\"2*3-4*5\"",
                "\"1+2+3+4+5\"",
                "\"10-5+2\"",
                "\"5*4-3*2\"",
                "\"9-8-7-6-5\"",
                "\"3*2+4*5\"",
                "\"6-3*2+4\"",
                "\"2+3*4-5\"",
                "\"1+2*3-4+5\"",
                "\"9-8+7-6+5\"",
                "\"5*4+3*2\"",
                "\"1+2+3+4+5+6+7+8+9+10\"",
                "\"10-9-8-7-6-5-4-3-2-1\"",
                "\"1*2*3*4*5*6*7*8*9*10\"",
                "\"10/2/5\"",
                "\"100-50-25\"",
                "\"100/10/5\"",
                "\"100*2*5\"",
                "\"100+50+25\""
            ],
            "outputs": [
                "[0,2]",
                "[-34,-14,-10,-10,10]",
                "[15,15,15,15,15]",
                "[7,7,7,7,7]",
                "[2,2,2,2,2]",
                "[-27,-27,-27,-27,-27]",
                "[26,26,26,26,26]",
                "[1,1,1,1,1]",
                "[9,9,9,9,9]",
                "[12,12,12,12,12]",
                "[-3,-3,-3,-3,-3]",
                "[26,26,26,26,26]",
                "[55,55,55,55,55]",
                "[-53,-53,-53,-53,-53]",
                "[3628800,3628800,3628800,3628800,3628800]",
                "[1,1,1,1,1]",
                "[25,25,25,25,25]",
                "[4,4,4,4,4]",
                "[1000,1000,1000,1000,1000]",
                "[175,175,175,175,175]"
            ]
        }
    },
    {
        "title": "Anagram Check",
        "description": "Given two strings `s` and `t`, determine if `t` is an anagram of `s`. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        "example": "Example:\n\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\n\nExplanation: The word \"nagaram\" is an anagram of \"anagram\".\n\nInput: s = \"rat\", t = \"car\"\nOutput: false\n\nExplanation: The word \"car\" is not an anagram of \"rat\".",
        "level": "Easy",
        "tags": [
            "string",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "\"anagram\", \"nagaram\"",
                "\"rat\", \"car\"",
                "\"listen\", \"silent\"",
                "\"debit card\", \"bad credit\"",
                "\"school master\", \"the classroom\"",
                "\"astronomer\", \"moon starer\"",
                "\"eleven plus two\", \"twelve plus one\"",
                "\"restful\", \"fluster\"",
                "\"dormitory\", \"dirty room\"",
                "\"funeral\", \"real fun\""
            ],
            "outputs": [
                "true",
                "false",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true"
            ]
        }
    },
    {
        "title": "Shortest Distance Between Words",
        "description": "Given an array of strings `wordsDict` and two different strings that already exist in the array `word1` and `word2`, write a function that returns the shortest distance between these two words in the list.",
        "example": "Example:\n\nInput: wordsDict = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"], word1 = \"coding\", word2 = \"practice\"\nOutput: 3\n\nExplanation: The shortest distance between \"coding\" and \"practice\" is 3.",
        "level": "Easy",
        "tags": [
            "array",
            "string",
            "search"
        ],
        "test_cases": {
            "inputs": [
                {
                    "wordsDict": [
                        "practice",
                        "makes",
                        "perfect",
                        "coding",
                        "makes"
                    ],
                    "word1": "coding",
                    "word2": "practice"
                },
                {
                    "wordsDict": [
                        "practice",
                        "makes",
                        "perfect",
                        "coding",
                        "makes"
                    ],
                    "word1": "makes",
                    "word2": "coding"
                },
                {
                    "wordsDict": [
                        "apple",
                        "banana",
                        "orange",
                        "apple",
                        "grape"
                    ],
                    "word1": "apple",
                    "word2": "grape"
                },
                {
                    "wordsDict": [
                        "cat",
                        "dog",
                        "cat",
                        "bird",
                        "cat"
                    ],
                    "word1": "cat",
                    "word2": "bird"
                },
                {
                    "wordsDict": [
                        "hello",
                        "world",
                        "hello",
                        "world",
                        "hello"
                    ],
                    "word1": "hello",
                    "word2": "world"
                },
                {
                    "wordsDict": [
                        "a",
                        "b",
                        "c",
                        "d",
                        "e"
                    ],
                    "word1": "a",
                    "word2": "e"
                },
                {
                    "wordsDict": [
                        "one",
                        "two",
                        "three",
                        "four",
                        "five"
                    ],
                    "word1": "one",
                    "word2": "five"
                },
                {
                    "wordsDict": [
                        "alpha",
                        "beta",
                        "gamma",
                        "delta",
                        "epsilon"
                    ],
                    "word1": "alpha",
                    "word2": "epsilon"
                },
                {
                    "wordsDict": [
                        "red",
                        "blue",
                        "green",
                        "yellow",
                        "red"
                    ],
                    "word1": "red",
                    "word2": "yellow"
                },
                {
                    "wordsDict": [
                        "up",
                        "down",
                        "left",
                        "right",
                        "up"
                    ],
                    "word1": "up",
                    "word2": "right"
                }
            ],
            "outputs": [
                3,
                1,
                2,
                2,
                1,
                4,
                4,
                4,
                1,
                1
            ]
        }
    },
    {
        "title": "Shortest Word Distance",
        "description": "Design a data structure that will be initialized with a string array, and then it should answer queries of the shortest distance between two different strings from the array.\n\nImplement the `WordDistance` class:\n\n- `WordDistance(String[] wordsDict)`: Initializes the object with the strings array `wordsDict`.\n- `int shortest(String word1, String word2)`: Returns the shortest distance between `word1` and `word2` in the array `wordsDict`.",
        "example": "Example:\n\nInput:\nwordsDict = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"]\n\nOutput:\nnull\n\nExplanation:\nWordDistance wordDistance = new WordDistance([\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"]);\nwordDistance.shortest(\"coding\", \"practice\"); // returns 3\nwordDistance.shortest(\"makes\", \"coding\"); // returns 1",
        "level": "Medium",
        "tags": [
            "array",
            "string",
            "design"
        ],
        "test_cases": {
            "inputs": [
                "[\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"]",
                "[\"hello\", \"world\", \"hello\", \"coding\", \"world\"]",
                "[\"apple\", \"banana\", \"orange\", \"apple\", \"grape\"]",
                "[\"cat\", \"dog\", \"cat\", \"dog\", \"cat\"]",
                "[\"one\", \"two\", \"three\", \"four\", \"five\"]",
                "[\"apple\", \"banana\", \"apple\", \"banana\", \"apple\"]",
                "[\"red\", \"blue\", \"green\", \"yellow\", \"red\"]",
                "[\"happy\", \"sad\", \"happy\", \"sad\", \"happy\"]",
                "[\"good\", \"bad\", \"good\", \"bad\", \"good\"]",
                "[\"up\", \"down\", \"up\", \"down\", \"up\"]"
            ],
            "outputs": [
                "null",
                "2",
                "1",
                "1",
                "1",
                "1",
                "2",
                "1",
                "1",
                "1"
            ]
        }
    },
    {
        "title": "Shortest Distance Between Words",
        "description": "Given an array of strings `wordsDict` and two strings that already exist in the array `word1` and `word2`, return the shortest distance between the occurrence of these two words in the list. Note that `word1` and `word2` may be the same. It is guaranteed that they represent two individual words in the list.",
        "example": "Example 1:\n\nInput: wordsDict = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"], word1 = \"makes\", word2 = \"coding\"\nOutput: 1\n\nExample 2:\n\nInput: wordsDict = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"], word1 = \"makes\", word2 = \"makes\"\nOutput: 3",
        "level": "Easy",
        "tags": [
            "array",
            "string",
            "search"
        ],
        "test_cases": {
            "inputs": [
                {
                    "wordsDict": [
                        "practice",
                        "makes",
                        "perfect",
                        "coding",
                        "makes"
                    ],
                    "word1": "makes",
                    "word2": "coding"
                },
                {
                    "wordsDict": [
                        "practice",
                        "makes",
                        "perfect",
                        "coding",
                        "makes"
                    ],
                    "word1": "makes",
                    "word2": "makes"
                },
                {
                    "wordsDict": [
                        "apple",
                        "banana",
                        "cherry",
                        "apple",
                        "banana"
                    ],
                    "word1": "apple",
                    "word2": "banana"
                },
                {
                    "wordsDict": [
                        "hello",
                        "world",
                        "hello",
                        "world",
                        "hello"
                    ],
                    "word1": "hello",
                    "word2": "world"
                },
                {
                    "wordsDict": [
                        "cat",
                        "dog",
                        "cat",
                        "dog",
                        "cat"
                    ],
                    "word1": "cat",
                    "word2": "dog"
                },
                {
                    "wordsDict": [
                        "one",
                        "two",
                        "three",
                        "four",
                        "five"
                    ],
                    "word1": "one",
                    "word2": "five"
                },
                {
                    "wordsDict": [
                        "alpha",
                        "beta",
                        "gamma",
                        "delta",
                        "epsilon"
                    ],
                    "word1": "beta",
                    "word2": "delta"
                },
                {
                    "wordsDict": [
                        "red",
                        "blue",
                        "green",
                        "yellow",
                        "red"
                    ],
                    "word1": "red",
                    "word2": "green"
                },
                {
                    "wordsDict": [
                        "up",
                        "down",
                        "left",
                        "right",
                        "up"
                    ],
                    "word1": "up",
                    "word2": "left"
                },
                {
                    "wordsDict": [
                        "good",
                        "bad",
                        "good",
                        "bad",
                        "good"
                    ],
                    "word1": "good",
                    "word2": "bad"
                }
            ],
            "outputs": [
                1,
                3,
                1,
                1,
                1,
                4,
                2,
                1,
                2,
                1
            ]
        }
    },
    null,
    {
        "title": "Strobogrammatic Numbers",
        "description": "Given an integer `n`, return all the strobogrammatic numbers that are of length `n`. A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).",
        "example": "Example 1:\n\nInput: n = 2\nOutput: [\"11\",\"69\",\"88\",\"96\"]\n\nExample 2:\n\nInput: n = 1\nOutput: [\"0\",\"1\",\"8\"]",
        "level": "Medium",
        "tags": [
            "Array",
            "String"
        ],
        "test_cases": {
            "inputs": [
                "2",
                "1",
                "3",
                "4",
                "5",
                "6",
                "7",
                "8",
                "9",
                "10"
            ],
            "outputs": [
                [
                    "11",
                    "69",
                    "88",
                    "96"
                ],
                [
                    "0",
                    "1",
                    "8"
                ],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                []
            ]
        }
    },
    null,
    {
        "title": "Group Shifting Sequences",
        "description": "Given an array of strings, group all strings that belong to the same shifting sequence. A shifting sequence is formed by shifting each letter of a string to its successive letter. For example, 'abc' can be shifted to 'bcd'. You may return the answer in any order.",
        "example": "Example 1:\n\nInput: strings = ['abc','bcd','acef','xyz','az','ba','a','z']\nOutput: [['acef'],['a','z'],['abc','bcd','xyz'],['az','ba']]\n\nExample 2:\n\nInput: strings = ['a']\nOutput: [['a']]\n",
        "level": "Medium",
        "tags": [
            "array",
            "string"
        ],
        "test_cases": {
            "inputs": [
                "['abc','bcd','acef','xyz','az','ba','a','z']",
                "['a']",
                "['abc','bcd','xyz','acef','az','ba','a','z']",
                "['abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z']",
                "['abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z']",
                "['abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z']",
                "['abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z']",
                "['abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z']",
                "['abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z']",
                "['abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z','abc','bcd','xyz','acef','az','ba','a','z']"
            ],
            "outputs": [
                "[['acef'],['a','z'],['abc','bcd','xyz'],['az','ba']]",
                "[['a']]",
                "[['acef'],['a','z'],['abc','bcd','xyz'],['az','ba']]",
                "[['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba']]",
                "[['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba']]",
                "[['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba']]",
                "[['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba']]",
                "[['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba']]",
                "[['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba']]",
                "[['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba'],['acef'],['a','z'],['abc','bcd','xyz'],['az','ba']]"
            ]
        }
    },
    {
        "title": "Count Uni-Value Subtrees in Binary Tree",
        "description": "Given the root of a binary tree, return the number of uni-value subtrees. A uni-value subtree means all nodes of the subtree have the same value.",
        "example": "Example 1:\n\nInput: root = [5,1,5,5,5,null,5]\nOutput: 4\n\nExplanation: The uni-value subtrees are [5], [5,5], [5,5,5], and [5].\n\nExample 2:\n\nInput: root = []\nOutput: 0\n\nExplanation: The tree is empty, so there are no uni-value subtrees.\n\nExample 3:\n\nInput: root = [5,5,5,5,5,null,5]\nOutput: 6\n\nExplanation: The uni-value subtrees are [5], [5,5], [5,5,5], [5,5,5,5], [5,5,5,5,5], and [5].",
        "level": "Medium",
        "tags": [
            "binary tree",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                "[5,1,5,5,5,null,5]",
                "[]",
                "[5,5,5,5,5,null,5]",
                "[1]",
                "[1,1]",
                "[1,1,1]",
                "[1,2,3]",
                "[1,2,2]",
                "[1,2,1]",
                "[1,1,null,1,1]"
            ],
            "outputs": [
                "4",
                "0",
                "6",
                "1",
                "2",
                "3",
                "1",
                "2",
                "1",
                "3"
            ]
        }
    },
    null,
    null,
    {
        "title": "Minimum Conference Rooms Required",
        "description": "Given an array of meeting time intervals `intervals` where `intervals[i] = [starti, endi]`, return the minimum number of conference rooms required.",
        "example": "Example 1:\n\nInput: intervals = [[0,30],[5,10],[15,20]]\nOutput: 2\n\nExample 2:\n\nInput: intervals = [[7,10],[2,4]]\nOutput: 1",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "[[0,30],[5,10],[15,20]]",
                "[[7,10],[2,4]]",
                "[[1,5],[2,6],[3,7],[4,8]]",
                "[[1,10],[2,9],[3,8],[4,7],[5,6]]",
                "[[1,2],[3,4],[5,6],[7,8],[9,10]]",
                "[[1,3],[2,4],[5,7],[6,8],[9,10]]",
                "[[1,5],[2,6],[3,7],[4,8],[5,9]]",
                "[[1,10],[2,9],[3,8],[4,7],[5,6],[6,7],[7,8],[8,9],[9,10]]",
                "[[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10]]",
                "[[1,10],[2,9],[3,8],[4,7],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11]]"
            ],
            "outputs": [
                "2",
                "1",
                "4",
                "5",
                "1",
                "2",
                "3",
                "9",
                "9",
                "10"
            ]
        }
    },
    {
        "title": "Factor Combinations",
        "description": "Given an integer n, return all possible combinations of its factors. The factors should be in the range [2, n - 1].",
        "example": "Example 1:\n\nInput: n = 12\nOutput: [[2,6],[3,4],[2,2,3]]\n\nExample 2:\n\nInput: n = 37\nOutput: []",
        "level": "Medium",
        "tags": [
            "math",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                "1",
                "12",
                "37",
                "8",
                "24",
                "100",
                "50",
                "64",
                "81",
                "107"
            ],
            "outputs": [
                "[]",
                "[[2,6],[3,4],[2,2,3]]",
                "[]",
                "[[2,2,2]]",
                "[[2,12],[3,8],[4,6],[2,2,6],[2,3,4]]",
                "[[2,50],[4,25],[5,20],[10,10],[2,2,25],[2,5,10],[4,5,5]]",
                "[[2,25],[5,10],[2,5,5]]",
                "[[2,32],[4,16],[8,8],[2,2,16],[2,4,8],[2,2,2,8],[2,2,4,4]]",
                "[[3,27],[9,9],[3,3,9]]",
                "[]"
            ]
        }
    },
    null,
    null,
    {
        "title": "Binary Tree Root-to-Leaf Paths",
        "description": "Given the root of a binary tree, return all root-to-leaf paths in any order. A leaf is a node with no children.",
        "example": "Example 1:\n\nInput: root = [1,2,3,null,5]\nOutput: [\"1->2->5\", \"1->3\"]\n\nExample 2:\n\nInput: root = [1]\nOutput: [\"1\"]",
        "level": "Medium",
        "tags": [
            "binary tree",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3,null,5]",
                "[1]",
                "[1,2,3,4,5,6,7]",
                "[1,2,3,null,4,null,5,null,6]",
                "[1,2,3,4,5,null,null,null,null,6,7,8,9,null,null,10]"
            ],
            "outputs": [
                "[\"1->2->5\", \"1->3\"]",
                "[\"1\"]",
                "[\"1->2->4\", \"1->2->5\", \"1->3->6\", \"1->3->7\"]",
                "[\"1->2->4->6\", \"1->3->5\"]",
                "[\"1->2->4->6->10\", \"1->2->4->6->7->9\", \"1->2->4->6->7->8\", \"1->3->5->6->10\"]"
            ]
        }
    },
    {
        "title": "Sum of Digits",
        "description": "Given an integer `num`, repeatedly add all its digits until the result has only one digit, and return it.",
        "example": "Example 1:\n\nInput: num = 38\nOutput: 2\nExplanation: The process is\n38 --> 3 + 8 --> 11\n11 --> 1 + 1 --> 2\nSince 2 has only one digit, return it.\n\nExample 2:\n\nInput: num = 0\nOutput: 0",
        "level": "Easy",
        "tags": [
            "math"
        ],
        "test_cases": {
            "inputs": [
                "38",
                "0",
                "9",
                "123",
                "456",
                "789",
                "100",
                "999",
                "123456789",
                "231"
            ],
            "outputs": [
                "2",
                "0",
                "9",
                "6",
                "6",
                "6",
                "1",
                "9",
                "9",
                "6"
            ]
        }
    },
    {
        "title": "Count Triplets with Sum Less than Target",
        "description": "Given an array of `n` integers `nums` and an integer `target`, find the number of index triplets `i`, `j`, `k` with `0 <= i < j < k < n` that satisfy the condition `nums[i] + nums[j] + nums[k] < target`.",
        "example": "Example 1:\n\nInput: nums = [-2,0,1,3], target = 2\nOutput: 2\nExplanation: Because there are two triplets which sums are less than 2:\n[-2,0,1]\n[-2,0,3]",
        "level": "Medium",
        "tags": [
            "array",
            "two pointers"
        ],
        "test_cases": {
            "inputs": [
                "[-2,0,1,3], 2",
                "[], 0",
                "[0], 0",
                "[-1,0,1,2,-1,-4], 0",
                "[1,2,3,4,5], 10",
                "[-5,-4,-3,-2,-1,0,1,2,3,4,5], 0",
                "[10,20,30,40,50], 100",
                "[-10,-20,-30,-40,-50], -100",
                "[0,0,0,0,0], 1",
                "[1,1,1,1,1], 3"
            ],
            "outputs": [
                "2",
                "0",
                "0",
                "4",
                "0",
                "0",
                "10",
                "0",
                "0",
                "10"
            ]
        }
    },
    null,
    null,
    {
        "title": "Ugly Number",
        "description": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. Given an integer n, return true if n is an ugly number.",
        "example": "Example 1:\n\nInput: n = 6\nOutput: true\nExplanation: 6 = 2 * 3\n\nExample 2:\n\nInput: n = 1\nOutput: true\nExplanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n\nExample 3:\n\nInput: n = 14\nOutput: false\nExplanation: 14 is not ugly since it includes the prime factor 7.",
        "level": "Easy",
        "tags": [
            "math",
            "prime numbers"
        ],
        "test_cases": {
            "inputs": [
                "6",
                "1",
                "14",
                "8",
                "30",
                "45",
                "12",
                "25",
                "18",
                "20"
            ],
            "outputs": [
                "true",
                "true",
                "false",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true"
            ]
        }
    },
    {
        "title": "Ugly Number",
        "description": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. Given an integer n, return the nth ugly number.",
        "example": "Example 1:\n\nInput: n = 10\nOutput: 12\nExplanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.\n\nExample 2:\n\nInput: n = 1\nOutput: 1\nExplanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.",
        "level": "Medium",
        "tags": [
            "Math",
            "Dynamic Programming"
        ],
        "test_cases": {
            "inputs": [
                "1",
                "2",
                "5",
                "10",
                "20",
                "50",
                "100",
                "500",
                "1000",
                "1690"
            ],
            "outputs": [
                "1",
                "2",
                "5",
                "12",
                "36",
                "243",
                "1536",
                "859963392",
                "51200000000",
                "2123366400"
            ]
        }
    },
    null,
    {
        "title": "Palindrome Permutation",
        "description": "Given a string `s`, determine if a permutation of the string could form a palindrome.",
        "example": "Example 1:\n\nInput: s = \"code\"\nOutput: false\n\nExplanation: No permutation of \"code\" can form a palindrome.\n\nExample 2:\n\nInput: s = \"aab\"\nOutput: true\n\nExplanation: The permutation \"aba\" can form a palindrome.\n\nExample 3:\n\nInput: s = \"carerac\"\nOutput: true\n\nExplanation: The permutation \"racecar\" can form a palindrome.",
        "level": "Easy",
        "tags": [
            "string",
            "palindrome",
            "permutation"
        ],
        "test_cases": {
            "inputs": [
                "\"code\"",
                "\"aab\"",
                "\"carerac\"",
                "\"aabbaa\"",
                "\"abcde\"",
                "\"a\"",
                "\"aa\"",
                "\"aaa\"",
                "\"aabb\"",
                "\"ababab\""
            ],
            "outputs": [
                "false",
                "true",
                "true",
                "true",
                "false",
                "true",
                "true",
                "true",
                "true",
                "true"
            ]
        }
    },
    {
        "title": "Palindromic Permutations",
        "description": "Given a string s, return all the palindromic permutations (without duplicates) of it. If s has no palindromic permutation, return an empty list.",
        "example": "Example 1:\n\nInput: s = \"aabb\"\nOutput: [\"abba\",\"baab\"]\n\nExample 2:\n\nInput: s = \"abc\"\nOutput: []",
        "level": "Medium",
        "tags": [
            "string",
            "permutations"
        ],
        "test_cases": {
            "inputs": [
                "\"aabb\"",
                "\"abc\"",
                "\"aabbaa\"",
                "\"racecar\"",
                "\"aab\"",
                "\"aabbaabb\"",
                "\"level\"",
                "\"aabbaabbaa\"",
                "\"madam\"",
                "\"aabbaabbaabb\""
            ],
            "outputs": [
                "[\"abba\",\"baab\"]",
                "[]",
                "[\"aabbaa\",\"aaabba\"]",
                "[\"racecar\"]",
                "[\"aba\",\"baa\"]",
                "[\"aabbaabb\",\"abbbaabba\"]",
                "[\"level\"]",
                "[\"aabbaabbaa\",\"aaabbbbaaaa\"]",
                "[\"madam\"]",
                "[\"aabbaabbaabb\",\"abbbaabbaabb\"]"
            ]
        }
    },
    null,
    null,
    null,
    {
        "title": "String List Encoding and Decoding",
        "description": "Design an algorithm to encode a list of strings to a single string. The encoded string is then sent over the network and decoded back to the original list of strings.\n\nMachine 1 (sender) has the function:\n\nstring encode(vector<string> strs) {\n  // ... your code\n  return encoded_string;\n}\n\nMachine 2 (receiver) has the function:\n\nvector<string> decode(string s) {\n  //... your code\n  return strs;\n}\n\nSo Machine 1 does:\n\nstring encoded_string = encode(strs);\n\nand Machine 2 does:\n\nvector<string> strs2 = decode(encoded_string);\n\nstrs2 in Machine 2 should be the same as strs in Machine 1.\n\nImplement the encode and decode methods.\n\nYou are not allowed to solve the problem using any serialize methods (such as eval).",
        "example": "Example:\n\nInput:\nstrs = [\"Hello\", \"World\"]\nOutput:\nEncoded String: \"Hello|World\"\n\nInput:\nstrs = [\"Hello\", \"World\", \"!\"]\nOutput:\nEncoded String: \"Hello|World|!\"\n\nInput:\nstrs = [\"Hello\", \"\", \"World\"]\nOutput:\nEncoded String: \"Hello||World\"",
        "level": "Medium",
        "tags": [
            "string",
            "encoding",
            "decoding"
        ],
        "test_cases": {
            "inputs": [
                "[\"Hello\", \"World\"]",
                "[\"Hello\", \"World\", \"!\"]",
                "[\"Hello\", \"\", \"World\"]",
                "[\"\", \"\", \"\"]",
                "[\"abc\", \"def\", \"ghi\", \"jkl\"]",
                "[\"123\", \"456\", \"789\"]",
                "[\"\", \"\", \"\", \"\"]",
                "[\"Hello\", \"World\", \"!\", \"\", \"Goodbye\"]",
                "[\"This\", \"is\", \"a\", \"test\", \"string\"]",
                "[\"\", \"\", \"\", \"\", \"\"]"
            ],
            "outputs": [
                "\"Hello|World\"",
                "\"Hello|World|!\"",
                "\"Hello||World\"",
                "\"||\"",
                "\"abc|def|ghi|jkl\"",
                "\"123|456|789\"",
                "\"|||\"",
                "\"Hello|World|!||Goodbye\"",
                "\"This|is|a|test|string\"",
                "\"||||\""
            ]
        }
    },
    {
        "title": "Closest Values in Binary Search Tree",
        "description": "Given the root of a binary search tree, a target value, and an integer k, return the k values in the BST that are closest to the target. You may return the answer in any order. You are guaranteed to have only one unique set of k values in the BST that are closest to the target.",
        "example": {
            "input": {
                "root": [
                    4,
                    2,
                    5,
                    1,
                    3
                ],
                "target": 3.714286,
                "k": 2
            },
            "output": [
                4,
                3
            ],
            "explanation": "In the given binary search tree, the closest values to the target 3.714286 are 4 and 3."
        },
        "level": "Medium",
        "tags": [
            "binary search tree",
            "closest values",
            "k values"
        ],
        "test_cases": {
            "inputs": [
                {
                    "root": [
                        4,
                        2,
                        5,
                        1,
                        3
                    ],
                    "target": 3.714286,
                    "k": 2
                },
                {
                    "root": [
                        1
                    ],
                    "target": 0.0,
                    "k": 1
                },
                {
                    "root": [
                        5,
                        3,
                        6,
                        2,
                        4,
                        null,
                        null,
                        1
                    ],
                    "target": 2.5,
                    "k": 2
                },
                {
                    "root": [
                        8,
                        1,
                        10,
                        12,
                        6,
                        null,
                        null,
                        null,
                        null,
                        null,
                        null
                    ],
                    "target": 9.5,
                    "k": 3
                },
                {
                    "root": [
                        3,
                        1,
                        4,
                        null,
                        2
                    ],
                    "target": 2.0,
                    "k": 2
                },
                {
                    "root": [
                        5,
                        3,
                        6,
                        2,
                        4,
                        null,
                        null,
                        1
                    ],
                    "target": 4.5,
                    "k": 3
                },
                {
                    "root": [
                        5,
                        3,
                        6,
                        2,
                        4,
                        null,
                        null,
                        1
                    ],
                    "target": 7.5,
                    "k": 1
                },
                {
                    "root": [
                        5,
                        3,
                        6,
                        2,
                        4,
                        null,
                        null,
                        1
                    ],
                    "target": 0.5,
                    "k": 1
                },
                {
                    "root": [
                        5,
                        3,
                        6,
                        2,
                        4,
                        null,
                        null,
                        1
                    ],
                    "target": 5.5,
                    "k": 4
                },
                {
                    "root": [
                        5,
                        3,
                        6,
                        2,
                        4,
                        null,
                        null,
                        1
                    ],
                    "target": 3.5,
                    "k": 5
                }
            ],
            "outputs": [
                [
                    4,
                    3
                ],
                [
                    1
                ],
                [
                    2,
                    3
                ],
                [
                    10,
                    8,
                    12
                ],
                [
                    2,
                    3
                ],
                [
                    4,
                    3,
                    5
                ],
                [
                    6
                ],
                [
                    1
                ],
                [
                    5,
                    4,
                    6,
                    3
                ],
                [
                    4,
                    3,
                    5,
                    2,
                    6
                ]
            ]
        }
    },
    {
        "title": "Integer to English Words",
        "description": "Write a function that converts a non-negative integer `num` to its English words representation.",
        "example": "Example 1:\n\nInput: num = 123\nOutput: \"One Hundred Twenty Three\"\n\nExample 2:\n\nInput: num = 12345\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\n\nExample 3:\n\nInput: num = 1234567\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"",
        "level": "Medium",
        "tags": [
            "string",
            "math"
        ],
        "test_cases": {
            "inputs": [
                0,
                1,
                10,
                20,
                100,
                123,
                1000,
                12345,
                1000000,
                1234567
            ],
            "outputs": [
                "Zero",
                "One",
                "Ten",
                "Twenty",
                "One Hundred",
                "One Hundred Twenty Three",
                "One Thousand",
                "Twelve Thousand Three Hundred Forty Five",
                "One Million",
                "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
            ]
        }
    },
    {
        "title": "Researcher's H-Index",
        "description": "Given an array of integers `citations` where `citations[i]` is the number of citations a researcher received for their `ith` paper, return the researcher's h-index. The h-index is defined as the maximum value of `h` such that the given researcher has published at least `h` papers that have each been cited at least `h` times.",
        "example": "Example:\n\nInput: citations = [3,0,6,1,5]\nOutput: 3\nExplanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "[3,0,6,1,5]",
                "[1,3,1]",
                "[0,0,0,0,0]",
                "[5,5,5,5,5]",
                "[1,1,1,1,1]",
                "[10,20,30,40,50]",
                "[50,40,30,20,10]",
                "[1,2,3,4,5]",
                "[5,4,3,2,1]",
                "[2,2,2,2,2]"
            ],
            "outputs": [
                "3",
                "1",
                "0",
                "5",
                "1",
                "5",
                "5",
                "3",
                "3",
                "2"
            ]
        }
    },
    {
        "title": "Researcher's H-Index",
        "description": "Given an array of integers `citations` where `citations[i]` is the number of citations a researcher received for their `ith` paper and `citations` is sorted in ascending order, return the researcher's h-index. The h-index is defined as the maximum value of `h` such that the given researcher has published at least `h` papers that have each been cited at least `h` times. Write an algorithm that runs in logarithmic time.",
        "example": "Example:\n\nInput: citations = [0,1,3,5,6]\nOutput: 3\nExplanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "[0,1,3,5,6]",
                "[1,2,100]",
                "[0,0,0,0,0]",
                "[1,1,1,1,1]",
                "[1,2,3,4,5]",
                "[5,5,5,5,5]",
                "[0,1,2,3,4]",
                "[4,3,2,1,0]",
                "[0,0,1,1,2,2,3,3,4,4]",
                "[4,4,3,3,2,2,1,1,0,0]"
            ],
            "outputs": [
                "3",
                "2",
                "0",
                "1",
                "2",
                "5",
                "2",
                "3",
                "2",
                "2"
            ]
        }
    },
    {
        "title": "Painting Fence",
        "description": "You are painting a fence of `n` posts with `k` different colors. You must paint the posts following these rules:\n\n- Every post must be painted **exactly one** color.\n- There **cannot** be three or more **consecutive** posts with the same color.\n\nGiven the two integers `n` and `k`, return the **number of ways** you can paint the fence.",
        "example": "Example:\n\nInput: n = 3, k = 2\nOutput: 6\nExplanation: All the possibilities are shown. Note that painting all the posts red or all the posts green is invalid because there cannot be three posts in a row with the same color.",
        "level": "Medium",
        "tags": [
            "dynamic programming",
            "combinatorics"
        ],
        "test_cases": {
            "inputs": [
                "3, 2",
                "1, 1",
                "7, 2",
                "4, 3",
                "10, 4",
                "2, 5",
                "6, 1",
                "8, 8",
                "12, 6",
                "50, 10"
            ],
            "outputs": [
                "6",
                "1",
                "42",
                "18",
                "96",
                "0",
                "1",
                "0",
                "0",
                "0"
            ]
        }
    },
    {
        "title": "Find the Celebrity",
        "description": "You are at a party with `n` people labeled from `0` to `n - 1`. Among them, there may exist one celebrity. The definition of a celebrity is that all the other `n - 1` people know the celebrity, but the celebrity does not know any of them. You are only allowed to ask questions like: 'Hi, A. Do you know B?' to get information about whether A knows B. Implement a function `int findCelebrity(n)` to find out who the celebrity is or verify that there is not one. Return the celebrity's label if there is a celebrity at the party. If there is no celebrity, return -1.",
        "example": "Example 1:\n\nInput: graph = [[1,1,0],[0,1,0],[1,1,1]]\nOutput: 1\nExplanation: There are three persons labeled with 0, 1, and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.",
        "level": "Medium",
        "tags": [
            "graph",
            "array",
            "celebrity"
        ],
        "test_cases": {
            "inputs": [
                "[[1,1,0],[0,1,0],[1,1,1]]",
                "[[1,0,1],[1,1,0],[0,1,1]]",
                "[[1,0],[0,1]]",
                "[[1,1],[1,1]]",
                "[[1,0,0],[1,1,0],[1,1,1]]",
                "[[1,1,1],[0,1,0],[1,1,1]]",
                "[[1,0,0,0],[1,1,0,0],[1,1,1,0],[1,1,1,1]]",
                "[[1,1,1,1],[0,1,0,0],[1,1,1,0],[1,1,1,1]]",
                "[[1,0,0,0,0],[1,1,0,0,0],[1,1,1,0,0],[1,1,1,1,0],[1,1,1,1,1]]",
                "[[1,1,1,1,1],[0,1,0,0,0],[1,1,1,0,0],[1,1,1,1,0],[1,1,1,1,1]]"
            ],
            "outputs": [
                "1",
                "-1",
                "0",
                "-1",
                "-1",
                "1",
                "3",
                "0",
                "-1",
                "0"
            ]
        }
    },
    {
        "title": "First Bad Version",
        "description": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\n\nSuppose you have `n` versions `[1, 2, ..., n]` and you want to find out the first bad one, which causes all the following ones to be bad.\n\nYou are given an API `bool isBadVersion(version)` which returns whether `version` is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.",
        "example": "Example:\n\nInput: n = 5, bad = 4\nOutput: 4\nExplanation:\ncall isBadVersion(3) -> false\ncall isBadVersion(5) -> true\ncall isBadVersion(4) -> true\nThen 4 is the first bad version.",
        "level": "Easy",
        "tags": [
            "binary search"
        ],
        "test_cases": {
            "inputs": [
                "5, 4",
                "1, 1",
                "10, 7",
                "100, 50",
                "1000, 999",
                "10000, 5000",
                "100000, 75000",
                "1000000, 1000000",
                "10000000, 1",
                "100000000, 99999999"
            ],
            "outputs": [
                "4",
                "1",
                "7",
                "50",
                "999",
                "5000",
                "75000",
                "1000000",
                "1",
                "99999999"
            ]
        }
    },
    {
        "title": "Least Number of Perfect Square Numbers",
        "description": "Given an integer `n`, find the least number of perfect square numbers that sum to `n`.",
        "example": "Example:\n\nInput: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.",
        "level": "Medium",
        "tags": [
            "dynamic programming",
            "math"
        ],
        "test_cases": {
            "inputs": [
                "1",
                "2",
                "3",
                "4",
                "5",
                "6",
                "7",
                "8",
                "9",
                "10"
            ],
            "outputs": [
                "1",
                "2",
                "3",
                "1",
                "2",
                "3",
                "4",
                "2",
                "1",
                "2"
            ]
        }
    },
    {
        "title": "Reorder Array",
        "description": "Given an integer array `nums`, reorder it such that `nums[0] <= nums[1] >= nums[2] <= nums[3]...`. You may assume the input array always has a valid answer.",
        "example": "Example 1:\n\nInput: nums = [3,5,2,1,6,4]\nOutput: [3,5,1,6,2,4]\nExplanation: [1,6,2,5,3,4] is also accepted.\n\nExample 2:\n\nInput: nums = [6,6,5,6,3,8]\nOutput: [6,6,5,6,3,8]",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "[3,5,2,1,6,4]",
                "[6,6,5,6,3,8]",
                "[1,2,3,4,5,6]",
                "[9,8,7,6,5,4]",
                "[10,20,30,40,50,60]",
                "[5,5,5,5,5,5]",
                "[2,4,6,8,10,12]",
                "[7,3,9,2,8,5]",
                "[1,3,5,2,4,6]",
                "[10,5,8,3,6,1]"
            ],
            "outputs": [
                "[3,5,1,6,2,4]",
                "[6,6,5,6,3,8]",
                "[1,3,2,5,4,6]",
                "[9,8,7,6,5,4]",
                "[10,20,30,40,50,60]",
                "[5,5,5,5,5,5]",
                "[2,6,4,10,8,12]",
                "[7,9,2,8,3,5]",
                "[1,3,2,5,4,6]",
                "[10,5,8,6,3,1]"
            ]
        }
    },
    null,
    null,
    {
        "title": "Move Zeros to End",
        "description": "Given an integer array `nums`, move all `0`'s to the end of it while maintaining the relative order of the non-zero elements. You must do this in-place without making a copy of the array.",
        "example": "Example 1:\n\nInput: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]\n\nExample 2:\n\nInput: nums = [0]\nOutput: [0]",
        "level": "Easy",
        "tags": [
            "array",
            "in-place"
        ],
        "test_cases": {
            "inputs": [
                "[0,1,0,3,12]",
                "[0,0,0,0,0]",
                "[1,2,3,4,5]",
                "[0,0,0,1,0]",
                "[0,0,0,0,1]",
                "[1,0,2,0,3]",
                "[0,1,0,2,0]",
                "[1,0,0,0,2]",
                "[1,0,0,0,0]",
                "[0,0,0,0,0,1]"
            ],
            "outputs": [
                "[1,3,12,0,0]",
                "[0,0,0,0,0]",
                "[1,2,3,4,5]",
                "[1,0,0,0,0]",
                "[1,0,0,0,0]",
                "[1,2,3,0,0]",
                "[1,2,0,0,0]",
                "[1,2,0,0,0]",
                "[1,0,0,0,0]",
                "[1,0,0,0,0,0]"
            ]
        }
    },
    null,
    null,
    {
        "title": "Distance to Nearest Gate",
        "description": "You are given an m x n grid `rooms` initialized with three possible values: -1 (a wall or obstacle), 0 (a gate), and INF (infinity, represented by 2147483647). Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.",
        "example": "Example 1:\n\nInput: rooms = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]\nOutput: [[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]\n\nExample 2:\n\nInput: rooms = [[-1]]\nOutput: [[-1]]",
        "level": "Medium",
        "tags": [
            "array",
            "graph",
            "bfs"
        ],
        "test_cases": {
            "inputs": [
                "[[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]",
                "[[-1]]",
                "[[0]]",
                "[[INF]]",
                "[[INF,0],[-1,INF]]",
                "[[INF,INF,INF],[-1,0,-1],[INF,INF,INF]]",
                "[[0,INF,INF],[-1,INF,INF],[INF,INF,INF]]",
                "[[INF,INF,INF],[-1,INF,INF],[0,INF,INF]]",
                "[[INF,INF,INF],[-1,INF,INF],[INF,INF,0]]",
                "[[INF,INF,INF],[-1,INF,INF],[INF,INF,INF],[0,0,0]]"
            ],
            "outputs": [
                "[[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]",
                "[[-1]]",
                "[[0]]",
                "[[INF]]",
                "[[1,0],[-1,1]]",
                "[[2,1,2],[-1,0,-1],[2,1,2]]",
                "[[0,1,2],[-1,1,2],[1,2,3]]",
                "[[2,1,2],[-1,2,3],[0,1,2]]",
                "[[3,2,1],[-1,2,1],[2,1,0]]",
                "[[3,2,1],[-1,2,1],[2,1,0],[0,0,0]]"
            ]
        }
    },
    null,
    {
        "title": "Word Abbreviation",
        "description": "You are given a dictionary of words. The abbreviation of a word is a concatenation of its first letter, the number of characters between the first and last letter, and its last letter. If a word has only two characters, then it is an abbreviation of itself. Implement the ValidWordAbbr class which has two methods: ValidWordAbbr(String[] dictionary) to initialize the object with a dictionary of words, and boolean isUnique(String word) to check if a given word is unique based on its abbreviation.",
        "example": "Example:\n\nValidWordAbbr validWordAbbr = new ValidWordAbbr([\"deer\", \"door\", \"cake\", \"card\"]);\nvalidWordAbbr.isUnique(\"dear\"); // returns false\nvalidWordAbbr.isUnique(\"cart\"); // returns true\nvalidWordAbbr.isUnique(\"cane\"); // returns false\nvalidWordAbbr.isUnique(\"make\"); // returns true\nvalidWordAbbr.isUnique(\"cake\"); // returns true",
        "level": "Medium",
        "tags": [
            "String",
            "Hash Table"
        ],
        "test_cases": {
            "inputs": [
                "[\"deer\", \"door\", \"cake\", \"card\"]",
                "\"dear\"",
                "\"cart\"",
                "\"cane\"",
                "\"make\"",
                "\"cake\"",
                "[\"internationalization\", \"abbreviation\", \"it\"]",
                "\"internationalization\"",
                "\"abbreviation\"",
                "\"it\"",
                "[\"apple\", \"banana\", \"cherry\", \"date\"]",
                "\"apple\"",
                "\"banana\"",
                "\"cherry\"",
                "\"date\"",
                "[\"hello\", \"world\", \"hello\", \"world\"]",
                "\"hello\"",
                "\"world\"",
                "\"hello\"",
                "\"world\"",
                "[\"a\", \"b\", \"c\", \"d\"]",
                "\"a\"",
                "\"b\"",
                "\"c\"",
                "\"d\"",
                "[\"abc\", \"def\", \"ghi\", \"jkl\"]",
                "\"abc\"",
                "\"def\"",
                "\"ghi\"",
                "\"jkl\""
            ],
            "outputs": [
                "null",
                "false",
                "true",
                "false",
                "true",
                "true",
                "false",
                "false",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true"
            ]
        }
    },
    null,
    {
        "title": "Pattern Matching",
        "description": "Given a pattern and a string, determine if the string follows the same pattern. Follow means a full match, such that there is a bijection between a letter in the pattern and a non-empty word in the string.",
        "example": "Example 1:\n\nInput: pattern = \"abba\", s = \"dog cat cat dog\"\nOutput: true\n\nExample 2:\n\nInput: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\n\nExample 3:\n\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false",
        "level": "Easy",
        "tags": [
            "string",
            "pattern matching"
        ],
        "test_cases": {
            "inputs": [
                "\"abba\", \"dog cat cat dog\"",
                "\"abba\", \"dog cat cat fish\"",
                "\"aaaa\", \"dog cat cat dog\"",
                "\"abc\", \"dog cat dog\"",
                "\"aabb\", \"dog dog cat cat\"",
                "\"abab\", \"dog cat dog cat\"",
                "\"a\", \"dog\"",
                "\"aa\", \"dog dog\"",
                "\"aaa\", \"dog dog dog\"",
                "\"a\", \"dog cat\""
            ],
            "outputs": [
                "true",
                "false",
                "false",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "false"
            ]
        }
    },
    {
        "title": "Pattern Matching",
        "description": "Given a pattern and a string, determine if the string matches the pattern. A string matches the pattern if there is a bijective mapping of single characters to strings such that replacing each character in the pattern with the corresponding string results in the given string. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.",
        "example": "Example:\n\nInput: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"",
        "level": "Medium",
        "tags": [
            "string",
            "mapping"
        ],
        "test_cases": {
            "inputs": [
                "\"abab\", \"redblueredblue\"",
                "\"aaaa\", \"asdasdasdasd\"",
                "\"aabb\", \"xyzabcxzyabc\"",
                "\"abc\", \"xyzabcxyz\"",
                "\"aabbcc\", \"xyzabcxyzabcxyz\"",
                "\"ababab\", \"redredredblueblueblue\"",
                "\"abba\", \"redbluebluered\"",
                "\"abcd\", \"wxyz\"",
                "\"a\", \"x\"",
                "\"ab\", \"xy\""
            ],
            "outputs": [
                "true",
                "true",
                "false",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true",
                "true"
            ]
        }
    },
    null,
    {
        "title": "Flip Game",
        "description": "You are playing a Flip Game with your friend. You are given a string `currentState` that contains only `'+'` and `'-'`. You and your friend take turns to flip **two consecutive** `'++'` into `'--'`. The game ends when a person can no longer make a move, and therefore the other person will be the winner. Return all possible states of the string `currentState` after **one valid move**. If there is no valid move, return an empty list `[]`.",
        "example": {
            "input": "++++",
            "output": [
                "--++",
                "+--+",
                "++--"
            ]
        },
        "level": "Easy",
        "tags": [
            "string",
            "game"
        ],
        "test_cases": {
            "inputs": [
                "++++",
                "++",
                "+",
                "----",
                "++--++",
                "++-+",
                "++-",
                "+++-",
                "++-++",
                "++-+++"
            ],
            "outputs": [
                [
                    "--++",
                    "+--+",
                    "++--"
                ],
                [
                    "--"
                ],
                [],
                [
                    "----"
                ],
                [
                    "--++--"
                ],
                [
                    "--+"
                ],
                [
                    "--"
                ],
                [
                    "++-"
                ],
                [
                    "--+++"
                ],
                [
                    "--++++"
                ]
            ]
        }
    },
    null,
    {
        "title": "Median Finder",
        "description": "Implement a class called MedianFinder that can find the median of a stream of integers. The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\n\nThe MedianFinder class should have the following methods:\n\n- `MedianFinder()`: Initializes the MedianFinder object.\n- `void addNum(int num)`: Adds the integer num from the data stream to the data structure.\n- `double findMedian()`: Returns the median of all elements so far. Answers within 10^-5 of the actual answer will be accepted.",
        "example": "Example:\n\nInput:\nMedianFinder mf = new MedianFinder();\nmf.addNum(1);\nmf.addNum(2);\nmf.findMedian(); // Output: 1.5\nmf.addNum(3);\nmf.findMedian(); // Output: 2.0",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "MedianFinder mf = new MedianFinder();\nmf.addNum(1);\nmf.addNum(2);\nmf.findMedian();",
                "MedianFinder mf = new MedianFinder();\nmf.addNum(1);\nmf.addNum(2);\nmf.addNum(3);\nmf.findMedian();",
                "MedianFinder mf = new MedianFinder();\nmf.addNum(1);\nmf.addNum(2);\nmf.addNum(3);\nmf.addNum(4);\nmf.findMedian();",
                "MedianFinder mf = new MedianFinder();\nmf.addNum(1);\nmf.addNum(2);\nmf.addNum(3);\nmf.addNum(4);\nmf.addNum(5);\nmf.findMedian();",
                "MedianFinder mf = new MedianFinder();\nmf.addNum(5);\nmf.addNum(4);\nmf.addNum(3);\nmf.addNum(2);\nmf.addNum(1);\nmf.findMedian();",
                "MedianFinder mf = new MedianFinder();\nmf.addNum(1);\nmf.addNum(3);\nmf.addNum(2);\nmf.findMedian();",
                "MedianFinder mf = new MedianFinder();\nmf.addNum(1);\nmf.addNum(3);\nmf.addNum(2);\nmf.addNum(4);\nmf.findMedian();",
                "MedianFinder mf = new MedianFinder();\nmf.addNum(1);\nmf.addNum(3);\nmf.addNum(2);\nmf.addNum(4);\nmf.addNum(5);\nmf.findMedian();",
                "MedianFinder mf = new MedianFinder();\nmf.addNum(5);\nmf.addNum(4);\nmf.addNum(3);\nmf.addNum(2);\nmf.addNum(1);\nmf.findMedian();",
                "MedianFinder mf = new MedianFinder();\nmf.addNum(1);\nmf.addNum(2);\nmf.addNum(3);\nmf.addNum(4);\nmf.addNum(5);\nmf.addNum(6);\nmf.findMedian();"
            ],
            "outputs": [
                "1.5",
                "2.0",
                "2.5",
                "3.0",
                "3.0",
                "2.0",
                "2.5",
                "3.0",
                "3.0",
                "3.5"
            ]
        }
    },
    null,
    {
        "title": "Serialize and Deserialize Binary Tree",
        "description": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.",
        "example": "Example 1:\n\nInput: root = [1,2,3,null,null,4,5]\nOutput: [1,2,3,null,null,4,5]\n\nExample 2:\n\nInput: root = []\nOutput: []",
        "level": "Medium",
        "tags": [
            "binary tree",
            "serialization",
            "deserialization"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3,null,null,4,5]",
                "[]",
                "[1]",
                "[1,2]",
                "[1,null,2]",
                "[1,2,3,4,null,null,5]",
                "[1,2,3,null,4,null,5]",
                "[1,null,2,null,3,null,4,null,5]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]",
                "[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9,null,10,null,11,null,12,null,13,null,14,null,15]"
            ],
            "outputs": [
                "[1,2,3,null,null,4,5]",
                "[]",
                "[1]",
                "[1,2]",
                "[1,null,2]",
                "[1,2,3,4,null,null,5]",
                "[1,2,3,null,4,null,5]",
                "[1,null,2,null,3,null,4,null,5]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]",
                "[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9,null,10,null,11,null,12,null,13,null,14,null,15]"
            ]
        }
    },
    null,
    null,
    null,
    null,
    {
        "title": "Smallest Rectangle Enclosing Black Pixels",
        "description": "You are given an `m x n` binary matrix `image` where `0` represents a white pixel and `1` represents a black pixel. The black pixels are connected (i.e., there is only one black region). Pixels are connected horizontally and vertically. Given two integers `x` and `y` that represent the location of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels. You must write an algorithm with less than `O(mn)` runtime complexity.",
        "example": "Example:\n\nInput: image = [[\"0\", \"0\", \"1\", \"0\"],[\"0\", \"1\", \"1\", \"0\"],[\"0\", \"1\", \"0\", \"0\"]], x = 0, y = 2\nOutput: 6\n\nInput: image = [[\"1\"]], x = 0, y = 0\nOutput: 1",
        "level": "Medium",
        "tags": [
            "matrix",
            "binary",
            "rectangle"
        ],
        "test_cases": {
            "inputs": [
                {
                    "image": [
                        [
                            "0",
                            "0",
                            "1",
                            "0"
                        ],
                        [
                            "0",
                            "1",
                            "1",
                            "0"
                        ],
                        [
                            "0",
                            "1",
                            "0",
                            "0"
                        ]
                    ],
                    "x": 0,
                    "y": 2
                },
                {
                    "image": [
                        [
                            "1"
                        ]
                    ],
                    "x": 0,
                    "y": 0
                },
                {
                    "image": [
                        [
                            "0",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "0",
                            "1",
                            "1",
                            "0"
                        ],
                        [
                            "0",
                            "1",
                            "1",
                            "0"
                        ],
                        [
                            "0",
                            "0",
                            "0",
                            "0"
                        ]
                    ],
                    "x": 1,
                    "y": 1
                },
                {
                    "image": [
                        [
                            "1",
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "1",
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "1",
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "1",
                            "1",
                            "1",
                            "1"
                        ]
                    ],
                    "x": 2,
                    "y": 3
                },
                {
                    "image": [
                        [
                            "0",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "0",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "0",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "0",
                            "0",
                            "0",
                            "0"
                        ]
                    ],
                    "x": 3,
                    "y": 2
                },
                {
                    "image": [
                        [
                            "1",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "0",
                            "1",
                            "0",
                            "0"
                        ],
                        [
                            "0",
                            "0",
                            "1",
                            "0"
                        ],
                        [
                            "0",
                            "0",
                            "0",
                            "1"
                        ]
                    ],
                    "x": 1,
                    "y": 1
                },
                {
                    "image": [
                        [
                            "1",
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "1",
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "1",
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "1",
                            "1",
                            "1",
                            "1"
                        ]
                    ],
                    "x": 0,
                    "y": 0
                },
                {
                    "image": [
                        [
                            "0",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "0",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "0",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "0",
                            "0",
                            "0",
                            "0"
                        ]
                    ],
                    "x": 2,
                    "y": 3
                },
                {
                    "image": [
                        [
                            "1",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "0",
                            "1",
                            "0",
                            "0"
                        ],
                        [
                            "0",
                            "0",
                            "1",
                            "0"
                        ],
                        [
                            "0",
                            "0",
                            "0",
                            "1"
                        ]
                    ],
                    "x": 3,
                    "y": 2
                },
                {
                    "image": [
                        [
                            "1",
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "1",
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "1",
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "1",
                            "1",
                            "1",
                            "1"
                        ]
                    ],
                    "x": 1,
                    "y": 1
                }
            ],
            "outputs": [
                6,
                1,
                4,
                16,
                0,
                4,
                16,
                0,
                4,
                4
            ]
        }
    },
    {
        "title": "Sum Range of Integer Array",
        "description": "You are given an integer array `nums` and you need to handle multiple queries of the following type: Calculate the sum of the elements of `nums` between indices `left` and `right` inclusive, where `left <= right`. Implement the `NumArray` class with the following methods: \n\n- `NumArray(int[] nums)`: Initializes the object with the integer array `nums`. \n- `int sumRange(int left, int right)`: Returns the sum of the elements of `nums` between indices `left` and `right` inclusive (i.e. `nums[left] + nums[left + 1] + ... + nums[right]`).",
        "example": "Example:\n\nInput:\nNumArray([-2, 0, 3, -5, 2, -1])\nsumRange(0, 2)\nsumRange(2, 5)\nsumRange(0, 5)\n\nOutput:\nnull\n1\n-1\n-3\n\nExplanation:\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // returns (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // returns 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // returns (-2) + 0 + 3 + (-5) + 2 + (-1) = -3",
        "level": "Medium",
        "tags": [
            "array",
            "prefix sum"
        ],
        "test_cases": {
            "inputs": [
                "[[1, 2, 3, 4, 5]]",
                "[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]",
                "[[5, 10, 15, 20, 25, 30, 35, 40, 45, 50]]",
                "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]",
                "[[1, -2, 3, -4, 5, -6, 7, -8, 9, -10]]",
                "[[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]]",
                "[[100, 200, 300, 400, 500, 600, 700, 800, 900, 1000]]",
                "[[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]",
                "[[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]]",
                "[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]"
            ],
            "outputs": [
                "null",
                "15",
                "275",
                "0",
                "-2",
                "550",
                "5500",
                "10",
                "110",
                "45"
            ]
        }
    },
    {
        "title": "Matrix Sum",
        "description": "You are given a 2D matrix `matrix` and you need to handle multiple queries of the following type: Calculate the sum of the elements of `matrix` inside the rectangle defined by its upper left corner `(row1, col1)` and lower right corner `(row2, col2)`. Implement the `NumMatrix` class with the following methods: `NumMatrix(int[][] matrix)` to initialize the object with the integer matrix `matrix`, and `int sumRegion(int row1, int col1, int row2, int col2)` to return the sum of the elements inside the specified rectangle. Your implementation should have a time complexity of O(1) for the `sumRegion` method.",
        "example": "Example:\n\nInput:\nNumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]])\nsumRegion(2, 1, 4, 3) // Output: 8\nsumRegion(1, 1, 2, 2) // Output: 11\nsumRegion(1, 2, 2, 4) // Output: 12",
        "level": "Medium",
        "tags": [
            "matrix",
            "2D array",
            "sum"
        ],
        "test_cases": {
            "inputs": [
                "[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]]",
                "[[2, 1, 4, 3]]",
                "[[1, 1, 2, 2]]",
                "[[1, 2, 2, 4]]"
            ],
            "outputs": [
                "null",
                "8",
                "11",
                "12"
            ]
        }
    },
    null,
    {
        "title": "Additive Number",
        "description": "An additive number is a string whose digits can form an additive sequence. A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two. Given a string containing only digits, return true if it is an additive number or false otherwise. Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.",
        "example": "Example 1:\n\nInput: \"112358\"\nOutput: true\nExplanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8. 1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\n\nExample 2:\n\nInput: \"199100199\"\nOutput: true\nExplanation: The additive sequence is: 1, 99, 100, 199. 1 + 99 = 100, 99 + 100 = 199",
        "level": "Medium",
        "tags": [
            "string",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                "\"112358\"",
                "\"199100199\"",
                "\"123456789\"",
                "\"101\"",
                "\"111\"",
                "\"123\"",
                "\"100200300\"",
                "\"123581321345\"",
                "\"987654321\"",
                "\"1234567890987654321\""
            ],
            "outputs": [
                "true",
                "true",
                "false",
                "true",
                "false",
                "false",
                "true",
                "true",
                "false",
                "true"
            ]
        }
    },
    null,
    null,
    null,
    {
        "title": "Minimum Height Trees",
        "description": "Given a tree with `n` nodes labelled from 0 to n-1, and an array of n-1 edges where edges[i] = [ai, bi] indicates an undirected edge between nodes ai and bi in the tree. Choose any node as the root and find the minimum height trees (MHTs) by returning a list of root labels. The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.",
        "example": "Example 1:\n\nInput: n = 4, edges = [[1,0],[1,2],[1,3]]\nOutput: [1]\nExplanation: The height of the tree is 1 when the root is the node with label 1, which is the only MHT.\n\nExample 2:\n\nInput: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]\nOutput: [3,4]",
        "level": "Medium",
        "tags": [
            "Graph",
            "Tree"
        ],
        "test_cases": {
            "inputs": [
                {
                    "n": 4,
                    "edges": [
                        [
                            1,
                            0
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            1,
                            3
                        ]
                    ]
                },
                {
                    "n": 6,
                    "edges": [
                        [
                            3,
                            0
                        ],
                        [
                            3,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            5,
                            4
                        ]
                    ]
                },
                {
                    "n": 5,
                    "edges": [
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            3,
                            4
                        ]
                    ]
                },
                {
                    "n": 8,
                    "edges": [
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            1,
                            4
                        ],
                        [
                            2,
                            5
                        ],
                        [
                            2,
                            6
                        ],
                        [
                            4,
                            7
                        ]
                    ]
                },
                {
                    "n": 10,
                    "edges": [
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            1,
                            4
                        ],
                        [
                            2,
                            5
                        ],
                        [
                            2,
                            6
                        ],
                        [
                            3,
                            7
                        ],
                        [
                            3,
                            8
                        ],
                        [
                            4,
                            9
                        ]
                    ]
                },
                {
                    "n": 3,
                    "edges": [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ]
                    ]
                },
                {
                    "n": 7,
                    "edges": [
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            1,
                            4
                        ],
                        [
                            2,
                            5
                        ],
                        [
                            2,
                            6
                        ]
                    ]
                },
                {
                    "n": 2,
                    "edges": [
                        [
                            0,
                            1
                        ]
                    ]
                },
                {
                    "n": 9,
                    "edges": [
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            1,
                            4
                        ],
                        [
                            2,
                            5
                        ],
                        [
                            2,
                            6
                        ],
                        [
                            3,
                            7
                        ],
                        [
                            4,
                            8
                        ]
                    ]
                },
                {
                    "n": 1,
                    "edges": []
                }
            ],
            "outputs": [
                [
                    1
                ],
                [
                    3,
                    4
                ],
                [
                    0
                ],
                [
                    0
                ],
                [
                    1,
                    2
                ],
                [
                    1
                ],
                [
                    0,
                    1,
                    2
                ],
                [
                    0
                ],
                [
                    0
                ],
                [
                    0
                ]
            ]
        }
    },
    null,
    {
        "title": "Burst Balloons",
        "description": "You are given `n` balloons, indexed from `0` to `n - 1`. Each balloon is painted with a number on it represented by an array `nums`. You are asked to burst all the balloons.\n\nIf you burst the `ith` balloon, you will get `nums[i - 1] * nums[i] * nums[i + 1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array, then treat it as if there is a balloon with a `1` painted on it.\n\nReturn the maximum coins you can collect by bursting the balloons wisely.",
        "example": "Example:\n\nInput: nums = [3,1,5,8]\nOutput: 167\nExplanation:\nnums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []\ncoins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                "[3,1,5,8]",
                "[1,5]",
                "[2,4,6,8]",
                "[9,7,5,3,1]",
                "[1,2,3,4,5]",
                "[5,4,3,2,1]",
                "[1,1,1,1,1]",
                "[2,2,2,2,2]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[10,9,8,7,6,5,4,3,2,1]"
            ],
            "outputs": [
                "167",
                "10",
                "160",
                "165",
                "110",
                "110",
                "5",
                "20",
                "945",
                "945"
            ]
        }
    },
    null,
    {
        "title": "Vertical Order Traversal of Binary Tree",
        "description": "Given the root of a binary tree, return the vertical order traversal of its nodes' values. If two nodes are in the same row and column, the order should be from left to right.",
        "example": "Example 1:\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[9],[3,15],[20],[7]]\n\nExample 2:\n\nInput: root = [3,9,8,4,0,1,7]\nOutput: [[4],[9],[3,0,1],[8],[7]]\n\nExample 3:\n\nInput: root = [3,9,8,4,0,1,7,null,null,null,2,5]\nOutput: [[4],[9,5],[3,0,1],[8,2],[7]]",
        "level": "Medium",
        "tags": [
            "binary tree",
            "traversal"
        ],
        "test_cases": {
            "inputs": [
                "[3,9,20,null,null,15,7]",
                "[3,9,8,4,0,1,7]",
                "[3,9,8,4,0,1,7,null,null,null,2,5]",
                "[]",
                "[1]",
                "[1,2]",
                "[1,null,2]",
                "[1,2,3]",
                "[1,2,3,4,5,6,7]",
                "[1,2,3,4,5,6,7,null,null,null,null,null,null,8]"
            ],
            "outputs": [
                "[[9],[3,15],[20],[7]]",
                "[[4],[9],[3,0,1],[8],[7]]",
                "[[4],[9,5],[3,0,1],[8,2],[7]]",
                "[]",
                "[[1]]",
                "[[2],[1]]",
                "[[1],[2]]",
                "[[4],[2],[1,5,6],[3],[7]]",
                "[[4],[2],[1,5,6],[3],[7,8]]"
            ]
        }
    },
    null,
    {
        "title": "Smallest Subsequence of Distinct Characters",
        "description": "Given a string `s`, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.",
        "example": "Example 1:\n\nInput: s = \"bcabc\"\nOutput: \"abc\"\n\nExample 2:\n\nInput: s = \"cbacdcbc\"\nOutput: \"acdb\"",
        "level": "Medium",
        "tags": [
            "string",
            "stack",
            "greedy"
        ],
        "test_cases": {
            "inputs": [
                "\"bcabc\"",
                "\"cbacdcbc\"",
                "\"abcabc\"",
                "\"cba\"",
                "\"aaabbbccc\"",
                "\"abcd\"",
                "\"dcba\"",
                "\"aaaaa\"",
                "\"aabbb\"",
                "\"xyzxyz\""
            ],
            "outputs": [
                "\"abc\"",
                "\"acdb\"",
                "\"abc\"",
                "\"acb\"",
                "\"abc\"",
                "\"abcd\"",
                "\"abcd\"",
                "\"a\"",
                "\"ab\"",
                "\"xyz\""
            ]
        }
    },
    {
        "title": "Shortest Travel Distance",
        "description": "You are given an m x n grid of values 0, 1, or 2, where each 0 marks an empty land that you can pass by freely, each 1 marks a building that you cannot pass through, and each 2 marks an obstacle that you cannot pass through. You want to build a house on an empty land that reaches all buildings in the shortest total travel distance. You can only move up, down, left, and right. Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1. The total travel distance is the sum of the distances between the houses of the friends and the meeting point. The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.",
        "example": "Example:\n\nInput: grid = [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]\nOutput: 7\nExplanation: Given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2). The point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal. So return 7.",
        "level": "Medium",
        "tags": [
            "grid",
            "manhattan distance"
        ],
        "test_cases": {
            "inputs": [
                "[[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]",
                "[[1,0]]",
                "[[1]]",
                "[[0,0,0],[0,0,0],[0,0,0]]",
                "[[1,1,1],[1,1,1],[1,1,1]]",
                "[[0,0,0],[0,1,0],[0,0,0]]",
                "[[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]",
                "[[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]]",
                "[[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,1]]",
                "[[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,1],[0,0,0,0,0]]"
            ],
            "outputs": [
                "7",
                "1",
                "-1",
                "0",
                "-1",
                "3",
                "-1",
                "-1",
                "-1",
                "-1"
            ]
        }
    },
    {
        "title": "Maximum Product of Word Lengths",
        "description": "Given a string array `words`, find the maximum value of `length(word[i]) * length(word[j])` where the two words do not share common letters. If no such two words exist, return 0.",
        "example": "Example 1:\n\nInput: words = [\"abcw\", \"baz\", \"foo\", \"bar\", \"xtfn\", \"abcdef\"]\nOutput: 16\nExplanation: The two words can be \"abcw\" and \"xtfn\".\n\nExample 2:\n\nInput: words = [\"a\", \"ab\", \"abc\", \"d\", \"cd\", \"bcd\", \"abcd\"]\nOutput: 4\nExplanation: The two words can be \"ab\" and \"cd\".\n\nExample 3:\n\nInput: words = [\"a\", \"aa\", \"aaa\", \"aaaa\"]\nOutput: 0\nExplanation: No such pair of words.",
        "level": "Medium",
        "tags": [
            "array",
            "string"
        ],
        "test_cases": {
            "inputs": [
                "[\"abcw\", \"baz\", \"foo\", \"bar\", \"xtfn\", \"abcdef\"]",
                "[\"a\", \"ab\", \"abc\", \"d\", \"cd\", \"bcd\", \"abcd\"]",
                "[\"a\", \"aa\", \"aaa\", \"aaaa\"]",
                "[\"abc\", \"def\", \"ghi\", \"jkl\"]",
                "[\"abcd\", \"efgh\", \"ijkl\", \"mnop\"]",
                "[\"abc\", \"def\", \"ghi\", \"jkl\", \"mnop\"]",
                "[\"a\", \"b\", \"c\", \"d\", \"e\"]",
                "[\"a\", \"aa\", \"aaa\", \"aaaa\", \"aaaaa\"]",
                "[\"abc\", \"def\", \"ghi\", \"jkl\", \"mnop\", \"qrst\"]",
                "[\"a\", \"ab\", \"abc\", \"abcd\", \"abcde\", \"abcdef\"]"
            ],
            "outputs": [
                "16",
                "4",
                "0",
                "9",
                "16",
                "16",
                "0",
                "0",
                "16",
                "16"
            ]
        }
    },
    {
        "title": "Bulb Switcher",
        "description": "There are `n` bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.\n\nOn the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the `ith` round, you toggle every `i` bulb. For the `nth` round, you only toggle the last bulb.\n\nReturn the number of bulbs that are on after `n` rounds.",
        "example": "Example 1:\n\nInput: n = 3\nOutput: 1\nExplanation: At first, the three bulbs are [off, off, off].\nAfter the first round, the three bulbs are [on, on, on].\nAfter the second round, the three bulbs are [on, off, on].\nAfter the third round, the three bulbs are [on, off, off].\nSo you should return 1 because there is only one bulb is on.\n\nExample 2:\n\nInput: n = 0\nOutput: 0\n\nExample 3:\n\nInput: n = 1\nOutput: 1",
        "level": "Easy",
        "tags": [
            "math"
        ],
        "test_cases": {
            "inputs": [
                "0",
                "1",
                "2",
                "3",
                "5",
                "10",
                "100",
                "1000",
                "10000",
                "100000"
            ],
            "outputs": [
                "0",
                "1",
                "1",
                "1",
                "2",
                "3",
                "10",
                "31",
                "100",
                "316"
            ]
        }
    },
    {
        "title": "Generalized Abbreviations",
        "description": "Given a word, generate all possible generalized abbreviations by replacing non-overlapping and non-adjacent substrings with their respective lengths.",
        "example": "Example 1:\n\nInput: word = \"word\"\nOutput: [\"4\",\"3d\",\"2r1\",\"2rd\",\"1o2\",\"1o1d\",\"1or1\",\"1ord\",\"w3\",\"w2d\",\"w1r1\",\"w1rd\",\"wo2\",\"wo1d\",\"wor1\",\"word\"]\n\nExample 2:\n\nInput: word = \"a\"\nOutput: [\"1\",\"a\"]",
        "level": "Medium",
        "tags": [
            "String",
            "Backtracking"
        ],
        "test_cases": {
            "inputs": [
                "\"word\"",
                "\"a\"",
                "\"abcde\"",
                "\"programming\"",
                "\"leetcode\"",
                "\"algorithm\"",
                "\"python\"",
                "\"coding\"",
                "\"challenge\"",
                "\"solution\""
            ],
            "outputs": [
                "[\"4\",\"3d\",\"2r1\",\"2rd\",\"1o2\",\"1o1d\",\"1or1\",\"1ord\",\"w3\",\"w2d\",\"w1r1\",\"w1rd\",\"wo2\",\"wo1d\",\"wor1\",\"word\"]",
                "[\"1\",\"a\"]",
                "[\"5\",\"4e\",\"3d1\",\"3d\",\"2r2\",\"2r1e\",\"2r1\",\"2rd\",\"1o3\",\"1o2e\",\"1o2\",\"1o1d2\",\"1o1d1e\",\"1o1d1\",\"1o1de\",\"1or2\",\"1or1e\",\"1or1\",\"1ord1\",\"1orde\",\"w4\",\"w3e\",\"w2d2\",\"w2d1e\",\"w2d1\",\"w2de\",\"w1r2\",\"w1r1e\",\"w1r1\",\"w1rd1\",\"w1rde\",\"wo3\",\"wo2e\",\"wo1d2\",\"wo1d1e\",\"wo1d1\",\"wo1de\",\"wor2\",\"wor1e\",\"wor1\",\"word1\",\"worde\"]",
                "[\"11\",\"10g\",\"9i\",\"8m\",\"7i1\",\"7i\",\"6n2\",\"6n1g\",\"6n1\",\"6ng\",\"5r3\",\"5r2g\",\"5r2\",\"5rg\",\"4a4\",\"4a3g\",\"4a3\",\"4ag\",\"3p5\",\"3p4g\",\"3p4\",\"3pg\",\"2r8\",\"2r7g\",\"2r7\",\"2rg\",\"1o10\",\"1o9g\",\"1o9\",\"1og\",\"0r11\",\"0r10g\",\"0r10\",\"0rg\",\"programming\"]",
                "[\"9\",\"8e\",\"7t\",\"6c\",\"5o\",\"4d\",\"3e\",\"2e1\",\"2e\",\"1t7\",\"1t6e\",\"1t6\",\"1te\",\"0l8\",\"0l7e\",\"0l7\",\"0le\",\"9c\",\"8o\",\"7d\",\"6i\",\"5n\",\"4g\",\"3l\",\"2e\",\"1e1\",\"1e\",\"0t\",\"leetcode\"]",
                "[\"9\",\"8m\",\"7i\",\"6t\",\"5h\",\"4m\",\"3a\",\"2l\",\"1g\",\"0r\",\"algorithm\"]",
                "[\"6\",\"5n\",\"4o\",\"3h\",\"2t\",\"1y\",\"0p\",\"python\"]",
                "[\"6\",\"5g\",\"4n\",\"3i\",\"2d\",\"1o\",\"0c\",\"coding\"]",
                "[\"9\",\"8e\",\"7g\",\"6n\",\"5i\",\"4l\",\"3l\",\"2e\",\"1c\",\"0h\",\"challenge\"]",
                "[\"8\",\"7n\",\"6o\",\"5i\",\"4t\",\"3u\",\"2l\",\"1o\",\"0i\",\"solution\"]"
            ]
        }
    },
    {
        "title": "Maximum Number from Two Arrays",
        "description": "Given two integer arrays `nums1` and `nums2` of lengths `m` and `n` respectively. `nums1` and `nums2` represent the digits of two numbers. You are also given an integer `k`. Create the maximum number of length `k <= m + n` from digits of the two numbers. The relative order of the digits from the same array must be preserved. Return an array of the `k` digits representing the answer.",
        "example": "Example 1:\n\nInput: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5\nOutput: [9,8,6,5,3]\n\nExample 2:\n\nInput: nums1 = [6,7], nums2 = [6,0,4], k = 5\nOutput: [6,7,6,0,4]\n\nExample 3:\n\nInput: nums1 = [3,9], nums2 = [8,9], k = 3\nOutput: [9,8,9]",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "[3,4,6,5]",
                "[9,1,2,5,8,3]",
                "[6,7]",
                "[6,0,4]",
                "[3,9]",
                "[8,9]",
                "[1,2,3,4,5]",
                "[9,8,7,6,5]",
                "[0,0,0,0,0]",
                "[1,2,3,4,5,6,7,8,9]",
                "[9,8,7,6,5,4,3,2,1]",
                "[1,3,5,7,9]",
                "[2,4,6,8,0]",
                "[1,2,3,4,5,6,7,8,9]",
                "[9,8,7,6,5,4,3,2,1]",
                "[1,2,3,4,5,6,7,8,9]",
                "[9,8,7,6,5,4,3,2,1]",
                "[1,2,3,4,5,6,7,8,9]",
                "[9,8,7,6,5,4,3,2,1]"
            ],
            "outputs": [
                "[9,8,6,5,3]",
                "[6,7,6,0,4]",
                "[9,8,9]",
                "[9,8,7,6,5]",
                "[9,8,7,6,5,4,3,2,1]",
                "[9,8,7,6,5,4,3,2,1]",
                "[5,4,3,2,1]",
                "[9,8,7,6,5]",
                "[0,0,0,0,0]",
                "[9,8,7,6,5,4,3,2,1]",
                "[9,8,7,6,5,4,3,2,1]",
                "[9,8,7,6,5,4,3,2,1]",
                "[9,8,7,6,5,4,3,2,1]",
                "[9,8,7,6,5,4,3,2,1]",
                "[9,8,7,6,5,4,3,2,1]",
                "[9,8,7,6,5,4,3,2,1]",
                "[9,8,7,6,5,4,3,2,1]",
                "[9,8,7,6,5,4,3,2,1]"
            ]
        }
    },
    {
        "title": "Fewest Coins",
        "description": "Given an array of coins representing different denominations and a total amount of money, find the fewest number of coins needed to make up that amount. If it is not possible to make up the amount with the given coins, return -1. You can assume that you have an infinite number of each kind of coin.",
        "example": "Example 1:\n\nInput: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\n\nExample 2:\n\nInput: coins = [2], amount = 3\nOutput: -1\n\nExample 3:\n\nInput: coins = [1], amount = 0\nOutput: 0",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,5]",
                "[2]",
                "[1]",
                "[1,2,5,10,20,50,100,200,500,1000,2000,5000]",
                "[1,2,5,10,20,50,100,200,500,1000,2000,5000]",
                "[1,2,5,10,20,50,100,200,500,1000,2000,5000]",
                "[1,2,5,10,20,50,100,200,500,1000,2000,5000]",
                "[1,2,5,10,20,50,100,200,500,1000,2000,5000]",
                "[1,2,5,10,20,50,100,200,500,1000,2000,5000]",
                "[1,2,5,10,20,50,100,200,500,1000,2000,5000]"
            ],
            "outputs": [
                "3",
                "-1",
                "0",
                "1",
                "2",
                "3",
                "4",
                "5",
                "6",
                "7"
            ]
        }
    },
    null,
    null,
    {
        "title": "Maximum Length of Subarray with Sum Equals to K",
        "description": "Given an integer array `nums` and an integer `k`, return the maximum length of a subarray that sums to `k`. If there is not one, return `0` instead.",
        "example": "Example 1:\n\nInput: nums = [1,-1,5,-2,3], k = 3\nOutput: 4\nExplanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest.\n\nExample 2:\n\nInput: nums = [-2,-1,2,1], k = 1\nOutput: 2\nExplanation: The subarray [-1, 2] sums to 1 and is the longest.",
        "level": "Medium",
        "tags": [
            "array",
            "subarray",
            "sum"
        ],
        "test_cases": {
            "inputs": [
                "[1,-1,5,-2,3]",
                "[-2,-1,2,1]",
                "[1,2,3,4,5]",
                "[-1,-2,-3,-4,-5]",
                "[0,0,0,0,0]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]"
            ],
            "outputs": [
                "4",
                "2",
                "0",
                "0",
                "5",
                "0",
                "0",
                "0",
                "0",
                "0"
            ]
        }
    },
    {
        "title": "Power of Three",
        "description": "Given an integer `n`, determine if it is a power of three. Return `true` if `n` is a power of three, otherwise return `false`.\n\nAn integer `n` is a power of three if there exists an integer `x` such that `n == 3^x`.",
        "example": "Example 1:\n\nInput: n = 27\nOutput: true\nExplanation: 27 = 3^3\n\nExample 2:\n\nInput: n = 0\nOutput: false\nExplanation: 0 is not a power of three.\n\nExample 3:\n\nInput: n = -1\nOutput: false\nExplanation: -1 is not a power of three.",
        "level": "Easy",
        "tags": [
            "math"
        ],
        "test_cases": {
            "inputs": [
                "27",
                "0",
                "-1",
                "1",
                "9",
                "45",
                "81",
                "100",
                "243",
                "1000"
            ],
            "outputs": [
                "true",
                "false",
                "false",
                "true",
                "true",
                "false",
                "true",
                "false",
                "true",
                "false"
            ]
        }
    },
    {
        "title": "Range Sum Count",
        "description": "Given an integer array `nums` and two integers `lower` and `upper`, return the number of range sums that lie in `[lower, upper]` inclusive. Range sum `S(i, j)` is defined as the sum of the elements in `nums` between indices `i` and `j` inclusive, where `i <= j`.",
        "example": "Example 1:\n\nInput: nums = [-2,5,-1], lower = -2, upper = 2\nOutput: 3\nExplanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.\n\nExample 2:\n\nInput: nums = [0], lower = 0, upper = 0\nOutput: 1",
        "level": "Medium",
        "tags": [
            "array",
            "prefix sum",
            "range sum"
        ],
        "test_cases": {
            "inputs": [
                {
                    "nums": [
                        -2,
                        5,
                        -1
                    ],
                    "lower": -2,
                    "upper": 2
                },
                {
                    "nums": [
                        0
                    ],
                    "lower": 0,
                    "upper": 0
                },
                {
                    "nums": [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    "lower": 5,
                    "upper": 10
                },
                {
                    "nums": [
                        -1,
                        -2,
                        -3,
                        -4,
                        -5
                    ],
                    "lower": -10,
                    "upper": -5
                },
                {
                    "nums": [
                        10,
                        20,
                        30,
                        40,
                        50
                    ],
                    "lower": 15,
                    "upper": 45
                },
                {
                    "nums": [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    "lower": 0,
                    "upper": 10
                },
                {
                    "nums": [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    "lower": -10,
                    "upper": 10
                },
                {
                    "nums": [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    "lower": -10,
                    "upper": -5
                },
                {
                    "nums": [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    "lower": 15,
                    "upper": 20
                },
                {
                    "nums": [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    "lower": 6,
                    "upper": 10
                }
            ],
            "outputs": [
                3,
                1,
                0,
                5,
                4,
                15,
                15,
                0,
                0,
                0
            ]
        }
    },
    {
        "title": "Reorder Linked List",
        "description": "Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list. The first node is considered odd, and the second node is even, and so on. Note that the relative order inside both the even and odd groups should remain as it was in the input. You must solve the problem in O(1) extra space complexity and O(n) time complexity.",
        "example": "Example 1:\n\nInput: head = [1,2,3,4,5]\nOutput: [1,3,5,2,4]\n\nExample 2:\n\nInput: head = [2,1,3,5,6,4,7]\nOutput: [2,3,6,7,1,5,4]",
        "level": "Medium",
        "tags": [
            "linked list"
        ],
        "test_cases": {
            "inputs": [
                "[1,2,3,4,5]",
                "[2,1,3,5,6,4,7]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[2,4,6,8,10]",
                "[1,3,5,7,9]",
                "[1]",
                "[]",
                "[1,2]",
                "[2,1]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]"
            ],
            "outputs": [
                "[1,3,5,2,4]",
                "[2,3,6,7,1,5,4]",
                "[1,3,5,7,9,2,4,6,8,10]",
                "[2,6,10,4,8]",
                "[1,5,9,3,7]",
                "[1]",
                "[]",
                "[1,2]",
                "[2,1]",
                "[1,3,5,7,9,11,13,15,2,4,6,8,10,12,14]"
            ]
        }
    },
    null,
    null,
    null,
    {
        "title": "Reconstruct Itinerary",
        "description": "You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and arrival airports of one flight. Reconstruct the itinerary in order and return it.\n\nAll of the tickets belong to a man who departs from 'JFK', thus, the itinerary must begin with 'JFK'. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\n\nFor example, the itinerary ['JFK', 'LGA'] has a smaller lexical order than ['JFK', 'LGB'].\n\nYou may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.",
        "example": "Example 1:\n\nInput: tickets = [['MUC', 'LHR'],['JFK', 'MUC'],['SFO', 'SJC'],['LHR', 'SFO']]\nOutput: ['JFK', 'MUC', 'LHR', 'SFO', 'SJC']\n\nExample 2:\n\nInput: tickets = [['JFK', 'SFO'],['JFK', 'ATL'],['SFO', 'ATL'],['ATL', 'JFK'],['ATL', 'SFO']]\nOutput: ['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO']\nExplanation: Another possible reconstruction is ['JFK', 'SFO', 'ATL', 'JFK', 'ATL', 'SFO'] but it is larger in lexical order.",
        "level": "Medium",
        "tags": [
            "graph",
            "depth-first search",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "[['MUC', 'LHR'],['JFK', 'MUC'],['SFO', 'SJC'],['LHR', 'SFO']]",
                "[['JFK', 'SFO'],['JFK', 'ATL'],['SFO', 'ATL'],['ATL', 'JFK'],['ATL', 'SFO']]",
                "[['JFK', 'LGA'],['LGA', 'LGB'],['LGB', 'JFK']]",
                "[['JFK', 'SFO'],['SFO', 'JFK'],['JFK', 'SFO']]",
                "[['JFK', 'LGA'],['LGA', 'JFK'],['JFK', 'LGA']]",
                "[['JFK', 'LGA'],['LGA', 'JFK'],['JFK', 'LGB'],['LGB', 'JFK']]",
                "[['JFK', 'LGA'],['LGA', 'JFK'],['JFK', 'LGB'],['LGB', 'LGA'],['LGA', 'JFK']]",
                "[['JFK', 'LGA'],['LGA', 'JFK'],['JFK', 'LGB'],['LGB', 'LGA'],['LGA', 'LGB'],['LGB', 'JFK']]",
                "[['JFK', 'LGA'],['LGA', 'JFK'],['JFK', 'LGB'],['LGB', 'LGA'],['LGA', 'LGB'],['LGB', 'LGA'],['LGA', 'JFK']]",
                "[['JFK', 'LGA'],['LGA', 'JFK'],['JFK', 'LGB'],['LGB', 'LGA'],['LGA', 'LGB'],['LGB', 'LGA'],['LGA', 'LGB'],['LGB', 'JFK']]"
            ],
            "outputs": [
                "['JFK', 'MUC', 'LHR', 'SFO', 'SJC']",
                "['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO']",
                "['JFK', 'LGA', 'LGB', 'JFK']",
                "['JFK', 'SFO', 'JFK', 'SFO']",
                "['JFK', 'LGA', 'JFK', 'LGA']",
                "['JFK', 'LGA', 'JFK', 'LGB', 'JFK']",
                "['JFK', 'LGA', 'JFK', 'LGB', 'LGA', 'JFK']",
                "['JFK', 'LGA', 'JFK', 'LGB', 'LGA', 'LGB', 'JFK']",
                "['JFK', 'LGA', 'JFK', 'LGB', 'LGA', 'LGB', 'LGA', 'JFK']",
                "['JFK', 'LGA', 'JFK', 'LGB', 'LGA', 'LGB', 'LGA', 'LGB', 'JFK']"
            ]
        }
    },
    null,
    null
]